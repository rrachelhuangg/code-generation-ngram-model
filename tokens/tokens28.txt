private Object memcacheGet ( Object key ) { try { return memcachedClient . asyncGet ( toKey ( key ) ) . get ( asynchGetTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
private void memcacheSet ( Object key , Object o ) { memcachedClient . set ( toKey ( key ) , cacheTimeSeconds , o ) ; } 
private String toKey ( Object key ) { return namespace + " : " + String . valueOf ( key ) . replace ( ' ' , '_' ) ; } 
public Object read ( Object key ) throws CacheException { return memcacheGet ( key ) ; } 
public Object get ( Object key ) throws CacheException { return memcacheGet ( key ) ; } 
public void put ( Object key , Object value ) throws CacheException { memcacheSet ( key , value ) ; } 
public void update ( Object key , Object value ) throws CacheException { memcacheSet ( key , value ) ; } 
public void remove ( Object key ) throws CacheException { memcachedClient . delete ( toKey ( key ) ) ; } 
public long nextTimestamp ( ) { return Timestamper . next ( ) ; } 
public Map toMap ( ) { throw new UnsupportedOperationException ( ) ; } 
public String toString ( ) { return " Memcached ( " + namespace + " ) " ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { return new MemcachedCache ( regionName , client ) ; } 
public void start ( Properties properties ) throws CacheException { String serverList = properties . getProperty ( " memcached.servers " , " localhost:11211 " ) ; try { client = new MemcachedClient ( AddrUtil . getAddresses ( serverList ) ) ; 
public void stop ( ) { if ( client ! = null ) { client . shutdown ( ) ; } client = null ; } 
public boolean isMinimalPutsEnabledByDefault ( ) { return false ; } 
public void test ( ) throws Exception { MemcachedCacheProvider provider = new MemcachedCacheProvider ( ) ; Properties properties = new Properties ( ) ; properties.setProperty("memcached.servers", ""); provider.start(properties); Cache cache = provider.buildCache("test", properties); assertNotNull(cache); provider.stop(); } 
private String toKey ( Object key ) { return namespace + " : " + getNamespaceIndex ( ) + " : " + String . valueOf ( key ) . replace ( ' ' , '_' ) ; } 
public void clear ( ) throws CacheException { memcachedClient . incr ( NAMESPACE_KEY_INDEX , 1 ) ; } 
public void start ( Properties properties ) throws CacheException { String serverList = properties . getProperty ( " hibernate.memcached.servers " , " localhost:11211 " ) ; try { client = new MemcachedClient ( AddrUtil . getAddresses ( serverList ) ) ; 
public boolean isClearSupported ( ) { return clearSupported ; } 
public void clear ( ) throws CacheException { if ( clearSupported ) { memcachedClient . incr ( namespaceIndexKey , 1 , 1 ) ; 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { MemcachedCache cache = new MemcachedCache ( regionName , client ) ; String memcachedPrefix = " hibernate.memcached. " + regionName ; String propAsynchGetTimeoutMillis = memcachedPrefix + " .asynchGetTimeoutMillis " ; if ( properties . containsKey ( propAsynchGetTimeoutMillis ) ) { cache . setAsynchGetTimeoutMillis ( Long . valueOf ( properties . getProperty ( propAsynchGetTimeoutMillis ) ) ) ; } String propCacheTimeSeconds = memcachedPrefix + " .cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } String propClearSupported = memcachedPrefix + " .clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } return cache ; } 
public void start ( Properties properties ) throws CacheException { String serverList = properties . getProperty ( PROP_SERVERS , " localhost:11211 " ) ; try { client = new MemcachedClient ( AddrUtil . getAddresses ( serverList ) ) ; 
public void test ( ) throws Exception { MemcachedCacheProvider provider = new MemcachedCacheProvider ( ) ; Properties properties = new Properties ( ) ; properties.setProperty("memcached.servers", ""); provider.start(properties); MemcachedCache cache = (MemcachedCache) provider.buildCache("test", properties); assertNotNull(cache); assert Defaults assertFalse(cache.isClearSupported()); assertEquals(500, cache.getAsynchGetTimeoutMillis()); assertEquals(300, cache.getCacheTimeSeconds()); provider.stop(); } 
public String toKey ( String namespace , long namespaceIndex , Object key ) { return new StringBuilder ( ) . append ( namespace ) . append ( " : " ) . append ( namespaceIndex ) . append ( " : " ) . append ( String . valueOf ( key ) . replace ( ' ' , '_' ) ) . toString ( ) ; } 
private Object memcacheGet ( Object key ) { try { return memcachedClient . get ( toKey ( key ) ) ; } catch ( OperationTimeoutException e ) { log . warn ( " Cache 'get' timed out for key [ " + toKey ( key ) + " ] " , e ) ; } return null ; } 
private String toKey ( Object key ) { return keyStrategy . toKey ( namespace , getNamespaceIndex ( ) , key ) ; } 
public void destroy ( ) throws CacheException { memcachedClient . shutdown ( ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( properties ) ; boolean defaultClearSupported = getDefaultClearSupported ( properties ) ; String keyStrategyClassProp = properties . getProperty ( PROP_PREFIX + " keyStrategy " ) ; if ( keyStrategyClassProp ! = null ) { KeyStrategy keyStrategy = instantiateKeyStrategy ( properties . getProperty ( keyStrategyClassProp ) ) ; cache . setKeyStrategy ( keyStrategy ) ; } String regionPrefix = PROP_PREFIX + regionName ; String propCacheTimeSeconds = regionPrefix + " .cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } else { cache . setCacheTimeSeconds ( defaultCacheTimeSeconds ) ; } String propClearSupported = regionPrefix + " .clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } else { cache . setClearSupported ( defaultClearSupported ) ; } return cache ; } 
private KeyStrategy instantiateKeyStrategy ( String cls ) { try { return ( KeyStrategy ) Class . forName ( cls ) . newInstance ( ) ; 
public void start ( Properties properties ) throws CacheException { String serverList = properties . getProperty ( PROP_SERVERS , " localhost:11211 " ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Starting MemcachedClient with serverList [ " + serverList + " ] " ) ; } try { client = createMemcachedClient ( serverList , properties ) ; 
protected MemcachedClient createMemcachedClient ( String serverList , Properties properties ) throws IOException { return new MemcachedClient ( AddrUtil . getAddresses ( serverList ) ) ; } 
public void stop ( ) { if ( client ! = null ) { log . debug ( " Shutting down MemcachedClient " ) ; client . shutdown ( ) ; } client = null ; } 
public void test ( ) { String key = strategy . toKey ( " test " , 0 , " boing " ) ; assertEquals ( " test:0:boing " , key ) ; } 
public void test_null_namespace_and_null_key ( ) { String key = strategy . toKey ( null , 0 , null ) ; assertEquals ( " null:0:null " , key ) ; 
public void test_defaults ( ) throws Exception { Properties properties = new Properties ( ) ; provider . start ( properties ) ; MemcachedCache cache = ( MemcachedCache ) provider . buildCache ( " test " , properties ) ; assertNotNull ( cache ) ; assert Defaults assertFalse(cache.isClearSupported()); assertEquals(300, cache.getCacheTimeSeconds()); } 
public void test_region_properties ( ) { MemcachedCacheProvider provider = new MemcachedCacheProvider ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( " hibernate.memcached.serverList " , " 127.0.0.1:11211 " ) ; properties . setProperty ( " hibernate.memcached.test.cacheTimeSeconds " , " 500 " ) ; properties . setProperty ( " hibernate.memcached.test.clearSupported " , " true " ) ; provider . start ( properties ) ; MemcachedCache cache = ( MemcachedCache ) provider . buildCache ( " test " , properties ) ; assertNotNull ( cache ) ; assert Defaults assertTrue(cache.isClearSupported()); assertEquals(500, cache.getCacheTimeSeconds()); } 
protected void setUp ( ) throws Exception { provider = new MemcachedCacheProvider ( ) ; } 
protected void tearDown ( ) throws Exception { provider . stop ( ) ; } 
protected void setUp ( ) throws Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11211 " ) ) ; cache = new MemcachedCache ( " MemcachedCacheTest " , client ) ; } 
protected void tearDown ( ) throws Exception { client . shutdown ( ) ; } 
public void test ( ) throws Exception { cache . put ( " test " , " value " ) ; Thread . sleep ( 500 ) ; assertEquals ( " value " , cache . get ( " test " ) ) ; } 
public void test_clear ( ) throws Exception { cache . setClearSupported ( true ) ; cache . put ( " test " , " value " ) ; Thread . sleep ( 500 ) ; assertEquals ( " value " , cache . get ( " test " ) ) ; cache . clear ( ) ; Thread . sleep ( 500 ) ; assertNull ( cache . get ( " test " ) ) ; } 
public String toKey ( String namespace , long namespaceIndex , Object key ) { StringBuilder stringKey = new StringBuilder ( ) . append ( namespace ) . append ( " : " ) . append ( namespaceIndex ) . append ( " : " ) . append ( String . valueOf ( key ) ) ; return CLEAN_PATTERN . matcher ( stringKey ) . replaceAll ( " " ) ; } 
public void test_null_namespace_and_null_key ( ) { String key = strategy . toKey ( null , 0 , null ) ; assertEquals ( " null:0:null " , key ) ; } 
public void test_spaces ( ) throws Exception { String key = strategy . toKey ( " I have spaces " , 0 , " so do I " ) ; assertEquals ( " Ihavespaces:0:sodoI " , key ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( properties ) ; boolean defaultClearSupported = getDefaultClearSupported ( properties ) ; String keyStrategyClassProp = properties . getProperty ( PROP_PREFIX + " keyStrategy " ) ; if ( keyStrategyClassProp ! = null ) { KeyStrategy keyStrategy = instantiateKeyStrategy ( properties . getProperty ( keyStrategyClassProp ) ) ; cache . setKeyStrategy ( keyStrategy ) ; } String regionPrefix = PROP_PREFIX + regionName + " . " ; String propCacheTimeSeconds = regionPrefix + " cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } else { cache . setCacheTimeSeconds ( defaultCacheTimeSeconds ) ; } String propClearSupported = regionPrefix + " clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } else { cache . setClearSupported ( defaultClearSupported ) ; } return cache ; } 
public String toKey ( String namespace , long namespaceIndex , Object key ) { return UUID . nameUUIDFromBytes ( super . toKey ( namespace , namespaceIndex , key ) . getBytes ( ) 
public void test ( ) throws Exception { String key = strategy . toKey ( " test " , 0 , " test " ) ; assertEquals ( " c0a30f2b-3803-3859-90e9-13dae6445d03 " , key ) ; } 
protected String convertKeyToString ( String regionName , long cleanIndex , Object key ) { return new StringBuilder ( ) . append ( regionName ) 
public String toKey ( String regionName , long cleanIndex , Object key ) { String keyString = convertKeyToString ( regionName , cleanIndex , key ) ; if ( keyString . length ( ) > maxKeyLength ) { return truncateKey ( keyString ) ; } return CLEAN_PATTERN . matcher ( keyString ) . replaceAll ( " " ) ; } 
protected String truncateKey ( String key ) { String uuidString = UUID . nameUUIDFromBytes ( key . getBytes ( ) ) . toString ( ) ; if ( log . isWarnEnabled ( ) ) { log . warn ( " Truncated key [ " + key + " ] to uuid [ " + uuidString + " ]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " + " Consider using the UUIDKeyStrategy when hibernate.cache.use_query_cache is enabled. " ) ; } return uuidString ; } 
private Object memcacheGet ( Object key ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.get( " + stringKey + " } " ) ; try { return memcachedClient . get ( stringKey ) ; } catch ( OperationTimeoutException e ) { log . warn ( " Cache 'get' timed out for key [ " + stringKey + " ] " , e ) ; } return null ; } 
private void memcacheSet ( Object key , Object o ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.set( " + stringKey + " } " ) ; memcachedClient . set ( stringKey , cacheTimeSeconds , o ) ; } 
private String toKey ( Object key ) { return keyStrategy . toKey ( regionName , getCleanIndex ( ) , key ) ; } 
public void clear ( ) throws CacheException { if ( clearSupported ) { memcachedClient . incr ( cleanIndexKey , 1 , 1 ) ; 
public String toString ( ) { return " Memcached ( " + regionName + " ) " ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( properties ) ; boolean defaultClearSupported = getDefaultClearSupported ( properties ) ; setKeyStrategy ( properties , cache ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String propCacheTimeSeconds = regionPrefix + " cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } else { cache . setCacheTimeSeconds ( defaultCacheTimeSeconds ) ; } String propClearSupported = regionPrefix + " clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } else { cache . setClearSupported ( defaultClearSupported ) ; } return cache ; } 
protected KeyStrategy instantiateKeyStrategy ( String cls ) { try { return ( KeyStrategy ) Class . forName ( cls ) . newInstance ( ) ; 
public String toKey ( String namespace , long namespaceIndex , Object key ) { String keyString = convertKeyToString ( namespace , namespaceIndex , key ) ; String uuidString = UUID . nameUUIDFromBytes ( keyString . getBytes ( ) ) . toString ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Converted keyString [ " + keyString + " ] to uuidString [ " + uuidString + " ] " ) ; } return uuidString ; } 
public void test_really_long_keys_get_truncated ( ) throws Exception { String regionName = " " ; String key = " " ; for ( int i = 0 ; i < 150 ; i + + ) { key + = " x " ; regionName + = " x " ; } assertEquals ( " f42403ec-dc00-398a-bf14-72669e131636 " , strategy . toKey ( regionName , 0 , key ) ) ; } 
public void test_custom_truncation ( ) throws Exception { strategy = new DefaultKeyStrategy ( ) { protected String truncateKey ( String key ) { return " great-googly-moogly " ; } } ; String regionName = " " ; String key = " " ; for ( int i = 0 ; i < 150 ; i + + ) { key + = " x " ; regionName + = " x " ; } assertEquals ( " great-googly-moogly " , strategy . toKey ( regionName , 0 , key ) ) ; } 
protected String truncateKey ( String key ) { return " great-googly-moogly " ; } 
public void test_uuid_key_strategy ( ) throws Exception { MemcachedCacheProvider provider = new MemcachedCacheProvider ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( " hibernate.memcached.keyStrategy " , UUIDKeyStrategy . class . getName ( ) ) ; provider . start ( properties ) ; MemcachedCache cache = ( MemcachedCache ) provider . buildCache ( " test " , properties ) ; assertNotNull ( cache ) ; } 
protected String convertKeyToString ( String regionName , long clearIndex , Object key ) { return new StringBuilder ( ) . append ( regionName ) 
public String toKey ( String regionName , long clearIndex , Object key ) { String keyString = convertKeyToString ( regionName , clearIndex , key ) ; if ( keyString . length ( ) > maxKeyLength ) { return truncateKey ( keyString ) ; } return CLEAN_PATTERN . matcher ( keyString ) . replaceAll ( " " ) ; } 
private String toKey ( Object key ) { return keyStrategy . toKey ( regionName , getClearIndex ( ) , key ) ; } 
public void clear ( ) throws CacheException { if ( clearSupported ) { memcachedClient . incr ( clearIndexKey , 1 , 1 ) ; 
public String toKey ( String regionName , long clearIndex , Object key ) { String keyString = convertKeyToString ( regionName , clearIndex , key ) ; String uuidString = UUID . nameUUIDFromBytes ( keyString . getBytes ( ) ) . toString ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Converted keyString [ " + keyString + " ] to uuidString [ " + uuidString + " ] " ) ; } return uuidString ; } 
public void test_null_region_and_null_key ( ) { String key = strategy . toKey ( null , 0 , null ) ; assertEquals ( " null:0:null " , key ) ; } 
protected void setupInTransaction ( ) { } protected void tearDownInTransaction ( ) { } protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; } } } 
protected void tearDownInTransaction ( ) { } protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; } } } 
protected void tearDown ( ) { try { tearDownInTransaction ( ) ; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Contact contact = ( Contact ) o ; if ( id ! = null ? ! id . equals ( contact . id ) : contact . id ! = null ) return false ; return true ; } 
public int hashCode ( ) { return ( id ! = null ? id . hashCode ( ) : 0 ) ; } 
protected void setupInTransaction ( ) { ray = new Contact ( ) ; ray . setFirstName ( " Ray " ) ; ray . setLastName ( " Krueger " ) ; session . saveOrUpdate ( ray ) ; session . flush ( ) ; session . clear ( ) ; } 
public void test ( ) { Contact fromDB = ( Contact ) session . get ( Contact . class , ray . getId ( ) ) ; assertNotNull ( fromDB ) ; } 
public void test_query_cache ( ) { Contact fromDB = ( Contact ) session . createCriteria ( Contact . class ) . add ( Restrictions . eq ( " firstName " , " Ray " ) ) . add ( Restrictions . eq ( " lastName " , " Krueger " ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastName " ) . uniqueResult ( ) ; assertEquals ( ray , fromDB ) ; } 
protected void setupInTransaction ( ) { } protected void tearDownInTransaction ( ) { } protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; resetLogging ( ) ; } } } 
protected void tearDownInTransaction ( ) { } protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; resetLogging ( ) ; } } } 
public void test_query_cache ( ) { Contact fromDB = ( Contact ) session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastName " ) . uniqueResult ( ) ; assertEquals ( ray , fromDB ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( properties ) ; boolean defaultClearSupported = getDefaultClearSupported ( properties ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String keyStrategy = getKeyStrategyName ( properties , regionPrefix ) ; setKeyStrategy ( keyStrategy , cache ) ; String propCacheTimeSeconds = regionPrefix + " cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } else { cache . setCacheTimeSeconds ( defaultCacheTimeSeconds ) ; } String propClearSupported = regionPrefix + " clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } else { cache . setClearSupported ( defaultClearSupported ) ; } return cache ; } 
public void start ( Properties properties ) throws CacheException { try { client = getMemcachedClientFactory ( properties ) . createMemcachedClient ( ) ; 
protected String truncateKey ( String key ) { String uuidString = UUID . nameUUIDFromBytes ( key . getBytes ( ) ) . toString ( ) ; log . warn ( " Truncated key [{}] to uuid [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " + " Consider using the UUIDKeyStrategy when hibernate.cache.use_query_cache is enabled. " , key , uuidString ) ; return uuidString ; } 
private Object memcacheGet ( Object key ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.get({}} " , stringKey ) ; try { return memcachedClient . get ( stringKey ) ; } catch ( OperationTimeoutException e ) { log . warn ( " Cache 'get' timed out for key [ " + stringKey + " ] " , e ) ; } return null ; } 
private void memcacheSet ( Object key , Object o ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.set({}) " , stringKey ) ; memcachedClient . set ( stringKey , cacheTimeSeconds , o ) ; } 
public String toKey ( String regionName , long clearIndex , Object key ) { String keyString = convertKeyToString ( regionName , clearIndex , key ) ; String uuidString = UUID . nameUUIDFromBytes ( keyString . getBytes ( ) ) . toString ( ) ; log . debug ( " Converted keyString [{}] to uuidString [{}] " , keyString , uuidString ) ; return uuidString ; } 
public String toKey ( String regionName , long clearIndex , Object key ) { if ( key = = null ) { throw new IllegalArgumentException ( " key must not be null " ) ; } String keyString = concatenateKey ( regionName , clearIndex , transformKeyObject ( key ) ) ; if ( keyString . length ( ) > maxKeyLength ) { return truncateKey ( keyString ) ; } String finalKey = CLEAN_PATTERN . matcher ( keyString ) . replaceAll ( " " ) ; log . debug ( " Final cache key: [{}] " , finalKey ) ; return finalKey ; } 
protected String truncateKey ( String key ) { String keyHashCode = String . valueOf ( key . hashCode ( ) ) ; log . warn ( " Truncated key [{}] to hashCode [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " , key , keyHashCode ) ; return keyHashCode ; } 
protected String concatenateKey ( String regionName , long clearIndex , Object key ) { return new StringBuilder ( ) . append ( regionName ) 
protected Object transformKeyObject ( Object key ) { int hashCode = key . hashCode ( ) ; log . debug ( " Transformed key [{}] to hashCode [{}] " , key , key . hashCode ( ) ) ; return hashCode ; } 
public void update ( Object key , Object value ) throws CacheException { put ( key , value ) ; } 
protected Object transformKeyObject ( Object key ) { String stringKey = String . valueOf ( key ) ; log . debug ( " Transformed key [{}] to string [{}] " , key , stringKey ) ; return stringKey ; } 
public void test_query_cache ( ) { Criteria criteria = session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastName " ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; assertEquals ( criteria . uniqueResult ( ) , criteria . uniqueResult ( ) ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { log . info ( " Building cache for region [{}] " , regionName ) ; MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( properties ) ; boolean defaultClearSupported = getDefaultClearSupported ( properties ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String keyStrategy = getKeyStrategyName ( properties , regionPrefix ) ; if ( keyStrategy ! = null ) { setKeyStrategy ( keyStrategy , cache ) ; } String propCacheTimeSeconds = regionPrefix + " cacheTimeSeconds " ; if ( properties . containsKey ( propCacheTimeSeconds ) ) { cache . setCacheTimeSeconds ( Integer . valueOf ( properties . getProperty ( propCacheTimeSeconds ) ) ) ; } else { cache . setCacheTimeSeconds ( defaultCacheTimeSeconds ) ; } String propClearSupported = regionPrefix + " clearSupported " ; if ( properties . containsKey ( propClearSupported ) ) { cache . setClearSupported ( Boolean . valueOf ( properties . getProperty ( propClearSupported ) ) ) ; } else { cache . setClearSupported ( defaultClearSupported ) ; } return cache ; } 
public void start ( Properties properties ) throws CacheException { log . info ( " Starting MemcachedClient... " ) ; try { client = getMemcachedClientFactory ( properties ) . createMemcachedClient ( ) ; 
protected String truncateKey ( String key ) { String keyHashCode = UUID . nameUUIDFromBytes ( key . getBytes ( ) ) . toString ( ) ; log . warn ( " Encoded key [{}] to uuid [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " , key , keyHashCode ) ; return keyHashCode ; } 
protected String transformKeyObject ( Object key ) { int hashCode = key . hashCode ( ) ; log . debug ( " Transformed key [{}] to hashCode [{}] " , key , key . hashCode ( ) ) ; return String . valueOf ( hashCode ) ; } 
protected String transformKeyObject ( Object key ) { String stringKey = String . valueOf ( key ) ; log . debug ( " Transformed key [{}] to string [{}] " , key , stringKey ) ; return stringKey ; } 
protected String transformKeyObject ( Object key ) { int hashCode = key . hashCode ( ) ; log . debug ( " Transformed key [{}] to hashCode [{}] " , key , hashCode ) ; return String . valueOf ( hashCode ) ; } 
protected String truncateKey ( String key ) { String keyHashCode = DigestUtils . md5Hex ( key . getBytes ( ) ) ; log . warn ( " Encoded key [{}] to uuid [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " , key , keyHashCode ) ; return keyHashCode ; } 
public long nextTimestamp ( ) { return System . currentTimeMillis ( ) / 100 ; } 
public boolean isMinimalPutsEnabledByDefault ( ) { return true ; } 
protected void setupInTransaction ( ) { ray = new Contact ( ) ; ray . setFirstName ( " Ray " ) ; ray . setLastName ( " Krueger " ) ; ray . setBirthday ( new Date ( ) ) ; session . saveOrUpdate ( ray ) ; session . flush ( ) ; session . clear ( ) ; } 
public void test_query_cache ( ) { Criteria criteria = session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastName " ) ; assertNotNull ( criteria . uniqueResult ( ) ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; assertEquals ( criteria . uniqueResult ( ) , criteria . uniqueResult ( ) ) ; } 
public void test_query_cache_with_date ( ) throws Exception { Thread . sleep ( 3000 ) ; Calendar birthday = Calendar . getInstance ( ) ; birthday . set ( Calendar . HOUR_OF_DAY , 0 ) ; birthday . set ( Calendar . MINUTE , 0 ) ; birthday . set ( Calendar . SECOND , 0 ) ; birthday . set ( Calendar . MILLISECOND , 0 ) ; Criteria criteria = session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . add ( eq ( " birthday " , birthday . getTime ( ) ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastName " ) ; assertNotNull ( criteria . uniqueResult ( ) ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; assertEquals ( criteria . uniqueResult ( ) , criteria . uniqueResult ( ) ) ; } 
public void test_query_cache_with_date ( ) throws Exception { Thread . sleep ( 3000 ) ; Calendar birthday = Calendar . getInstance ( ) ; birthday . set ( Calendar . HOUR_OF_DAY , 0 ) ; birthday . set ( Calendar . MINUTE , 0 ) ; birthday . set ( Calendar . SECOND , 0 ) ; birthday . set ( Calendar . MILLISECOND , 0 ) ; Criteria criteria = session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . add ( eq ( " birthday " , birthday . getTime ( ) ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastNameAndBirthday " ) ; assertNotNull ( criteria . uniqueResult ( ) ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; assertEquals ( criteria . uniqueResult ( ) , criteria . uniqueResult ( ) ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { PropertiesHelper props = new PropertiesHelper ( properties ) ; log . info ( " Building cache for region [{}] " , regionName ) ; MemcachedCache cache = new MemcachedCache ( regionName , client ) ; int defaultCacheTimeSeconds = getDefaultCacheTimeSeconds ( props ) ; boolean defaultClearSupported = getDefaultClearSupported ( props ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String keyStrategy = getKeyStrategyName ( props , regionPrefix ) ; if ( keyStrategy ! = null ) { setKeyStrategy ( keyStrategy , cache ) ; } int cacheTime = props . getInt ( regionPrefix + " cacheTimeSeconds " , defaultCacheTimeSeconds ) ; cache . setCacheTimeSeconds ( cacheTime ) ; boolean clearSupported = props . getBoolean ( regionPrefix + " clearSupported " , defaultClearSupported ) ; cache . setClearSupported ( clearSupported ) ; return cache ; } 
public String get ( String key ) { return properties . getProperty ( key ) ; } 
public String get ( String key , String defaultVal ) { String val = get ( key ) ; return val = = null ? defaultVal : val ; } 
public String findValue ( String . . . keys ) { for ( String key : keys ) { String value = get ( key ) ; if ( value ! = null ) { return value ; } } return null ; } 
Object get ( String key ) ; void set ( String key , int cacheTimeSeconds , Object o ) ; void delete ( String key ) ; void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
void set ( String key , int cacheTimeSeconds , Object o ) ; void delete ( String key ) ; void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
void delete ( String key ) ; void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
private Object memcacheGet ( Object key ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.get({}} " , stringKey ) ; return memcache . get ( stringKey ) ; } 
private void memcacheSet ( Object key , Object o ) { String stringKey = toKey ( key ) ; log . debug ( " Memcache.set({}) " , stringKey ) ; memcache . set ( stringKey , cacheTimeSeconds , o ) ; } 
public void remove ( Object key ) throws CacheException { memcache . delete ( toKey ( key ) ) ; } 
public void clear ( ) throws CacheException { if ( clearSupported ) { memcache . incr ( clearIndexKey , 1 , 1 ) ; 
public void start ( Properties properties ) throws CacheException { log . info ( " Starting MemcachedClient... " ) ; try { client = getMemcachedClientFactory ( new PropertiesHelper ( properties ) ) 
public void stop ( ) { if ( client ! = null ) { log . debug ( " Shutting down Memcache client " ) ; client . shutdown ( ) ; } client = null ; } 
public Object get ( String key ) { try { return memcachedClient . get ( key ) ; } catch ( OperationTimeoutException e ) { log . warn ( " Cache 'get' timed out for key [ " + key + " ] " , e ) ; } return null ; } 
public void set ( String key , int cacheTimeSeconds , Object o ) { try { memcachedClient . set ( key , cacheTimeSeconds , o ) ; 
public void delete ( String key ) { try { memcachedClient . delete ( key ) ; 
public void incr ( String key , int factor , int startingValue ) { try { memcachedClient . incr ( key , factor , startingValue ) ; 
public void shutdown ( ) { log . debug ( " Shutting down spy MemcachedClient " ) ; memcachedClient . shutdown ( ) ; } 
public boolean isDogpilePreventionEnabled ( ) { return dogpilePreventionEnabled ; } 
private String dogpileTokenKey ( String objectKey ) { return objectKey + " .dogpileTokenKey " ; } 
private Object memcacheGet ( Object key ) { String objectKey = toKey ( key ) ; if ( dogpilePreventionEnabled ) { String dogpileKey = dogpileTokenKey ( objectKey ) ; log . debug ( " Checking dogpile key: [{}] " , dogpileKey ) ; if ( memcache . get ( dogpileKey ) = = null ) { log . debug ( " Dogpile key ({}) not found updating token and returning null " , dogpileKey ) ; memcache . set ( dogpileKey , cacheTimeSeconds , DOGPILE_TOKEN ) ; return null ; } else { log . debug ( " Dogpile token found for key ({}), getting cached object " , dogpileKey ) ; } } log . debug ( " Memcache.get({}) " , objectKey ) ; return memcache . get ( objectKey ) ; } 
private void memcacheSet ( Object key , Object o ) { String objectKey = toKey ( key ) ; int cacheTime = cacheTimeSeconds ; if ( dogpilePreventionEnabled ) { String dogpileKey = dogpileTokenKey ( objectKey ) ; log . debug ( " Dogpile prevention enabled, setting token and adjusting object cache time. Key: [{}] " , dogpileKey ) ; memcache . set ( dogpileKey , cacheTimeSeconds , DOGPILE_TOKEN ) ; cacheTime = cacheTimeSeconds * dogpilePreventionExpirationFactor ; } log . debug ( " Memcache.set({}) " , objectKey ) ; memcache . set ( objectKey , cacheTime , o ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { PropertiesHelper props = new PropertiesHelper ( properties ) ; log . info ( " Building cache for region [{}] " , regionName ) ; MemcachedCache cache = new MemcachedCache ( regionName , client ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String keyStrategy = getKeyStrategyName ( props , regionPrefix ) ; if ( keyStrategy ! = null ) { setKeyStrategy ( keyStrategy , cache ) ; } int globalCacheTimeSeconds = getGlobalCacheTimeSeconds ( props ) ; int cacheTime = props . getInt ( regionPrefix + " cacheTimeSeconds " , globalCacheTimeSeconds ) ; cache . setCacheTimeSeconds ( cacheTime ) ; boolean globalClearSupported = getGlobalClearSupported ( props ) ; boolean clearSupported = props . getBoolean ( regionPrefix + " clearSupported " , globalClearSupported ) ; cache . setClearSupported ( clearSupported ) ; boolean globalDogpilePrevention = getGlobalDogpilePrevention ( props ) ; boolean dogpilePrevention = props . getBoolean ( PROP_DOGPILE_PREVENTION , globalDogpilePrevention ) ; cache . setDogpilePreventionEnabled ( dogpilePrevention ) ; if ( dogpilePrevention ) { cache . setDogpilePreventionExpirationFactor ( props . getInt ( PROP_DOGPILE_PREVENTION_EXPIRATION_FACTOR , 2 ) ) ; } return cache ; } 
public Object get ( String key ) { try { log . debug ( " MemcachedClient.get({}) " , key ) ; return memcachedClient . get ( key ) ; } catch ( OperationTimeoutException e ) { log . warn ( " Cache 'get' timed out for key [ " + key + " ] " , e ) ; } return null ; } 
public void set ( String key , int cacheTimeSeconds , Object o ) { log . debug ( " MemcachedClient.set({}) " , key ) ; try { memcachedClient . set ( key , cacheTimeSeconds , o ) ; 
public void test_query_cache_with_date ( ) throws Exception { Thread . sleep ( 100 ) ; Calendar birthday = Calendar . getInstance ( ) ; birthday . set ( Calendar . HOUR_OF_DAY , 0 ) ; birthday . set ( Calendar . MINUTE , 0 ) ; birthday . set ( Calendar . SECOND , 0 ) ; birthday . set ( Calendar . MILLISECOND , 0 ) ; Criteria criteria = session . createCriteria ( Contact . class ) . add ( eq ( " firstName " , " Ray " ) ) . add ( eq ( " lastName " , " Krueger " ) ) . add ( eq ( " birthday " , birthday . getTime ( ) ) ) . setCacheable ( true ) . setCacheRegion ( " contact.findByFirstNameAndLastNameAndBirthday " ) ; assertNotNull ( criteria . uniqueResult ( ) ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; criteria . uniqueResult ( ) ; assertEquals ( criteria . uniqueResult ( ) , criteria . uniqueResult ( ) ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { PropertiesHelper props = new PropertiesHelper ( properties ) ; log . info ( " Building cache for region [{}] " , regionName ) ; MemcachedCache cache = new MemcachedCache ( regionName , client ) ; String regionPrefix = PROP_PREFIX + regionName + " . " ; String keyStrategy = getKeyStrategyName ( props , regionPrefix ) ; if ( keyStrategy ! = null ) { setKeyStrategy ( keyStrategy , cache ) ; } int globalCacheTimeSeconds = getGlobalCacheTimeSeconds ( props ) ; int cacheTime = props . getInt ( regionPrefix + " cacheTimeSeconds " , globalCacheTimeSeconds ) ; cache . setCacheTimeSeconds ( cacheTime ) ; boolean globalClearSupported = getGlobalClearSupported ( props ) ; boolean clearSupported = props . getBoolean ( regionPrefix + " clearSupported " , globalClearSupported ) ; cache . setClearSupported ( clearSupported ) ; boolean globalDogpilePrevention = getGlobalDogpilePrevention ( props ) ; boolean dogpilePrevention = props . getBoolean ( regionPrefix + " dogpilePrevention " , globalDogpilePrevention ) ; cache . setDogpilePreventionEnabled ( dogpilePrevention ) ; if ( dogpilePrevention ) { cache . setDogpilePreventionExpirationFactor ( props . getInt ( PROP_DOGPILE_PREVENTION_EXPIRATION_FACTOR , 2 ) ) ; } return cache ; } 
public boolean isClearSupported ( String cacheRegion ) { boolean globalClearSupported = props . getBoolean ( PROP_CLEAR_SUPPORTED , DEFAULT_CLEAR_SUPPORTED ) ; return props . getBoolean ( cacheRegionPrefix ( cacheRegion ) + CLEAR_SUPPORTED , globalClearSupported ) ; 
public boolean isDogpilePreventionEnabled ( String cacheRegion ) { boolean globalDogpilePrevention = props . getBoolean ( PROP_DOGPILE_PREVENTION , DEFAULT_DOGPILE_PREVENTION ) ; return props . getBoolean ( cacheRegionPrefix ( cacheRegion ) + DOGPILE_PREVENTION , globalDogpilePrevention ) ; 
private String cacheRegionPrefix ( String cacheRegion ) { return PROP_PREFIX + cacheRegion + " . " ; } 
private void memcacheSet ( Object key , Object o ) { String objectKey = toKey ( key ) ; int cacheTime = cacheTimeSeconds ; if ( dogpilePreventionEnabled ) { String dogpileKey = dogpileTokenKey ( objectKey ) ; log . debug ( " Dogpile prevention enabled, setting token and adjusting object cache time. Key: [{}] " , dogpileKey ) ; memcache . set ( dogpileKey , cacheTimeSeconds , DOGPILE_TOKEN ) ; cacheTime = ( int ) ( cacheTimeSeconds * dogpilePreventionExpirationFactor ) ; } log . debug ( " Memcache.set({}) " , objectKey ) ; memcache . set ( objectKey , cacheTime , o ) ; } 
public Cache buildCache ( String regionName , Properties properties ) throws CacheException { Config config = new Config ( new PropertiesHelper ( properties ) ) ; log . info ( " Building cache for region [{}] " , regionName ) ; MemcachedCache cache = new MemcachedCache ( regionName , client ) ; String keyStrategy = config . getKeyStrategyName ( regionName ) ; if ( keyStrategy ! = null ) { setKeyStrategy ( keyStrategy , cache ) ; } cache . setCacheTimeSeconds ( config . getCacheTimeSeconds ( regionName ) ) ; cache . setClearSupported ( config . isClearSupported ( regionName ) ) ; boolean dogpilePrevention = config . isDogpilePreventionEnabled ( regionName ) ; cache . setDogpilePreventionEnabled ( dogpilePrevention ) ; if ( dogpilePrevention ) { cache . setDogpilePreventionExpirationFactor ( config . getDogpilePreventionExpirationFactor ( regionName ) ) ; } return cache ; } 
public void start ( Properties properties ) throws CacheException { log . info ( " Starting MemcachedClient... " ) ; try { client = getMemcachedClientFactory ( new Config ( new PropertiesHelper ( properties ) ) ) 
protected String truncateKey ( String key ) { String keyHashCode = DigestUtils . md5Hex ( key . getBytes ( ) ) ; log . warn ( " Encoded key [{}] to md5 hash [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " , key , keyHashCode ) ; return keyHashCode ; } 
public Object get ( String key ) { try { log . debug ( " MemCachedClient.get({}) " , key ) ; return memcachedClient . get ( key ) ; } catch ( Exception e ) { log . warn ( " Cache 'get' timed out for key [ " + key + " ] " , e ) ; } return null ; } 
public void set ( String key , int cacheTimeSeconds , Object o ) { log . debug ( " MemCachedClient.set({}) " , key ) ; try { Calendar calendar = Calendar . getInstance ( ) ; 
public void incr ( String key , int factor , int startingValue ) { try { Try to incr 
public void shutdown ( ) { log . debug ( " Shutting down danga MemCachedClient " ) ; Danga's MemCachedClient does not provide a method to shutdown or close it, let's shutdown its SockIOPool instead SockIOPool.getInstance(poolName).shutDown(); } 
public Memcache createMemcacheClient ( ) throws Exception { String poolName = getPoolName ( ) ; pool.initialize(); MemCachedClient client = new MemCachedClient( getClassLoader(), getErrorHandler(), poolName); client.setCompressEnable(isCompressEnable()); client.setDefaultEncoding(getDefaultEncoding()); return new DangaMemcache(client, poolName); } 
public boolean isCompressEnable ( ) { return properties . getBoolean ( PROP_COMPRESS_ENABLE , DEFAULT_COMPRESS_ENABLE ) ; } 
public void handleErrorOnDelete ( MemCachedClient client , Throwable error , tString cacheKey ) { tlog . error ( " Error on delete cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnFlush ( MemCachedClient client , Throwable error ) { tlog . error ( " Error on flush: {} " , error ) ; } 
public void handleErrorOnGet ( MemCachedClient client , Throwable error , tString cacheKey ) { tlog . error ( " Error on get cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnGet ( MemCachedClient client , Throwable error , tString [ ] cacheKeys ) { thandleErrorOnGet ( client , error , new StringBuffer ( ) . append ( cacheKeys ) . toString ( ) ) ; } 
public void handleErrorOnInit ( MemCachedClient client , Throwable error ) { tlog . error ( " Error on initialization: {} " , error ) ; } 
public void handleErrorOnSet ( MemCachedClient client , Throwable error , tString cacheKey ) { tlog . error ( " Error on set cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnStats ( MemCachedClient client , Throwable error ) { tlog . error ( " Error on stats: {} " , error ) ; } 
public void set ( String key , int cacheTimeSeconds , Object o ) { log . debug ( " MemCachedClient.set({}) " , key ) ; try { Calendar calendar = Calendar . getInstance ( ) ; 
public Memcache createMemcacheClient ( ) throws Exception { String poolName = getPoolName ( ) ; grab an instance of our connection pool SockIOPool pool = SockIOPool.getInstance(poolName); set the servers and the weights pool.setServers(getServers()); pool.setWeights(getWeights()); set some basic pool settings pool.setInitConn(getInitConn()); pool.setMinConn(getMinConn()); pool.setMaxConn(getMaxConn()); pool.setMaxIdle(getMaxIdle()); set the sleep for the maint thread it will wake up every x seconds and maintain the pool size pool.setMaintSleep(getMaintSleep()); set some TCP settings pool.setNagle(false); pool.setSocketTO(getSocketTimeout()); pool.setSocketConnectTO(getSocketConnectTimeout()); initialize the connection pool pool.initialize(); MemCachedClient client = new MemCachedClient( getClassLoader(), getErrorHandler(), poolName); client.setCompressEnable(isCompressEnable()); client.setDefaultEncoding(getDefaultEncoding()); return new DangaMemcache(client, poolName); } 
public void handleErrorOnDelete ( MemCachedClient client , Throwable error , String cacheKey ) { log . error ( " Error on delete cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnFlush ( MemCachedClient client , Throwable error ) { log . error ( " Error on flush: {} " , error ) ; } 
public void handleErrorOnGet ( MemCachedClient client , Throwable error , String cacheKey ) { log . error ( " Error on get cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnGet ( MemCachedClient client , Throwable error , String [ ] cacheKeys ) { StringBuilder keys = new StringBuilder ( ) ; for ( int i = 0 ; i < cacheKeys . length ; i + + ) { String cacheKey = cacheKeys [ i ] ; keys . append ( cacheKey ) ; if ( i < cacheKeys . length - 1 ) { keys . append ( " " ) ; } } handleErrorOnGet ( client , error , keys . toString ( ) ) ; } 
public void handleErrorOnInit ( MemCachedClient client , Throwable error ) { log . error ( " Error on initialization: {} " , error ) ; } 
public void handleErrorOnSet ( MemCachedClient client , Throwable error , String cacheKey ) { log . error ( " Error on set cacheKey [{}]: {} " , cacheKey , error ) ; } 
public void handleErrorOnStats ( MemCachedClient client , Throwable error ) { log . error ( " Error on stats: {} " , error ) ; } 
protected String truncateKey ( String key ) { String keyHashCode = StringUtils . md5Hex ( key ) ; log . warn ( " Encoded key [{}] to md5 hash [{}]. " + " Be sure to set cache region names whenever possible as the names Hibernate generates are really long. " , key , keyHashCode ) ; return keyHashCode ; } 
public void handleErrorOnGet ( MemCachedClient client , Throwable error , String [ ] cacheKeys ) { handleErrorOnGet ( client , error , StringUtils . join ( cacheKeys , " , " ) ) ; } 
public static String join ( Object [ ] array , String separator ) { if ( array = = null ) { return null ; } int arraySize = array . length ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < arraySize ; i + + ) { if ( i > 0 ) { buffer . append ( separator ) ; } if ( array [ i ] ! = null ) { buffer . append ( array [ i ] ) ; } } return buffer . toString ( ) ; } 
public static String md5Hex ( String data ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } byte [ ] bytes = digest . digest ( data . getBytes ( ) ) ; int l = bytes . length ; char [ ] out = new char [ l < < 1 ] ; for ( int i = 0 , j = 0 ; i < l ; i + + ) { out [ j + + ] = DIGITS [ ( 0xF0 & bytes [ i ] ) > > > 4 ] ; out [ j + + ] = DIGITS [ 0x0F & bytes [ i ] ] ; } return new String ( out ) ; } 
public static String md5Hex ( String data ) { if ( data = = null ) { throw new IllegalArgumentException ( " data must not be null " ) ; } MessageDigest digest ; try { digest = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } byte [ ] bytes = digest . digest ( data . getBytes ( ) ) ; int l = bytes . length ; char [ ] out = new char [ l < < 1 ] ; for ( int i = 0 , j = 0 ; i < l ; i + + ) { out [ j + + ] = DIGITS [ ( 0xF0 & bytes [ i ] ) > > > 4 ] ; out [ j + + ] = DIGITS [ 0x0F & bytes [ i ] ] ; } return new String ( out ) ; } 
protected String concatenateKey ( String regionName , long clearIndex , Object key ) { String longKey = super . concatenateKey ( regionName , clearIndex , key ) ; return StringUtils . md5Hex ( longKey ) ; } 
protected String concatenateKey ( String regionName , long clearIndex , Object key ) { String longKey = super . concatenateKey ( regionName , clearIndex , key ) ; return StringUtils . sha1Hex ( longKey ) ; } 
public static String md5Hex ( String data ) { if ( data = = null ) { throw new IllegalArgumentException ( " data must not be null " ) ; } byte [ ] bytes = digest ( " MD5 " , data ) ; return toHexString ( bytes ) ; } 
public static String sha1Hex ( String data ) { if ( data = = null ) { throw new IllegalArgumentException ( " data must not be null " ) ; } byte [ ] bytes = digest ( " SHA1 " , data ) ; return toHexString ( bytes ) ; } 
private static String toHexString ( byte [ ] bytes ) { int l = bytes . length ; char [ ] out = new char [ l < < 1 ] ; for ( int i = 0 , j = 0 ; i < l ; i + + ) { out [ j + + ] = DIGITS [ ( 0xF0 & bytes [ i ] ) > > > 4 ] ; out [ j + + ] = DIGITS [ 0x0F & bytes [ i ] ] ; } return new String ( out ) ; } 
private static byte [ ] digest ( String algorithm , String data ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } byte [ ] bytes = digest . digest ( data . getBytes ( ) ) ; return bytes ; } 
public void handleErrorOnGet ( String key , Exception e ) { log . warn ( " Cache 'get' failed for key [ " + key + " ] " , e ) ; } 
public void handleErrorOnSet ( String key , int cacheTimeSeconds , Object o , Exception e ) { log . warn ( " Cache 'set' failed for key [ " + key + " ] " , e ) ; } 
public void handleErrorOnDelete ( String key , Exception e ) { log . warn ( " Cache 'delete' failed for key [ " + key + " ] " , e ) ; } 
public void handleErrorOnIncr ( String key , int factor , int startingValue , Exception e ) { log . warn ( " Cache 'incr' failed for key [ " + key + " ] " , e ) ; } 
void handleErrorOnGet ( String key , Exception e ) ; void handleErrorOnSet ( String key , int cacheTimeSeconds , Object o , Exception e ) ; void handleErrorOnDelete ( String key , Exception e ) ; void handleErrorOnIncr ( String key , int factor , int startingValue , Exception e ) ; } 
void handleErrorOnSet ( String key , int cacheTimeSeconds , Object o , Exception e ) ; void handleErrorOnDelete ( String key , Exception e ) ; void handleErrorOnIncr ( String key , int factor , int startingValue , Exception e ) ; } 
void handleErrorOnDelete ( String key , Exception e ) ; void handleErrorOnIncr ( String key , int factor , int startingValue , Exception e ) ; } 
void handleErrorOnIncr ( String key , int factor , int startingValue , Exception e ) ; } 
public Object get ( String key ) { try { log . debug ( " MemCachedClient.get({}) " , key ) ; return memcachedClient . get ( key ) ; } catch ( Exception e ) { exceptionHandler . handleErrorOnGet ( key , e ) ; } return null ; } 
public Object get ( String key ) { try { log . debug ( " MemcachedClient.get({}) " , key ) ; return memcachedClient . get ( key ) ; } catch ( Exception e ) { exceptionHandler . handleErrorOnGet ( key , e ) ; } return null ; } 
public void addFilter ( Filter newFilter ) { throw new UnsupportedOperationException ( ) ; } 
public void clearFilters ( ) { throw new UnsupportedOperationException ( ) ; } 
public void doAppend ( LoggingEvent event ) { Assert . assertEquals ( expectedMessage , event . getMessage ( ) ) ; Assert . assertEquals ( expectedError , event . getThrowableInformation ( ) . getThrowable ( ) ) ; appenderCalled = true ; } 
public boolean requiresLayout ( ) { throw new UnsupportedOperationException ( ) ; } 
protected void setupInTransaction ( ) { } protected void tearDownInTransaction ( ) { } @Override protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; } } } 
protected void tearDownInTransaction ( ) { } @Override protected void tearDown ( ) { try { tearDownInTransaction ( ) ; } finally { transaction . rollback ( ) ; session . close ( ) ; } } } 
public Memcache createMemcacheClient ( ) throws Exception { ConnectionFactory connectionFactory = getConnectionFactory ( ) ; MemcachedClient client = new MemcachedClient ( connectionFactory , AddrUtil . getAddresses ( getServerList ( ) ) ) ; return new SpyMemcache ( client ) ; } 
private boolean connectionFactoryNameEquals ( Class < ? > cls ) { return cls . getSimpleName ( ) . equals ( getConnectionFactoryName ( ) ) ; } 
private KetamaConnectionFactory buildKetamaConnectionFactory ( ) { return new KetamaConnectionFactory ( ) { @Override 
Object get ( String key ) ; Map < String , Object > getMulti ( String . . . keys ) ; void set ( String key , int cacheTimeSeconds , Object o ) ; void delete ( String key ) ; void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
Map < String , Object > getMulti ( String . . . keys ) ; void set ( String key , int cacheTimeSeconds , Object o ) ; void delete ( String key ) ; void incr ( String key , int factor , int startingValue ) ; void shutdown ( ) ; } 
private Object memcacheGet ( Object key ) { String objectKey = toKey ( key ) ; String dogpileKey = dogpileTokenKey ( objectKey ) ; Map < String , Object > multi ; if ( dogpilePreventionEnabled ) { log . debug ( " Checking dogpile key: [{}] " , dogpileKey ) ; log . debug ( " Memcache.getMulti({}, {}) " , objectKey , dogpileKey ) ; multi = memcache . getMulti ( dogpileKey , objectKey ) ; if ( multi . get ( dogpileKey ) = = null ) { log . debug ( " Dogpile key ({}) not found updating token and returning null " , dogpileKey ) ; memcache . set ( dogpileKey , cacheTimeSeconds , DOGPILE_TOKEN ) ; return null ; } else { log . debug ( " Dogpile token found for key ({}), getting cached object " , dogpileKey ) ; } } else { log . debug ( " Memcache.get({}) " , objectKey ) ; multi = memcache . getMulti ( objectKey ) ; } return multi . get ( objectKey ) ; } 
private Object memcacheGet ( Object key ) { String objectKey = toKey ( key ) ; Map < String , Object > multi ; if ( dogpilePreventionEnabled ) { String dogpileKey = dogpileTokenKey ( objectKey ) ; log . debug ( " Checking dogpile key: [{}] " , dogpileKey ) ; log . debug ( " Memcache.getMulti({}, {}) " , objectKey , dogpileKey ) ; multi = memcache . getMulti ( dogpileKey , objectKey ) ; if ( multi . get ( dogpileKey ) = = null ) { log . debug ( " Dogpile key ({}) not found updating token and returning null " , dogpileKey ) ; memcache . set ( dogpileKey , cacheTimeSeconds , DOGPILE_TOKEN ) ; return null ; } log . debug ( " Dogpile token found for key ({}), getting cached object " , dogpileKey ) ; } else { log . debug ( " Memcache.get({}) " , objectKey ) ; multi = memcache . getMulti ( objectKey ) ; } return multi . get ( objectKey ) ; } 
private static byte [ ] digest ( String algorithm , String data ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } return digest . digest ( data . getBytes ( ) ) ; } 
private Object memcacheGet ( Object key ) { String objectKey = toKey ( key ) ; if ( dogpilePreventionEnabled ) { return getUsingDogpilePrevention ( objectKey ) ; 
public Map < ? , ? > toMap ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isDaemon ( ) { return isDaemonMode ( ) ; } 
public boolean isDaemonMode ( ) { return properties . getBoolean ( PROP_DAEMON_MODE , false ) ; } 
public String toKey ( String regionName , long clearIndex , Object key ) { if ( key = = null ) { throw new IllegalArgumentException ( " key must not be null " ) ; } String keyString = concatenateKey ( regionName , clearIndex , transformKeyObject ( key ) ) ; if ( keyString . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is longer than " + MAX_KEY_LENGTH + " characters, try using the Sha1KeyStrategy: " + keyString ) ; } String finalKey = CLEAN_PATTERN . matcher ( keyString ) . replaceAll ( " " ) ; log . debug ( " Final cache key: [{}] " , finalKey ) ; return finalKey ; } 
protected abstract String transformKeyObject ( Object key ) ; protected String concatenateKey ( String regionName , long clearIndex , Object key ) { return new StringBuilder ( ) . append ( regionName ) . append ( " : " ) . append ( clearIndex ) . append ( " : " ) . append ( String . valueOf ( key ) ) . toString ( ) ; } } 
protected String transformKeyObject ( Object key ) { return key . toString ( ) + " : " + key . hashCode ( ) ; } 
protected String concatenateKey ( String regionName , long clearIndex , Object key ) { String longKey = super . concatenateKey ( regionName , clearIndex , key ) ; return digest ( longKey ) ; } 
protected String digest ( String key ) { return StringUtils . md5Hex ( key ) ; } 
protected String digest ( String key ) { return StringUtils . sha1Hex ( key ) ; } 
protected AuthDescriptor createAuthDescriptor ( ) { String username = properties . get ( PROP_USERNAME ) ; String password = properties . get ( PROP_PASSWORD ) ; if ( username = = null | | password = = null ) { return null ; } return new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( username , password ) ) ; 
