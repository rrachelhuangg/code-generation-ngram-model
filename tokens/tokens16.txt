public void storeAsync ( StoreOperation . StoreType storeType , String key , tint flags , int exp , byte [ ] value , tStoreOperation . Callback callback ) { tconn . addOperation ( getServerForKey ( key ) , tnew StoreOperation ( storeType , key , flags , exp , value , 
public String storeSync ( StoreOperation . StoreType storeType , String key , tint flags , int exp , byte [ ] value ) { tfinal SynchronizationObject < String > so = tnew SynchronizationObject < String > ( null ) ; tstoreAsync ( storeType , key , flags , exp , value , tnew StoreOperation . Callback ( ) { public void storeResult ( String val ) { tso . set ( val ) ; } } ) ; twaitForNotNull ( so ) ; treturn so . get ( ) ; } 
public void storeResult ( String val ) { tso . set ( val ) ; } 
public String add ( String key , int flags , int exp , byte [ ] value ) { treturn storeSync ( StoreOperation . StoreType . add , key , flags , exp , value ) ; } 
public String set ( String key , int flags , int exp , byte [ ] value ) { treturn storeSync ( StoreOperation . StoreType . set , key , flags , exp , value ) ; } 
public String replace ( String key , int flags , int exp , byte [ ] value ) { treturn storeSync ( StoreOperation . StoreType . replace , key , flags , exp , tvalue ) ; 
public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { tfor ( String key : keys ) { tconn . addOperation ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ; 
public void gotData ( String k , int flags , byte [ ] data ) { tassert k . equals ( key ) : " Incorrect key returned: " + k ; trvContainer [ 0 ] = data ; } } , key ) ; 
public void gotData ( String k , int flags , byte [ ] data ) { trv . put ( k , data ) ; } 
public boolean evaluate ( AtomicInteger val ) { treturn val . get ( ) = = 0 ; } } , 
public void versionResult ( String s ) { trv . put ( sa , s ) ; tsync . set ( s ) ; } 
public void gotStat ( String name , String val ) { trv . get ( sa ) . put ( name , val ) ; } 
public void statsComplete ( ) { ttodo . decrementAndGet ( ) ; tsync . set ( todo ) ; } } ) ) ; 
public boolean evaluate ( AtomicInteger c ) { treturn c . intValue ( ) = = 0 ; } } , 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal SynchronizationObject < Long > sync = tnew SynchronizationObject < Long > ( null ) ; tconn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { tif ( val = = null ) { tval = new Long ( - 1 ) ; } tsync . set ( val ) ; } } ) ) ; twaitForNotNull ( sync ) ; tgetLogger ( ) . info ( " Mutation returned %s " , sync . get ( ) ) ; treturn sync . get ( ) . longValue ( ) ; } 
public void mutatorResult ( Long val ) { tif ( val = = null ) { tval = new Long ( - 1 ) ; } tsync . set ( val ) ; } } ) ) ; 
public long incr ( String key , int by ) { treturn mutate ( MutatorOperation . Mutator . incr , key , by ) ; } 
public long decr ( String key , int by ) { treturn mutate ( MutatorOperation . Mutator . decr , key , by ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tString v = storeSync ( StoreOperation . StoreType . add , key , 0 , 0 , tString . valueOf ( def ) . getBytes ( ) ) ; tif ( v . equals ( " STORED " ) ) { trv = def ; } } treturn rv ; } 
public long incr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatorOperation . Mutator . incr , key , by , def ) ; } 
public long decr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatorOperation . Mutator . decr , key , by , def ) ; } 
public void delete ( String key , int when ) { tconn . addOperation ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; } 
public void run ( ) { twhile ( running ) { ttry { tconn . handleIO ( ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " Problem handling memcached IO " , e ) ; } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public void shutdown ( ) { trunning = false ; ttry { tconn . shutdown ( ) ; 
private void waitForNotNull ( SynchronizationObject < ? > sync ) { ttry { tsync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . SECONDS ) ; 
public void handleIO ( ) throws IOException { tint selected = selector . select ( ) ; tif ( selected > 0 ) { tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; } 
public void shutdown ( ) throws IOException { tfor ( SelectionKey sk : connections ) { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tqa . channel . close ( ) ; tqa . sk = null ; tgetLogger ( ) . info ( " Shut down channel %s " , qa . channel ) ; } tselector . close ( ) ; tgetLogger ( ) . info ( " Shut down selector %s " , selector ) ; } 
public void storeResult ( String val ) { tSystem . out . println ( " Big store result: " + val ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { tSystem . out . printf ( " Got data for %s (%d): %s " , tkey , flags , new String ( data ) ) ; 
public void handleLine ( String line ) { tgetLogger ( ) . info ( " Delete of %s returned %s " , key , line ) ; tassert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; ttransitionState ( State . COMPLETE ) ; } 
public void initialize ( ) { tByteBuffer b = ByteBuffer . allocate ( key . length ( ) + OVERHEAD ) ; tsetArguments ( b , " delete " , key , when ) ; tb . flip ( ) ; tsetBuffer ( b ) ; } 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) ; tgetLogger ( ) . info ( " Flush completed successfully " ) ; ttransitionState ( State . COMPLETE ) ; } 
public void initialize ( ) { tByteBuffer b = null ; tif ( delay = = - 1 ) { tb = ByteBuffer . wrap ( FLUSH ) ; } else { tb = ByteBuffer . allocate ( 32 ) ; tb . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; } tsetBuffer ( b ) ; } 
public void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tgetLogger ( ) . info ( " Get complete! " ) ; 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; if(cb != null) { 
public void initialize ( ) { } 
tvoid gotData ( String key , int flags , byte [ ] data ) ; tvoid getComplete ( ) ; } } 
public void handleLine ( String line ) { tgetLogger ( ) . info ( " Result: %s " , line ) ; tLong found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = new Long ( line ) ; } tif ( cb ! = null ) { tcb . mutatorResult ( found ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void initialize ( ) { tint size = key . length ( ) + OVERHEAD ; tByteBuffer b = ByteBuffer . allocate ( size ) ; tsetArguments ( b , mutator . name ( ) , key , amount ) ; tb . flip ( ) ; tsetBuffer ( b ) ; } 
tprotected void transitionState ( State newState ) { tgetLogger ( ) . info ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; cmd=null; 
public void writeComplete ( ) { ttransitionState ( State . READING ) ; } 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) { 
public void handleRead ( ByteBuffer data ) { tassert false ; } 
public void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tif ( cb ! = null ) { 
public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( MSG ) ) ; } 
tvoid statsComplete ( ) ; tvoid gotStat ( String name , String val ) ; } } 
public void handleLine ( String firstLine ) { tif ( cb ! = null ) { tcb . storeResult ( firstLine ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; tsetArguments ( bb , type . name ( ) , key , flags , exp , data . length ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( " r " . getBytes ( ) ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public void handleLine ( String line ) { tif ( cb ! = null ) { tassert line . startsWith ( " VERSION " ) ; tcb . versionResult ( line . substring ( " VERSION " . length ( ) ) ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; } 
public void testDataReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; tassertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; } 
public void testLineReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; tassertSame ( Operation . ReadType . LINE , op . getReadType ( ) ) ; } 
public void xtestLineParser ( ) throws Exception { tString input = " This is a multiline string r nhere is line two r nxyz " ; tByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; tSimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; top . readFromBuffer ( b ) ; tassertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; top . readFromBuffer ( b ) ; tassertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; top . setReadType ( Operation . ReadType . DATA ) ; top . setBytesToRead ( 2 ) ; top . readFromBuffer ( b ) ; tbyte expected [ ] = { 'x' , 'y' } ; tassertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , tArrays . equals ( expected , op . getCurentBytes ( ) ) ) ; tassertEquals ( 1 , b . remaining ( ) ) ; tassertEquals ( ( byte ) 'z' , b . get ( ) ) ; } 
public void testPartialLine ( ) throws Exception { tString input1 = " this is a " ; tString input2 = " test r " ; tByteBuffer b = ByteBuffer . allocate ( 20 ) ; tSimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; tb . put ( input1 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertNull ( op . getCurrentLine ( ) ) ; tb . clear ( ) ; tb . put ( input2 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertEquals ( " this is a test " , op . getCurrentLine ( ) ) ; } 
public void handleLine ( String line ) { tassert getReadType ( ) = = Operation . ReadType . LINE ; tcurrentLine = line ; } 
public void handleRead ( ByteBuffer data ) { tassert getReadType ( ) = = Operation . ReadType . DATA ; tif ( bytesToRead > 0 ) { tcurrentBytes = new byte [ bytesToRead ] ; 
public void initialize ( ) { tsetBuffer ( ByteBuffer . allocate ( 0 ) ) ; } 
public String toString ( ) { treturn " {CachedData flags= " + flags + " data= " + Arrays . toString ( data ) + " } " ; 
public void storeAsync ( StoreOperation . StoreType storeType , String key , tint exp , Object value , StoreOperation . Callback callback ) { tCachedData co = transcoder . encode ( value ) ; tconn . addOperation ( getServerForKey ( key ) , tnew StoreOperation ( storeType , key , co . getFlags ( ) , exp , 
public String storeSync ( StoreOperation . StoreType storeType , String key , tint exp , Object o ) { tfinal SynchronizationObject < String > so = tnew SynchronizationObject < String > ( null ) ; tstoreAsync ( storeType , key , exp , o , tnew StoreOperation . Callback ( ) { public void storeResult ( String val ) { tso . set ( val ) ; } } ) ; twaitForNotNull ( so ) ; treturn so . get ( ) ; } 
public String add ( String key , int exp , Object o ) { treturn storeSync ( StoreOperation . StoreType . add , key , exp , o ) ; } 
public String set ( String key , int exp , Object o ) { treturn storeSync ( StoreOperation . StoreType . set , key , exp , o ) ; } 
public String replace ( String key , int exp , Object o ) { treturn storeSync ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tString v = storeSync ( StoreOperation . StoreType . add , key , 0 , tnew Long ( def ) ) ; tif ( v . equals ( " STORED " ) ) { trv = def ; } } treturn rv ; } 
public Object decode ( CachedData d ) { tassert d . getFlags ( ) = = 0 ; treturn new String ( d . getData ( ) ) ; } 
public CachedData encode ( Object o ) { treturn new CachedData ( 0 , String . valueOf ( o ) . getBytes ( ) ) ; } 
tCachedData encode ( Object o ) ; tObject decode ( CachedData d ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert k . equals ( key ) : " Incorrect key returned: " + k ; trvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ; 
public void gotData ( String k , int flags , byte [ ] data ) { trv . put ( k , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte b [ ] = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tb = compress ( b ) ; tflags | = COMPRESSED ; } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
private byte [ ] serialize ( Object o ) { tassert o ! = null ; tbyte rv [ ] = null ; ttry { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tObjectOutputStream os = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } treturn rv ; } 
private Object deserialize ( byte [ ] in ) { tObject rv = null ; tassert in ! = null ; ttry { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tObjectInputStream is = new ObjectInputStream ( bis ) ; trv = is . readObject ( ) ; tis . close ( ) ; tbis . close ( ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , tin . length , e ) ; } catch ( ClassNotFoundException e ) { tgetLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , tin . length , e ) ; } treturn rv ; } 
private byte [ ] compress ( byte [ ] in ) { tassert in ! = null ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gz = null ; ttry { tgz = new GZIPOutputStream ( bos ) ; tgz . write ( in ) ; } catch ( IOException e ) { tthrow new RuntimeException ( " IO exception compressing data " , e ) ; } finally { tCloseUtil . close ( gz ) ; tCloseUtil . close ( bos ) ; } tbyte [ ] rv = bos . toByteArray ( ) ; tgetLogger ( ) . info ( " Compressed %d bytes to %d " , in . length , rv . length ) ; treturn rv ; } 
private byte [ ] decompress ( byte [ ] in ) { tassert in ! = null ; tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPInputStream gis ; ttry { tgis = new GZIPInputStream ( bis ) ; tbyte [ ] buf = new byte [ 8192 ] ; tint r = - 1 ; twhile ( ( r = gis . read ( buf ) ) > 0 ) { tbos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { tthrow new RuntimeException ( " Error decompressing data " , e ) ; } treturn bos . toByteArray ( ) ; } 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; if(cb != null) { 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new SerializingTranscoder ( ) ; } 
public void testStrings ( ) throws Exception { tString s1 = " This is a simple test string. " ; tCachedData cd = tc . encode ( s1 ) ; tassertEquals ( 0 , cd . getFlags ( ) ) ; tassertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; tassertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testCompressedString ( ) throws Exception { tString s1 = " This is a test simple string that will be compressed. " ; ttc . setCompressionThreshold ( 8 ) ; tCachedData cd = tc . encode ( s1 ) ; tassertEquals ( SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; tassertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; tassertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testObject ( ) throws Exception { tDate d1 = new Date ( ) ; tCachedData cd = tc . encode ( d1 ) ; tassertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; tassertEquals ( d1 , tc . decode ( cd ) ) ; } 
public void testCompressedObject ( ) throws Exception { ttc . setCompressionThreshold ( 8 ) ; tDate d1 = new Date ( ) ; tCachedData cd = tc . encode ( d1 ) ; tassertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; tassertEquals ( d1 , tc . decode ( cd ) ) ; } 
public void testSomethingBigger ( ) throws Exception { tCollection < Date > dates = new ArrayList < Date > ( ) ; tfor ( int i = 0 ; i < 1024 ; i + + ) { tdates . add ( new Date ( ) ) ; } tCachedData d = tc . encode ( dates ) ; tassertEquals ( dates , tc . decode ( d ) ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tString v = storeSync ( StoreOperation . StoreType . add , key , 0 , tString . valueOf ( def ) ) ; tif ( v . equals ( " STORED " ) ) { trv = def ; } } treturn rv ; } 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal SynchronizationObject < Long > sync = tnew SynchronizationObject < Long > ( null ) ; tconn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { tif ( val = = null ) { tval = new Long ( - 1 ) ; } tsync . set ( val ) ; } } ) ) ; twaitForNotNull ( sync ) ; tgetLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; treturn sync . get ( ) . longValue ( ) ; } 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; } 
public void shutdown ( ) throws IOException { tfor ( SelectionKey sk : connections ) { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tqa . channel . close ( ) ; tqa . sk = null ; tgetLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } tselector . close ( ) ; tgetLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
private byte [ ] compress ( byte [ ] in ) { tassert in ! = null ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gz = null ; ttry { tgz = new GZIPOutputStream ( bos ) ; tgz . write ( in ) ; } catch ( IOException e ) { tthrow new RuntimeException ( " IO exception compressing data " , e ) ; } finally { tCloseUtil . close ( gz ) ; tCloseUtil . close ( bos ) ; } tbyte [ ] rv = bos . toByteArray ( ) ; tgetLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; treturn rv ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; tassert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) ; tgetLogger ( ) . debug ( " Flush completed successfully " ) ; ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tgetLogger ( ) . debug ( " Get complete! " ) ; 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; if(cb != null) { 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tLong found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = new Long ( line ) ; } tif ( cb ! = null ) { tcb . mutatorResult ( found ) ; } ttransitionState ( State . COMPLETE ) ; } 
tprotected void transitionState ( State newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; cmd=null; 
private void handleIO ( SelectionKey sk ) throws IOException { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( qa . ops . size ( ) > 0 ) { tOperation currentOp = qa . ops . peek ( ) ; 
private void reconnect ( QueueAttachment qa ) throws IOException { tgetLogger ( ) . warn ( " Closing, and reopening connection. " ) ; tsynchronized ( qa ) { tqa . sk . cancel ( ) ; 
public void handleIO ( ) throws IOException { tint selected = selector . select ( ) ; tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; tgetLogger ( ) . debug ( " Selected %d, selected %d keys " , tselected , selectedKeys . size ( ) ) ; tif ( selectedKeys . size ( ) > 0 ) { temptySelects = 0 ; tfor ( SelectionKey sk : selectedKeys ) { tgetLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , tsk , sk . isReadable ( ) , sk . isWritable ( ) , tsk . isConnectable ( ) , sk . attachment ( ) ) ; thandleIO ( sk ) ; } } 
private void handleIO ( SelectionKey sk ) throws IOException { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . warn ( " Connection state changed for " + sk ) ; 
private void setupResend ( QueueAttachment qa ) { tif ( qa . ops . size ( ) > 0 ) { tOperation op = qa . ops . peek ( ) ; 
public String toString ( ) { treturn " {QA #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ; } 
public void handleIO ( ) throws IOException { tlong delay = 0 ; tif ( reconnectQueue . size ( ) > 0 ) { tlong now = System . currentTimeMillis ( ) ; tlong then = reconnectQueue . firstKey ( ) ; tdelay = Math . max ( then - now , 1 ) ; } tint selected = selector . select ( delay ) ; tif ( selected > 0 ) { tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; tassert selected = = selectedKeys . size ( ) ; tgetLogger ( ) . debug ( " Selected %d, selected %d keys " , tselected , selectedKeys . size ( ) ) ; temptySelects = 0 ; tfor ( SelectionKey sk : selectedKeys ) { tgetLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , tsk , sk . isReadable ( ) , sk . isWritable ( ) , tsk . isConnectable ( ) , sk . attachment ( ) ) ; thandleIO ( sk ) ; } attemptReconnects(); 
private void handleIO ( SelectionKey sk ) throws IOException { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for " + sk ) ; 
private void queueReconnect ( QueueAttachment qa ) throws IOException { tgetLogger ( ) . warn ( " Closing, and reopening connection. " ) ; tsynchronized ( qa ) { tqa . sk . cancel ( ) ; 
private void attemptReconnects ( ) throws IOException { tlong now = System . currentTimeMillis ( ) ; tfor ( Iterator < QueueAttachment > i = treconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tb = compress ( b ) ; tflags | = COMPRESSED ; } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
private byte [ ] serialize ( Object o ) { tassert o ! = null ; tbyte [ ] rv = null ; ttry { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tObjectOutputStream os = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } treturn rv ; } 
public void xtestLineParser ( ) throws Exception { tString input = " This is a multiline string r nhere is line two r nxyz " ; tByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; tSimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; top . readFromBuffer ( b ) ; tassertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; top . readFromBuffer ( b ) ; tassertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; top . setReadType ( Operation . ReadType . DATA ) ; top . setBytesToRead ( 2 ) ; top . readFromBuffer ( b ) ; tbyte [ ] expected = { 'x' , 'y' } ; tassertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , tArrays . equals ( expected , op . getCurentBytes ( ) ) ) ; tassertEquals ( 1 , b . remaining ( ) ) ; tassertEquals ( ( byte ) 'z' , b . get ( ) ) ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tb = compress ( b ) ; tflags | = COMPRESSED ; } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
private byte [ ] encodeNum ( long l , int maxBytes ) { tbyte [ ] rv = new byte [ maxBytes ] ; tfor ( int i = 0 ; i < rv . length ; i + + ) { tint pos = rv . length - i - 1 ; trv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } tint firstNonZero = 0 ; tfor ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { } 
tlong decodeLong ( byte [ ] b ) { tlong rv = 0 ; tfor ( byte i : b ) { trv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } treturn rv ; } 
tint decodeInt ( byte [ ] in ) { tassert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; treturn ( int ) decodeLong ( in ) ; } 
tbyte decodeByte ( byte [ ] in ) { tassert in . length < = 1 : " Too long for a byte " ; tbyte rv = 0 ; tif ( in . length = = 1 ) { trv = in [ 0 ] ; } treturn rv ; } 
tbyte [ ] encodeBoolean ( boolean b ) { tbyte [ ] rv = new byte [ 1 ] ; trv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; treturn rv ; } 
tboolean decodeBoolean ( byte [ ] in ) { tassert in . length = = 1 : " Wrong length for a boolean " ; treturn in [ 0 ] = = '1' ; } 
public void testObject ( ) throws Exception { tCalendar c = Calendar . getInstance ( ) ; tCachedData cd = tc . encode ( c ) ; tassertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; tassertEquals ( c , tc . decode ( cd ) ) ; } 
public void testCompressedObject ( ) throws Exception { ttc . setCompressionThreshold ( 8 ) ; tCalendar c = Calendar . getInstance ( ) ; tCachedData cd = tc . encode ( c ) ; tassertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; tassertEquals ( c , tc . decode ( cd ) ) ; } 
public void testDate ( ) throws Exception { tDate d = new Date ( ) ; tCachedData cd = tc . encode ( d ) ; tassertEquals ( d , tc . decode ( cd ) ) ; } 
public void testLong ( ) throws Exception { tassertEquals ( 923l , tc . decode ( tc . encode ( 923l ) ) ) ; } 
public void testInt ( ) throws Exception { tassertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) ) ; } 
public void testBoolean ( ) throws Exception { tassertSame ( Boolean . TRUE , tc . decode ( tc . encode ( true ) ) ) ; tassertSame ( Boolean . FALSE , tc . decode ( tc . encode ( false ) ) ) ; } 
public void testByte ( ) throws Exception { tassertEquals ( ( byte ) - 127 , tc . decode ( tc . encode ( ( byte ) - 127 ) ) ) ; } 
private void assertFloat ( float f ) { tassertEquals ( f , tc . decode ( tc . encode ( f ) ) ) ; } 
public void testFloat ( ) throws Exception { tassertFloat ( 0f ) ; tassertFloat ( Float . MIN_VALUE ) ; tassertFloat ( Float . MAX_VALUE ) ; tassertFloat ( 3.14f ) ; tassertFloat ( - 3.14f ) ; tassertFloat ( Float . NaN ) ; tassertFloat ( Float . POSITIVE_INFINITY ) ; tassertFloat ( Float . NEGATIVE_INFINITY ) ; } 
private void assertDouble ( double d ) { tassertEquals ( d , tc . decode ( tc . encode ( d ) ) ) ; } 
public void testDouble ( ) throws Exception { tassertDouble ( 0d ) ; tassertDouble ( Double . MIN_VALUE ) ; tassertDouble ( Double . MAX_VALUE ) ; tassertDouble ( 3.14d ) ; tassertDouble ( - 3.14d ) ; tassertDouble ( Double . NaN ) ; tassertDouble ( Double . POSITIVE_INFINITY ) ; tassertDouble ( Double . NEGATIVE_INFINITY ) ; } 
private void assertLong ( long l ) { tbyte [ ] encoded = tc . encodeLong ( l ) ; tlong decoded = tc . decodeLong ( encoded ) ; tassertEquals ( l , decoded ) ; } 
public void testLongEncoding ( ) throws Exception { tassertLong ( Long . MIN_VALUE ) ; tassertLong ( 1 ) ; tassertLong ( 23852 ) ; tassertLong ( 0 l ) ; tassertLong ( - 1 ) ; tassertLong ( - 23835 ) ; tassertLong ( Long . MAX_VALUE ) ; } 
private void assertInt ( int i ) { tbyte [ ] encoded = tc . encodeInt ( i ) ; tint decoded = tc . decodeInt ( encoded ) ; tassertEquals ( i , decoded ) ; } 
public void testIntEncoding ( ) throws Exception { tassertInt ( Integer . MIN_VALUE ) ; tassertInt ( 83526 ) ; tassertInt ( 1 ) ; tassertInt ( 0 ) ; tassertInt ( - 1 ) ; tassertInt ( - 238526 ) ; tassertInt ( Integer . MAX_VALUE ) ; } 
public void testBooleanEncoding ( ) throws Exception { tassertTrue ( tc . decodeBoolean ( tc . encodeBoolean ( true ) ) ) ; tassertFalse ( tc . decodeBoolean ( tc . encodeBoolean ( false ) ) ) ; } 
private void addOp ( int which , Operation op ) { tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( which , op ) ; } 
public void storeAsync ( StoreOperation . StoreType storeType , String key , tint exp , Object value , StoreOperation . Callback callback ) { tCachedData co = transcoder . encode ( value ) ; taddOp ( getServerForKey ( key ) , tnew StoreOperation ( storeType , key , co . getFlags ( ) , exp , 
public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { tfor ( String key : keys ) { taddOp ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ; 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal SynchronizationObject < Long > sync = tnew SynchronizationObject < Long > ( null ) ; taddOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { tif ( val = = null ) { tval = new Long ( - 1 ) ; } tsync . set ( val ) ; } } ) ) ; twaitForNotNull ( sync ) ; tgetLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; treturn sync . get ( ) . longValue ( ) ; } 
public void delete ( String key , int when ) { taddOp ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; } 
public void handleIO ( ) throws IOException { tlong delay = 0 ; tif ( reconnectQueue . size ( ) > 0 ) { tlong now = System . currentTimeMillis ( ) ; tlong then = reconnectQueue . firstKey ( ) ; tdelay = Math . max ( then - now , 1 ) ; } tgetLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; tint selected = selector . select ( delay ) ; tif ( selected > 0 ) { tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; tassert selected = = selectedKeys . size ( ) ; tgetLogger ( ) . debug ( " Selected %d, selected %d keys " , tselected , selectedKeys . size ( ) ) ; temptySelects = 0 ; tfor ( SelectionKey sk : selectedKeys ) { tgetLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , tsk , sk . isReadable ( ) , sk . isWritable ( ) , tsk . isConnectable ( ) , sk . attachment ( ) ) ; thandleIO ( sk ) ; } attemptReconnects(); 
private void handleIO ( SelectionKey sk ) throws IOException { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; } 
public void shutdown ( ) throws IOException { tfor ( QueueAttachment qa : connections ) { tqa . channel . close ( ) ; tqa . sk = null ; tgetLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } tselector . close ( ) ; tgetLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " {MemcachedConnection to " ) ; tfor ( QueueAttachment qa : connections ) { tsb . append ( " " ) ; tsb . append ( qa . socketAddress ) ; } tsb . append ( " } " ) ; treturn sb . toString ( ) ; } 
public String toString ( ) { treturn " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ; 
private SynchronizationObject < String > setupStoreSync ( tStoreOperation . StoreType storeType , String key , tint exp , Object o ) { tfinal SynchronizationObject < String > so = tnew SynchronizationObject < String > ( null ) ; tstoreAsync ( storeType , key , exp , o , tnew StoreOperation . Callback ( ) { public void storeResult ( String val ) { tso . set ( val ) ; } } ) ; treturn so ; } 
public String storeSync ( StoreOperation . StoreType storeType , String key , tint exp , Object o ) { tSynchronizationObject < String > so = setupStoreSync ( tstoreType , key , exp , o ) ; twaitForNotNull ( so ) ; treturn so . get ( ) ; } 
public String storeSync ( long timeout , StoreOperation . StoreType storeType , tString key , int exp , Object o ) throws TimeoutException { tSynchronizationObject < String > so = setupStoreSync ( tstoreType , key , exp , o ) ; twaitForNotNull ( timeout , so ) ; treturn so . get ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert k . equals ( key ) : " Incorrect key returned: " + k ; trvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ; 
public Object get ( String key ) { tSynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; twaitForNotNull ( sync ) ; tCachedData [ ] rvContainer = sync . get ( ) ; tassert rvContainer . length = = 1 ; tObject rv = null ; tif ( rvContainer [ 0 ] ! = null ) { trv = transcoder . decode ( rvContainer [ 0 ] ) ; } treturn rv ; } 
public Object get ( long timeout , String key ) throws TimeoutException { tSynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; twaitForNotNull ( timeout , sync ) ; tCachedData [ ] rvContainer = sync . get ( ) ; tassert rvContainer . length = = 1 ; tObject rv = null ; tif ( rvContainer [ 0 ] ! = null ) { trv = transcoder . decode ( rvContainer [ 0 ] ) ; } treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } 
public Map < String , Object > get ( String . . . keys ) { tMap < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; tSynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; twaitForOperations ( sync ) ; treturn rv ; } 
public Map < String , Object > get ( long timeout , String . . . keys ) tthrows TimeoutException { tMap < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; tSynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; twaitForOperations ( timeout , sync ) ; treturn rv ; } 
public void versionResult ( String s ) { trv . put ( sa , s ) ; tai . decrementAndGet ( ) ; tsync . set ( ai ) ; } 
private void waitForNotNull ( long timeout , SynchronizationObject < ? > sync ) tthrows TimeoutException { ttry { tsync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
private void waitForNotNull ( SynchronizationObject < ? > sync ) { ttry { twaitForNotNull ( Long . MAX_VALUE , sync ) ; 
private void waitForOperations ( long timeout , tfinal SynchronizationObject < AtomicInteger > sync ) tthrows TimeoutException { ttry { tsync . waitUntilTrue ( 
private void waitForOperations ( tfinal SynchronizationObject < AtomicInteger > sync ) { ttry { twaitForOperations ( Long . MAX_VALUE , sync ) ; 
public void storeResult ( String val ) { tsync . set ( val ) ; } } ) ; 
public Future < String > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; } 
public Future < String > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; } 
public Future < String > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) . equals ( " STORED " ) ) { trv = def ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public boolean cancel ( boolean ign ) { tassert op ! = null : " No operation " ; top . cancel ( ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { ttry { twaitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { tassert false : " Timed out waiting forever. " ; } treturn sync . get ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { twaitForIt ( duration , units ) ; treturn sync . get ( ) ; } 
tprotected void waitForIt ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { tsync . waitUntilNotNull ( duration , units ) ; } 
public boolean isCancelled ( ) { tassert op ! = null : " No operation " ; treturn op . isCancelled ( ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn op . getState ( ) = = Operation . State . COMPLETE ; } 
private boolean hasPendingOperations ( QueueAttachment qa ) { tassert Thread . holdsLock ( qa ) : " Not locking qa " ; tOperation nextOp = qa . ops . peek ( ) ; twhile ( nextOp ! = null & & nextOp . isCancelled ( ) ) { tgetLogger ( ) . info ( " Removing cancelled operation: %s " , tnextOp ) ; tqa . ops . remove ( ) ; tnextOp = qa . ops . peek ( ) ; } treturn nextOp ! = null ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tb = compress ( b ) ; tflags | = COMPRESSED ; } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
public void testByteArray ( ) throws Exception { tbyte [ ] a = { 'a' , 'b' , 'c' } ; tCachedData cd = tc . encode ( a ) ; tassertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; tassertTrue ( Arrays . equals ( a , ( byte [ ] ) tc . decode ( cd ) ) ) ; } 
private Operation addOp ( int which , Operation op ) { tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( which , op ) ; treturn op ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } } ) ; 
tprotected void waitForIt ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { tsync . waitUntilTrue ( tnew SynchronizationObject . Predicate < Object > ( ) { 
public boolean evaluate ( Object o ) { treturn o ! = marker ; } 
public Object get ( String key ) { ttry { treturn asyncGet ( key ) . get ( ) ; 
public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) ) ; } 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal SynchronizationObject < Long > sync = tnew SynchronizationObject < Long > ( null ) ; taddOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { tif ( val = = null ) { tval = new Long ( - 1 ) ; } tsync . set ( val ) ; } } ) ) ; ttry { tsync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { tthrow new RuntimeException ( " Timed out waiting forever. " ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; treturn sync . get ( ) . longValue ( ) ; } 
private void waitForOperations ( tfinal SynchronizationObject < AtomicInteger > sync ) { ttry { tsync . waitUntilTrue ( 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = Operation . State . WRITING ; top . cancel ( ) ; } tcancelled = true ; treturn rv ; } 
public Map < String , Object > get ( ) tthrows InterruptedException , ExecutionException { ttry { treturn get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tsync . waitUntilTrue ( tnew SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { treturn i . get ( ) = = 0 ; } } , ttimeout , unit ) ; treturn m ; } 
public boolean evaluate ( AtomicInteger i ) { treturn i . get ( ) = = 0 ; } } , 
public boolean isDone ( ) { treturn requests . get ( ) = = 0 ; } 
public static void main ( String args [ ] ) throws Exception { tfinal MemcachedClient c = new MemcachedClient ( tnew InetSocketAddress ( " localhost " , 11211 ) ) ; ttry { tassert false ; tthrow new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { } 
public void receivedStatus ( String val ) { tsync . set ( val ) ; } } ) ; 
public Future < Object > asyncGet ( final String key ) { @Override 
public void receivedStatus ( String line ) { tsync . set ( val ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal AtomicInteger requests = new AtomicInteger ( ) ; tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; tfinal SynchronizationObject < AtomicInteger > sync = new SynchronizationObject < AtomicInteger > ( requests ) ; tGetOperation . Callback cb = new GetOperation . Callback ( ) { public void receivedStatus ( String line ) { trequests . decrementAndGet ( ) ; tsync . set ( requests ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } } ; } 
public void receivedStatus ( String line ) { trequests . decrementAndGet ( ) ; tsync . set ( requests ) ; } 
public void receivedStatus ( String s ) { trv . put ( sa , s ) ; tai . decrementAndGet ( ) ; tsync . set ( ai ) ; } 
public void receivedStatus ( String line ) { ttodo . decrementAndGet ( ) ; tsync . set ( todo ) ; } } ) ) ; 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal SynchronizationObject < Long > sync = tnew SynchronizationObject < Long > ( null ) ; taddOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { tsync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ; ttry { tsync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { tthrow new RuntimeException ( " Timed out waiting forever. " ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; treturn sync . get ( ) . longValue ( ) ; } 
public void receivedStatus ( String val ) { tsync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ; 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tString found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = line ; } tif ( cb ! = null ) { tcb . receivedStatus ( found ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tif ( cb ! = null ) { tcb . receivedStatus ( line ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tif ( cb ! = null ) { tassert line . startsWith ( " VERSION " ) ; tcb . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; } ttransitionState ( State . COMPLETE ) ; } 
private byte [ ] serialize ( Object o ) { tassert o ! = null ; tbyte [ ] rv = null ; ttry { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tObjectOutputStream os = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tthrow new IllegalArgumentException ( " Non-serializable object " , e ) ; } treturn rv ; } 
public static void main ( String args [ ] ) throws Exception { tfinal MemcachedClient c = new MemcachedClient ( tnew InetSocketAddress ( " localhost " , 11211 ) ) ; ttry { tassert false ; tthrow new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { } 
public void testNonserializable ( ) throws Exception { ttry { ttc . encode ( new Object ( ) ) ; 
public void handleIO ( ) throws IOException { tlong delay = 0 ; tif ( ! reconnectQueue . isEmpty ( ) ) { tlong now = System . currentTimeMillis ( ) ; tlong then = reconnectQueue . firstKey ( ) ; tdelay = Math . max ( then - now , 1 ) ; } tgetLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; tint selected = selector . select ( delay ) ; tif ( selected > 0 ) { tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; tassert selected = = selectedKeys . size ( ) ; tgetLogger ( ) . debug ( " Selected %d, selected %d keys " , tselected , selectedKeys . size ( ) ) ; temptySelects = 0 ; tfor ( SelectionKey sk : selectedKeys ) { tgetLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , tsk , sk . isReadable ( ) , sk . isWritable ( ) , tsk . isConnectable ( ) , sk . attachment ( ) ) ; thandleIO ( sk ) ; } attemptReconnects(); 
private void queueReconnect ( QueueAttachment qa ) throws IOException { tsynchronized ( qa ) { tgetLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tsync . waitUntilTrue ( tnew SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { treturn i . get ( ) = = 0 ; } } , ttimeout , unit ) ; tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } } treturn m ; } 
public T get ( ) throws InterruptedException , ExecutionException { ttry { twaitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { tassert false : " Timed out waiting forever. " ; } tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn sync . get ( ) ; } 
tprotected void wasCancelled ( ) { }} 
tprotected void wasCancelled ( ) { }} 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; cb.gotData(currentKey, currentFlags, data); 
tvoid gotData ( String key , int flags , byte [ ] data ) ; } @Override tprotected void wasCancelled ( ) { tcb . receivedStatus ( " cancelled " ) ; } } 
tprotected void wasCancelled ( ) { tcb . receivedStatus ( " cancelled " ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tString found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = line ; } tcb . receivedStatus ( found ) ; ttransitionState ( State . COMPLETE ) ; } 
public void cancel ( ) { tcancelled = true ; twasCancelled ( ) ; } 
public void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tcb . receivedStatus ( line ) ; 
public static void main ( String args [ ] ) throws Exception { tfinal MemcachedClient c = new MemcachedClient ( tnew InetSocketAddress ( " localhost " , 11211 ) ) ; ttry { tassert false ; tthrow new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { } 
tprotected void wasCancelled ( ) { }} 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compress ( b ) ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
public void testCompressedStringNotSmaller ( ) throws Exception { tString s1 = " This is a test simple string that will not be compressed. " ; } 
public void testCompressedString ( ) throws Exception { } 
public void handleIO ( ) throws IOException { tlong delay = 0 ; tif ( ! reconnectQueue . isEmpty ( ) ) { tlong now = System . currentTimeMillis ( ) ; tlong then = reconnectQueue . firstKey ( ) ; tdelay = Math . max ( then - now , 1 ) ; } tgetLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; tint selected = selector . select ( delay ) ; tif ( selected > 0 ) { tSet < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; tassert selected = = selectedKeys . size ( ) ; tgetLogger ( ) . debug ( " Selected %d, selected %d keys " , tselected , selectedKeys . size ( ) ) ; temptySelects = 0 ; tfor ( SelectionKey sk : selectedKeys ) { tgetLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , tsk , sk . isReadable ( ) , sk . isWritable ( ) , tsk . isConnectable ( ) , sk . attachment ( ) ) ; thandleIO ( sk ) ; } attemptReconnects(); 
public void handleIO ( ) throws IOException { attemptReconnects(); 
private void handleInputQueue ( ) throws IOException { tif ( ! addedQueue . isEmpty ( ) ) { tgetLogger ( ) . debug ( " Handling queue " ) ; 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; tif ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) ) { tqa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } taddedQueue . offer ( qa ) ; tselector . wakeup ( ) ; tgetLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
public String toString ( ) { tint sops = 0 ; tif ( sk . isValid ( ) ) { tsops = sk . interestOps ( ) ; } treturn " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ; 
public void handleIO ( ) throws IOException { attemptReconnects(); 
public String toString ( ) { tint sops = 0 ; tif ( sk ! = null & & sk . isValid ( ) ) { tsops = sk . interestOps ( ) ; } treturn " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ; 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tsync . waitUntilTrue ( tnew SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { treturn i . get ( ) = = 0 ; } } , ttimeout , unit ) ; tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } } treturn rvMap ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
public int hash ( String k ) { tint rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
private void assertHash ( HashAlgorithm ha , String key , int exp ) { tassertTrue ( exp > = 0 ) ; tassertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp); 
private void assertNativeHash ( String key ) { tassertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
public void testNativeHash ( ) { tfor ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { tassertNativeHash ( k ) ; 
public void testCrc32Hash ( ) { tMap < String , Integer > exp = new HashMap < String , Integer > ( ) ; texp . put ( " Test1 " , 19315 ) ; texp . put ( " Test2 " , 21114 ) ; texp . put ( " Test3 " , 9597 ) ; texp . put ( " Test4 " , 15129 ) ; tfor ( Map . Entry < String , Integer > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testSingle ( ) throws Exception { tList < InetSocketAddress > addrs = tAddrUtil . getAddresses ( " www.google.com:80 " ) ; tassertEquals ( 1 , addrs . size ( ) ) ; tassertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; tassertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
public void testTwo ( ) throws Exception { tList < InetSocketAddress > addrs = tAddrUtil . getAddresses ( " www.google.com:80 www.yahoo.com:81 " ) ; tassertEquals ( 2 , addrs . size ( ) ) ; tassertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; tassertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; tassertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; tassertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; } 
public void testBrokenHost ( ) throws Exception { tString s = " www.google.com:80 www.yahoo.com:81:more " ; ttry { tList < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenHost2 ( ) throws Exception { tString s = " www.google.com:80 www.yahoo.com " ; ttry { tList < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenList ( ) throws Exception { tString s = " " ; ttry { tList < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenList2 ( ) throws Exception { tString s = " " ; ttry { tList < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testNullList ( ) throws Exception { tString s = null ; ttry { tList < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
private void handleInputQueue ( ) { tif ( ! addedQueue . isEmpty ( ) ) { tgetLogger ( ) . debug ( " Handling queue " ) ; 
private void handleIO ( SelectionKey sk ) { tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; 
private void queueReconnect ( QueueAttachment qa ) { tsynchronized ( qa ) { tgetLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
private String dbgBuffer ( ByteBuffer b , int size ) { tStringBuilder sb = new StringBuilder ( ) ; tbyte [ ] bytes = b . array ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tchar ch = ( char ) bytes [ i ] ; tif ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { tsb . append ( ch ) ; } else { tsb . append ( " \\ x " ) ; tsb . append ( Integer . toHexString ( bytes [ i ] & 0xff ) ) ; } } treturn sb . toString ( ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) . equals ( " STORED " ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
tstatic String dbgBuffer ( ByteBuffer b , int size ) { tStringBuilder sb = new StringBuilder ( ) ; tbyte [ ] bytes = b . array ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tchar ch = ( char ) bytes [ i ] ; tif ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { tsb . append ( ch ) ; } else { tsb . append ( " \\ x " ) ; tsb . append ( Integer . toHexString ( bytes [ i ] & 0xff ) ) ; } } treturn sb . toString ( ) ; } 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tqa . ops . add ( o ) ; tif ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { tqa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } taddedQueue . offer ( qa ) ; tselector . wakeup ( ) ; tgetLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
public void initialize ( ) { tByteBuffer b = null ; tif ( delay = = - 1 ) { tb = ByteBuffer . wrap ( FLUSH ) ; } else { tb = ByteBuffer . allocate ( 32 ) ; tb . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; tb . flip ( ) ; } tsetBuffer ( b ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tclient = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; } 
tprotected void tearDown ( ) throws Exception { tclient . flush ( ) ; } 
public void testSimpleGet ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; } 
public void testInvalidKey1 ( ) throws Exception { ttry { tclient . get ( " key with spaces " ) ; 
public void testInvalidKey2 ( ) throws Exception { ttry { tStringBuilder longKey = new StringBuilder ( ) ; 
public Boolean call ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { tclient . set ( " test " + i , 5 , " value " + i ) ; tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } tfor ( int i = 0 ; i < 10 ; i + + ) { tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } treturn Boolean . TRUE ; } } ) ; 
public void testAdd ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tclient . add ( " test1 " , 5 , " ignoredvalue " ) ; } 
public void testUpdate ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . replace ( " test1 " , 5 , " test1value " ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testGetBulk ( ) throws Exception { tCollection < String > keys = Arrays . asList ( " test1 " , " test2 " , " test3 " ) ; tassertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " ) ; tclient . set ( " test2 " , 5 , " val2 " ) ; tMap < String , Object > vals = client . getBulk ( keys ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetBulkVararg ( ) throws Exception { tassertEquals ( 0 , client . getBulk ( " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " ) ; tclient . set ( " test2 " , 5 , " val2 " ) ; tMap < String , Object > vals = client . getBulk ( " test1 " , " test2 " , " test3 " ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetVersions ( ) throws Exception { tMap < SocketAddress , String > vs = client . getVersions ( ) ; tassertEquals ( 1 , vs . size ( ) ) ; tMap . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; tassertEquals ( " /127.0.0.1:11211 " , me . getKey ( ) . toString ( ) ) ; tassertNotNull ( me . getValue ( ) ) ; } 
public void testGetStats ( ) throws Exception { tMap < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; tassertEquals ( 1 , stats . size ( ) ) ; tMap < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; tassertTrue ( oneStat . containsKey ( " total_items " ) ) ; } 
public void testNonexistentMutate ( ) throws Exception { tassertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; tassertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; } 
public void testMutateWithDefault ( ) throws Exception { tassertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; tassertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; tassertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; tassertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; } 
public Long call ( ) throws Exception { treturn client . incr ( " mtest " , 1 , 11 ) ; } } ) ; 
public void testImmediateDelete ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tclient . delete ( " test1 " ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testFutureDelete ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tclient . delete ( " test1 " , 5 ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testFutureFlush ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tclient . flush ( 1 ) ; XXX: I do not understand the semantics of flush_all 
public void testDebugBuffer ( ) throws Exception { tString input = " this is a test _ " ; tByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; tString s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; tassertEquals ( " this is a test \\ x5f " , s ) ; } 
public void testFutureFlush ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tclient . set ( " test2 " , 5 , " test2value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassertEquals ( " test2value " , client . get ( " test2 " ) ) ; tclient . flush ( 2 ) ; tThread . sleep ( 2100 ) ; tassertNull ( client . get ( " test1 " ) ) ; tassertNull ( client . get ( " test2 " ) ) ; } 
public void testDataReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; tassertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; } 
public void testLineParser ( ) throws Exception { tString input = " This is a multiline string r nhere is line two r " ; tByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; tSimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; top . linesToRead = 2 ; top . readFromBuffer ( b ) ; tassertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; tassertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; top . setBytesToRead ( 2 ) ; top . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; tbyte [ ] expected = { 'x' , 'y' } ; tassertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , 
public void handleLine ( String line ) { tassert getReadType ( ) = = Operation . ReadType . LINE ; tlines . add ( line ) ; tif ( - - linesToRead = = 0 ) { tsetReadType ( Operation . ReadType . DATA ) ; 
public void handleRead ( ByteBuffer data ) { tassert getReadType ( ) = = Operation . ReadType . DATA ; tassert bytesToRead > 0 ; tif ( bytesToRead > 0 ) { tcurrentBytes = new byte [ bytesToRead ] ; 
public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( msg ) ) ; } 
public void testGetKeys ( ) throws Exception { tclient . set ( " test1 " , 5 , " test1value " ) ; tclient . set ( " test2 " , 5 , " test2value " ) ; tCollection < String > ks = client . findKeys ( " " ) ; tassertEquals ( 2 , ks . size ( ) ) ; tassertTrue ( ks . contains ( " test1 " ) ) ; tassertTrue ( ks . contains ( " test2 " ) ) ; } 
public void receivedStatus ( String s ) { trv . put ( sa , s ) ; tlatch . countDown ( ) ; } 
public void receivedStatus ( String line ) { tlatch . countDown ( ) ; } } ) ) ; 
public void receivedStatus ( String val ) { trv . set ( val ) ; tlatch . countDown ( ) ; } } ) ; 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; tlatch . countDown ( ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( getServerForKey ( key ) , op ) ; treturn rv ; } 
public void receivedStatus ( String line ) { trv . set ( val ) ; tlatch . countDown ( ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void receivedStatus ( String line ) { tlatch . countDown ( ) ; } 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tlatch . await ( timeout , unit ) ; tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } } treturn rvMap ; } 
public boolean isDone ( ) { treturn latch . getCount ( ) = = 0 ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn obj ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { tlatch . await ( duration , units ) ; treturn obj ; } 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tboolean wasEmpty = qa . ops . isEmpty ( ) ; tqa . ops . add ( o ) ; tif ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { tqa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } taddedQueue . offer ( qa ) ; tselector . wakeup ( ) ; tgetLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = new DeleteOperation ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( getServerForKey ( key ) , op ) ; treturn rv ; } 
public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; tlatch . countDown ( ) ; } } ) ; 
public Future < Boolean > delete ( String key ) { treturn delete ( key , 0 ) ; } 
public void receivedStatus ( String line ) { trv . set ( line . equals ( " OK " ) ) ; tlatch . countDown ( ) ; } } ) ) ; 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op ! = null & & op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn obj ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; tassert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; tcallback . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) ; tgetLogger ( ) . debug ( " Flush completed successfully " ) ; tcallback . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
tprotected void tearDown ( ) throws Exception { tassertTrue ( client . flush ( ) . get ( ) ) ; tclient . shutdown ( ) ; tclient = null ; tsuper . tearDown ( ) ; } 
public void testDeleteFuture ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tFuture < Boolean > f = client . delete ( " test1 " ) ; tassertNull ( client . get ( " test1 " ) ) ; tassertTrue ( " Deletion didn't return true " , f . get ( ) ) ; tassertFalse ( " Second deletion returned true " , tclient . delete ( " test1 " ) . get ( ) ) ; 
public void testDelayedDelete ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tclient . delete ( " test1 " , 5 ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testDelayedFlush ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tclient . set ( " test2 " , 5 , " test2value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassertEquals ( " test2value " , client . get ( " test2 " ) ) ; tclient . flush ( 2 ) ; tThread . sleep ( 2100 ) ; tassertNull ( client . get ( " test1 " ) ) ; tassertNull ( client . get ( " test2 " ) ) ; } 
public void testFlush ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tclient . set ( " test2 " , 5 , " test2value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassertEquals ( " test2value " , client . get ( " test2 " ) ) ; tassertTrue ( client . flush ( ) . get ( ) ) ; tassertNull ( client . get ( " test1 " ) ) ; tassertNull ( client . get ( " test2 " ) ) ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tBlockingQueue < Operation > createOperationQueue ( ) ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( readBufSize , this , addrs ) ; } 
public BlockingQueue < Operation > createOperationQueue ( ) { treturn new ArrayBlockingQueue < Operation > ( opQueueLen ) ; } 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tboolean wasEmpty = qa . ops . isEmpty ( ) ; tboolean added = qa . ops . add ( o ) ; tassert added ; } 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; tlatch . countDown ( ) ; } } ) ) ; 
public void receivedStatus ( String val ) { trv . set ( val . equals ( " STORED " ) ) ; tlatch . countDown ( ) ; } } ) ; 
public Future < Boolean > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; } 
public Future < Boolean > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; } 
public Future < Boolean > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; } 
private long mutateWithDefault ( MutatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public void testAdd ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tassertTrue ( client . set ( " test1 " , 5 , " test1value " ) . get ( ) ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " ) . get ( ) ) ; } 
private Operation addOp ( int which , Operation op ) { tassert isAlive ( ) : " IO Thread is not running. " ; tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tconn . addOperation ( which , op ) ; treturn op ; } 
public void shutdown ( ) { tshutdown ( - 1 , TimeUnit . MILLISECONDS ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { tshuttingDown = true ; tString baseName = getName ( ) ; tsetName ( baseName + " - SHUTTING DOWN " ) ; tboolean rv = false ; tif ( timeout > 0 ) { tsetName ( baseName + " - SHUTTING DOWN (waiting) " ) ; trv = waitForQueues ( timeout , unit ) ; } ttry { tsetName ( baseName + " - SHUTTING DOWN (telling client) " ) ; trunning = false ; tconn . shutdown ( ) ; tsetName ( baseName + " - SHUTTING DOWN (informed client) " ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " exception while shutting down " , e ) ; } treturn rv ; } 
public void receivedStatus ( String s ) { tlatch . countDown ( ) ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void queueReconnect ( QueueAttachment qa ) { tif ( ! shutDown ) { tsynchronized ( qa ) { 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) : " Expected OK, was " + line ; tgetLogger ( ) . debug ( " Flush completed successfully " ) ; tcallback . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
public void testGracefulShutdown ( ) throws Exception { tfor ( int i = 0 ; i < 1000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertTrue ( " Couldn't shut down within five seconds " , tclient . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i)); 
public void testGracefulShutdownTooSlow ( ) throws Exception { tfor ( int i = 0 ; i < 1000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertFalse ( " Weird, shut down too fast " , tclient . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; ttry { tMap < SocketAddress , String > m = client . getVersions ( ) ; tfail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { tassertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
private Operation addOp ( int which , Operation op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( which , op ) ; treturn op ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { tshuttingDown = true ; tString baseName = getName ( ) ; tsetName ( baseName + " - SHUTTING DOWN " ) ; tboolean rv = false ; ttry { } 
public void testAddNotSerializable ( ) throws Exception { ttry { tclient . add ( " t1 " , 5 , new Object ( ) ) ; 
public void testSetNotSerializable ( ) throws Exception { ttry { tclient . set ( " t1 " , 5 , new Object ( ) ) ; 
public void testReplaceNotSerializable ( ) throws Exception { ttry { tclient . replace ( " t1 " , 5 , new Object ( ) ) ; 
public long hash ( String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
private void assertHash ( HashAlgorithm ha , String key , long exp ) { tassertTrue ( exp > = 0 L ) ; tassertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp); 
public void testCrc32Hash ( ) { tMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " Test1 " , 19315L ) ; texp . put ( " Test2 " , 21114L ) ; texp . put ( " Test3 " , 9597L ) ; texp . put ( " Test4 " , 15129L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testFowlerNollVoHash ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0xcbf29ce484222325L ) ; texp . put ( " " , 0xaf63bd4c8601b7ffL ) ; texp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0x536c9cdee87c054aL ) ; texp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; texp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) , 
public long hash ( String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
private void assertNativeHash ( String key ) { tassertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
public void testNativeHash ( ) { tfor ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { tassertNativeHash ( k ) ; 
public void testCrc32Hash ( ) { tMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " Test1 " , 19315L ) ; texp . put ( " Test2 " , 21114L ) ; texp . put ( " Test3 " , 9597L ) ; texp . put ( " Test4 " , 15129L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testFowlerNollVoHash ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0xcbf29ce484222325L ) ; texp . put ( " " , 0xaf63bd4c8601b7ffL ) ; texp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0x536c9cdee87c054aL ) ; texp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; texp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) , Math . abs ( me 
public long hash ( String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
public static void main ( String [ ] args ) throws Exception { } 
private boolean hasPendingOperations ( QueueAttachment qa ) { tassert Thread . holdsLock ( qa ) : " Not locking qa " ; tOperation nextOp = qa . getCurrentOp ( ) ; twhile ( nextOp ! = null & & nextOp . isCancelled ( ) ) { tgetLogger ( ) . info ( " Removing cancelled operation: %s " , tnextOp ) ; tqa . removeCurrentOp ( ) ; tnextOp = qa . getCurrentOp ( ) ; } treturn nextOp ! = null ; } 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tsynchronized ( qa ) { tboolean wasEmpty = ! qa . hasOp ( ) ; tqa . addOp ( o ) ; tif ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { tqa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } taddedQueue . offer ( qa ) ; tselector . wakeup ( ) ; tgetLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
public void optimize ( ) { tassert Thread . holdsLock ( this ) : " Not holding the lock for QA " ; getOp=(GetOperation)opq.remove(); 
public Operation removeCurrentOp ( ) { tOperation rv = getOp ; tif ( rv = = null ) { trv = opq . remove ( ) ; } else { tgetOp = null ; } treturn rv ; } 
public boolean hasOp ( ) { treturn ! ( getOp = = null & & opq . isEmpty ( ) ) ; } 
public void addOp ( Operation op ) { tboolean added = opq . add ( op ) ; tassert added ; } 
public String toString ( ) { tint sops = 0 ; tif ( sk ! = null & & sk . isValid ( ) ) { tsops = sk . interestOps ( ) ; } tint size = opq . size ( ) + ( getOp = = null ? 0 : 1 ) ; treturn " {QA sa= " + socketAddress + " , #ops= " + size + " , topop= " + getCurrentOp ( ) + " , interested= " + sops + " } " ; 
public void initialize ( ) { } 
public int numCallbacks ( ) { treturn allCallbacks . size ( ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { tCollection < Callback > cbs = callbacks . get ( key ) ; tassert cbs ! = null : " No callbacks for key " + key ; tfor ( Callback c : cbs ) { tc . gotData ( key , flags , data ) ; 
public void receivedStatus ( String line ) { tfor ( Callback c : allCallbacks ) { tc . receivedStatus ( line ) ; 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public void gotData ( String key , int flags , byte [ ] data ) { tassert ! completed : " Got data for a completed wrapped op " ; tcb . gotData ( key , flags , data ) ; tif ( - - remainingKeys = = 0 ) { Fake a status line 
public void receivedStatus ( String line ) { tif ( ! completed ) { tcb . receivedStatus ( line ) ; 
private boolean selectorsMakeSense ( ) { tfor ( QueueAttachment qa : connections ) { tif ( qa . sk . isValid ( ) ) { tif ( qa . channel . isConnected ( ) ) { tint sops = qa . sk . interestOps ( ) ; tint expected = 0 ; tif ( qa . hasReadOp ( ) ) { texpected | = SelectionKey . OP_READ ; } tif ( qa . hasWriteOp ( ) ) { texpected | = SelectionKey . OP_WRITE ; } tassert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { tint sops = qa . sk . interestOps ( ) ; tassert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } tgetLogger ( ) . debug ( " Checked the selectors. " ) ; treturn true ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void handleIO ( SelectionKey sk ) { tassert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; ttry { tif ( qa . channel . finishConnect ( ) ) { tassert qa . channel . isConnected ( ) : " Not connected. " ; tqa . reconnectAttempt = 0 ; taddedQueue . offer ( qa ) ; tif ( qa . hasWriteOp ( ) ) { thandleWrites ( sk , qa ) ; } } else { tassert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Problem handling connect " , e ) ; tqueueReconnect ( qa ) ; } } else { tif ( sk . isWritable ( ) ) { ttry { thandleWrites ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , tqa . getCurrentWriteOp ( ) , e ) ; } } tif ( sk . isReadable ( ) ) { ttry { thandleReads ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , tqa . getCurrentReadOp ( ) , e ) ; } } } tfixupOps ( qa ) ; } 
private void handleWrites ( SelectionKey sk , QueueAttachment qa ) tthrows IOException { tboolean canWriteMore = true ; twhile ( canWriteMore ) { tOperation currentOp = qa . getCurrentWriteOp ( ) ; 
private void handleReads ( SelectionKey sk , QueueAttachment qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tint read = qa . channel . read ( qa . buf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
private void fixupOps ( QueueAttachment qa ) { tif ( qa . sk . isValid ( ) ) { tint iops = qa . getSelectionOps ( ) ; 
private boolean preparePending ( QueueAttachment qa ) { } 
private void queueReconnect ( QueueAttachment qa ) { tif ( ! shutDown ) { tgetLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
private void setupResend ( QueueAttachment qa ) { getLogger().warn("Discarding partially completed op: %s", op); 
public void addOperation ( int which , Operation o ) { tQueueAttachment qa = connections [ which ] ; to . initialize ( ) ; tqa . addOp ( o ) ; taddedQueue . offer ( qa ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %d " , o , which ) ; } 
public void copyInputQueue ( ) { tCollection < Operation > tmp = new ArrayList < Operation > ( ) ; tinputQueue . drainTo ( tmp ) ; twriteQ . addAll ( tmp ) ; } 
public void transitionWriteItem ( ) { tOperation op = writeQ . remove ( ) ; tassert op ! = null : " There is no write item to transition " ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public void optimize ( ) { tassert Thread . holdsLock ( this ) : " Not holding the lock for QA " ; getOp=(GetOperation)writeQ.remove(); 
public Operation removeCurrentReadOp ( ) { treturn readQ . remove ( ) ; } 
public Operation removeCurrentWriteOp ( ) { tOperation rv = getOp ; tif ( rv = = null ) { trv = writeQ . remove ( ) ; } else { tgetOp = null ; } treturn rv ; } 
public boolean hasReadOp ( ) { treturn ! readQ . isEmpty ( ) ; } 
public boolean hasWriteOp ( ) { treturn ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
public void addOp ( Operation op ) { tboolean added = inputQueue . add ( op ) ; tassert added ; } 
public String toString ( ) { tint sops = 0 ; tif ( sk ! = null & & sk . isValid ( ) ) { tsops = sk . interestOps ( ) ; } tint rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; tint wsize = writeQ . size ( ) ; tint isize = inputQueue . size ( ) ; treturn " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) { 
public void handleLine ( String line ) { tassert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; tif ( cb ! = null ) { tcb . receivedStatus ( line ) ; } ttransitionState ( State . COMPLETE ) ; } 
public void testGracefulShutdownTooSlow ( ) throws Exception { tfor ( int i = 0 ; i < 10000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertFalse ( " Weird, shut down too fast " , tclient . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; ttry { tMap < SocketAddress , String > m = client . getVersions ( ) ; tfail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { tassertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
public static void main ( String [ ] args ) throws Exception { } 
public void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tassert op . getState ( ) = = Operation . State . READING ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
public void testMixedSetsAndUpdates ( ) throws Exception { tCollection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; tCollection < String > keys = new ArrayList < String > ( ) ; tfor ( int i = 0 ; i < 100 ; i + + ) { tString key = " k " + i ; tfutures . add ( client . set ( key , 10 , key ) ) ; tfutures . add ( client . add ( key , 10 , " a " + i ) ) ; tkeys . add ( key ) ; } tMap < String , Object > m = client . getBulk ( keys ) ; tassertEquals ( 100 , m . size ( ) ) ; tfor ( Map . Entry < String , Object > me : m . entrySet ( ) ) { tassertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } tfor ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { tassertTrue ( i . next ( ) . get ( ) ) ; 
private void setupResend ( QueueAttachment qa ) { op=qa.removeCurrentReadOp(); 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void handleIO ( SelectionKey sk ) { tassert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; ttry { tif ( qa . channel . finishConnect ( ) ) { tassert qa . channel . isConnected ( ) : " Not connected. " ; tqa . reconnectAttempt = 0 ; taddedQueue . offer ( qa ) ; tif ( qa . wbuf . hasRemaining ( ) ) { thandleWrites ( sk , qa ) ; } } else { tassert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Problem handling connect " , e ) ; tqueueReconnect ( qa ) ; } } else { tif ( sk . isWritable ( ) ) { ttry { thandleWrites ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , tqa . getCurrentWriteOp ( ) , e ) ; } } tif ( sk . isReadable ( ) ) { ttry { thandleReads ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , tqa . getCurrentReadOp ( ) , e ) ; } } } tfixupOps ( qa ) ; } 
private void handleWrites ( SelectionKey sk , QueueAttachment qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . wbuf . hasRemaining ( ) ; twhile ( canWriteMore ) { tint wrote = qa . channel . write ( qa . wbuf ) ; 
private void handleReads ( SelectionKey sk , QueueAttachment qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tint read = qa . channel . read ( qa . rbuf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
private boolean preparePending ( ) { } 
public void fillWriteBuffer ( boolean optimizeGets ) { tgetLogger ( ) . info ( " Buffer: %s " , wbuf ) ; tif ( wbuf . position ( ) < = wbuf . limit ( ) ) { twbuf . clear ( ) ; 
private boolean selectorsMakeSense ( ) { tfor ( QueueAttachment qa : connections ) { tif ( qa . sk . isValid ( ) ) { tif ( qa . channel . isConnected ( ) ) { tint sops = qa . sk . interestOps ( ) ; tint expected = 0 ; tif ( qa . hasReadOp ( ) ) { texpected | = SelectionKey . OP_READ ; } tif ( qa . hasWriteOp ( ) ) { texpected | = SelectionKey . OP_WRITE ; } tif ( qa . toWrite > 0 ) { texpected | = SelectionKey . OP_WRITE ; } tassert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { tint sops = qa . sk . interestOps ( ) ; tassert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } tgetLogger ( ) . debug ( " Checked the selectors. " ) ; treturn true ; } 
private void handleWrites ( SelectionKey sk , QueueAttachment qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . toWrite > 0 ; twhile ( canWriteMore ) { tint wrote = qa . channel . write ( qa . wbuf ) ; 
public void shutdown ( ) throws IOException { tfor ( QueueAttachment qa : connections ) { tqa . channel . close ( ) ; tqa . sk = null ; tif ( qa . toWrite > 0 ) { tgetLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , tqa . toWrite ) ; } tgetLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } tselector . close ( ) ; tgetLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
public void fillWriteBuffer ( boolean optimizeGets ) { tif ( toWrite = = 0 ) { twbuf . clear ( ) ; 
public static void main ( String [ ] args ) throws Exception { } 
tOperation addOp ( int which , Operation op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( which , op ) ; treturn op ; } 
public void receivedStatus ( String val ) { trv . set ( val . equals ( " STORED " ) ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } } ) ; 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( getServerForKey ( key ) , op ) ; treturn rv ; } 
public void receivedStatus ( String line ) { trv . set ( val ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void receivedStatus ( String line ) { tassert line . equals ( " END " ) ; } 
public void receivedStatus ( String s ) { trv . put ( sa , s ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } 
public void receivedStatus ( String line ) { tassert line . equals ( " END " ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = new DeleteOperation ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( getServerForKey ( key ) , op ) ; treturn rv ; } 
public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } 
public void receivedStatus ( String line ) { trv . set ( line . equals ( " OK " ) ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tlatch . await ( timeout , unit ) ; tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } treturn rvMap ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op ! = null & & op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } treturn obj ; } 
private void handleIO ( SelectionKey sk ) { tassert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; tQueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; ttry { tif ( qa . channel . finishConnect ( ) ) { tassert qa . channel . isConnected ( ) : " Not connected. " ; tqa . reconnectAttempt = 0 ; taddedQueue . offer ( qa ) ; tif ( qa . wbuf . hasRemaining ( ) ) { thandleWrites ( sk , qa ) ; } } else { tassert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Problem handling connect " , e ) ; tqueueReconnect ( qa ) ; } } else { tif ( sk . isWritable ( ) ) { ttry { thandleWrites ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOException handling %s, reconnecting " , tqa . getCurrentWriteOp ( ) , e ) ; tqueueReconnect ( qa ) ; } } tif ( sk . isReadable ( ) ) { ttry { thandleReads ( sk , qa ) ; tqa . protocolErrors = 0 ; } catch ( OperationException e ) { tif ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { tqueueReconnect ( qa ) ; } } catch ( IOException e ) { tgetLogger ( ) . info ( " IOException handling %s, reconnecting " , tqa . getCurrentReadOp ( ) , e ) ; tqueueReconnect ( qa ) ; } } } tfixupOps ( qa ) ; } 
public void setupResend ( ) { } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; tassert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) : " Expected OK, was " + line ; tgetLogger ( ) . debug ( " Flush completed successfully " ) ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tString found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = line ; } tgetCallback ( ) . receivedStatus ( found ) ; ttransitionState ( State . COMPLETE ) ; } 
tprotected void wasCancelled ( ) { } 
public boolean hasErrored ( ) { treturn exception ! = null ; } 
public void cancel ( ) { tcancelled = true ; twasCancelled ( ) ; tcallback . complete ( ) ; } 
tprotected void transitionState ( State newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; callback.complete(); 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public final void readFromBuffer ( ByteBuffer data ) throws IOException { if(readType == ReadType.DATA) { 
private void handleError ( ErrorType eType , String line ) throws IOException { tgetLogger ( ) . error ( " Error: %s " , line ) ; tswitch ( eType ) { tcase GENERAL : texception = new OperationException ( ) ; tbreak ; tcase SERVER : texception = new OperationException ( eType , line ) ; tbreak ; tcase CLIENT : texception = new OperationException ( eType , line ) ; tbreak ; tdefault : assert false ; } ttransitionState ( State . COMPLETE ) ; tthrow exception ; } 
private ErrorType classifyError ( String line ) { tErrorType rv = null ; tif ( line . startsWith ( " ERROR " ) ) { trv = ErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { trv = ErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { trv = ErrorType . SERVER ; } treturn rv ; } 
tvoid receivedStatus ( String line ) ; tvoid complete ( ) ; } 
public String toString ( ) { tString rv = null ; tif ( type = = Operation . ErrorType . GENERAL ) { trv = " OperationException: " + type ; } else { trv = " OperationException: " + type + " : " + getMessage ( ) ; } treturn rv ; } 
public void complete ( ) { tfor ( Callback c : allCallbacks ) { tc . complete ( ) ; 
public void complete ( ) { tassert ! completed ; tcb . complete ( ) ; tcompleted = true ; } 
public void handleLine ( String line ) { tassert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( State . COMPLETE ) ; } 
tprotected void wasCancelled ( ) { } 
public void handleLine ( String line ) { tassert line . startsWith ( " VERSION " ) ; tgetCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; ttransitionState ( State . COMPLETE ) ; } 
private void initClient ( ) throws Exception { tclient = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tinitClient ( ) ; } 
tprotected void tearDown ( ) throws Exception { } 
public void testBadOperation ( ) throws Exception { tclient . addOp ( 0 , new Operation ( new OperationCallback ( ) { public void complete ( ) { 
public void complete ( ) { tSystem . err . println ( " Complete. " ) ; } 
public void receivedStatus ( String line ) { tSystem . err . println ( " Received a line. " ) ; } } ) { 
public void handleLine ( String line ) { tSystem . out . println ( " Woo! A line! " ) ; } 
public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } 
tprotected void wasCancelled ( ) { tgetLogger ( ) . info ( " I was cancelled. " ) ; } } ) ; 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; } } 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; while(lookingFor != '\0' && b.hasRemaining()) { 
private void initClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( ) ) ; } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; 
public MemcachedConnection createConnection ( tList < InetSocketAddress > addrs ) throws IOException { tMemcachedConnection rv = super . createConnection ( addrs ) ; trv . setGetOptimization ( false ) ; treturn rv ; } } ) ; 
public Integer call ( ) throws Exception { tfor ( int i = 0 ; i < 25 ; i + + ) { tMap < String , Object > m = client . getBulk ( keys ) ; tfor ( String s : keys ) { tbyte b [ ] = ( byte [ ] ) m . get ( s ) ; tassert Arrays . hashCode ( b ) = = hashcode ; } } treturn hashcode ; } } ) ; 
public void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; do { 
public static void main ( String [ ] args ) throws Exception { } 
public void testInvalidKey3 ( ) throws Exception { ttry { tObject val = client . get ( " Key " ) ; 
public void testInvalidAlgorithm ( ) { ttry { tclient . setHashAlgorithm ( null ) ; 
public void testSetHashAlg ( ) { tassertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; tclient . setHashAlgorithm ( HashAlgorithm . FNV_HASH ) ; tassertSame ( HashAlgorithm . FNV_HASH , client . getHashAlgorithm ( ) ) ; } 
public void testInvalidTranscoder ( ) { ttry { tclient . setTranscoder ( null ) ; 
public void testSetTranscoder ( ) { tTranscoder tc = client . getTranscoder ( ) ; tassertTrue ( tc instanceof SerializingTranscoder ) ; tTranscoder tmptc = new Transcoder ( ) { public Object decode ( CachedData d ) { tthrow new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { tthrow new RuntimeException ( " Not implemented. " ) ; } } ; tclient . setTranscoder ( tmptc ) ; tassertSame ( tmptc , client . getTranscoder ( ) ) ; } 
public Object decode ( CachedData d ) { tthrow new RuntimeException ( " Not implemented. " ) ; } 
public CachedData encode ( Object o ) { tthrow new RuntimeException ( " Not implemented. " ) ; } } ; 
public void testStrings ( ) throws Exception { tString s1 = " This is a simple test string. " ; tCachedData cd = tc . encode ( s1 ) ; } 
public void testEmpty ( ) { tOperationException oe = new OperationException ( ) ; tassertSame ( Operation . ErrorType . GENERAL , oe . getType ( ) ) ; tassertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
public void testServer ( ) { tOperationException oe = new OperationException ( tOperation . ErrorType . SERVER , " SERVER_ERROR figures " ) ; tassertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; tassertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
public void testClient ( ) { tOperationException oe = new OperationException ( tOperation . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; tassertSame ( Operation . ErrorType . CLIENT , oe . getType ( ) ) ; tassertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
public void testGeneral ( ) { } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void receivedStatus ( String line ) { tif ( ! line . equals ( " END " ) ) { tgetLogger ( ) . warn ( " Expected ``END'', was ``%s'' " , line ) ; 
public void receivedStatus ( String line ) { tif ( ! line . equals ( " END " ) ) { tgetLogger ( ) . warn ( " Expeted ``END'', was ``%s'', " + 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
public static void main ( String [ ] args ) throws Exception { tif ( args . length ! = 4 ) { tSystem . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; tSystem . exit ( 1 ) ; } tint runs = Integer . parseInt ( args [ 0 ] ) ; tint start = Integer . parseInt ( args [ 1 ] ) ; tString serverlist = " 127.0.0.1: " + args [ 2 ] ; tint threads = Integer . parseInt ( args [ 3 ] ) ; tMemcachedClient client = new MemcachedClient ( tnew DefaultConnectionFactory ( runs , 32768 ) , tAddrUtil . getAddresses ( serverlist ) ) ; tWorkerStat [ ] statArray = new WorkerStat [ threads ] ; tThread [ ] threadArray = new Thread [ threads ] ; tWorkerStat mainStat = new WorkerStat ( ) ; tmainStat . runs = runs * threads ; tlong begin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tstatArray [ i ] = new WorkerStat ( ) ; tstatArray [ i ] . start = start + i * runs ; tstatArray [ i ] . runs = runs ; tthreadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . setterTime = System . currentTimeMillis ( ) - begin ; tbegin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . getterTime = System . currentTimeMillis ( ) - begin ; tclient . shutdown ( ) ; tWorkerStat totalStat = new WorkerStat ( ) ; tSystem . out . println ( " Thread tstart truns tset time(ms) tget time(ms) " ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tSystem . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; ttotalStat . runs = totalStat . runs + statArray [ i ] . runs ; ttotalStat . setterTime = totalStat . setterTime + statArray [ i ] . setterTime ; ttotalStat . getterTime = totalStat . getterTime + statArray [ i ] . getterTime ; } tSystem . out . println ( " nAvg " + runs + " " + totalStat . setterTime / threads + " " + totalStat . getterTime / threads ) ; tSystem . out . println ( " nTotal " + totalStat . runs + " " + totalStat . setterTime + " " + totalStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * totalStat . runs / totalStat . setterTime + " tget - " + 1000 * totalStat . runs / totalStat . getterTime ) ; tSystem . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * mainStat . runs / mainStat . setterTime + " tget - " + 1000 * mainStat . runs 
public void run ( ) { tString keyBase = " testKey " ; tString object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; tlong begin = System . currentTimeMillis ( ) ; } 
public void run ( ) { tString keyBase = " testKey " ; tlong begin = System . currentTimeMillis ( ) ; tfor ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { tString str = ( String ) mc . get ( " " + i + keyBase ) ; tassert str ! = null ; } tlong end = System . currentTimeMillis ( ) ; tstat . getterTime = end - begin ; } 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; tsetArguments ( bb , type . name ( ) , key , flags , exp , data . length ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( CRLF ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public void addOperation ( int which , Operation o ) { tboolean placed = false ; tint pos = which ; tint loops = 0 ; twhile ( ! placed ) { tassert loops < 3 : " Too many loops! " ; 
public void shutdown ( ) throws IOException { tfor ( QueueAttachment qa : connections ) { tif ( qa . channel ! = null ) { tqa . channel . close ( ) ; tqa . sk = null ; tif ( qa . toWrite > 0 ) { tgetLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , tqa . toWrite ) ; } tgetLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } tselector . close ( ) ; tgetLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
tprotected void tearDown ( ) throws Exception { } 
tprotected void flushPause ( ) throws InterruptedException { }} 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11211 127.0.0.1:11212 " ) ) ; 
tprotected void flushPause ( ) throws InterruptedException { tThread . sleep ( 100 ) ; } 
public void testMixedSetsAndUpdates ( ) throws Exception { tCollection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; tCollection < String > keys = new ArrayList < String > ( ) ; tThread . sleep ( 100 ) ; tfor ( int i = 0 ; i < 100 ; i + + ) { tString key = " k " + i ; tfutures . add ( client . set ( key , 10 , key ) ) ; tfutures . add ( client . add ( key , 10 , " a " + i ) ) ; tkeys . add ( key ) ; } tMap < String , Object > m = client . getBulk ( keys ) ; tassertEquals ( 100 , m . size ( ) ) ; tfor ( Map . Entry < String , Object > me : m . entrySet ( ) ) { tassertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } tfor ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { tassertTrue ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; tassertFalse ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; } tSystem . err . println ( getName ( ) + " complete. " ) ; } 
public void testCrap ( ) throws Exception { tmain ( new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ) ; } 
public static void main ( String [ ] args ) throws Exception { tif ( args . length ! = 4 ) { tSystem . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; tSystem . exit ( 1 ) ; } tint runs = Integer . parseInt ( args [ 0 ] ) ; tint start = Integer . parseInt ( args [ 1 ] ) ; tString serverlist = " 127.0.0.1: " + args [ 2 ] ; tint threads = Integer . parseInt ( args [ 3 ] ) ; tMemcachedClient client = new MemcachedClient ( tnew DefaultConnectionFactory ( 100000 , 32768 ) , tAddrUtil . getAddresses ( serverlist ) ) ; tWorkerStat [ ] statArray = new WorkerStat [ threads ] ; tThread [ ] threadArray = new Thread [ threads ] ; tWorkerStat mainStat = new WorkerStat ( ) ; tmainStat . runs = runs * threads ; tlong begin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tstatArray [ i ] = new WorkerStat ( ) ; tstatArray [ i ] . start = start + i * runs ; tstatArray [ i ] . runs = runs ; tthreadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . setterTime = System . currentTimeMillis ( ) - begin ; tbegin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . getterTime = System . currentTimeMillis ( ) - begin ; tclient . shutdown ( ) ; tWorkerStat totalStat = new WorkerStat ( ) ; tSystem . out . println ( " Thread tstart truns tset time(ms) tget time(ms) " ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tSystem . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; ttotalStat . runs = totalStat . runs + statArray [ i ] . runs ; ttotalStat . setterTime = totalStat . setterTime + statArray [ i ] . setterTime ; ttotalStat . getterTime = totalStat . getterTime + statArray [ i ] . getterTime ; } tSystem . out . println ( " nAvg " + runs + " " + totalStat . setterTime / threads + " " + totalStat . getterTime / threads ) ; tSystem . out . println ( " nTotal " + totalStat . runs + " " + totalStat . setterTime + " " + totalStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * totalStat . runs / totalStat . setterTime + " tget - " + 1000 * totalStat . runs / totalStat . getterTime ) ; tSystem . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * mainStat . runs / mainStat . setterTime + " tget - " + 1000 * mainStat . runs 
public void run ( ) { tString keyBase = " testKey " ; tString object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; tlong begin = System . currentTimeMillis ( ) ; tfor ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { tmc . set ( " " + i + keyBase , 3600 , object ) ; tif ( total . incrementAndGet ( ) > = MAX_QUEUE ) { tflush ( ) ; } } tlong end = System . currentTimeMillis ( ) ; tstat . setterTime = end - begin ; } 
private synchronized void flush ( ) { tif ( total . intValue ( ) > = MAX_QUEUE ) { tmc . waitForQueues ( 5 , TimeUnit . SECONDS ) ; 
public void addOperation ( int which , Operation o ) { tboolean placed = false ; tint pos = which ; tint loops = 0 ; assert loops < 3 : "Too many loops!"; 
private boolean selectorsMakeSense ( ) { tfor ( MemcachedNode qa : connections ) { tif ( qa . sk . isValid ( ) ) { tif ( qa . channel . isConnected ( ) ) { tint sops = qa . sk . interestOps ( ) ; tint expected = 0 ; tif ( qa . hasReadOp ( ) ) { texpected | = SelectionKey . OP_READ ; } tif ( qa . hasWriteOp ( ) ) { texpected | = SelectionKey . OP_WRITE ; } tif ( qa . toWrite > 0 ) { texpected | = SelectionKey . OP_WRITE ; } tassert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { tint sops = qa . sk . interestOps ( ) ; tassert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } tgetLogger ( ) . debug ( " Checked the selectors. " ) ; treturn true ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void handleIO ( SelectionKey sk ) { tassert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; tMemcachedNode qa = ( MemcachedNode ) sk . attachment ( ) ; tif ( sk . isConnectable ( ) ) { tgetLogger ( ) . info ( " Connection state changed for %s " , sk ) ; ttry { tif ( qa . channel . finishConnect ( ) ) { tassert qa . channel . isConnected ( ) : " Not connected. " ; tqa . reconnectAttempt = 0 ; taddedQueue . offer ( qa ) ; tif ( qa . wbuf . hasRemaining ( ) ) { thandleWrites ( sk , qa ) ; } } else { tassert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Problem handling connect " , e ) ; tqueueReconnect ( qa ) ; } } else { tif ( sk . isWritable ( ) ) { ttry { thandleWrites ( sk , qa ) ; } catch ( IOException e ) { tgetLogger ( ) . info ( " IOException handling %s, reconnecting " , tqa . getCurrentWriteOp ( ) , e ) ; tqueueReconnect ( qa ) ; } } tif ( sk . isReadable ( ) ) { ttry { thandleReads ( sk , qa ) ; tqa . protocolErrors = 0 ; } catch ( OperationException e ) { tif ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { tqueueReconnect ( qa ) ; } } catch ( IOException e ) { tgetLogger ( ) . info ( " IOException handling %s, reconnecting " , tqa . getCurrentReadOp ( ) , e ) ; tqueueReconnect ( qa ) ; } } } tfixupOps ( qa ) ; } 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . toWrite > 0 ; twhile ( canWriteMore ) { tint wrote = qa . channel . write ( qa . wbuf ) ; 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tint read = qa . channel . read ( qa . rbuf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
private void fixupOps ( MemcachedNode qa ) { tif ( qa . sk . isValid ( ) ) { tint iops = qa . getSelectionOps ( ) ; 
private void queueReconnect ( MemcachedNode qa ) { tif ( ! shutDown ) { tgetLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
private void attemptReconnects ( ) throws IOException { tlong now = System . currentTimeMillis ( ) ; tfor ( Iterator < MemcachedNode > i = treconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
public void shutdown ( ) throws IOException { tfor ( MemcachedNode qa : connections ) { tif ( qa . channel ! = null ) { tqa . channel . close ( ) ; tqa . sk = null ; tif ( qa . toWrite > 0 ) { tgetLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , tqa . toWrite ) ; } tgetLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } tselector . close ( ) ; tgetLogger ( ) . debug ( " Shut down selector %s " , selector ) ; } 
public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " {MemcachedConnection to " ) ; tfor ( MemcachedNode qa : connections ) { tsb . append ( " " ) ; tsb . append ( qa . socketAddress ) ; } tsb . append ( " } " ) ; treturn sb . toString ( ) ; } 
public void copyInputQueue ( ) { tCollection < Operation > tmp = new ArrayList < Operation > ( ) ; tinputQueue . drainTo ( tmp ) ; twriteQ . addAll ( tmp ) ; } 
public void setupResend ( ) { } 
private boolean preparePending ( ) { } 
public void fillWriteBuffer ( boolean optimizeGets ) { tif ( toWrite = = 0 ) { twbuf . clear ( ) ; 
public void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tassert op . getState ( ) = = Operation . State . READING ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
public Operation removeCurrentReadOp ( ) { treturn readQ . remove ( ) ; } 
public Operation removeCurrentWriteOp ( ) { tOperation rv = getOp ; tif ( rv = = null ) { trv = writeQ . remove ( ) ; } else { tgetOp = null ; } treturn rv ; } 
public boolean hasReadOp ( ) { treturn ! readQ . isEmpty ( ) ; } 
public boolean hasWriteOp ( ) { treturn ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
public void addOp ( Operation op ) { tboolean added = inputQueue . add ( op ) ; tassert added ; } 
public String toString ( ) { tint sops = 0 ; tif ( sk ! = null & & sk . isValid ( ) ) { tsops = sk . interestOps ( ) ; } tint rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; tint wsize = writeQ . size ( ) ; tint isize = inputQueue . size ( ) ; treturn " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . toWrite > 0 ; twhile ( canWriteMore ) { tint wrote = qa . getChannel ( ) . write ( qa . getWbuf ( ) ) ; 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tByteBuffer rbuf = qa . getRbuf ( ) ; tfinal SocketChannel channel = qa . getChannel ( ) ; tint read = channel . read ( rbuf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " {MemcachedConnection to " ) ; tfor ( MemcachedNode qa : connections ) { tsb . append ( " " ) ; tsb . append ( qa . getSocketAddress ( ) ) ; } tsb . append ( " } " ) ; treturn sb . toString ( ) ; } 
public void setupResend ( ) { } 
public void fillWriteBuffer ( boolean optimizeGets ) { tif ( toWrite = = 0 ) { tgetWbuf ( ) . clear ( ) ; 
public boolean isActive ( ) { treturn reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { tsetChannel ( ch ) ; tsetSk ( selectionKey ) ; } 
private void computeNext ( ) { tif ( + + next > = nodes . length ) { tnext = 0 ; } tif ( next = = start ) { tnext = - 1 ; 
public void remove ( ) { tthrow new UnsupportedOperationException ( " Can't remove a node " ) ; } 
tMemcachedNode getPrimary ( String k ) ; tCollection < MemcachedNode > getAll ( ) ; } 
tIterator < MemcachedNode > getSequence ( String k ) ; tCollection < MemcachedNode > getAll ( ) ; } 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; twhile ( canWriteMore ) { tint wrote = qa . writeSome ( ) ; 
public void setupResend ( ) { } 
public int writeSome ( ) throws IOException { tint wrote = channel . write ( wbuf ) ; tassert wrote > = 0 : " Wrote negative bytes? " ; ttoWrite - = wrote ; tassert toWrite > = 0 : " toWrite went negative after writing " + wrote + " bytes for " + this ; tgetLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; treturn wrote ; } 
public MemcachedNodeImpl next ( ) { treturn nodes [ next ] ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void handleWrites ( SelectionKey sk , MemcachedNodeImpl qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; twhile ( canWriteMore ) { tint wrote = qa . writeSome ( ) ; 
private void handleReads ( SelectionKey sk , MemcachedNodeImpl qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tByteBuffer rbuf = qa . getRbuf ( ) ; tfinal SocketChannel channel = qa . getChannel ( ) ; tint read = channel . read ( rbuf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
private void queueReconnect ( MemcachedNodeImpl qa ) { tif ( ! shutDown ) { tgetLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , 
private void attemptReconnects ( ) throws IOException { tlong now = System . currentTimeMillis ( ) ; tfor ( Iterator < MemcachedNodeImpl > i = treconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
public String toString ( ) { tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " {MemcachedConnection to " ) ; tfor ( MemcachedNodeImpl qa : connections ) { tsb . append ( " " ) ; tsb . append ( qa . getSocketAddress ( ) ) ; } tsb . append ( " } " ) ; treturn sb . toString ( ) ; } 
tMemcachedNodeImpl getPrimary ( String k ) ; tCollection < MemcachedNodeImpl > getAll ( ) ; } 
tIterator < MemcachedNodeImpl > getSequence ( String k ) ; tCollection < MemcachedNodeImpl > getAll ( ) ; } 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tqa . fillWriteBuffer ( optimizeGets ) ; tboolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; twhile ( canWriteMore ) { tint wrote = qa . writeSome ( ) ; 
tvoid copyInputQueue ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid setupResend ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tint writeSome ( ) throws IOException ; } 
tvoid transitionWriteItem ( ) ; tint writeSome ( ) throws IOException ; } 
tOperation getCurrentReadOp ( ) ; tint writeSome ( ) throws IOException ; } 
tOperation removeCurrentReadOp ( ) ; tint writeSome ( ) throws IOException ; } 
tOperation getCurrentWriteOp ( ) ; tint writeSome ( ) throws IOException ; } 
tOperation removeCurrentWriteOp ( ) ; tint writeSome ( ) throws IOException ; } 
tboolean hasReadOp ( ) ; tint writeSome ( ) throws IOException ; } 
tboolean hasWriteOp ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid addOp ( Operation op ) ; tint writeSome ( ) throws IOException ; } 
tint getSelectionOps ( ) ; tint writeSome ( ) throws IOException ; } 
tByteBuffer getRbuf ( ) ; tint writeSome ( ) throws IOException ; } 
tByteBuffer getWbuf ( ) ; tint writeSome ( ) throws IOException ; } 
tSocketAddress getSocketAddress ( ) ; tint writeSome ( ) throws IOException ; } 
tboolean isActive ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid reconnecting ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid connected ( ) ; tint writeSome ( ) throws IOException ; } 
tint getReconnectCount ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; tint writeSome ( ) throws IOException ; } 
tvoid setChannel ( SocketChannel to ) ; tint writeSome ( ) throws IOException ; } 
tSocketChannel getChannel ( ) ; tint writeSome ( ) throws IOException ; } 
tvoid setSk ( SelectionKey to ) ; tint writeSome ( ) throws IOException ; } 
tSelectionKey getSk ( ) ; tint writeSome ( ) throws IOException ; } 
tint getBytesRemainingToWrite ( ) ; tint writeSome ( ) throws IOException ; } 
private void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
tMemcachedNode getPrimary ( String k ) ; tCollection < MemcachedNodeImpl > getAll ( ) ; } 
public MemcachedNode next ( ) { ttry { treturn nodes [ next ] ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tnodes = new MemcachedNode [ 4 ] ; tnodeMocks = new Mock [ nodes . length ] ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; tnodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } tlocator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; } 
public void testPrimary ( ) throws Exception { tassertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
public void testAll ( ) throws Exception { tCollection < MemcachedNode > all = locator . getAll ( ) ; tassertEquals ( 4 , all . size ( ) ) ; tassertTrue ( all . contains ( nodes [ 0 ] ) ) ; tassertTrue ( all . contains ( nodes [ 1 ] ) ) ; tassertTrue ( all . contains ( nodes [ 2 ] ) ) ; tassertTrue ( all . contains ( nodes [ 3 ] ) ) ; } 
public void testSeq1 ( ) { tassertSequence ( " dustin " , 2 , 3 , 0 , 1 ) ; tassertSequence ( " noelani " , 1 , 2 , 3 , 0 ) ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( readBufSize , this , addrs , hashAlg ) ; } 
tOperation addOp ( final String key , final Operation op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tif ( key . length ( ) > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } } 
tOperation addOp ( final MemcachedNode node , final Operation op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( node , op ) ; treturn op ; } 
tCountDownLatch broadcastOp ( final OperationFactory of ) { treturn broadcastOp ( of , true ) ; } 
private CountDownLatch broadcastOp ( OperationFactory of , tboolean checkShuttingDown ) { tif ( checkShuttingDown & & shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } treturn conn . broadcastOperation ( of ) ; } 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; treturn new VersionOperation ( tnew OperationCallback ( ) { 
public void receivedStatus ( String s ) { trv . put ( sa , s ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; trv . put ( sa , new HashMap < String , String > ( ) ) ; treturn new StatsOperation ( arg , tnew StatsOperation . Callback ( ) { 
public void gotStat ( String name , String val ) { trv . get ( sa ) . put ( name , val ) ; } 
public void receivedStatus ( String line ) { tif ( ! line . equals ( " END " ) ) { tgetLogger ( ) . warn ( " Expeted ``END'', was ``%s'' " , 
private long mutate ( MutatorOperation . Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , new MutatorOperation ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = new DeleteOperation ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperation ( tnew OperationCallback ( ) { return blatch.await(timeout, unit); 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperation ( tnew OperationCallback ( ) { 
public void receivedStatus ( String s ) { tlatch . countDown ( ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op ! = null & & op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } treturn objRef . get ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { tlatch . await ( duration , units ) ; treturn objRef . get ( ) ; } 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) ) { tplaceIn = primary ; } else { } 
public void addOperation ( final MemcachedNode node , final Operation o ) { to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %d " , o , node ) ; } 
tvoid copyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
tvoid setupResend ( ) ; tvoid fixupOps ( ) ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tvoid fixupOps ( ) ; } 
tvoid transitionWriteItem ( ) ; tvoid fixupOps ( ) ; } 
tOperation getCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation removeCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation getCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation removeCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasReadOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tvoid addOp ( Operation op ) ; tvoid fixupOps ( ) ; } 
tint getSelectionOps ( ) ; tvoid fixupOps ( ) ; } 
tByteBuffer getRbuf ( ) ; tvoid fixupOps ( ) ; } 
tByteBuffer getWbuf ( ) ; tvoid fixupOps ( ) ; } 
tSocketAddress getSocketAddress ( ) ; tvoid fixupOps ( ) ; } 
tboolean isActive ( ) ; tvoid fixupOps ( ) ; } 
tvoid reconnecting ( ) ; tvoid fixupOps ( ) ; } 
tvoid connected ( ) ; tvoid fixupOps ( ) ; } 
tint getReconnectCount ( ) ; tvoid fixupOps ( ) ; } 
tvoid registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; tvoid fixupOps ( ) ; } 
tvoid setChannel ( SocketChannel to ) ; tvoid fixupOps ( ) ; } 
tSocketChannel getChannel ( ) ; tvoid fixupOps ( ) ; } 
tvoid setSk ( SelectionKey to ) ; tvoid fixupOps ( ) ; } 
tSelectionKey getSk ( ) ; tvoid fixupOps ( ) ; } 
tint getBytesRemainingToWrite ( ) ; tvoid fixupOps ( ) ; } 
tint writeSome ( ) throws IOException ; tvoid fixupOps ( ) ; } 
public void fixupOps ( ) { tif ( sk ! = null & & sk . isValid ( ) ) { tint iops = getSelectionOps ( ) ; 
public void testBadOperation ( ) throws Exception { tclient . addOp ( " x " , new Operation ( new OperationCallback ( ) { public void complete ( ) { 
private void setupNodes ( int ) { tnodes = new MemcachedNode [ ] ; tnodeMocks = new Mock [ nodes . length ] ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; tnodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } tlocator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; } 
public void testPrimary ( ) throws Exception { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
public void testAll ( ) throws Exception { tsetupNodes ( 4 ) ; tCollection < MemcachedNode > all = locator . getAll ( ) ; tassertEquals ( 4 , all . size ( ) ) ; tassertTrue ( all . contains ( nodes [ 0 ] ) ) ; tassertTrue ( all . contains ( nodes [ 1 ] ) ) ; tassertTrue ( all . contains ( nodes [ 2 ] ) ) ; tassertTrue ( all . contains ( nodes [ 3 ] ) ) ; } 
public void testSeq1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 2 , 3 , 0 ) ; } 
public void testSeq2 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " noelani " , 1 , 2 , 3 ) ; } 
public void testSeqOnlyOneServer ( ) { tsetupNodes ( 1 ) ; tassertSequence ( " noelani " ) ; } 
public void testSeqWithTwoNodes ( ) { tsetupNodes ( 2 ) ; tassertSequence ( " dustin " , 0 ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
tprotected void setUp ( ) throws Exception { tserverList = " 127.0.0.1:11211 127.0.0.1:11212 " ; tsuper . setUp ( ) ; } 
tprotected void tearDown ( ) throws Exception { tserverList = " 127.0.0.1:11211 " ; tsuper . tearDown ( ) ; } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; } 
private void setupNodes ( int ) { tnodes = new MemcachedNode [ ] ; tnodeMocks = new Mock [ nodes . length ] ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; tnodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } tlocator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , tHashAlgorithm . NATIVE_HASH ) ; 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { treturn new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; } 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
private void nextHash ( ) { } 
public boolean hasNext ( ) { treturn remainingTries > 0 ; } 
public MemcachedNode next ( ) { ttry { treturn getNodeForKey ( hashVal ) ; 
public void remove ( ) { tthrow new UnsupportedOperationException ( " remove not supported " ) ; } 
private void setupNodes ( int ) { tnodes = new MemcachedNode [ ] ; tnodeMocks = new Mock [ nodes . length ] ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; tnodeMocks [ i ] . expects ( exactly ( KetamaNodeLocator . NUM_REPS ) ) . method ( " getSocketAddress " ) . will ( returnValue ( tInetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; tnodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } tlocator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , tHashAlgorithm . KETAMA_HASH ) ; 
private InvocationMatcher exactly ( final int ) { return new InvocationMatcher ( ) { private int cnt = 0 ; 
public boolean matches ( Invocation arg0 ) { return ( cnt + + < ) ; } 
public boolean hasDescription ( ) { return true ; } 
public void verify ( ) { if ( cnt ! = ) { throw new AssertionFailedError ( " Expected " + 
public StringBuffer describeTo ( StringBuffer buf ) { buf . append ( " allowed " ) ; return buf ; } 
public void testLookups ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testClusterResizing ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; tsetupNodes ( 5 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testSequence1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 0 , 1 , 1 , 3 ) ; } 
public void testSequence2 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " noelani " , 2 , 0 , 0 , 0 ) ; } 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( getReadBufSize ( ) , this , addrs ) ; } 
public BlockingQueue < Operation > createOperationQueue ( ) { treturn new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } 
tprotected void setupNodes ( int ) { tnodes = new MemcachedNode [ ] ; tnodeMocks = new Mock [ nodes . length ] ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; 
tprotected void setupNodes ( int ) { tsuper . setupNodes ( ) ; tlocator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , tHashAlgorithm . NATIVE_HASH ) ; 
tprotected void setupNodes ( int ) { tsuper . setupNodes ( ) ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] . expects ( once ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } tlocator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , tHashAlgorithm . KETAMA_HASH ) ; 
public void testAll ( ) throws Exception { tsetupNodes ( 4 ) ; tCollection < MemcachedNode > all = locator . getAll ( ) ; tassertEquals ( 4 , all . size ( ) ) ; tfor ( int i = 0 ; i < 4 ; i + + ) { tassertTrue ( all . contains ( nodes [ i ] ) ) ; 
public void testContinuumWrapping ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 3 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; tassertSame ( nodes [ 3 ] , locator . getPrimary ( " N6H4245M " ) ) ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
tBlockingQueue < OperationImpl > createOperationQueue ( ) ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
public BlockingQueue < OperationImpl > createOperationQueue ( ) { treturn new ArrayBlockingQueue < OperationImpl > ( getOpQueueLen ( ) ) ; } 
tOperationImpl addOp ( final String key , final OperationImpl op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tif ( key . length ( ) > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } } 
tOperationImpl addOp ( final MemcachedNode node , final OperationImpl op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( node , op ) ; treturn op ; } 
public Future < Boolean > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperationImpl . StoreType . add , key , exp , o ) ; } 
public Future < Boolean > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperationImpl . StoreType . set , key , exp , o ) ; } 
public Future < Boolean > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreOperationImpl . StoreType . replace , key , exp , o ) ; } 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperationImpl op = new GetOperationImpl ( key , tnew GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; treturn new VersionOperationImpl ( tnew OperationCallback ( ) { 
public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; trv . put ( sa , new HashMap < String , String > ( ) ) ; treturn new StatsOperationImpl ( arg , tnew StatsOperationImpl . Callback ( ) { 
private long mutate ( MutatorOperationImpl . Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , new MutatorOperationImpl ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
public long incr ( String key , int by ) { treturn mutate ( MutatorOperationImpl . Mutator . incr , key , by ) ; } 
public long decr ( String key , int by ) { treturn mutate ( MutatorOperationImpl . Mutator . decr , key , by ) ; } 
private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < Boolean > f = asyncStore ( StoreOperationImpl . StoreType . add , tkey , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public long incr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatorOperationImpl . Mutator . incr , tkey , by , def ) ; 
public long decr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatorOperationImpl . Mutator . decr , key , by , def ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperationImpl op = new DeleteOperationImpl ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperationImpl ( tnew OperationCallback ( ) { return blatch.await(timeout, unit); 
public OperationImpl newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperationImpl ( tnew OperationCallback ( ) { 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( OperationImpl op : ops ) { trv | = op . getState ( ) = = OperationImpl . State . WRITING ; top . cancel ( ) ; } tcancelled = true ; treturn rv ; } 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tlatch . await ( timeout , unit ) ; tfor ( OperationImpl op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } treturn rvMap ; } 
public boolean cancel ( boolean ign ) { tassert op ! = null : " No operation " ; top . cancel ( ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn op . getState ( ) = = OperationImpl . State . COMPLETE ; } 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperationImpl currentOp = qa . getCurrentReadOp ( ) ; tByteBuffer rbuf = qa . getRbuf ( ) ; tfinal SocketChannel channel = qa . getChannel ( ) ; tint read = channel . read ( rbuf ) ; twhile ( read > 0 ) { tgetLogger ( ) . debug ( " Read %d bytes " , read ) ; 
public void addOperation ( final String key , final OperationImpl o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) ) { tplaceIn = primary ; } else { } 
public void addOperation ( final MemcachedNode node , final OperationImpl o ) { to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %d " , o , node ) ; } 
tvoid copyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
tvoid setupResend ( ) ; tvoid fixupOps ( ) ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tvoid fixupOps ( ) ; } 
tvoid transitionWriteItem ( ) ; tvoid fixupOps ( ) ; } 
tOperationImpl getCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperationImpl removeCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperationImpl getCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tOperationImpl removeCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasReadOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tvoid addOp ( OperationImpl op ) ; tvoid fixupOps ( ) ; } 
public void copyInputQueue ( ) { tCollection < OperationImpl > tmp = new ArrayList < OperationImpl > ( ) ; tinputQueue . drainTo ( tmp ) ; twriteQ . addAll ( tmp ) ; } 
public void setupResend ( ) { } 
private boolean preparePending ( ) { } 
public void transitionWriteItem ( ) { tOperationImpl op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tassert op . getState ( ) = = OperationImpl . State . READING ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
public OperationImpl removeCurrentReadOp ( ) { treturn readQ . remove ( ) ; } 
public OperationImpl removeCurrentWriteOp ( ) { tOperationImpl rv = getOp ; tif ( rv = = null ) { trv = writeQ . remove ( ) ; } else { tgetOp = null ; } treturn rv ; } 
public void addOp ( OperationImpl op ) { tboolean added = inputQueue . add ( op ) ; tassert added ; } 
tOperationImpl newOp ( MemcachedNode , CountDownLatch latch ) ; } 
public String toString ( ) { tString rv = null ; tif ( type = = OperationImpl . ErrorType . GENERAL ) { trv = " OperationException: " + type ; } else { trv = " OperationException: " + type + " : " + getMessage ( ) ; } treturn rv ; } 
public void testBadOperation ( ) throws Exception { tclient . addOp ( " x " , new OperationImpl ( new OperationCallback ( ) { public void complete ( ) { 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; } } 
public void testDataReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( OperationImpl . ReadType . DATA ) ; tassertSame ( OperationImpl . ReadType . DATA , op . getReadType ( ) ) ; } 
public void testLineReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; tassertSame ( OperationImpl . ReadType . LINE , op . getReadType ( ) ) ; } 
public void testLineParser ( ) throws Exception { tString input = " This is a multiline string r nhere is line two r " ; tByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; tSimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; top . linesToRead = 2 ; top . readFromBuffer ( b ) ; tassertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; tassertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; top . setBytesToRead ( 2 ) ; top . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; tbyte [ ] expected = { 'x' , 'y' } ; tassertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , 
public void testPartialLine ( ) throws Exception { tString input1 = " this is a " ; tString input2 = " test r " ; tByteBuffer b = ByteBuffer . allocate ( 20 ) ; tSimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; tb . put ( input1 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertNull ( op . getCurrentLine ( ) ) ; tb . clear ( ) ; tb . put ( input2 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertEquals ( " this is a test " , op . getCurrentLine ( ) ) ; } 
public void handleLine ( String line ) { tassert getReadType ( ) = = OperationImpl . ReadType . LINE ; tlines . add ( line ) ; tif ( - - linesToRead = = 0 ) { tsetReadType ( OperationImpl . ReadType . DATA ) ; 
public void handleRead ( ByteBuffer data ) { tassert getReadType ( ) = = OperationImpl . ReadType . DATA ; tassert bytesToRead > 0 ; tif ( bytesToRead > 0 ) { tcurrentBytes = new byte [ bytesToRead ] ; 
public void testEmpty ( ) { tOperationException oe = new OperationException ( ) ; tassertSame ( OperationImpl . ErrorType . GENERAL , oe . getType ( ) ) ; tassertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
public void testServer ( ) { tOperationException oe = new OperationException ( tOperationImpl . ErrorType . SERVER , " SERVER_ERROR figures " ) ; tassertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; tassertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
public void testClient ( ) { tOperationException oe = new OperationException ( tOperationImpl . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; tassertSame ( OperationImpl . ErrorType . CLIENT , oe . getType ( ) ) ; tassertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
public void testGeneral ( ) { } 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = new GetOperationImpl ( key , tnew GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; treturn new VersionOperationImpl ( tnew OperationCallback ( ) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; trv . put ( sa , new HashMap < String , String > ( ) ) ; treturn new StatsOperationImpl ( arg , tnew StatsOperationImpl . Callback ( ) { 
public long incr ( String key , int by ) { treturn mutate ( MutatatorOperation . Mutator . incr , key , by ) ; } 
public long decr ( String key , int by ) { treturn mutate ( MutatatorOperation . Mutator . decr , key , by ) ; } 
private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < Boolean > f = asyncStore ( StoreOperation . StoreType . add , tkey , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public long incr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatatorOperation . Mutator . incr , tkey , by , def ) ; 
public long decr ( String key , int by , long def ) { treturn mutateWithDefault ( MutatatorOperation . Mutator . decr , key , by , def ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = new DeleteOperationImpl ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperationImpl ( tnew OperationCallback ( ) { return blatch.await(timeout, unit); 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperationImpl ( tnew OperationCallback ( ) { 
private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
tboolean isCancelled ( ) ; tvoid handleLine ( String line ) ; } 
tboolean hasErrored ( ) ; tvoid handleLine ( String line ) ; } 
tOperationException getException ( ) ; tvoid handleLine ( String line ) ; } 
tOperationCallback getCallback ( ) ; tvoid handleLine ( String line ) ; } 
tvoid cancel ( ) ; tvoid handleLine ( String line ) ; } 
tState getState ( ) ; tvoid handleLine ( String line ) ; } 
tByteBuffer getBuffer ( ) ; tvoid handleLine ( String line ) ; } 
tvoid writeComplete ( ) ; tvoid handleLine ( String line ) ; } 
tReadType getReadType ( ) ; tvoid handleLine ( String line ) ; } 
tvoid initialize ( ) ; tvoid handleLine ( String line ) ; } 
tvoid readFromBuffer ( ByteBuffer data ) throws IOException ; tvoid handleLine ( String line ) ; } 
tvoid handleRead ( ByteBuffer data ) ; tvoid handleLine ( String line ) ; } 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public void testBadOperation ( ) throws Exception { tclient . addOp ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; } 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { treturn new AsciiMemcachedNodeImpl ( sa , c , bufSize , tcreateOperationQueue ( ) , 
tCountDownLatch broadcastOp ( final BroadcastOpFactory of ) { treturn broadcastOp ( of , true ) ; } 
private CountDownLatch broadcastOp ( BroadcastOpFactory of , tboolean checkShuttingDown ) { tif ( checkShuttingDown & & shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } treturn conn . broadcastOperation ( of ) ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperationImpl ( tnew OperationCallback ( ) { return blatch.await(timeout, unit); 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tOperationFactory getOperationFactory ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tOperationFactory getOperationFactory ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tOperationFactory getOperationFactory ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tOperationFactory getOperationFactory ( ) ; } 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; treturn opFact . version ( tnew OperationCallback ( ) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal SocketAddress sa = . getSocketAddress ( ) ; trv . put ( sa , new HashMap < String , String > ( ) ) ; treturn opFact . stats ( arg , tnew StatsOperation . Callback ( ) { 
private long mutate ( MutatatorOperation . Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
private long mutateWithDefault ( MutatatorOperation . Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < Boolean > f = asyncStore ( StoreOperation . StoreType . add , tkey , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { trv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { tflushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . version ( tnew OperationCallback ( ) { return blatch.await(timeout, unit); 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . version ( tnew OperationCallback ( ) { 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( MutatatorOperation . Mutator m , String key , int by , tOperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tvoid gotData ( String key , int flags , byte [ ] data ) ; } tCollection < String > getKeys ( ) ; } 
public DeleteOperation delete ( String key , int when , tOperationCallback cb ) { treturn new DeleteOperationImpl ( key , when , cb ) ; } 
public FlushOperation flush ( int delay , OperationCallback cb ) { treturn new FlushOperationImpl ( delay , cb ) ; } 
public GetOperation get ( String key , Callback cb ) { treturn new GetOperationImpl ( key , cb ) ; } 
public GetOperation get ( Collection < String > keys , Callback cb ) { treturn new GetOperationImpl ( keys , cb ) ; } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tOperationCallback cb ) { treturn new MutatorOperationImpl ( m , key , by , cb ) ; } 
public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { treturn new StatsOperationImpl ( arg , cb ) ; } 
public StoreOperation store ( StoreType storeType , String key , int flags , tint exp , byte [ ] data , OperationCallback cb ) { treturn new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; } 
public VersionOperation version ( OperationCallback cb ) { treturn new VersionOperationImpl ( cb ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { tCollection < GetOperation . Callback > cbs = callbacks . get ( key ) ; tassert cbs ! = null : " No callbacks for key " + key ; tfor ( GetOperation . Callback c : cbs ) { tc . gotData ( key , flags , data ) ; 
public void receivedStatus ( String line ) { tfor ( GetOperation . Callback c : allCallbacks ) { tc . receivedStatus ( line ) ; 
public void complete ( ) { tfor ( GetOperation . Callback c : allCallbacks ) { tc . complete ( ) ; 
public final void copyInputQueue ( ) { tCollection < Operation > tmp = new ArrayList < Operation > ( ) ; tinputQueue . drainTo ( tmp ) ; twriteQ . addAll ( tmp ) ; } 
public final void setupResend ( ) { } 
public final void fillWriteBuffer ( boolean optimizeGets ) { tif ( toWrite = = 0 ) { tgetWbuf ( ) . clear ( ) ; 
public final void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tassert op . getState ( ) = = Operation . State . READING ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public final Operation removeCurrentReadOp ( ) { treturn readQ . remove ( ) ; } 
public final Operation removeCurrentWriteOp ( ) { tOperation rv = getOp ; tif ( rv = = null ) { trv = writeQ . remove ( ) ; } else { tgetOp = null ; } treturn rv ; } 
public final boolean hasReadOp ( ) { treturn ! readQ . isEmpty ( ) ; } 
public final boolean hasWriteOp ( ) { treturn ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; } 
public final void addOp ( Operation op ) { tboolean added = inputQueue . add ( op ) ; tassert added ; } 
public final boolean isActive ( ) { treturn reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
public final void reconnecting ( ) { treconnectAttempt + + ; } 
public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { tsetChannel ( ch ) ; tsetSk ( skey ) ; } 
public final int writeSome ( ) throws IOException { tint wrote = channel . write ( wbuf ) ; tassert wrote > = 0 : " Wrote negative bytes? " ; ttoWrite - = wrote ; tassert toWrite > = 0 : " toWrite went negative after writing " + wrote + " bytes for " + this ; tgetLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; treturn wrote ; } 
public final void fixupOps ( ) { tif ( sk ! = null & & sk . isValid ( ) ) { tint iops = getSelectionOps ( ) ; 
tprotected final void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
tCachedData encode ( Object o ) ; tObject decode ( CachedData d ) ; } 
tprotected void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove(); 
public final void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tgetLogger ( ) . debug ( " Get complete! " ) ; 
public final void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; do { 
public final void initialize ( ) { } 
tprotected final void wasCancelled ( ) { tcb . receivedStatus ( " cancelled " ) ; } 
public final boolean isCancelled ( ) { treturn cancelled ; } 
public final boolean hasErrored ( ) { treturn exception ! = null ; } 
public final void cancel ( ) { tcancelled = true ; twasCancelled ( ) ; tcallback . complete ( ) ; } 
tprotected final void transitionState ( State newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; callback.complete(); 
public final void writeComplete ( ) { ttransitionState ( State . READING ) ; } 
public Future < Boolean > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . add , key , exp , o ) ; } 
public Future < Boolean > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . set , key , exp , o ) ; } 
public Future < Boolean > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . replace , key , exp , o ) ; } 
private long mutate ( Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( String val ) { trv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; ttry { tlatch . await ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted " , e ) ; } tgetLogger ( ) . debug ( " Mutation returned %s " , rv ) ; treturn rv . get ( ) ; } 
public long incr ( String key , int by ) { treturn mutate ( Mutator . incr , key , by ) ; } 
public long decr ( String key , int by ) { treturn mutate ( Mutator . decr , key , by ) ; } 
private long mutateWithDefault ( Mutator , String key , tint by , long def ) { tlong rv = mutate ( , key , by ) ; tif ( rv = = - 1 ) { tFuture < Boolean > f = asyncStore ( StoreType . add , tkey , 0 , tString . valueOf ( def ) ) ; ttry { tif ( f . get ( ) ) { trv = def ; } else { trv = mutate ( , key , by ) ; tassert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { tthrow new RuntimeException ( " Failed waiting for store " , e ) ; } } treturn rv ; } 
public long incr ( String key , int by , long def ) { treturn mutateWithDefault ( Mutator . incr , tkey , by , def ) ; 
public long decr ( String key , int by , long def ) { treturn mutateWithDefault ( Mutator . decr , key , by , def ) ; } 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = OperationState . WRITING ; top . cancel ( ) ; } tcancelled = true ; treturn rv ; } 
public boolean cancel ( boolean ign ) { tassert op ! = null : " No operation " ; top . cancel ( ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn op . getState ( ) = = OperationState . COMPLETE ; } 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tOperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tboolean isCancelled ( ) ; tvoid handleLine ( String line ) ; } 
tboolean hasErrored ( ) ; tvoid handleLine ( String line ) ; } 
tOperationException getException ( ) ; tvoid handleLine ( String line ) ; } 
tOperationCallback getCallback ( ) ; tvoid handleLine ( String line ) ; } 
tvoid cancel ( ) ; tvoid handleLine ( String line ) ; } 
tOperationState getState ( ) ; tvoid handleLine ( String line ) ; } 
tByteBuffer getBuffer ( ) ; tvoid handleLine ( String line ) ; } 
tvoid writeComplete ( ) ; tvoid handleLine ( String line ) ; } 
tOperationReadType getReadType ( ) ; tvoid handleLine ( String line ) ; } 
public String toString ( ) { tString rv = null ; tif ( type = = OperationErrorType . GENERAL ) { trv = " OperationException: " + type ; } else { trv = " OperationException: " + type + " : " + getMessage ( ) ; } treturn rv ; } 
public final void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tassert op . getState ( ) = = OperationState . READING ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; tassert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { tassert line . equals ( " OK " ) : " Expected OK, was " + line ; tgetLogger ( ) . debug ( " Flush completed successfully " ) ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tString found = null ; tif ( ! line . equals ( " NOT_FOUND " ) ) { tfound = line ; } tgetCallback ( ) . receivedStatus ( found ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
tprotected final void transitionState ( OperationState newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; callback.complete(); 
public final void writeComplete ( ) { ttransitionState ( OperationState . READING ) ; } 
public abstract void initialize ( ) ; public abstract void handleLine(String line);} 
public final void readFromBuffer ( ByteBuffer data ) throws IOException { if(readType == OperationReadType.DATA) { 
private void handleError ( OperationErrorType eType , String line ) throws IOException { tgetLogger ( ) . error ( " Error: %s " , line ) ; tswitch ( eType ) { tcase GENERAL : texception = new OperationException ( ) ; tbreak ; tcase SERVER : texception = new OperationException ( eType , line ) ; tbreak ; tcase CLIENT : texception = new OperationException ( eType , line ) ; tbreak ; tdefault : assert false ; } ttransitionState ( OperationState . COMPLETE ) ; tthrow exception ; } 
private OperationErrorType classifyError ( String line ) { tOperationErrorType rv = null ; tif ( line . startsWith ( " ERROR " ) ) { trv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { trv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { trv = OperationErrorType . SERVER ; } treturn rv ; } 
public void handleLine ( String line ) { tassert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; tgetCallback ( ) . receivedStatus ( line ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { tassert line . startsWith ( " VERSION " ) ; tgetCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public void testDataReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; tassertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; } 
public void testLineReadType ( ) throws Exception { tSimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; tassertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; } 
public void testLineParser ( ) throws Exception { tString input = " This is a multiline string r nhere is line two r " ; tByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; tSimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; top . linesToRead = 2 ; top . readFromBuffer ( b ) ; tassertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; tassertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; top . setBytesToRead ( 2 ) ; top . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; tbyte [ ] expected = { 'x' , 'y' } ; tassertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , 
public void testPartialLine ( ) throws Exception { tString input1 = " this is a " ; tString input2 = " test r " ; tByteBuffer b = ByteBuffer . allocate ( 20 ) ; tSimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; tb . put ( input1 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertNull ( op . getCurrentLine ( ) ) ; tb . clear ( ) ; tb . put ( input2 . getBytes ( ) ) ; tb . flip ( ) ; top . readFromBuffer ( b ) ; tassertEquals ( " this is a test " , op . getCurrentLine ( ) ) ; } 
public void handleLine ( String line ) { tassert getReadType ( ) = = OperationReadType . LINE ; tlines . add ( line ) ; tif ( - - linesToRead = = 0 ) { tsetReadType ( OperationReadType . DATA ) ; 
public void handleRead ( ByteBuffer data ) { tassert getReadType ( ) = = OperationReadType . DATA ; tassert bytesToRead > 0 ; tif ( bytesToRead > 0 ) { tcurrentBytes = new byte [ bytesToRead ] ; 
public void testEmpty ( ) { tOperationException oe = new OperationException ( ) ; tassertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; tassertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
public void testServer ( ) { tOperationException oe = new OperationException ( tOperationErrorType . SERVER , " SERVER_ERROR figures " ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; tassertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; } 
public void testClient ( ) { tOperationException oe = new OperationException ( tOperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; tassertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; tassertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; } 
public void testGeneral ( ) { } 
tprotected void wasCancelled ( ) { tgetLogger ( ) . debug ( " was cancelled. " ) ; } 
public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ) ; 
tboolean isCancelled ( ) ; tvoid handleLine ( String line ) ; } 
tboolean hasErrored ( ) ; tvoid handleLine ( String line ) ; } 
tOperationException getException ( ) ; tvoid handleLine ( String line ) ; } 
tOperationCallback getCallback ( ) ; tvoid handleLine ( String line ) ; } 
tvoid cancel ( ) ; tvoid handleLine ( String line ) ; } 
tOperationState getState ( ) ; tvoid handleLine ( String line ) ; } 
tByteBuffer getBuffer ( ) ; tvoid handleLine ( String line ) ; } 
tvoid writeComplete ( ) ; tvoid handleLine ( String line ) ; } 
public void receivedStatus ( String val ) { } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void receivedStatus ( String line ) { getLogger().warn("Expected ``END'', was ``%s''", line); 
public void receivedStatus ( String line ) { getLogger().warn("Expeted ``END'', was ``%s''", 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( String line ) { } 
public void receivedStatus ( String line ) { } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { } 
public void receivedStatus ( String line ) { } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn new VersionOperation ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( String line ) { return blatch.await(timeout, unit); 
public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) ) ; } 
public Future < Object > asyncGet ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = transcoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void receivedStatus ( OperationStatus status ) { tif ( ! status . isSuccess ( ) ) { tgetLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ; 
public void receivedStatus ( OperationStatus s ) { trv . put ( sa , s . getMessage ( ) ) ; } 
public void receivedStatus ( OperationStatus status ) { tif ( ! status . isSuccess ( ) ) { tgetLogger ( ) . warn ( " Unsuccessful stat fetch: %s " , 
private long mutate ( Mutator m , String key , int by ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
public void receivedStatus ( OperationStatus s ) { } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) ; } 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { 
public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . version ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit); 
tvoid receivedStatus ( OperationStatus status ) ; tvoid complete ( ) ; } 
public String toString ( ) { treturn " {OperationStatus success= " + isSuccess + " : " + message + " } " ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; tgetCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Flush completed successfully " ) ; tgetCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
tprotected final void wasCancelled ( ) { tcb . receivedStatus ( CANCELLED ) ; } 
public void handleLine ( String line ) { tgetLogger ( ) . debug ( " Result: %s " , line ) ; tOperationStatus found = null ; tif ( line . equals ( " NOT_FOUND " ) ) { tfound = NOT_FOUND ; } else { tfound = new OperationStatus ( true , line ) ; } tgetCallback ( ) . receivedStatus ( found ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
tprotected void wasCancelled ( ) { } 
public void receivedStatus ( OperationStatus status ) { tfor ( GetOperation . Callback c : allCallbacks ) { tc . receivedStatus ( status ) ; 
public void receivedStatus ( OperationStatus status ) { tif ( ! completed ) { tcb . receivedStatus ( status ) ; 
public void handleLine ( String line ) { tif ( line . equals ( " END " ) ) { tcb . receivedStatus ( END ) ; 
tprotected void wasCancelled ( ) { tcb . receivedStatus ( CANCELLED ) ; } 
public void handleLine ( String line ) { tassert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; tgetCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
tprotected void wasCancelled ( ) { } 
public void handleLine ( String line ) { tassert line . startsWith ( " VERSION " ) ; tgetCallback ( ) . receivedStatus ( tnew OperationStatus ( true , line . substring ( " VERSION " . length ( ) ) ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void receivedStatus ( OperationStatus s ) { tSystem . err . println ( " Received a line. " ) ; } } ) { 
public abstract void initialize ( ) ; public abstract void readFromBuffer ( ByteBuffer data ) throws IOException ; tprotected void handleError ( OperationErrorType eType , String line ) tthrows IOException { tgetLogger ( ) . error ( " Error: %s " , line ) ; tswitch ( eType ) { tcase GENERAL : texception = new OperationException ( ) ; tbreak ; tcase SERVER : texception = new OperationException ( eType , line ) ; tbreak ; tcase CLIENT : texception = new OperationException ( eType , line ) ; tbreak ; tdefault : assert false ; } ttransitionState ( OperationState . COMPLETE ) ; tthrow exception ; } public void handleRead ( ByteBuffer data ) { tassert false ; } } 
public abstract void readFromBuffer ( ByteBuffer data ) throws IOException ; tprotected void handleError ( OperationErrorType eType , String line ) tthrows IOException { tgetLogger ( ) . error ( " Error: %s " , line ) ; tswitch ( eType ) { tcase GENERAL : texception = new OperationException ( ) ; tbreak ; tcase SERVER : texception = new OperationException ( eType , line ) ; tbreak ; tcase CLIENT : texception = new OperationException ( eType , line ) ; tbreak ; tdefault : assert false ; } ttransitionState ( OperationState . COMPLETE ) ; tthrow exception ; } public void handleRead ( ByteBuffer data ) { tassert false ; } } 
tprotected void handleError ( OperationErrorType eType , String line ) tthrows IOException { tgetLogger ( ) . error ( " Error: %s " , line ) ; tswitch ( eType ) { tcase GENERAL : texception = new OperationException ( ) ; tbreak ; tcase SERVER : texception = new OperationException ( eType , line ) ; tbreak ; tcase CLIENT : texception = new OperationException ( eType , line ) ; tbreak ; tdefault : assert false ; } ttransitionState ( OperationState . COMPLETE ) ; tthrow exception ; } 
tOperationErrorType classifyError ( String line ) { tOperationErrorType rv = null ; tif ( line . startsWith ( " ERROR " ) ) { trv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { trv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { trv = OperationErrorType . SERVER ; } treturn rv ; } 
tprotected void optimize ( ) { }} 
public DeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) { } 
public FlushOperation flush ( int delay , OperationCallback cb ) { } 
public GetOperation get ( String key , Callback callback ) { } 
public GetOperation get ( Collection < String > value , Callback cb ) { } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tOperationCallback cb ) { } 
public StatsOperation stats ( String arg , tnet . spy . memcached . ops . StatsOperation . Callback cb ) { } 
public StoreOperation store ( StoreType storeType , String key , int flags , tint exp , byte [ ] data , OperationCallback cb ) { } 
public VersionOperation version ( OperationCallback cb ) { } 
public void readFromBuffer ( ByteBuffer data ) throws IOException { }} 
tprotected void prepareBuffer ( int cmd , int opaque , String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
tprotected void initClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( ) ) ; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . noop ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit); 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . noop ( tnew OperationCallback ( ) { 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tboolean isCancelled ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tboolean hasErrored ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tOperationException getException ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tOperationCallback getCallback ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tvoid cancel ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tOperationState getState ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tByteBuffer getBuffer ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tvoid writeComplete ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tvoid initialize ( ) ; tvoid handleRead ( ByteBuffer data ) ; } 
tvoid readFromBuffer ( ByteBuffer data ) throws IOException ; tvoid handleRead ( ByteBuffer data ) ; } 
public NoopOperation noop ( OperationCallback cb ) { treturn new VersionOperationImpl ( cb ) ; } 
public FlushOperation flush ( int delay , OperationCallback cb ) { treturn new FlushOperationImpl ( cb ) ; } 
public NoopOperation noop ( OperationCallback cb ) { treturn new NoopOperationImpl ( cb ) ; } 
public void initialize ( ) { tprepareBuffer ( " " , EMPTY_BYTES ) ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { int toRead=payload.length - payloadOffset; 
private void finishedPayload ( byte [ ] pl ) throws IOException { ttransitionState ( OperationState . COMPLETE ) ; tif ( errorCode ! = 0 ) { thandleError ( OperationErrorType . GENERAL , new String ( pl ) ) ; 
tprotected void decodePayload ( byte [ ] pl ) { tassert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
tprotected boolean opaqueIsValid ( ) { tSystem . err . println ( " Expected " + opaque + " , got " + responseOpaque ) ; treturn responseOpaque = = opaque ; } 
private int decodeInt ( byte [ ] data , int i ) { tSystem . out . printf ( " Decoding %d %d %d %d " , tdata [ i ] , data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] ) ; treturn data [ i ] < < 24 | data [ i + 1 ] < < 16 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
tstatic int generateOpaque ( ) { tint rv = seqNumber . incrementAndGet ( ) ; twhile ( rv < 0 ) { tseqNumber . compareAndSet ( rv , 0 ) ; trv = seqNumber . incrementAndGet ( ) ; } treturn rv ; } 
tprotected void initClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( ) { @Override 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { treturn new BinaryMemcachedNodeImpl ( sa , c , bufSize , tcreateOperationQueue ( ) , 
public GetOperation get ( String key , Callback callback ) { treturn new GetOperationImpl ( key , callback ) ; } 
public void initialize ( ) { tprepareBuffer ( key , EMPTY_BYTES ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - 4 ] ; tSystem . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; tCallback cb = ( Callback ) getCallback ( ) ; tcb . gotData ( key , flags , data ) ; tcb . receivedStatus ( STATUS_OK ) ; } 
tprotected void handleError ( int errCode , byte [ ] errPl ) throws IOException { tif ( errCode = = NOT_FOUND ) { tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
private void finishedPayload ( byte [ ] pl ) throws IOException { tif ( errorCode ! = 0 ) { thandleError ( errorCode , pl ) ; 
tprotected void handleError ( int errCode , byte [ ] errPl ) throws IOException { thandleError ( OperationErrorType . SERVER , new String ( errPl ) ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tassert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
tprotected boolean opaqueIsValid ( ) { tif ( responseOpaque ! = opaque ) { tSystem . err . printf ( " Expected opaque: %d, got opaque: %d " , tresponseOpaque , opaque ) ; } treturn responseOpaque = = opaque ; } 
tstatic int decodeInt ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 
private static int cmdMap ( StoreType ) { tint rv = - 1 ; tswitch ( ) { tcase set : rv = SET ; break ; tcase add : rv = ADD ; break ; tcase replace : rv = REPLACE ; break ; tdefault : assert false : " Unhandled store type: " + ; } treturn rv ; } 
public void initialize ( ) { tprepareBuffer ( key , data , flags , exp ) ; } 
public void testIntegerDecode ( ) { tassertEquals ( 129 , tOperationImpl . decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; tassertEquals ( 129 * 256 , tOperationImpl . decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; tassertEquals ( 129 * 256 * 256 , tOperationImpl . decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; tassertEquals ( 129 * 256 * 256 * 256 , tOperationImpl . decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
public final void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tgetLogger ( ) . debug ( " Transitioning %s to read " , op ) ; treadQ . add ( op ) ; } 
public DeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) { treturn new DeleteOperationImpl ( key , operationCallback ) ; } 
public GetOperation get ( Collection < String > value , Callback cb ) { treturn new MultiGetOperationImpl ( value , cb ) ; } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tOperationCallback cb ) { } 
public StatsOperation stats ( String arg , tnet . spy . memcached . ops . StatsOperation . Callback cb ) { } 
public VersionOperation version ( OperationCallback cb ) { } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( String s : keys . values ( ) ) { tsize + = s . length ( ) ; } } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; ttransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { tgetLogger ( ) . warn ( " Error on key %s: %s (%d) " , tkeys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - 4 ] ; tSystem . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; tCallback cb = ( Callback ) getCallback ( ) ; tcb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } tresetInput ( ) ; } 
tprotected boolean opaqueIsValid ( ) { treturn responseOpaque = = terminalOpaque | | keys . containsKey ( responseOpaque ) ; 
tprotected void resetInput ( ) { tpayload = null ; tpayloadOffset = 0 ; theaderOffset = 0 ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( errorCode ! = 0 ) { tOperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; 
tprotected boolean opaqueIsValid ( ) { tif ( responseOpaque ! = opaque ) { tgetLogger ( ) . warn ( " Expected opaque: %d, got opaque: %d " , tresponseOpaque , opaque ) ; } treturn responseOpaque = = opaque ; } 
tprotected void decodePayload ( byte [ ] pl ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ; } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " 127.0.0.1:11212 " ) ) ; 
public void testGetVersions ( ) throws Exception { tMap < SocketAddress , String > vs = client . getVersions ( ) ; tassertEquals ( 1 , vs . size ( ) ) ; tMap . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; tassertEquals ( " /127.0.0.1:11212 " , me . getKey ( ) . toString ( ) ) ; tassertNotNull ( me . getValue ( ) ) ; } 
tprotected void setUp ( ) throws Exception { tserverList = " 127.0.0.1:11211 127.0.0.1:11311 " ; tsuper . setUp ( ) ; } 
public void testServer ( ) { tOperationException oe = new OperationException ( tOperationErrorType . SERVER , " SERVER_ERROR figures " ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; tassertEquals ( " OperationException: SERVER: SERVER_ERROR figures " , tString . valueOf ( oe ) ) ; 
public void testClient ( ) { tOperationException oe = new OperationException ( tOperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; tassertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; tassertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , tString . valueOf ( oe ) ) ; 
private long mutate ( Mutator m , String key , int by , long def , int exp ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
public long incr ( String key , int by ) { treturn mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public long decr ( String key , int by ) { treturn mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) { tlong rv = mutate ( , key , by , def , exp ) ; } 
public long incr ( String key , int by , int def ) { treturn mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public long decr ( String key , int by , long def ) { treturn mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tlong exp , int def , OperationCallback cb ) { treturn new MutatorOperationImpl ( m , key , by , cb ) ; } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) { return new MutatorOperationImpl(m, key, by, def, exp, cb); 
public void initialize ( ) { } 
tprotected void decodePayload ( byte [ ] pl ) { tassert pl . length = = 4 : " expected 4 bytes, got " + pl . length ; tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tString . valueOf ( decodeInt ( pl , 0 ) ) ) ) ; 
tstatic long decodeUnsignedInt ( byte [ ] data , int i ) { treturn ( ( long ) ( data [ i ] & 0xff ) < < 24 ) | ( ( data [ i + 1 ] & 0xff ) < < 16 ) 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
public void testIntegerDecode ( ) { tassertEquals ( 129 , tdecodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; tassertEquals ( 129 * 256 , tdecodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; tassertEquals ( 129 * 256 * 256 , tdecodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; tassertEquals ( 129 * 256 * 256 * 256 , tdecodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
public void testUnsignedIntegerDecode ( ) { tassertEquals ( 129 , tdecodeUnsignedInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; tassertEquals ( 129 * 256 , tdecodeUnsignedInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; tassertEquals ( 129 * 256 * 256 , tdecodeUnsignedInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; tassertEquals ( 129L * 256L * 256L * 256L , tdecodeUnsignedInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
public void initialize ( ) { } 
tprotected void decodePayload ( byte [ ] pl ) { tassert pl . length = = 8 : " expected 8 bytes, got " + pl . length ; tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tString . valueOf ( decodeLong ( pl , 0 ) ) ) ) ; 
tstatic long decodeLong ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 56 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
tprotected void decodePayload ( byte [ ] pl ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tnew String ( pl ) ) ) ; 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { treturn new BinaryMemcachedNodeImpl ( sa , c , bufSize , tcreateOperationQueue ( ) , 
tprotected void initClient ( ) throws Exception { tinitClient ( new BinaryConnectionFactory ( ) ) ; } 
public void testGracefulShutdown ( ) throws Exception { tfor ( int i = 0 ; i < 1000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertTrue ( " Couldn't shut down within five seconds " , tclient . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i)); 
public void testGracefulShutdownTooSlow ( ) throws Exception { tfor ( int i = 0 ; i < 10000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertFalse ( " Weird, shut down too fast " , tclient . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; ttry { tMap < SocketAddress , String > m = client . getVersions ( ) ; tfail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { tassertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
public void testOperationStatusString ( ) { tString s = String . valueOf ( OperationImpl . STATUS_OK ) ; tassertEquals ( " {OperationStatus success=true: OK} " , s ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { tassert ! completed : " Got data for a completed wrapped op " ; tcb . gotData ( key , flags , data ) ; tif ( - - remainingKeys = = 0 ) { Fake a status line 
public void receivedStatus ( OperationStatus status ) { tif ( ! completed ) { tcb . receivedStatus ( status ) ; 
public void complete ( ) { tassert ! completed ; tcb . complete ( ) ; tcompleted = true ; } 
tprotected void optimize ( ) { getOp=(GetOperation)writeQ.remove(); 
tprotected int addKey ( String k ) { tInteger rv = rkeys . get ( k ) ; tif ( rv = = null ) { trv = generateOpaque ( ) ; tkeys . put ( rv , k ) ; trkeys . put ( k , rv ) ; } treturn rv ; } 
public void gotData ( String key , int flags , byte [ ] data ) { tCollection < GetOperation . Callback > cbs = callbacks . get ( key ) ; tassert cbs ! = null : " No callbacks for key " + key ; tfor ( GetOperation . Callback c : cbs ) { tc . gotData ( key , flags , data ) ; 
public void receivedStatus ( OperationStatus status ) { tfor ( GetOperation . Callback c : allCallbacks ) { tc . receivedStatus ( status ) ; 
public void complete ( ) { tfor ( GetOperation . Callback c : allCallbacks ) { tc . complete ( ) ; 
public int numCallbacks ( ) { treturn allCallbacks . size ( ) ; } 
public void addOperation ( GetOperation o ) { tgetKeys ( ) . addAll ( o . getKeys ( ) ) ; tpcb . addCallbacks ( o ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op ! = null & & op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult ) { @Override 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { top . cancel ( ) ; trv | = op . getState ( ) = = OperationState . WRITING ; } treturn rv ; } 
public boolean isCancelled ( ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . isCancelled ( ) ; } treturn rv ; } 
public boolean isDone ( ) { tboolean rv = true ; tfor ( Operation op : ops ) { trv & = op . getState ( ) = = OperationState . COMPLETE ; } treturn rv ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
tprotected void tearDown ( ) throws Exception { } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " 127.0.0.1:11213 " ) ) ; 
tprotected void tryCancellation ( Future < ? > f ) throws Exception { tf . cancel ( true ) ; ttry { tObject o = f . get ( ) ; 
public void testAsyncGetCancellation ( ) throws Exception { ttryCancellation ( client . asyncGet ( " k " ) ) ; } 
public void testAsyncGetBulkCancellationCollection ( ) throws Exception { ttryCancellation ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; } 
public void testAsyncGetBulkCancellationVararg ( ) throws Exception { ttryCancellation ( client . asyncGetBulk ( " k " , " k2 " ) ) ; } 
public void testDeleteCancellation ( ) throws Exception { ttryCancellation ( client . delete ( " x " ) ) ; } 
public void testDelayedDeleteCancellation ( ) throws Exception { ttryCancellation ( client . delete ( " x " , 5 ) ) ; } 
public void testflushCancellation ( ) throws Exception { ttryCancellation ( client . flush ( ) ) ; } 
public void testDelayedflushCancellation ( ) throws Exception { ttryCancellation ( client . flush ( 3 ) ) ; } 
public void testReplaceCancellation ( ) throws Exception { ttryCancellation ( client . replace ( " x " , 3 , " y " ) ) ; } 
public void testAddCancellation ( ) throws Exception { ttryCancellation ( client . add ( " x " , 3 , " y " ) ) ; } 
public void testSetCancellation ( ) throws Exception { ttryCancellation ( client . set ( " x " , 3 , " y " ) ) ; } 
public void testGetVersions ( ) throws Exception { tMap < SocketAddress , String > vs = client . getVersions ( ) ; tassertEquals ( 1 , vs . size ( ) ) ; tMap . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; tassertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . toString ( ) ) ; tassertNotNull ( me . getValue ( ) ) ; } 
public boolean isDone ( ) { tboolean rv = true ; tfor ( Operation op : ops ) { trv & = op . getState ( ) = = OperationState . COMPLETE ; } treturn rv | | isCancelled ( ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( ) ; tassert isDone ( ) : " Latch released, but operation wasn't done. " ; tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn latch . getCount ( ) = = 0 | | top . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ; 
tstatic int generateOpaque ( ) { tint rv = seqNumber . incrementAndGet ( ) ; twhile ( rv < 0 ) { tif ( seqNumber . compareAndSet ( rv , 0 ) ) { trv = seqNumber . incrementAndGet ( ) ; } } treturn rv ; } 
private static int cmdMap ( StoreType ) { tint rv = - 1 ; tswitch ( ) { tcase set : rv = SET ; break ; tcase add : rv = ADD ; break ; tcase replace : rv = REPLACE ; break ; } } 
tprotected void tryCancellation ( Future < ? > f ) throws Exception { tf . cancel ( true ) ; tassertTrue ( f . isCancelled ( ) ) ; tassertTrue ( f . isDone ( ) ) ; ttry { tObject o = f . get ( ) ; 
public void testBinaryEmptyCons ( ) { tnew BinaryConnectionFactory ( ) ; } 
public void testBinaryTwoIntCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 ) ; } 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV_HASH ) ; } 
public Boolean call ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { tclient . set ( " test " + i , 5 , " value " + i ) ; tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } tMap < String , Object > m = client . getBulk ( " test0 " , " test1 " , " test2 " , " test3 " , " test4 " , " test5 " , " test6 " , " test7 " , " test8 " , " test9 " , " test10 " ) ; }}); 
public void testQueueAfterShutdown ( ) throws Exception { tclient . shutdown ( ) ; ttry { tObject o = client . get ( " k " ) ; 
public void testMultiReqAfterShutdown ( ) throws Exception { tclient . shutdown ( ) ; ttry { tMap < String , ? > m = client . getBulk ( " k1 " , " k2 " , " k3 " ) ; 
public void testBroadcastAfterShutdown ( ) throws Exception { tclient . shutdown ( ) ; ttry { tFuture < ? > f = client . flush ( ) ; 
public void testABunchOfCancelledOperations ( ) throws Exception { tCollection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; tfor ( int i = 0 ; i < 1000 ; i + + ) { tfutures . add ( client . set ( " x " , 5 , " xval " ) ) ; tfutures . add ( client . asyncGet ( " x " ) ) ; } tFuture < Boolean > sf = client . set ( " x " , 5 , " myxval " ) ; tFuture < Object > gf = client . asyncGet ( " x " ) ; tfor ( Future < ? > f : futures ) { tf . cancel ( true ) ; } tassertTrue ( sf . get ( ) ) ; tassertEquals ( " myxval " , gf . get ( ) ) ; } 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
public static byte [ ] computeMd5 ( String k ) { tMessageDigest md5 ; ttry { tmd5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new RuntimeException ( " MD5 not supported " , e ) ; } tmd5 . reset ( ) ; tmd5 . update ( k . getBytes ( ) ) ; treturn md5 . digest ( ) ; } 
public void testKetamaHash ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " 26 " , 3979113294L ) ; texp . put ( " 1404 " , 2065000984L ) ; texp . put ( " 4177 " , 1125759251L ) ; texp . put ( " 9315 " , 3302915307L ) ; texp . put ( " 14745 " , 2580083742L ) ; texp . put ( " 105106 " , 3986458246L ) ; texp . put ( " 355107 " , 3611074310L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . KETAMA_HASH , me . getKey ( ) , 
tprotected void setupNodes ( int ) { tsuper . setupNodes ( ) ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } tlocator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , tHashAlgorithm . KETAMA_HASH ) ; 
public void testLookups ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testContinuumWrapping ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " N6H4245M " ) ) ; } 
public void testClusterResizing ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; tsetupNodes ( 5 ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testSequence1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 0 , 2 , 1 , 1 ) ; } 
public void testSequence2 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " noelani " , 2 , 1 , 3 , 0 ) ; } 
private void assertPosForKey ( String k , int nid ) { tassertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; } 
public void testLibKetamaCompat ( ) { tsetupNodes ( 5 ) ; tassertPosForKey ( " 36 " , 2 ) ; tassertPosForKey ( " 10037 " , 3 ) ; tassertPosForKey ( " 22051 " , 1 ) ; tassertPosForKey ( " 49044 " , 4 ) ; } 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
private void nextHash ( ) { } 
public void testPrimary ( ) throws Exception { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
public void testSeq1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 0 , 1 , 2 ) ; } 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ; } 
private void assertHash ( HashAlgorithm ha , String key , long exp ) { tassertTrue ( exp > = 0 L ) ; exp, ha.hash(key)); 
public void testFnv1_64 ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0x84222325L ) ; texp . put ( " " , 0x8601b7ffL ) ; texp . put ( " hello world! " , 0xb97b86bcL ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0xe87c054aL ) ; texp . put ( " wd:com.google " , 0x071b08f8L ) ; texp . put ( " wd:com.google " , 0x12f03d48L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV1_64_HASH , me . getKey ( ) , 
public void testFnv1a_64 ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0x84222325L ) ; texp . put ( " " , 0x8601817fL ) ; texp . put ( " hello world! " , 0xcd5a2672L ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0xbec309a8L ) ; texp . put ( " wd:com.google " , 0x097b3f26L ) ; texp . put ( " wd:com.google " , 0x1c6c1732L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) , 
public void testFnv1_32 ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0x811c9dc5L ) ; texp . put ( " " , 0x050c5d3fL ) ; texp . put ( " hello world! " , 0x8a01b99cL ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0x9277524aL ) ; texp . put ( " wd:com.google " , 0x455e0df8L ) ; texp . put ( " wd:com.google " , 0x2b0ffd48L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) , 
public void testFnv1a_32 ( ) { tHashMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " " , 0x811c9dc5L ) ; texp . put ( " " , 0x250c8f7fL ) ; texp . put ( " hello world! " , 0xb034fff2L ) ; texp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , t0xa9795ec8L ) ; texp . put ( " wd:com.google " , 0xaa90fcc6L ) ; texp . put ( " wd:com.google " , 0x683e1e12L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . FNV1A_32_HASH , me . getKey ( ) , 
tprotected void setupNodes ( HashAlgorithm alg , int ) { tsuper . setupNodes ( ) ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tnodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } tlocator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; } 
tprotected void setupNodes ( int ) { tsetupNodes ( HashAlgorithm . KETAMA_HASH , ) ; } 
public void testContinuumWrapping ( ) { tsetupNodes ( 4 ) ; } 
public void testSequence1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 0 , 2 , 1 , 2 ) ; } 
public void testSequence2 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " noelani " , 2 , 1 , 1 , 3 ) ; } 
public void testFNV1A_32 ( ) { tHashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; tsetupNodes ( alg , 5 ) ; tassertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testSetHashAlg ( ) { tassertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; tclient . setHashAlgorithm ( HashAlgorithm . FNV1_64_HASH ) ; tassertSame ( HashAlgorithm . FNV1_64_HASH , client . getHashAlgorithm ( ) ) ; } 
private void nextHash ( ) { } 
public DeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) { treturn new DeleteOperationImpl ( key , when , operationCallback ) ; } 
public void initialize ( ) { tprepareBuffer ( key , EMPTY_BYTES , when ) ; } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( String s : keys . values ( ) ) { tsize + = s . length ( ) ; } } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
private void validateKey ( String key ) { tif ( key . length ( ) > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(Character.isWhitespace(c) || Character.isISOControl(c)) { 
tOperation addOp ( final String key , final Operation op ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tvalidateKey ( key ) ; tassert isAlive ( ) : " IO Thread is not running. " ; tconn . addOperation ( key , op ) ; treturn op ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void testInvalidKeyBulk ( ) throws Exception { ttry { tObject val = client . getBulk ( " Key key2 " ) ; 
public Boolean call ( ) throws Exception { tclient . set ( " testparallel " , 5 , " parallelvalue " ) ; tfor ( int i = 0 ; i < 10 ; i + + ) { tassertEquals ( " parallelvalue " , client . get ( " testparallel " ) ) ; } treturn Boolean . TRUE ; } } ) ; 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tObject val = transcoder . decode ( new CachedData ( flags , data ) ) ; m.put(k, val); 
public Integer call ( ) throws Exception { tfor ( int i = 0 ; i < 25 ; i + + ) { tMap < String , Object > m = client . getBulk ( keys ) ; tfor ( String s : keys ) { tbyte b [ ] = ( byte [ ] ) m . get ( s ) ; tassert Arrays . hashCode ( b ) = = hashcode : " Expected " + hashcode + " was " + Arrays . hashCode ( b ) ; } } treturn hashcode ; } } ) ; 
public void addOperation ( final MemcachedNode node , final Operation o ) { to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
private void checkState ( ) { tif ( shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; } 
tOperation addOp ( final String key , final Operation op ) { tvalidateKey ( key ) ; tcheckState ( ) ; tconn . addOperation ( key , op ) ; treturn op ; } 
tOperation addOp ( final MemcachedNode node , final Operation op ) { tcheckState ( ) ; tconn . addOperation ( node , op ) ; treturn op ; } 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { tfinal Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { tfor ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { tfinal MemcachedNode node = me . getKey ( ) ; tOperation o = me . getValue ( ) ; to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; } tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
private void attemptReconnects ( ) throws IOException { tfinal long now = System . currentTimeMillis ( ) ; tfinal Map < MemcachedNode , Boolean > seen = tnew IdentityHashMap < MemcachedNode , Boolean > ( ) ; tfor ( Iterator < MemcachedNode > i = treconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( String s : keys . values ( ) ) { tsize + = s . length ( ) ; } } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; ttransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { tgetLogger ( ) . warn ( " Error on key %s: %s (%d) " , tkeys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , t0 , pl . length - EXTRA_HDR_LEN ) ; tCallback cb = ( Callback ) getCallback ( ) ; tcb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } tresetInput ( ) ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tstatic int decodeShort ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ; 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tint bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; } 
public void initialize ( ) { tprepareBuffer ( key , data , flags , exp , cas ) ; } 
public void xtestStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { ttry { tb = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { tthrow new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
public void testUTF8String ( ) throws Exception { tString s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; tCachedData cd = tc . encode ( s1 ) ; } 
public void testValidCharacterSet ( ) { ttc . setCharset ( " KOI8 " ) ; } 
public void testInvalidCharacterSet ( ) { ttry { ttc . setCharset ( " Dustin's Kick Ass Character Set " ) ; 
public final void initialize ( ) { } 
public void initialize ( ) { tint size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; tByteBuffer b = ByteBuffer . allocate ( size ) ; tsetArguments ( b , mutator . name ( ) , key , amount ) ; tb . flip ( ) ; tsetBuffer ( b ) ; } 
public void testExtendedUTF8Key ( ) throws Exception { tString key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; tassertNull ( client . get ( key ) ) ; tclient . set ( key , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( key ) ) ; } 
private void validateKey ( String key ) { tbyte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tif ( keyBytes . length > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) { 
public void testCrc32Hash ( ) { tMap < String , Long > exp = new HashMap < String , Long > ( ) ; texp . put ( " Test1 " , 19315L ) ; texp . put ( " Test2 " , 21114L ) ; texp . put ( " Test3 " , 9597L ) ; texp . put ( " Test4 " , 15129L ) ; texp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; tfor ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { tassertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
tprotected void decodePayload ( byte [ ] pl ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tString . valueOf ( decodeLong ( pl , 0 ) ) ) ) ; 
tstatic long decodeLong ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 56 | ( data [ i + 1 ] & 0xff ) < < 48 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( bb , type . name ( ) , key , flags , exp , data . length ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( CRLF ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public void initialize ( ) { tByteBuffer b = ByteBuffer . allocate ( tKeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( b , " delete " , key , when ) ; tb . flip ( ) ; tsetBuffer ( b ) ; } 
tprotected void prepareBuffer ( String key , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tfinal byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tint bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
tprotected int addKey ( String k ) { tInteger rv = rkeys . get ( k ) ; tif ( rv = = null ) { trv = generateOpaque ( ) ; tkeys . put ( rv , k ) ; tbkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; trkeys . put ( k , rv ) ; } treturn rv ; } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( byte [ ] b : bkeys . values ( ) ) { tsize + = b . length ; } } 
public Map < String , Object > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( timeout , unit ) ) { tthrow new TimeoutException ( " Operation timed out. " ) ; } tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } treturn rvMap ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } treturn objRef . get ( ) ; } 
private void tryCancellation ( Future < ? > f ) throws Exception { tf . cancel ( true ) ; tassertTrue ( f . isCancelled ( ) ) ; tassertTrue ( f . isDone ( ) ) ; ttry { tObject o = f . get ( ) ; 
private void tryTimeout ( Future < ? > f ) throws Exception { ttry { tObject o = f . get ( 10 , TimeUnit . MILLISECONDS ) ; 
tprotected void tryTestSequence ( Future < ? > f ) throws Exception { ttryTimeout ( f ) ; ttryCancellation ( f ) ; } 
public void testAsyncGetCancellation ( ) throws Exception { ttryTestSequence ( client . asyncGet ( " k " ) ) ; } 
public void testAsyncGetBulkCancellationCollection ( ) throws Exception { ttryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; } 
public void testAsyncGetBulkCancellationVararg ( ) throws Exception { ttryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; } 
public void testDeleteCancellation ( ) throws Exception { ttryTestSequence ( client . delete ( " x " ) ) ; } 
public void testDelayedDeleteCancellation ( ) throws Exception { ttryTestSequence ( client . delete ( " x " , 5 ) ) ; } 
public void testflushCancellation ( ) throws Exception { ttryTestSequence ( client . flush ( ) ) ; } 
public void testDelayedflushCancellation ( ) throws Exception { ttryTestSequence ( client . flush ( 3 ) ) ; } 
public void testReplaceCancellation ( ) throws Exception { ttryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; } 
public void testAddCancellation ( ) throws Exception { ttryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; } 
public void testSetCancellation ( ) throws Exception { ttryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; } 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tvoid gotData ( String key , int flags , long cas , byte [ ] data ) ; } tCollection < String > getKeys ( ) ; } 
public GetOperation get ( String key , GetOperation . Callback cb ) { treturn new GetOperationImpl ( key , cb ) ; } 
public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { treturn new GetOperationImpl ( keys , cb ) ; } 
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; } 
public final void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; do { 
tprotected abstract String getCmd ( ) ; @Override public final void initialize ( ) { }} 
public final void initialize ( ) { } 
tprotected final void wasCancelled ( ) { tgetCallback ( ) . receivedStatus ( CANCELLED ) ; } 
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { treturn new GetOperationImpl ( key , cb ) ; } 
public MutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) { treturn new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; } 
public StatsOperation stats ( String arg , tnet . spy . memcached . ops . StatsOperation . Callback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
public Future < CASValue > asyncGets ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue > rv = tnew OperationFuture < CASValue > ( latch ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CASValue ( cas , ttranscoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CASValue ( cas , ttranscoder . decode ( new CachedData ( flags , data ) ) ) ; 
public CASValue gets ( String key ) { ttry { treturn asyncGets ( key ) . get ( ) ; 
public void testSimpleCASGets ( ) throws Exception { tassertNull ( client . gets ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . gets ( " test1 " ) . getValue ( ) ) ; } 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tCASOperation cas ( String key , long casId , int flags , byte [ ] data , tOperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
public CASOperation cas ( String key , long casId , int flags , tbyte [ ] data , OperationCallback cb ) { treturn new CASOperationImpl ( key , casId , flags , data , cb ) ; } 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( bb , " cas " , key , flags , 0 , data . length , casValue ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( CRLF ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public CASOperation cas ( String key , long casId , int flags , tbyte [ ] data , OperationCallback cb ) { treturn new StoreOperationImpl ( StoreType . set , key , flags , 0 , data , tcasId , cb ) ; 
public boolean cas ( String key , long casId , Object value ) { ttry { treturn asyncCAS ( key , casId , value ) . get ( ) ; 
public Future < CASValue > asyncGets ( final String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue > rv = tnew OperationFuture < CASValue > ( latch ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue ( cas , ttranscoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue ( cas , ttranscoder . decode ( new CachedData ( flags , data ) ) ) ; 
public void testCAS ( ) throws Exception { tfinal String key = " castestkey " ; } 
public final void initialize ( ) { } 
public void receivedStatus ( OperationStatus val ) { tif ( val instanceof CASOperationStatus ) { trv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) ) ; 
public CASResponse cas ( String key , long casId , Object value ) { ttry { treturn asyncCAS ( key , casId , value ) . get ( ) ; 
public void handleLine ( String line ) { tassert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; tgetCallback ( ) . receivedStatus ( matchStatus ( line , tSTORED , NOT_FOUND , EXISTS ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } 
public void testCAS ( ) throws Exception { tfinal String key = " castestkey " ; } 
public void testAsyncGetsCancellation ( ) throws Exception { ttryTestSequence ( client . asyncGets ( " k " ) ) ; } 
public void testCASCancellation ( ) throws Exception { ttryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; } 
public Long call ( ) throws Exception { treturn mutator . cas ( " test.cas.concurrent " , 0 L , 0 , mutation ) ; } } ) ; 
public void testIncorrectTypeInCAS ( ) throws Throwable { Long rv=mutator.cas("x", 1L, 0, mutation); 
public void testIPv6Host ( ) throws Exception { tList < InetSocketAddress > addrs = tAddrUtil . getAddresses ( " ::1:80 " ) ; tassertEquals ( 1 , addrs . size ( ) ) ; tassertEquals ( " localhost " , addrs . get ( 0 ) . getHostName ( ) ) ; tassertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " ::1:11211 " ) ) ; 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " ::1:11212 " ) ) ; 
private void logRunException ( Exception e ) { tif ( shuttingDown ) { There are a couple types of errors that occur during the 
public void run ( ) { twhile ( running ) { ttry { tconn . handleIO ( ) ; } catch ( IOException e ) { tlogRunException ( e ) ; } catch ( CancelledKeyException e ) { tlogRunException ( e ) ; } catch ( ClosedSelectorException e ) { tlogRunException ( e ) ; } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public void testDoubleShutdown ( ) { tclient . shutdown ( ) ; tclient . shutdown ( ) ; } 
tCachedData encode ( T o ) ; tT decode ( CachedData d ) ; } 
public void testSetTranscoder ( ) { tTranscoder < Object > tc = client . getTranscoder ( ) ; tassertTrue ( tc instanceof SerializingTranscoder ) ; tTranscoder < Object > tmptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { tthrow new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { tthrow new RuntimeException ( " Not implemented. " ) ; } } ; tclient . setTranscoder ( tmptc ) ; tassertSame ( tmptc , client . getTranscoder ( ) ) ; } 
private Future < Boolean > asyncStore ( StoreType storeType , tString key , int exp , Object value ) { treturn asyncStore ( storeType , key , exp , value , transcoder ) ; } 
public Future < CASResponse > asyncCAS ( String key , long casId , Object value ) { treturn asyncCAS ( key , casId , value , transcoder ) ; } 
public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) { ttry { treturn asyncCAS ( key , casId , value , tc ) . get ( ) ; 
public CASResponse cas ( String key , long casId , Object value ) { treturn cas ( key , casId , value , transcoder ) ; } 
public < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) { treturn asyncStore ( StoreType . add , key , exp , o , tc ) ; } 
public Future < Boolean > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . add , key , exp , o , transcoder ) ; } 
public < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) { treturn asyncStore ( StoreType . set , key , exp , o , tc ) ; } 
public Future < Boolean > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . set , key , exp , o , transcoder ) ; } 
public < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) { treturn asyncStore ( StoreType . replace , key , exp , o , tc ) ; } 
public Future < Boolean > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . replace , key , exp , o , transcoder ) ; } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < T > rv = new OperationFuture < T > ( latch ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tc . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tc . decode ( new CachedData ( flags , data ) ) ; } 
public Future < Object > asyncGet ( final String key ) { treturn asyncGet ( key , transcoder ) ; } 
public < T > Future < CASValue > asyncGets ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue > rv = tnew OperationFuture < CASValue > ( latch ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue ( cas , ttc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue ( cas , ttc . decode ( new CachedData ( flags , data ) ) ) ; 
public Future < CASValue > asyncGets ( final String key ) { treturn asyncGets ( key , transcoder ) ; } 
public < T > CASValue gets ( String key , Transcoder < T > tc ) { ttry { treturn asyncGets ( key , tc ) . get ( ) ; 
public CASValue gets ( String key ) { treturn gets ( key , transcoder ) ; } 
public < T > T get ( String key , Transcoder < T > tc ) { ttry { treturn asyncGet ( key , tc ) . get ( ) ; 
public Object get ( String key ) { treturn get ( key , transcoder ) ; } 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > tc ) { tfinal Map < String , T > m = new ConcurrentHashMap < String , T > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tT val = tc . decode ( new CachedData ( flags , data ) ) ; m.put(k, val); 
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { treturn asyncGetBulk ( keys , transcoder ) ; } 
public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; } 
public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) , transcoder ) ; } 
public Map < String , T > get ( ) tthrows InterruptedException , ExecutionException { ttry { treturn get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
public Map < String , T > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( timeout , unit ) ) { tthrow new TimeoutException ( " Operation timed out. " ) ; } tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } treturn rvMap ; } 
public static byte [ ] encodeNum ( long l , int maxBytes ) { tbyte [ ] rv = new byte [ maxBytes ] ; tfor ( int i = 0 ; i < rv . length ; i + + ) { tint pos = rv . length - i - 1 ; trv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } tint firstNonZero = 0 ; tfor ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { } 
public static byte [ ] encodeLong ( long l ) { treturn encodeNum ( l , 8 ) ; } 
public static long decodeLong ( byte [ ] b ) { tlong rv = 0 ; tfor ( byte i : b ) { trv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } treturn rv ; } 
public static byte [ ] encodeInt ( int in ) { treturn encodeNum ( in , 4 ) ; } 
public static int decodeInt ( byte [ ] in ) { tassert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; treturn ( int ) decodeLong ( in ) ; } 
public static byte [ ] encodeByte ( byte in ) { treturn new byte [ ] { in } ; } 
public static byte decodeByte ( byte [ ] in ) { tassert in . length < = 1 : " Too long for a byte " ; tbyte rv = 0 ; tif ( in . length = = 1 ) { trv = in [ 0 ] ; } treturn rv ; } 
public static byte [ ] encodeBoolean ( boolean b ) { tbyte [ ] rv = new byte [ 1 ] ; trv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; treturn rv ; } 
public static boolean decodeBoolean ( byte [ ] in ) { tassert in . length = = 1 : " Wrong length for a boolean " ; treturn in [ 0 ] = = '1' ; } 
public static int hashForFlags ( int i ) { } 
public static int hashForFlags ( long l ) { } 
public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; } 
public CachedData encode ( Object o ) { tCachedData rv = null ; tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { ttry { tb = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { tthrow new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { tb = TranscoderUtils . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = TranscoderUtils . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = TranscoderUtils . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tif ( b ! = null ) { tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } trv = new CachedData ( flags , b ) ; } treturn rv ; } 
private void assertLong ( long l ) { tbyte [ ] encoded = TranscoderUtils . encodeLong ( l ) ; tlong decoded = TranscoderUtils . decodeLong ( encoded ) ; tassertEquals ( l , decoded ) ; } 
private void assertInt ( int i ) { tbyte [ ] encoded = TranscoderUtils . encodeInt ( i ) ; tint decoded = TranscoderUtils . decodeInt ( encoded ) ; tassertEquals ( i , decoded ) ; } 
public void testBooleanEncoding ( ) throws Exception { tassertTrue ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( true ) ) ) ; tassertFalse ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( false ) ) ) ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; 
public Future < CASValue < Object > > asyncGets ( final String key ) { treturn asyncGets ( key , transcoder ) ; } 
public < T > CASValue < T > gets ( String key , Transcoder < T > tc ) { ttry { treturn asyncGets ( key , tc ) . get ( ) ; 
public CASValue < Object > gets ( String key ) { treturn gets ( key , transcoder ) ; } 
public CachedData encode ( java . lang . Long l ) { treturn new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; } 
public CachedData encode ( java . lang . Integer l ) { treturn new CachedData ( flags , TranscoderUtils . encodeInt ( l ) ) ; } 
public void testCAS ( ) throws Exception { tfinal String key = " castestkey " ; } 
public T cas ( final String key , final T initial , long initialExp , tfinal CASMutation < T > m ) throws Exception { tT rv = initial ; tboolean done = false ; tfor ( int i = 0 ; ! done & & i < max ; i + + ) { tCASValue < T > casval = client . gets ( key , transcoder ) ; tT current = null ; } 
public String toString ( ) { treturn " {CasValue " + cas + " / " + value + " } " ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void testCASValueToString ( ) { tCASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; tassertEquals ( " {CasValue 717/hi} " , c . toString ( ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new IntegerTranscoder ( ) ; } 
public void testInt ( ) throws Exception { tassertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) . intValue ( ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new LongTranscoder ( ) ; } 
public void testLong ( ) throws Exception { tassertEquals ( 923 , tc . decode ( tc . encode ( 923L ) ) . longValue ( ) ) ; } 
public void testAddWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertNull ( client . get ( " test1 " , ) ) ; tassertTrue ( client . set ( " test1 " , 5 , " test1value " , ) . get ( ) ) ; tassertEquals ( " test1value " , client . get ( " test1 " , ) ) ; tassertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; } 
public void testUpdateWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertNull ( client . get ( " test1 " , ) ) ; tclient . replace ( " test1 " , 5 , " test1value " , ) ; tassertNull ( client . get ( " test1 " , ) ) ; } 
public void testGetBulkVarargWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " , ) ; tclient . set ( " test2 " , 5 , " val2 " , ) ; tMap < String , String > vals = client . getBulk ( , " test1 " , " test2 " , " test3 " ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public String decode ( CachedData d ) { tassert d . getFlags ( ) = = flags ; treturn new String ( d . getData ( ) ) ; } 
public CachedData encode ( String o ) { treturn new CachedData ( flags , o . getBytes ( ) ) ; } 
public void testBadFlags ( ) throws Exception { tCachedData cd = tc . encode ( 9284 ) ; tassertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; } 
public void testBadFlags ( ) throws Exception { tCachedData cd = tc . encode ( 9284l ) ; tassertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; } 
public void testBooleanOverflow ( ) { ttry { tboolean b = TranscoderUtils . decodeBoolean ( oversizeBytes ) ; 
public void testByteOverflow ( ) { ttry { tbyte b = TranscoderUtils . decodeByte ( oversizeBytes ) ; 
public void testIntOverflow ( ) { ttry { tint b = TranscoderUtils . decodeInt ( oversizeBytes ) ; 
public void testLongOverflow ( ) { ttry { tlong b = TranscoderUtils . decodeLong ( oversizeBytes ) ; 
public static void main ( String args [ ] ) throws Exception { tMemcachedClient c = new MemcachedClient ( tAddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; twhile ( true ) { tfor ( int i = 0 ; i < 1000 ; i + + ) { 
public T cas ( final String key , final T initial , int initialExp , tfinal CASMutation < T > m ) throws Exception { tT rv = initial ; tboolean done = false ; tfor ( int i = 0 ; ! done & & i < max ; i + + ) { tCASValue < T > casval = client . gets ( key , transcoder ) ; tT current = null ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 8 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; ttransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { tgetLogger ( ) . warn ( " Error on key %s: %s (%d) " , tkeys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { tfinal int flags = decodeInt ( pl , 8 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , t0 , pl . length - EXTRA_HDR_LEN ) ; tCallback cb = ( Callback ) getCallback ( ) ; tcb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } tresetInput ( ) ; } 
public void initialize ( ) { tprepareBuffer ( key , data , cas , flags , exp ) ; } 
public String decode ( CachedData d ) { tassert d . getFlags ( ) = = flags : " expected " + flags + " got " + d . getFlags ( ) ; treturn new String ( d . getData ( ) ) ; } 
tprotected void tearDown ( ) throws Exception { tif ( client ! = null ) { tclient . shutdown ( ) ; } tsuper . tearDown ( ) ; } 
private void assertWorking ( ) throws Exception { tMap < SocketAddress , String > versions = client . getVersions ( ) ; tassertEquals ( " /127.0.0.1:11211 " , tversions . keySet ( ) . iterator ( ) . next ( ) . toString ( ) ) ; 
private void assertArgRequired ( IllegalArgumentException e ) { tassertEquals ( " You must have at least one server to connect to " , te . getMessage ( ) ) ; 
public void testVarargConstructor ( ) throws Exception { tclient = new MemcachedClient ( tnew InetSocketAddress ( InetAddress . getByName ( " 127.0.0.1 " ) , 11211 ) ) ; tassertWorking ( ) ; } 
public void testEmptyVarargConstructor ( ) throws Exception { ttry { tclient = new MemcachedClient ( ) ; 
public void testNulListConstructor ( ) throws Exception { ttry { tList < InetSocketAddress > l = null ; 
public void testEmptyListConstructor ( ) throws Exception { ttry { tclient = new MemcachedClient ( 
public void testNullFactoryConstructor ( ) throws Exception { ttry { tclient = new MemcachedClient ( null , 
public void testConnFactoryWithoutOpFactory ( ) throws Exception { ttry { tclient = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public void testConnFactoryWithoutConns ( ) throws Exception { ttry { tclient = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public MemcachedConnection createConnection ( tList < InetSocketAddress > addrs ) throws IOException { treturn null ; } 
public void testInvalidKey4 ( ) throws Exception { ttry { tObject val = client . get ( " Key r " ) ; 
public void testInvalidKey5 ( ) throws Exception { ttry { tObject val = client . get ( " Key 0 " ) ; 
private long mutate ( Mutator m , String key , int by , long def , int exp ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
public void receivedStatus ( OperationStatus s ) { } 
public void initialize ( ) { tprepareBuffer ( key , cas , EMPTY_BYTES , when ) ; } 
public void initialize ( ) { tprepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; } 
public void initialize ( ) { tprepareBuffer ( key , 0 , EMPTY_BYTES ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( byte [ ] b : bkeys . values ( ) ) { tsize + = b . length ; } } 
public void initialize ( ) { } 
public void initialize ( ) { tprepareBuffer ( " " , 0 , EMPTY_BYTES ) ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tprotected void prepareBuffer ( String key , long cas , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tfinal byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tint bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
public void initialize ( ) { tprepareBuffer ( key , cas , data , flags , exp ) ; } 
public void testDeleteFuture ( ) throws Exception { tString key = " deleteFuture " ; tassertNull ( client . get ( key ) ) ; tclient . set ( key , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( key ) ) ; tFuture < Boolean > f = client . delete ( key ) ; tassertNull ( client . get ( key ) ) ; tassertTrue ( " Deletion didn't return true " , f . get ( ) ) ; tassertFalse ( " Second deletion returned true " , tclient . delete ( key ) . get ( ) ) ; 
public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncCAS ( key , casId , value , tc ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < T > rv = new OperationFuture < T > ( latch , globalOperationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tc . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncGets ( key , tc ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
public < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncGet ( key , tc ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncGetBulk ( keys , tc ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
private long mutate ( Mutator m , String key , int by , long def , int exp ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) throws OperationTimeoutException { tlong rv = mutate ( , key , by , def , exp ) ; } 
public long incr ( String key , int by , int def ) throws OperationTimeoutException { treturn mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public long decr ( String key , int by , long def ) throws OperationTimeoutException { treturn mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , globalOperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult , globalOperationTimeout ) { @Override 
public T get ( ) throws InterruptedException , ExecutionException { tlatch . await ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; tassert isDone ( ) : " Latch released, but operation wasn't done. " ; tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
private void validateKey ( String key ) { tbyte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tif ( keyBytes . length > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) { 
private long mutate ( Mutator m , String key , int by , long def , int exp ) throws OperationTimeoutException { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
public long incr ( String key , int by ) throws OperationTimeoutException { treturn mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public long decr ( String key , int by ) throws OperationTimeoutException { treturn mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException { treturn cas ( key , casId , value , transcoder ) ; } 
public CASValue < Object > gets ( String key ) throws OperationTimeoutException { treturn gets ( key , transcoder ) ; } 
public Object get ( String key ) throws OperationTimeoutException { treturn get ( key , transcoder ) ; } 
public Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException { treturn getBulk ( keys , transcoder ) ; } 
public < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException { treturn getBulk ( Arrays . asList ( keys ) , tc ) ; } 
public Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException { treturn getBulk ( Arrays . asList ( keys ) , transcoder ) ; } 
public < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncCAS ( key , casId , value , tc ) . get ( globalOperationTimeout , 
public CASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException { treturn cas ( key , casId , value , transcoder ) ; } 
public < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) { treturn asyncStore ( StoreType . replace , key , exp , o , tc ) ; } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < T > rv = new OperationFuture < T > ( latch , tglobalOperationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tc . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , ttc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , ttc . decode ( new CachedData ( flags , data ) ) ) ; 
public < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException { ttry { treturn asyncGets ( key , tc ) . get ( 
public < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException { ttry { treturn asyncGet ( key , tc ) . get ( 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , T > m = new ConcurrentHashMap < String , T > ( ) ; } 
public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; } 
public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException { ttry { treturn asyncGetBulk ( keys , tc ) . get ( 
public Map < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException { treturn getBulk ( keys , transcoder ) ; } 
public < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException { treturn getBulk ( Arrays . asList ( keys ) , tc ) ; } 
public Map < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException { treturn getBulk ( Arrays . asList ( keys ) , transcoder ) ; } 
private long mutate ( Mutator m , String key , int by , long def , int exp ) tthrows OperationTimeoutException { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) throws OperationTimeoutException { tlong rv = mutate ( , key , by , def , exp ) ; } 
public long incr ( String key , int by , int def ) tthrows OperationTimeoutException { treturn mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public long decr ( String key , int by , long def ) tthrows OperationTimeoutException { treturn mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , tglobalOperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult , tglobalOperationTimeout ) { 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { } 
public void testGracefulShutdownTooSlow ( ) throws Exception { tfor ( int i = 0 ; i < 10000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertFalse ( " Weird, shut down too fast " , tclient . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; ttry { tMap < SocketAddress , String > m = client . getVersions ( ) ; tfail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { tassertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tlong getOperationTimeout ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tlong getOperationTimeout ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tlong getOperationTimeout ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tlong getOperationTimeout ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tlong getOperationTimeout ( ) ; } 
public < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException { ttry { treturn asyncCAS ( key , casId , value , tc ) . get ( operationTimeout , 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < T > rv = new OperationFuture < T > ( latch , toperationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tc . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , ttc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
private long mutate ( Mutator m , String key , int by , long def , int exp ) tthrows OperationTimeoutException { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) throws OperationTimeoutException { tlong rv = mutate ( , key , by , def , exp ) ; } 
public Future < Boolean > delete ( String key , int when ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , when , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult , toperationTimeout ) { 
public MemcachedConnection createConnection ( tList < InetSocketAddress > addrs ) throws IOException { tMemcachedConnection rv = super . createConnection ( addrs ) ; trv . setGetOptimization ( false ) ; treturn rv ; } 
public void testNegativeTimeout ( ) throws Exception { ttry { tclient = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public void testZeroTimeout ( ) throws Exception { ttry { tclient = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
tprotected void initClient ( ) throws Exception { tclient = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override 
private void tryTimeout ( String name , Runnable r ) { ttry { tr . run ( ) ; 
public void testCasTimeout ( ) { ttryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { tclient . cas ( " k " , 1 , " blah " ) ; 
ttryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { tclient . cas ( " k " , 1 , " blah " ) ; } } ) ; 
public void testGetsTimeout ( ) { ttryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { tclient . gets ( " k " ) ; 
ttryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { tclient . gets ( " k " ) ; } } ) ; 
public void testGetTimeout ( ) { ttryTimeout ( " get " , new Runnable ( ) { public void run ( ) { tclient . get ( " k " ) ; 
ttryTimeout ( " get " , new Runnable ( ) { public void run ( ) { tclient . get ( " k " ) ; } } ) ; 
public void testGetBulkTimeout ( ) { ttryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { tclient . getBulk ( " k " , " k2 " ) ; 
ttryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { tclient . getBulk ( " k " , " k2 " ) ; } } ) ; 
public void testIncrTimeout ( ) { ttryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { tclient . incr ( " k " , 1 ) ; 
ttryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { tclient . incr ( " k " , 1 ) ; } } ) ; 
public void testIncrWithDefTimeout ( ) { ttryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { tclient . incr ( " k " , 1 , 5 ) ; 
ttryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { tclient . incr ( " k " , 1 , 5 ) ; } } ) ; 
private < T > Future < Boolean > asyncCat ( tConcatenationType catType , long cas , String key , tT value , Transcoder < T > tc ) { tCachedData co = tc . encode ( value ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tOperation op = opFact . cat ( catType , cas , key , co . getData ( ) , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) ) ; } 
public Future < Boolean > append ( long cas , String key , Object val ) { treturn append ( cas , key , val , transcoder ) ; } 
public < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) { treturn asyncCat ( ConcatenationType . append , cas , key , val , tc ) ; } 
public Future < Boolean > prepend ( long cas , String key , Object val ) { treturn prepend ( cas , key , val , transcoder ) ; } 
public < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) { treturn asyncCat ( ConcatenationType . prepend , cas , key , val , tc ) ; } 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , int when , tOperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
public ConcatenationOperation cat ( ConcatenationType catType , tlong casId , tString key , byte [ ] data , OperationCallback cb ) { treturn new ConcatenationOperationImpl ( catType , key , data , cb ) ; } 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( bb , type , key , flags , exp , data . length ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( CRLF ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public StoreOperation store ( StoreType storeType , String key , int flags , tint exp , byte [ ] data , OperationCallback cb ) { treturn new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; } 
public ConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) { treturn new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; } 
private static int cmdMap ( ConcatenationType ) { tint rv = - 1 ; tswitch ( ) { tcase append : rv = APPEND ; break ; tcase prepend : rv = PREPEND ; break ; } } 
public void initialize ( ) { tprepareBuffer ( key , cas , data ) ; } 
public void testAppend ( ) throws Exception { } 
public void testPrepend ( ) throws Exception { } 
public void testCASAppendFail ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tCASValue < Object > casv = client . gets ( key ) ; tassertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; tassertEquals ( " test " , client . get ( key ) ) ; } 
public void testCASAppendSuccess ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tCASValue < Object > casv = client . gets ( key ) ; tassertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; tassertEquals ( " testes " , client . get ( key ) ) ; } 
public void testCASPrependFail ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tCASValue < Object > casv = client . gets ( key ) ; tassertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; tassertEquals ( " test " , client . get ( key ) ) ; } 
public void testCASPrependSuccess ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tCASValue < Object > casv = client . gets ( key ) ; tassertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; tassertEquals ( " estest " , client . get ( key ) ) ; } 
public void testAppend ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tassertTrue ( client . append ( 0 , key , " es " ) . get ( ) ) ; tassertEquals ( " testes " , client . get ( key ) ) ; } 
public void testPrepend ( ) throws Exception { tfinal String key = " prepend.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tassertTrue ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; tassertEquals ( " estest " , client . get ( key ) ) ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tboolean isDaemon ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tboolean isDaemon ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tboolean isDaemon ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tboolean isDaemon ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tboolean isDaemon ( ) ; } 
tlong getOperationTimeout ( ) ; tboolean isDaemon ( ) ; } 
public long hash ( final String k ) { tlong rv = 0 ; tswitch ( this ) { tcase NATIVE_HASH : trv = k . hashCode ( ) ; tbreak ; tcase CRC32_HASH : } 
public static byte [ ] computeMd5 ( String k ) { tMessageDigest md5 ; ttry { tmd5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new RuntimeException ( " MD5 not supported " , e ) ; } tmd5 . reset ( ) ; tmd5 . update ( KeyUtil . getKeyBytes ( k ) ) ; treturn md5 . digest ( ) ; } 
public void testAvailableServers ( ) { tclient . asyncGet ( " x " ) ; tassertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; } 
public void testUnavailableServers ( ) { tclient . asyncGet ( " x " ) ; tassertEquals ( new ArrayList < String > ( tCollections . singleton ( " /127.0.0.1:11213 " ) ) , 
tprotected Collection < String > stringify ( Collection < ? > c ) { tCollection < String > rv = new ArrayList < String > ( ) ; tfor ( Object o : c ) { trv . add ( String . valueOf ( o ) ) ; } treturn rv ; } 
public void testAvailableServers ( ) { tclient . getVersions ( ) ; tassertEquals ( new ArrayList < String > ( tCollections . singleton ( getExpectedVersionSource ( ) ) ) , 
public void testUnavailableServers ( ) { tclient . getVersions ( ) ; tassertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; } 
tprotected byte [ ] serialize ( Object o ) { tassert o ! = null ; tbyte [ ] rv = null ; ttry { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tObjectOutputStream os = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tthrow new IllegalArgumentException ( " Non-serializable object " , e ) ; } treturn rv ; } 
tprotected Object deserialize ( byte [ ] in ) { tObject rv = null ; tassert in ! = null ; ttry { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tObjectInputStream is = new ObjectInputStream ( bis ) ; trv = is . readObject ( ) ; tis . close ( ) ; tbis . close ( ) ; } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , tin . length , e ) ; } catch ( ClassNotFoundException e ) { tgetLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , tin . length , e ) ; } treturn rv ; } 
tprotected byte [ ] compress ( byte [ ] in ) { tassert in ! = null ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gz = null ; ttry { tgz = new GZIPOutputStream ( bos ) ; tgz . write ( in ) ; } catch ( IOException e ) { tthrow new RuntimeException ( " IO exception compressing data " , e ) ; } finally { tCloseUtil . close ( gz ) ; tCloseUtil . close ( bos ) ; } tbyte [ ] rv = bos . toByteArray ( ) ; tgetLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; treturn rv ; } 
tprotected byte [ ] decompress ( byte [ ] in ) { tassert in ! = null ; tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPInputStream gis ; ttry { tgis = new GZIPInputStream ( bis ) ; tbyte [ ] buf = new byte [ 8192 ] ; tint r = - 1 ; twhile ( ( r = gis . read ( buf ) ) > 0 ) { tbos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Failed to decompress data " , e ) ; tbos = null ; } treturn bos = = null ? null : bos . toByteArray ( ) ; } 
tprotected String decodeString ( byte [ ] data ) { tString rv = null ; ttry { tif ( data ! = null ) { trv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { tthrow new RuntimeException ( e ) ; } treturn rv ; } 
tprotected byte [ ] encodeString ( String in ) { tbyte [ ] rv = null ; ttry { trv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { tthrow new RuntimeException ( e ) ; } treturn rv ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { tb = TranscoderUtils . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = TranscoderUtils . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = TranscoderUtils . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; tflags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { tflags | = SPECIAL_STRINGBUFFER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { tflags | = SPECIAL_STRINGBUILDER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { tb = TranscoderUtils . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = TranscoderUtils . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Short ) { tb = TranscoderUtils . encodeInt ( ( Short ) o ) ; tflags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { tb = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = TranscoderUtils . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = TranscoderUtils . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = TranscoderUtils . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
public void testSetTranscoder ( ) { tTranscoder < Object > tc = client . getTranscoder ( ) ; tassertTrue ( tc instanceof BaseSerializingTranscoder ) ; tTranscoder < Object > tmptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { tthrow new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { tthrow new RuntimeException ( " Not implemented. " ) ; } } ; tclient . setTranscoder ( tmptc ) ; tassertSame ( tmptc , client . getTranscoder ( ) ) ; } 
public void testUnencodeable ( ) throws Exception { ttry { tCachedData cd = tc . encode ( new Object ( ) ) ; 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( tSerializingTranscoder . COMPRESSED , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tSystem . out . println ( " got " + tc . decode ( cd ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new WhalinTranscoder ( ) ; } 
public void testStrings ( ) throws Exception { tString s1 = " This is a simple test string. " ; tCachedData cd = tc . encode ( s1 ) ; } 
public void testUTF8String ( ) throws Exception { tString s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; tCachedData cd = tc . encode ( s1 ) ; } 
public void testCompressedStringNotSmaller ( ) throws Exception { tString s1 = " This is a test simple string that will not be compressed. " ; } 
public void testCompressedString ( ) throws Exception { } 
public void testObject ( ) throws Exception { tCalendar c = Calendar . getInstance ( ) ; tCachedData cd = tc . encode ( c ) ; tassertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; tassertEquals ( c , tc . decode ( cd ) ) ; } 
public void testCompressedObject ( ) throws Exception { ttc . setCompressionThreshold ( 8 ) ; tCalendar c = Calendar . getInstance ( ) ; tCachedData cd = tc . encode ( c ) ; tassertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; tassertEquals ( c , tc . decode ( cd ) ) ; } 
public void testShort ( ) throws Exception { tassertEquals ( ( short ) 923 , tc . decode ( tc . encode ( ( short ) 923 ) ) ) ; } 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tTranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testCharacter ( ) throws Exception { tassertEquals ( 'c' , tc . decode ( tc . encode ( 'c' ) ) ) ; } 
public void testStringBuilder ( ) throws Exception { tStringBuilder sb = new StringBuilder ( " test " ) ; tStringBuilder sb2 = ( StringBuilder ) tc . decode ( tc . encode ( sb ) ) ; tassertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; } 
public void testStringBuffer ( ) throws Exception { tStringBuffer sb = new StringBuffer ( " test " ) ; tStringBuffer sb2 = ( StringBuffer ) tc . decode ( tc . encode ( sb ) ) ; tassertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; } 
tprotected byte [ ] serialize ( Object o ) { tif ( o = = null ) { tthrow new NullPointerException ( " Can't serialize null " ) ; } tbyte [ ] rv = null ; ttry { tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tObjectOutputStream os = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tthrow new IllegalArgumentException ( " Non-serializable object " , e ) ; } treturn rv ; } 
tprotected Object deserialize ( byte [ ] in ) { tObject rv = null ; ttry { tif ( in ! = null ) { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tObjectInputStream is = new ObjectInputStream ( bis ) ; trv = is . readObject ( ) ; tis . close ( ) ; tbis . close ( ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , tin . length , e ) ; } catch ( ClassNotFoundException e ) { tgetLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , tin . length , e ) ; } treturn rv ; } 
tprotected byte [ ] compress ( byte [ ] in ) { tif ( in = = null ) { tthrow new NullPointerException ( " Can't compress null " ) ; } tByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; tGZIPOutputStream gz = null ; ttry { tgz = new GZIPOutputStream ( bos ) ; tgz . write ( in ) ; } catch ( IOException e ) { tthrow new RuntimeException ( " IO exception compressing data " , e ) ; } finally { tCloseUtil . close ( gz ) ; tCloseUtil . close ( bos ) ; } tbyte [ ] rv = bos . toByteArray ( ) ; tgetLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; treturn rv ; } 
tprotected byte [ ] decompress ( byte [ ] in ) { tByteArrayOutputStream bos = null ; tif ( in ! = null ) { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tbos = new ByteArrayOutputStream ( ) ; tGZIPInputStream gis ; ttry { tgis = new GZIPInputStream ( bis ) ; tbyte [ ] buf = new byte [ 8192 ] ; tint r = - 1 ; twhile ( ( r = gis . read ( buf ) ) > 0 ) { tbos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Failed to decompress data " , e ) ; tbos = null ; } } treturn bos = = null ? null : bos . toByteArray ( ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tex = new Exposer ( ) ; } 
public void testValidCharacterSet ( ) { tex . setCharset ( " KOI8 " ) ; } 
public void testInvalidCharacterSet ( ) { ttry { tex . setCharset ( " Dustin's Kick Ass Character Set " ) ; 
public void testCompressNull ( ) { ttry { tex . compress ( null ) ; 
public void testDecodeStringNull ( ) { tassertNull ( ex . decodeString ( null ) ) ; } 
public void testDeserializeNull ( ) { tassertNull ( ex . deserialize ( null ) ) ; } 
public void testEncodeStringNull ( ) { ttry { tex . encodeString ( null ) ; 
public void testSerializeNull ( ) { ttry { tex . serialize ( null ) ; 
public void testDecompressNull ( ) { tassertNull ( ex . decompress ( null ) ) ; } 
public void testUndeserializable ( ) throws Exception { tbyte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , t116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; tassertNull ( ex . deserialize ( data ) ) ; } 
public void testDeserializable ( ) throws Exception { tbyte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; tassertEquals ( " hello " , ex . deserialize ( data ) ) ; } 
public void testBadCharsetDecode ( ) { tex . overrideCharsetSet ( " Some Crap " ) ; ttry { tex . encodeString ( " Woo! " ) ; 
public void testBadCharsetEncode ( ) { tex . overrideCharsetSet ( " Some Crap " ) ; ttry { tex . decodeString ( " Woo! " . getBytes ( ) ) ; 
public void overrideCharsetSet ( String to ) { tcharset = to ; } 
public byte [ ] compress ( byte [ ] in ) { treturn super . compress ( in ) ; } 
public String decodeString ( byte [ ] data ) { treturn super . decodeString ( data ) ; } 
public byte [ ] decompress ( byte [ ] in ) { treturn super . decompress ( in ) ; } 
public Object deserialize ( byte [ ] in ) { treturn super . deserialize ( in ) ; } 
public byte [ ] encodeString ( String in ) { treturn super . encodeString ( in ) ; } 
public byte [ ] serialize ( Object o ) { treturn super . serialize ( o ) ; } 
public CachedData encode ( java . lang . Integer l ) { treturn new CachedData ( flags , tu . encodeInt ( l ) ) ; } 
public CachedData encode ( java . lang . Long l ) { treturn new CachedData ( flags , tu . encodeLong ( l ) ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = tu . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
public byte [ ] encodeNum ( long l , int maxBytes ) { tbyte [ ] rv = new byte [ maxBytes ] ; tfor ( int i = 0 ; i < rv . length ; i + + ) { tint pos = rv . length - i - 1 ; trv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } tif ( packZeros ) { tint firstNon0 = 0 ; tfor ( ; firstNon0 < rv . length & & rv [ firstNon0 ] = = 0 ; firstNon0 + + ) { } 
public byte [ ] encodeLong ( long l ) { treturn encodeNum ( l , 8 ) ; } 
public long decodeLong ( byte [ ] b ) { tlong rv = 0 ; tfor ( byte i : b ) { trv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } treturn rv ; } 
public byte [ ] encodeInt ( int in ) { treturn encodeNum ( in , 4 ) ; } 
public int decodeInt ( byte [ ] in ) { tassert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; treturn ( int ) decodeLong ( in ) ; } 
public byte [ ] encodeByte ( byte in ) { treturn new byte [ ] { in } ; } 
public byte decodeByte ( byte [ ] in ) { tassert in . length < = 1 : " Too long for a byte " ; tbyte rv = 0 ; tif ( in . length = = 1 ) { trv = in [ 0 ] ; } treturn rv ; } 
public byte [ ] encodeBoolean ( boolean b ) { tbyte [ ] rv = new byte [ 1 ] ; trv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; treturn rv ; } 
public boolean decodeBoolean ( byte [ ] in ) { tassert in . length = = 1 : " Wrong length for a boolean " ; treturn in [ 0 ] = = '1' ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; tflags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { tflags | = SPECIAL_STRINGBUFFER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { tflags | = SPECIAL_STRINGBUILDER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Short ) { tb = tu . encodeInt ( ( Short ) o ) ; tflags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { tb = tu . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new SerializingTranscoder ( ) ; ttu = new TranscoderUtils ( true ) ; } 
private void assertLong ( long l ) { tbyte [ ] encoded = tu . encodeLong ( l ) ; tlong decoded = tu . decodeLong ( encoded ) ; tassertEquals ( l , decoded ) ; } 
private void assertInt ( int i ) { tbyte [ ] encoded = tu . encodeInt ( i ) ; tint decoded = tu . decodeInt ( encoded ) ; tassertEquals ( i , decoded ) ; } 
public void testBooleanEncoding ( ) throws Exception { tassertTrue ( tu . decodeBoolean ( tu . encodeBoolean ( true ) ) ) ; tassertFalse ( tu . decodeBoolean ( tu . encodeBoolean ( false ) ) ) ; } 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( tSerializingTranscoder . COMPRESSED , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tSystem . out . println ( " got " + tc . decode ( cd ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttu = new TranscoderUtils ( true ) ; } 
public void testBooleanOverflow ( ) { ttry { tboolean b = tu . decodeBoolean ( oversizeBytes ) ; 
public void testByteOverflow ( ) { ttry { tbyte b = tu . decodeByte ( oversizeBytes ) ; 
public void testIntOverflow ( ) { ttry { tint b = tu . decodeInt ( oversizeBytes ) ; 
public void testLongOverflow ( ) { ttry { tlong b = tu . decodeLong ( oversizeBytes ) ; 
public void testPackedLong ( ) { tassertEquals ( " [1] " , Arrays . toString ( tu . encodeLong ( 1 ) ) ) ; } 
public void testUnpackedLong ( ) { tassertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , tArrays . toString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ; 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new WhalinTranscoder ( ) ; ttu = new TranscoderUtils ( false ) ; } 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , ttu . encodeInt ( Integer . MAX_VALUE ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testAppendNoSuchKey ( ) throws Exception { tfinal String key = " append.missing " ; tassertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; tassertNull ( client . get ( key ) ) ; } 
public void testPrependNoSuchKey ( ) throws Exception { tfinal String key = " prepend.missing " ; tassertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; tassertNull ( client . get ( key ) ) ; } 
public void testDefaultConstructor ( ) { } 
public void testAsyncGetBulkVarargWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " , ) ; tclient . set ( " test2 " , 5 , " val2 " , ) ; tFuture < Map < String , String > > vals = client . asyncGetBulk ( , " test1 " , " test2 " , " test3 " ) ; tassertEquals ( 2 , vals . get ( ) . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( ) . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( ) . get ( " test2 " ) ) ; } 
public void xtestGracefulShutdownTooSlow ( ) throws Exception { tfor ( int i = 0 ; i < 10000 ; i + + ) { tclient . set ( " " + i , 10 , i ) ; } tassertFalse ( " Weird, shut down too fast " , tclient . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; ttry { tMap < SocketAddress , String > m = client . getVersions ( ) ; tfail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { tassertEquals ( " Shutting down " , e . getMessage ( ) ) ; } } 
tprotected void tearDown ( ) throws Exception { tif ( client ! = null ) { ttry { tclient . shutdown ( ) ; } catch ( NullPointerException e ) { } 
public void testAssertions ( ) { tboolean caught = false ; ttry { tassert false ; } catch ( AssertionError e ) { tcaught = true ; } tassertTrue ( " Assertions are not enabled! " , caught ) ; } 
tprotected void initClient ( ) throws Exception { tinitClient ( new BinaryConnectionFactory ( ) { @Override 
tprotected void initClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( ) { @Override 
public final void copyInputQueue ( ) { tCollection < Operation > tmp = new ArrayList < Operation > ( ) ; } 
public final void fillWriteBuffer ( boolean optimizeGets ) { tif ( toWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { tgetWbuf ( ) . clear ( ) ; 
tprotected void initClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( 5 , 1024 ) { @Override 
private void runOverflowTest ( byte b [ ] ) throws Exception { tCollection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; ttry { tfor ( int i = 0 ; i < 1000 ; i + + ) { tc . add ( client . set ( " k " + i , 0 , b ) ) ; } tfail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { } 
public void testOverflowingInputQueue ( ) throws Exception { trunOverflowTest ( new byte [ ] { 1 } ) ; } 
public void testOverflowingWriteQueue ( ) throws Exception { tbyte [ ] b = new byte [ 8192 ] ; tRandom r = new Random ( ) ; tr . nextBytes ( b ) ; trunOverflowTest ( b ) ; } 
public void testOverflowingReadQueue ( ) throws Exception { tbyte [ ] b = new byte [ 8192 ] ; tRandom r = new Random ( ) ; tr . nextBytes ( b ) ; tclient . set ( " x " , 0 , b ) ; tCollection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; ttry { tfor ( int i = 0 ; i < 1000 ; i + + ) { tc . add ( client . asyncGet ( " x " ) ) ; } tfail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { } 
public void run ( ) { twhile ( running ) { ttry { tconn . handleIO ( ) ; } catch ( IOException e ) { tlogRunException ( e ) ; } catch ( CancelledKeyException e ) { tlogRunException ( e ) ; } catch ( ClosedSelectorException e ) { tlogRunException ( e ) ; } catch ( IllegalStateException e ) { tlogRunException ( e ) ; } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { ttry { treturn get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
public Future < Boolean > delete ( String key , int hold ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , hold , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { treturn new BinaryMemcachedNodeImpl ( sa , c , bufSize , tcreateReadOperationQueue ( ) , 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tboolean isDaemon ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tboolean isDaemon ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tboolean isDaemon ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tboolean isDaemon ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tboolean isDaemon ( ) ; } 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { treturn new AsciiMemcachedNodeImpl ( sa , c , bufSize , tcreateReadOperationQueue ( ) , 
public BlockingQueue < Operation > createReadOperationQueue ( ) { treturn new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ; 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { treturn createOperationQueue ( ) ; } 
public void testQueueSizes ( ) { tConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; tassertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; tassertEquals ( 100 , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; tassertEquals ( 110 , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { treturn new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; } 
public void testCorrectTypes ( ) { tConnectionFactory factory = new KetamaConnectionFactory ( ) ; tNodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; tassertTrue ( locator instanceof KetamaNodeLocator ) ; tDefaultConnectionFactory dflt = ( DefaultConnectionFactory ) factory ; tassertEquals ( HashAlgorithm . KETAMA_HASH , dflt . getHashAlg ( ) ) ; } 
public void testABunchOfCancelledOperations ( ) throws Exception { tfinal String k = " bunchOCancel " ; tCollection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; tfor ( int i = 0 ; i < 1000 ; i + + ) { tfutures . add ( client . set ( k , 5 , " xval " ) ) ; tfutures . add ( client . asyncGet ( k ) ) ; } tFuture < Boolean > sf = client . set ( k , 5 , " myxval " ) ; tFuture < Object > gf = client . asyncGet ( k ) ; tfor ( Future < ? > f : futures ) { tf . cancel ( true ) ; } tassertTrue ( sf . get ( ) ) ; tassertEquals ( " myxval " , gf . get ( ) ) ; } 
private void runThisManyNodes ( final int totalNodes ) { tfinal String [ ] stringNodes = generateAddresses ( totalNodes ) ; tList < MemcachedNode > smaller = createNodes ( tAddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; tList < MemcachedNode > larger = createNodes ( tAddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; tassertTrue ( larger . containsAll ( smaller ) ) ; tMemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; tassertFalse ( smaller . contains ( oddManOut ) ) ; tKetamaNodeLocator lgLocator = new KetamaNodeLocator ( tlarger , HashAlgorithm . KETAMA_HASH ) ; tKetamaNodeLocator smLocator = new KetamaNodeLocator ( tsmaller , HashAlgorithm . KETAMA_HASH ) ; tSortedMap < Long , MemcachedNode > lgMap = lgLocator . ketamaNodes ; tSortedMap < Long , MemcachedNode > smMap = smLocator . ketamaNodes ; assertFalse(failed); 
private String [ ] generateAddresses ( final int maxSize ) { tfinal String [ ] results = new String [ 2 ] ; } 
private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { tList < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; tfor ( InetSocketAddress addr : addresses ) { tresults . add ( new MockMemcachedNode ( addr ) ) ; } treturn results ; } 
public int hashCode ( ) { treturn ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; } 
public Operation removeCurrentWriteOp ( ) { return null ; } public boolean hasReadOp ( ) { return false ; } 
public boolean hasReadOp ( ) { return false ; } public boolean hasWriteOp ( ) { return false ; } 
public boolean hasWriteOp ( ) { return false ; } public void addOp ( Operation op ) { 
public boolean isActive ( ) { return false ; } public void reconnecting ( ) { 
public int writeSome ( ) throws IOException { return 0 ; } public void fixupOps ( ) { 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , CachedData > m = new ConcurrentHashMap < String , CachedData > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , new CachedData ( flags , data ) ) ; } 
public Map < String , T > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( timeout , unit ) ) { tthrow new TimeoutException ( " Operation timed out. " ) ; } tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } tMap < String , T > m = new HashMap < String , T > ( ) ; tfor ( Map . Entry < String , CachedData > me : rvMap . entrySet ( ) ) { tT val = tc . decode ( me . getValue ( ) ) ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by , int def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public long incr ( String key , int by , long def ) tthrows OperationTimeoutException { treturn mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( tc , latch , operationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private CachedData val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CachedData ( flags , data ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CachedData ( flags , data ) ; } 
public boolean cancel ( boolean ign ) { treturn rv . cancel ( ign ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { treturn decode ( rv . get ( ) ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { treturn decode ( rv . get ( duration , units ) ) ; } 
private T decode ( CachedData d ) { treturn tc . decode ( d ) ; } 
public boolean isCancelled ( ) { treturn rv . isCancelled ( ) ; } 
private T decode ( CachedData d ) { treturn d = = null ? null : tc . decode ( d ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = tu . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , maxSize ) ; } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tclient . setTranscoder ( st ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { tassertEquals ( " Cannot cache data larger than 1MB " + " (you tried to cache a " + data . length + " byte object) " , te . getMessage ( ) ) ; } } 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tByteBuffer rbuf = qa . getRbuf ( ) ; tfinal SocketChannel channel = qa . getChannel ( ) ; tint read = channel . read ( rbuf ) ; tif ( read < 0 ) { getLogger().debug("Read %d bytes", read); 
public Future < Boolean > delete ( String key , int hold ) { treturn delete ( key ) ; } 
public Future < Boolean > delete ( String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
public DeleteOperation delete ( String key , OperationCallback cb ) { treturn new DeleteOperationImpl ( key , cb ) ; } 
public void initialize ( ) { tByteBuffer b = ByteBuffer . allocate ( tKeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( b , " delete " , key ) ; tb . flip ( ) ; tsetBuffer ( b ) ; } 
public DeleteOperation delete ( String key , tOperationCallback operationCallback ) { treturn new DeleteOperationImpl ( key , operationCallback ) ; } 
public void initialize ( ) { tprepareBuffer ( key , cas , EMPTY_BYTES ) ; } 
public StatsOperation stats ( String arg , tnet . spy . memcached . ops . StatsOperation . Callback cb ) { treturn new StatsOperationImpl ( arg , cb ) ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tprotected boolean opaqueIsValid ( ) { treturn responseOpaque = = STAT_VALUE_OPAQUE | | super . opaqueIsValid ( ) ; } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( keyLen > 0 ) { tfinal byte [ ] keyBytes = new byte [ keyLen ] ; tfinal byte [ ] data = new byte [ pl . length - keyLen ] ; tSystem . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; tSystem . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; tCallback cb = ( Callback ) getCallback ( ) ; tcb . gotStat ( new String ( keyBytes , " UTF-8 " ) , tnew String ( data , " UTF-8 " ) ) ; } else { tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; ttransitionState ( OperationState . COMPLETE ) ; } tresetInput ( ) ; } 
public void testGetStats ( ) throws Exception { tMap < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; tSystem . out . println ( " Stats: " + stats ) ; tassertEquals ( 1 , stats . size ( ) ) ; tMap < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; tassertTrue ( oneStat . containsKey ( " total_items " ) ) ; } 
tprotected boolean opaqueIsValid ( ) { treturn responseOpaque = = STAT_VALUE_OPAQUE | | responseOpaque = = 0 XXX: This is working around a server bug 
public void testChar ( ) throws Exception { tassertEquals ( 'c' , tc . decode ( tc . encode ( 'c' ) ) ) ; } 
tprotected void setTranscoder ( Transcoder < Object > ) throws Exception { tassert ! = null ; ttc = ; } 
private void assertLong ( long l ) { tCachedData encoded = tc . encode ( l ) ; tlong decoded = ( Long ) tc . decode ( encoded ) ; tassertEquals ( l , decoded ) ; } 
private void assertInt ( int i ) { tCachedData encoded = tc . encode ( i ) ; tint decoded = ( Integer ) tc . decode ( encoded ) ; tassertEquals ( i , decoded ) ; } 
public void testBooleanEncoding ( ) throws Exception { tassertTrue ( ( Boolean ) tc . decode ( tc . encode ( true ) ) ) ; tassertFalse ( ( Boolean ) tc . decode ( tc . encode ( false ) ) ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new SerializingTranscoder ( ) ; tsetTranscoder ( tc ) ; ttu = new TranscoderUtils ( true ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttc = new WhalinTranscoder ( ) ; tsetTranscoder ( tc ) ; ttu = new TranscoderUtils ( false ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; tflags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { tflags | = SPECIAL_STRINGBUFFER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { tflags | = SPECIAL_STRINGBUILDER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Short ) { tb = tu . encodeInt ( ( Short ) o ) ; tflags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { tb = this . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { tb = tu . encodeInt ( ( Character ) o ) ; tflags | = SPECIAL_CHARACTER ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
tprotected Character decodeCharacter ( byte [ ] b ) { treturn Character . valueOf ( ( char ) tu . decodeInt ( b ) ) ; } 
public byte [ ] encodeBoolean ( boolean b ) { tbyte [ ] rv = new byte [ 1 ] ; trv [ 0 ] = ( byte ) ( b ? 1 : 0 ) ; treturn rv ; } 
public boolean decodeBoolean ( byte [ ] in ) { tassert in . length = = 1 : " Wrong length for a boolean " ; treturn in [ 0 ] = = 1 ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { tb = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { tb = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { tb = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { tb = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { tb = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { tb = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof byte [ ] ) { tthrow new IllegalArgumentException ( " Cannot handle byte arrays. " ) ; } else if ( o instanceof Character ) { tb = encodeCharacter ( ( Character ) o ) ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b ) ; } 
private Short decodeShort ( byte [ ] data ) { treturn Short . valueOf ( ( short ) decodeInteger ( data ) . intValue ( ) ) ; } 
private Byte decodeByte ( byte [ ] in ) { tassert in . length = = 2 : " Wrong length for a byte " ; tbyte value = in [ 1 ] ; treturn Byte . valueOf ( value ) ; 
private Integer decodeInteger ( byte [ ] in ) { tassert in . length = = 5 : " Wrong length for an int " ; treturn Integer . valueOf ( ( int ) decodeLong ( in ) . longValue ( ) ) ; 
private Float decodeFloat ( byte [ ] in ) { tassert in . length = = 5 : " Wrong length for a float " ; tInteger l = decodeInteger ( in ) ; treturn Float . valueOf ( Float . intBitsToFloat ( l . intValue ( ) ) ) ; } 
private Double decodeDouble ( byte [ ] in ) { tassert in . length = = 9 : " Wrong length for a double " ; tLong l = decodeLong ( in ) ; treturn Double . valueOf ( Double . longBitsToDouble ( l . longValue ( ) ) ) ; } 
private Boolean decodeBoolean ( byte [ ] in ) { tassert in . length = = 2 : " Wrong length for a boolean " ; treturn Boolean . valueOf ( in [ 1 ] = = 1 ) ; } 
private Long decodeLong ( byte [ ] in ) { tlong rv = 0 L ; tfor ( int idx = 1 ; idx < in . length ; idx + + ) { tbyte i = in [ idx ] ; trv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } treturn Long . valueOf ( rv ) ; } 
private Character decodeCharacter ( byte [ ] b ) { treturn Character . valueOf ( ( char ) decodeInteger ( b ) . intValue ( ) ) ; } 
private String decodeW1String ( byte [ ] b ) { ttry { treturn new String ( b , 1 , b . length - 1 , charset ) ; 
private byte [ ] encodeByte ( Byte value ) { tbyte [ ] b = new byte [ 2 ] ; tb [ 0 ] = SPECIAL_BYTE ; tb [ 1 ] = value . byteValue ( ) ; treturn b ; } 
private byte [ ] encodeBoolean ( Boolean value ) { tbyte [ ] b = new byte [ 2 ] ; tb [ 0 ] = SPECIAL_BOOLEAN ; tb [ 1 ] = ( byte ) ( value . booleanValue ( ) ? 1 : 0 ) ; treturn b ; } 
private byte [ ] encodeInteger ( Integer value ) { tbyte [ ] b = encodeNum ( value , 4 ) ; tb [ 0 ] = SPECIAL_INTEGER ; treturn b ; } 
private byte [ ] encodeLong ( Long value , int type ) { tbyte [ ] b = encodeNum ( value , 8 ) ; tb [ 0 ] = ( byte ) type ; treturn b ; } 
private byte [ ] encodeLong ( Long value ) { treturn encodeLong ( value , SPECIAL_LONG ) ; } 
private byte [ ] encodeShort ( Short value ) { tbyte [ ] b = encodeInteger ( ( int ) value . shortValue ( ) ) ; tb [ 0 ] = SPECIAL_SHORT ; treturn b ; } 
private byte [ ] encodeFloat ( Float value ) { tbyte [ ] b = encodeInteger ( Float . floatToIntBits ( value ) ) ; tb [ 0 ] = SPECIAL_FLOAT ; treturn b ; } 
private byte [ ] encodeDouble ( Double value ) { tbyte [ ] b = encodeLong ( Double . doubleToLongBits ( value ) ) ; tb [ 0 ] = SPECIAL_DOUBLE ; treturn b ; } 
private byte [ ] encodeCharacter ( Character value ) { tbyte [ ] result = encodeInteger ( ( int ) value . charValue ( ) ) ; tresult [ 0 ] = SPECIAL_CHARACTER ; treturn result ; } 
private byte [ ] encodeStringBuffer ( StringBuffer value ) { tbyte [ ] b = encodeW1String ( value . toString ( ) ) ; tb [ 0 ] = SPECIAL_STRINGBUFFER ; treturn b ; } 
private byte [ ] encodeStringbuilder ( StringBuilder value ) { tbyte [ ] b = encodeW1String ( value . toString ( ) ) ; tb [ 0 ] = SPECIAL_STRINGBUILDER ; treturn b ; } 
private byte [ ] encodeW1String ( String value ) { tbyte [ ] svalue = null ; ttry { tsvalue = value . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { tthrow new RuntimeException ( e ) ; } tbyte [ ] result = new byte [ svalue . length + 1 ] ; tSystem . arraycopy ( svalue , 0 , result , 1 , svalue . length ) ; tresult [ 0 ] = SPECIAL_STRING ; treturn result ; } 
private byte [ ] encodeNum ( long l , int maxBytes ) { tbyte [ ] rv = new byte [ maxBytes + 1 ] ; tfor ( int i = 0 ; i < rv . length - 1 ; i + + ) { tint pos = rv . length - i - 1 ; trv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } treturn rv ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tsetTranscoder ( new WhalinV1Transcoder ( ) ) ; } 
public void testByteArray ( ) throws Exception { tbyte [ ] a = { 'a' , 'b' , 'c' } ; ttry { tCachedData cd = getTranscoder ( ) . encode ( a ) ; 
public static void main ( String [ ] args ) throws Exception { } 
public void testCAS ( ) throws Exception { tfinal String key = " castestkey " ; } 
public void testLong ( ) throws Exception { tassertEquals ( 923L , tc . decode ( tc . encode ( 923L ) ) ) ; } 
public void testLongEncoding ( ) throws Exception { tassertLong ( Long . MIN_VALUE ) ; tassertLong ( 1 ) ; tassertLong ( 23852 ) ; tassertLong ( 0 L ) ; tassertLong ( - 1 ) ; tassertLong ( - 23835 ) ; tassertLong ( Long . MAX_VALUE ) ; } 
public void testBadFlags ( ) throws Exception { tCachedData cd = tc . encode ( 9284L ) ; tassertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; } 
public void testStrings ( ) throws Exception { tString s1 = " This is a simple test string. " ; tCachedData cd = tc . encode ( s1 ) ; tassertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; tassertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testUTF8String ( ) throws Exception { tString s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; tCachedData cd = tc . encode ( s1 ) ; tassertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; tassertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testToString ( ) throws Exception { tString exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; tCachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) ) ; tassertEquals ( exp , String . valueOf ( cd ) ) ; } 
private Future < Long > asyncMutate ( Mutator m , String key , int by , long def , tint exp ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Long > rv = new OperationFuture < Long > ( tlatch , operationTimeout ) ; tOperation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; trv . setOperation ( op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus s ) { trv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; } 
public Future < Long > asyncIncr ( String key , int by ) { treturn asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public Future < Long > asyncDecr ( String key , int by ) { treturn asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public void testAsyncIncrement ( ) throws Exception { tString k = " async-incr " ; tclient . set ( k , 0 , " 5 " ) ; tFuture < Long > f = client . asyncIncr ( k , 1 ) ; tassertEquals ( 6 , ( long ) f . get ( ) ) ; } 
public void testAsyncIncrementNonExistent ( ) throws Exception { tString k = " async-incr-non-existent " ; tFuture < Long > f = client . asyncIncr ( k , 1 ) ; tassertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrement ( ) throws Exception { tString k = " async-decr " ; tclient . set ( k , 0 , " 5 " ) ; tFuture < Long > f = client . asyncDecr ( k , 1 ) ; tassertEquals ( 4 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrementNonExistent ( ) throws Exception { tString k = " async-decr-non-existent " ; tFuture < Long > f = client . asyncDecr ( k , 1 ) ; tassertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public void testGetStatsSlabs ( ) throws Exception { tMap < SocketAddress , Map < String , String > > stats = client . getStats ( " slabs " ) ; tSystem . out . println ( " Stats: " + stats ) ; tassertEquals ( 1 , stats . size ( ) ) ; tMap < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; tassertTrue ( oneStat . containsKey ( " 1:chunk_size " ) ) ; } 
public void testGetStatsSlabs ( ) throws Exception { } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) throws OperationTimeoutException { tlong rv = mutate ( , key , by , def , exp ) ; } 
public long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; } 
public long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; } 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
long decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) tthrows OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public void testMutateWithDefaultAndExp ( ) throws Exception { tassertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; tassertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; tassertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; tassertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; tThread . sleep ( 2000 ) ; tassertNull ( client . get ( " mtest " ) ) ; } 
public void receivedStatus ( OperationStatus status ) { tif ( ! status . isSuccess ( ) ) { tgetLogger ( ) . warn ( " Unsuccessful stat fetch: t%s " , 
public long incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException { treturn mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; } 
public long decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException { treturn mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; } 
public void addOp ( Operation op ) { tthrow new UnsupportedOperationException ( ) ; } 
public void connected ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void copyInputQueue ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( boolean optimizeGets ) { tthrow new UnsupportedOperationException ( ) ; } 
public void fixupOps ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public boolean hasReadOp ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public boolean hasWriteOp ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public boolean isActive ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void reconnecting ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { tthrow new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentReadOp ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentWriteOp ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void setupResend ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void transitionWriteItem ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public int writeSome ( ) throws IOException { tthrow new UnsupportedOperationException ( ) ; } 
tMemcachedNode getPrimary ( String k ) ; tNodeLocator getReadonlyCopy ( ) ; } 
tIterator < MemcachedNode > getSequence ( String k ) ; tNodeLocator getReadonlyCopy ( ) ; } 
tCollection < MemcachedNode > getAll ( ) ; tNodeLocator getReadonlyCopy ( ) ; } 
public final void testCloningGetPrimary ( ) { tsetupNodes ( 5 ) ; tassertTrue ( locator . getReadonlyCopy ( ) . getPrimary ( " hi " ) tinstanceof MemcachedNodeROImpl ) ; 
public final void testCloningGetAll ( ) { tsetupNodes ( 5 ) ; tassertTrue ( locator . getReadonlyCopy ( ) . getAll ( ) . iterator ( ) . next ( ) tinstanceof MemcachedNodeROImpl ) ; 
public final void testCloningGetSequence ( ) { tsetupNodes ( 5 ) ; tassertTrue ( locator . getReadonlyCopy ( ) . getSequence ( " hi " ) . next ( ) tinstanceof MemcachedNodeROImpl ) ; 
tprotected final void assertSequence ( String k , int . . . seq ) { trunSequenceAssertion ( locator , k , seq ) ; trunSequenceAssertion ( locator . getReadonlyCopy ( ) , k , seq ) ; } 
public void testPrimaryClone ( ) throws Exception { tsetupNodes ( 4 ) ; tassertEquals ( nodes [ 3 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . toString ( ) ) ; tassertEquals ( nodes [ 0 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " x " ) . toString ( ) ) ; tassertEquals ( nodes [ 1 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " y " ) . toString ( ) ) ; 
public void testAllClone ( ) throws Exception { tsetupNodes ( 4 ) ; tCollection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; tassertEquals ( 4 , all . size ( ) ) ; } 
public void testAllClone ( ) throws Exception { tsetupNodes ( 4 ) ; tCollection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; tassertEquals ( 4 , all . size ( ) ) ; } 
public void testLookupsClone ( ) { tsetupNodes ( 4 ) ; tassertSame ( nodes [ 0 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . toString ( ) ) ; tassertSame ( nodes [ 2 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " noelani " ) . toString ( ) ) ; tassertSame ( nodes [ 0 ] . toString ( ) , tlocator . getReadonlyCopy ( ) . getPrimary ( " some other key " ) . toString ( ) ) ; 
public void testArraymodNodeLocatorAccessor ( ) throws Exception { tclient = new MemcachedClient ( AddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; tassertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; tassertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) tinstanceof MemcachedNodeROImpl ) ; 
public void testKetamaNodeLocatorAccessor ( ) throws Exception { tclient = new MemcachedClient ( new KetamaConnectionFactory ( ) , tAddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; tassertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; tassertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) tinstanceof MemcachedNodeROImpl ) ; 
private void fillArgs ( Class < ? > [ ] parameterTypes , Object [ ] args ) { tint i = 0 ; tfor ( Class < ? > c : parameterTypes ) { tif ( c = = Boolean . TYPE ) { 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . noop ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here 
public < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) { ttry { treturn asyncCAS ( key , casId , value , tc ) . get ( operationTimeout , 
public < T > CASValue < T > gets ( String key , Transcoder < T > tc ) { ttry { treturn asyncGets ( key , tc ) . get ( 
public < T > T get ( String key , Transcoder < T > tc ) { ttry { treturn asyncGet ( key , tc ) . get ( 
public < T > Map < String , T > getBulk ( Collection < String > keys , tTranscoder < T > tc ) { ttry { treturn asyncGetBulk ( keys , tc ) . get ( 
private long mutate ( Mutator m , String key , int by , long def , int exp ) { tfinal AtomicLong rv = new AtomicLong ( ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; taddOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { } 
public long incr ( String key , int by , long def , int exp ) { treturn mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; } 
public long decr ( String key , int by , long def , int exp ) { treturn mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; } 
private long mutateWithDefault ( Mutator , String key , tint by , long def , int exp ) { tlong rv = mutate ( , key , by , def , exp ) ; } 
public long incr ( String key , int by , long def ) { treturn mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) { return asyncCAS ( key , casId , 0 , value , tc ) ; } 
public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) { return cas ( key , casId , 0 , value , tc ) ; } 
public < T > CASResponse cas ( String key , long casId , int exp , T value , tTranscoder < T > tc ) { ttry { treturn asyncCAS ( key , casId , exp , value , tc ) . get ( operationTimeout , 
tNoopOperation noop ( OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
tCASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , tOperationCallback cb ) ; tVersionOperation version ( OperationCallback cb ) ; } 
public CASOperation cas ( String key , long casId , int flags , int exp , tbyte [ ] data , OperationCallback cb ) { treturn new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; } 
public void initialize ( ) { tByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; tsetArguments ( bb , " cas " , key , flags , exp , data . length , casValue ) ; tassert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; tbb . put ( data ) ; tbb . put ( CRLF ) ; tbb . flip ( ) ; tsetBuffer ( bb ) ; } 
public CASOperation cas ( String key , long casId , int flags , int exp , tbyte [ ] data , OperationCallback cb ) { treturn new StoreOperationImpl ( StoreType . set , key , flags , exp , data , tcasId , cb ) ; 
public static void main ( String args [ ] ) throws Exception { System.out.println(":) Failed as expected."); 
public T cas ( final String key , final T initial , int initialExp , tfinal CASMutation < T > m ) throws Exception { tT rv = initial ; tboolean done = false ; tfor ( int i = 0 ; ! done & & i < max ; i + + ) { tCASValue < T > casval = client . gets ( key , transcoder ) ; tT current = null ; } 
protected InvocationMatcher any ( ) { return new InvocationMatcher ( ) { 
public boolean matches ( Invocation i ) { return true ; } public void invoked ( Invocation i ) { 
public void invoked ( Invocation i ) { do nothing } public boolean hasDescription() { return true; } public void verify() { do nothing } public StringBuffer describeTo(StringBuffer buf) { return buf.append("allowed"); } }; }} 
public boolean hasDescription ( ) { return true ; } public void verify ( ) { 
public void verify ( ) { do nothing } public StringBuffer describeTo(StringBuffer buf) { return buf.append("allowed"); } }; }} 
public StringBuffer describeTo ( StringBuffer buf ) { return buf . append ( " allowed " ) ; } 
public static void close ( Closeable closeable ) { if ( closeable ! = null ) { try { 
public static void close ( Connection closeable ) { if ( closeable ! = null ) { try { 
public void run ( ) { ttry { tbarrier . await ( ) ; trv = callable . call ( ) ; } catch ( Throwable ) { tthrowable = ; } tlatch . countDown ( ) ; } 
public T getResult ( ) throws Throwable { tlatch . await ( ) ; tif ( throwable ! = null ) { tthrow throwable ; } treturn rv ; } 
public static < T > Collection < SyncThread < T > > getCompletedThreads ( tint num , Callable < T > callable ) throws InterruptedException { tCollection < SyncThread < T > > rv = new ArrayList < SyncThread < T > > ( num ) ; tCyclicBarrier barrier = new CyclicBarrier ( num ) ; tfor ( int i = 0 ; i < num ; i + + ) { trv . add ( new SyncThread < T > ( barrier , callable ) ) ; } tfor ( SyncThread < T > : rv ) { tt . join ( ) ; } treturn rv ; } 
public static < T > int getDistinctResultCount ( int num , Callable < T > callable ) tthrows Throwable { tIdentityHashMap < T , Object > found = new IdentityHashMap < T , Object > ( ) ; tCollection < SyncThread < T > > threads = getCompletedThreads ( num , callable ) ; tfor ( SyncThread < T > s : threads ) { tfound . put ( s . getResult ( ) , new Object ( ) ) ; } treturn found . size ( ) ; } 
public void debug ( Object message , Throwable exception ) { tlog ( Level . DEBUG , message , exception ) ; } 
public void debug ( String message , Object . . . args ) { tif ( isDebugEnabled ( ) ) { tdebug ( String . format ( message , args ) , getThrowable ( args ) ) ; 
public void debug ( Object message ) { tdebug ( message , null ) ; } 
public void info ( Object message , Throwable exception ) { tlog ( Level . INFO , message , exception ) ; } 
public void info ( String message , Object . . . args ) { tif ( isInfoEnabled ( ) ) { tinfo ( String . format ( message , args ) , getThrowable ( args ) ) ; 
public void info ( Object message ) { tinfo ( message , null ) ; } 
public void warn ( Object message , Throwable exception ) { tlog ( Level . WARN , message , exception ) ; } 
public void warn ( String message , Object . . . args ) { twarn ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void warn ( Object message ) { twarn ( message , null ) ; } 
public void error ( Object message , Throwable exception ) { tlog ( Level . ERROR , message , exception ) ; } 
public void error ( String message , Object . . . args ) { terror ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void error ( Object message ) { terror ( message , null ) ; } 
public void fatal ( Object message , Throwable exception ) { tlog ( Level . FATAL , message , exception ) ; } 
public void fatal ( String message , Object . . . args ) { tfatal ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void fatal ( Object message ) { tfatal ( message , null ) ; } 
public void log ( Level level , Object message ) { tlog ( level , message , null ) ; } 
public abstract void log ( Level level , Object message , Throwable e ) ; } 
public synchronized void log ( Level level , Object message , Throwable e ) { tif ( level = = Level . INFO | | level = = Level . WARN 
public String toString ( ) { treturn ( " {LogLevel: " + name ( ) + " } " ) ; } 
public boolean isDebugEnabled ( ) { treturn ( l4jLogger . isDebugEnabled ( ) ) ; } 
public boolean isInfoEnabled ( ) { treturn ( l4jLogger . isInfoEnabled ( ) ) ; } 
public void log ( Level level , Object message , Throwable e ) { torg . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; tswitch ( level = = null ? Level . FATAL : level ) { tcase DEBUG : tpLevel = org . apache . log4j . Level . DEBUG ; tbreak ; tcase INFO : tpLevel = org . apache . log4j . Level . INFO ; tbreak ; tcase WARN : tpLevel = org . apache . log4j . Level . WARN ; tbreak ; tcase ERROR : tpLevel = org . apache . log4j . Level . ERROR ; tbreak ; tcase FATAL : tpLevel = org . apache . log4j . Level . FATAL ; tbreak ; tdefault : } 
tString getName ( ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tboolean isDebugEnabled ( ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tboolean isInfoEnabled ( ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid log ( Level level , Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid log ( Level level , Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid debug ( Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid debug ( Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid debug ( String message , Object . . . args ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid info ( Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid info ( Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid info ( String message , Object . . . args ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid warn ( Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid warn ( Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid warn ( String message , Object . . . args ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid error ( Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid error ( Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid error ( String message , Object . . . args ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid fatal ( Object message , Throwable exception ) ; tvoid fatal ( String message , Object . . . args ) ; } 
tvoid fatal ( Object message ) ; tvoid fatal ( String message , Object . . . args ) ; } 
private static void init ( ) { if ( instance = = null ) { tinstance = new LoggerFactory ( ) ; 
private Logger internalGetLogger ( String name ) { assert name ! = null : " Name was null " ; Logger rv = instances . get ( name ) ; if ( rv = = null ) { tLogger newLogger = null ; ttry { tnewLogger = getNewInstance ( name ) ; } catch ( Exception e ) { tthrow new RuntimeException ( " Problem getting logger " , e ) ; } Logger tmp = instances . putIfAbsent ( name , newLogger ) ; Return either the new logger we've just made, or one that was created while we were waiting rv = tmp == null ? newLogger : tmp; } return(rv); 
private Logger getNewInstance ( String name ) tthrows tInstantiationException , IllegalAccessException , tIllegalArgumentException , InvocationTargetException { tif ( instanceConstructor = = null ) { tgetConstructor ( ) ; } tObject [ ] args = { name } ; tLogger rv = instanceConstructor . newInstance ( args ) ; treturn ( rv ) ; } 
public boolean isDebugEnabled ( ) { treturn ( sunLogger . isLoggable ( java . util . logging . Level . FINE ) ) ; } 
public boolean isInfoEnabled ( ) { treturn ( sunLogger . isLoggable ( java . util . logging . Level . INFO ) ) ; } 
public void testDebugLogging ( ) { } 
public void testInfoLogging ( ) { tassertTrue ( logger . isInfoEnabled ( ) ) ; tlogger . info ( " info message " ) ; } 
public void testOtherLogging ( ) { tlogger . warn ( " warn message " ) ; tlogger . warn ( " test %s " , " message " ) ; tlogger . error ( " error message " ) ; tlogger . error ( " test %s " , " message " ) ; tlogger . fatal ( " fatal message " ) ; tlogger . fatal ( " test %s " , " message " ) ; tlogger . log ( null , " test null " , null ) ; tassertEquals ( getClass ( ) . getName ( ) , logger . getName ( ) ) ; } 
public void testLog4j ( ) { public void testNoExceptionArg() throws Exception { Object[] args=new Object[]{"a", 42, new Exception("test"), "x"}; Throwable t=((AbstractLogger)logger).getThrowable(args); assertNull(t); }} 
public void testSunLogger ( ) { tLogger l = new SunLogger ( getClass ( ) . getName ( ) ) ; tassertFalse ( l . isDebugEnabled ( ) ) ; tl . debug ( " debug message " ) ; tassertTrue ( l . isInfoEnabled ( ) ) ; tl . info ( " info message " ) ; tl . warn ( " warn message " ) ; tl . error ( " error message " ) ; tl . fatal ( " fatal message " ) ; tl . fatal ( " fatal message with exception " , new Exception ( ) ) ; tl . log ( null , " test null " , null ) ; tl . log ( null , " null message with exception and no requestor " , tnew Exception ( ) ) ; 
public void testMyLogger ( ) { tLogger l = new DefaultLogger ( getClass ( ) . getName ( ) ) ; tassertFalse ( l . isDebugEnabled ( ) ) ; tl . debug ( " debug message " ) ; tassertTrue ( l . isInfoEnabled ( ) ) ; tl . info ( " info message " ) ; tl . warn ( " warn message " ) ; tl . error ( " error message " ) ; tl . fatal ( " fatal message " ) ; tl . fatal ( " fatal message with exception " , new Exception ( ) ) ; tl . log ( null , " test null " , null ) ; tl . log ( null , " null message with exception and no requestor " , tnew Exception ( ) ) ; ttry { tl = new DefaultLogger ( null ) ; 
public void testLevelStrings ( ) { tassertEquals ( " {LogLevel: DEBUG} " , String . valueOf ( Level . DEBUG ) ) ; tassertEquals ( " {LogLevel: INFO} " , String . valueOf ( Level . INFO ) ) ; tassertEquals ( " {LogLevel: WARN} " , String . valueOf ( Level . WARN ) ) ; tassertEquals ( " {LogLevel: ERROR} " , String . valueOf ( Level . ERROR ) ) ; tassertEquals ( " {LogLevel: FATAL} " , String . valueOf ( Level . FATAL ) ) ; tassertEquals ( " DEBUG " , Level . DEBUG . name ( ) ) ; tassertEquals ( " INFO " , Level . INFO . name ( ) ) ; tassertEquals ( " WARN " , Level . WARN . name ( ) ) ; tassertEquals ( " ERROR " , Level . ERROR . name ( ) ) ; tassertEquals ( " FATAL " , Level . FATAL . name ( ) ) ; } 
public void testExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( ) ; assertEquals ( " test " , . getMessage ( ) ) ; } 
public void testNoExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) , " x " } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNull ( ) ; } 
tvoid connectionEstablished ( SocketAddress sa , int reconnectCount ) ; tvoid connectionLost ( SocketAddress sa ) ; } 
public boolean addObserver ( ConnectionObserver obs ) { treturn conn . addObserver ( obs ) ; } 
public boolean removeObserver ( ConnectionObserver obs ) { treturn conn . removeObserver ( obs ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tvoid setTranscoder ( Transcoder < Object > tc ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
public boolean addObserver ( ConnectionObserver obs ) { treturn connObservers . add ( obs ) ; } 
public boolean removeObserver ( ConnectionObserver obs ) { treturn connObservers . remove ( obs ) ; } 
private void connected ( MemcachedNode qa ) { tassert qa . getChannel ( ) . isConnected ( ) : " Not connected. " ; tint rt = qa . getReconnectCount ( ) ; tqa . connected ( ) ; tfor ( ConnectionObserver observer : connObservers ) { tobserver . connectionEstablished ( qa . getSocketAddress ( ) , rt ) ; 
private void lostConnection ( MemcachedNode qa ) { tqueueReconnect ( qa ) ; tfor ( ConnectionObserver observer : connObservers ) { tobserver . connectionLost ( qa . getSocketAddress ( ) ) ; 
public void testConnectionObserver ( ) throws Exception { tConnectionObserver obs = new LoggingObserver ( ) ; tassertTrue ( client . addObserver ( obs ) ) ; tassertTrue ( client . removeObserver ( obs ) ) ; tassertFalse ( client . removeObserver ( obs ) ) ; } 
public void connectionEstablished ( SocketAddress sa , tint reconnectCount ) { tgetLogger ( ) . info ( " Connection established to %s (%s) " , tsa , reconnectCount ) ; 
public void connectionLost ( SocketAddress sa ) { tgetLogger ( ) . info ( " Connection lost from %s " , sa ) ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tlong getOperationTimeout ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
tboolean isDaemon ( ) ; tCollection < ConnectionObserver > getInitialObservers ( ) ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( getReadBufSize ( ) , this , addrs , tgetInitialObservers ( ) ) ; 
public void testConnectionObserver ( ) throws Exception { tConnectionObserver obs = new LoggingObserver ( ) ; tassertTrue ( " Didn't add observer. " , client . addObserver ( obs ) ) ; tassertTrue ( " Didn't remove observer. " , client . removeObserver ( obs ) ) ; tassertFalse ( " Removed observer more than once. " , tclient . removeObserver ( obs ) ) ; 
public void connectionEstablished ( SocketAddress sa , tint reconnectCount ) { tlatch . countDown ( ) ; } 
public void connectionLost ( SocketAddress sa ) { tassert false : " Should not see this. " ; } 
tprotected void initClient ( ) throws Exception { @Override 
public BlockingQueue < Operation > createOperationQueue ( ) { treturn new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } 
public BlockingQueue < Operation > createReadOperationQueue ( ) { treturn new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ; 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { treturn createOperationQueue ( ) ; } 
private void runOverflowTest ( byte b [ ] ) throws Exception { tCollection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; ttry { tfor ( int i = 0 ; i < 1000 ; i + + ) { tc . add ( client . set ( " k " + i , 0 , b ) ) ; } tfail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { client.set("kx", 0, "woo").get(1, TimeUnit.SECONDS)); 
public BlockingQueue < Operation > createReadOperationQueue ( ) { treturn new LinkedBlockingQueue < Operation > ( ) ; } 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { treturn new LinkedBlockingQueue < Operation > ( ) ; } 
public void testQueueSizes ( ) { tConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; tassertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; tassertEquals ( Integer . MAX_VALUE , tcf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; tassertEquals ( Integer . MAX_VALUE , tcf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ; 
public void testCrap ( ) throws Exception { tmain ( new String [ ] { " 10000 " , " 100 " , " 11211 " , " 100 " } ) ; } 
public static void main ( String [ ] args ) throws Exception { tif ( args . length ! = 4 ) { args = new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ; tSystem . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; } tint runs = Integer . parseInt ( args [ 0 ] ) ; tint start = Integer . parseInt ( args [ 1 ] ) ; tString serverlist = " 127.0.0.1: " + args [ 2 ] ; tint threads = Integer . parseInt ( args [ 3 ] ) ; tMemcachedClient client = new MemcachedClient ( tnew DefaultConnectionFactory ( 100000 , 32768 ) , tAddrUtil . getAddresses ( serverlist ) ) ; tWorkerStat [ ] statArray = new WorkerStat [ threads ] ; tThread [ ] threadArray = new Thread [ threads ] ; tWorkerStat mainStat = new WorkerStat ( ) ; tmainStat . runs = runs * threads ; tlong begin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tstatArray [ i ] = new WorkerStat ( ) ; tstatArray [ i ] . start = start + i * runs ; tstatArray [ i ] . runs = runs ; tthreadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . setterTime = System . currentTimeMillis ( ) - begin ; tbegin = System . currentTimeMillis ( ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; tthreadArray [ i ] . start ( ) ; } tfor ( int i = 0 ; i < threads ; i + + ) { tthreadArray [ i ] . join ( ) ; } tmainStat . getterTime = System . currentTimeMillis ( ) - begin ; tclient . shutdown ( ) ; tWorkerStat totalStat = new WorkerStat ( ) ; tSystem . out . println ( " Thread tstart truns tset time(ms) tget time(ms) " ) ; tfor ( int i = 0 ; i < threads ; i + + ) { tSystem . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; ttotalStat . runs = totalStat . runs + statArray [ i ] . runs ; ttotalStat . setterTime = totalStat . setterTime + statArray [ i ] . setterTime ; ttotalStat . getterTime = totalStat . getterTime + statArray [ i ] . getterTime ; } tSystem . out . println ( " nAvg " + runs + " " + totalStat . setterTime / threads + " " + totalStat . getterTime / threads ) ; tSystem . out . println ( " nTotal " + totalStat . runs + " " + totalStat . setterTime + " " + totalStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * totalStat . runs / totalStat . setterTime + " tget - " + 1000 * totalStat . runs / totalStat . getterTime ) ; tSystem . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; tSystem . out . println ( " tReqPerSecond tset - " + 1000 * mainStat . runs / mainStat . setterTime + " tget - " + 1000 * mainStat . runs 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tFailureMode getFailureMode ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tFailureMode getFailureMode ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tFailureMode getFailureMode ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tFailureMode getFailureMode ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tFailureMode getFailureMode ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tFailureMode getFailureMode ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tFailureMode getFailureMode ( ) ; } 
tlong getOperationTimeout ( ) ; tFailureMode getFailureMode ( ) ; } 
tboolean isDaemon ( ) ; tFailureMode getFailureMode ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tFailureMode getFailureMode ( ) ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( getReadBufSize ( ) , this , addrs , tgetInitialObservers ( ) , getFailureMode ( ) ) ; 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { tplaceIn = primary ; } else { } 
tvoid gotData ( String key , int flags , long cas , byte [ ] data ) ; } } 
private void redistributeOperations ( Collection < Operation > ops ) { tfor ( Operation op : ops ) { tif ( op instanceof KeyedOperation ) { 
tvoid copyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
tCollection < Operation > destroyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { tCollection < Operation > rv = new ArrayList < Operation > ( ) ; tinputQueue . drainTo ( rv ) ; treturn rv ; } 
public void fixupOps ( ) { }} 
public Collection < Operation > destroyInputQueue ( ) { treturn null ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException { treturn new MemcachedConnection ( getReadBufSize ( ) , this , addrs , tgetInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ; 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , tOperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public Collection < Operation > clone ( KeyedOperation op ) { } 
tlong getCasValue ( ) ; tbyte [ ] getBytes ( ) ; } 
tint getFlags ( ) ; tbyte [ ] getBytes ( ) ; } 
tint getExpiration ( ) ; tbyte [ ] getBytes ( ) ; } 
tConcatenationType getType ( ) ; tbyte [ ] getData ( ) ; } 
tlong getCasValue ( ) ; tbyte [ ] getData ( ) ; } 
tConcatenationType getStoreType ( ) ; tbyte [ ] getData ( ) ; } 
tStoreType getStoreType ( ) ; tbyte [ ] getData ( ) ; } 
tint getFlags ( ) ; tbyte [ ] getData ( ) ; } 
tint getExpiration ( ) ; tbyte [ ] getData ( ) ; } 
tMutator getType ( ) ; tint getExpiration ( ) ; } 
tint getBy ( ) ; tint getExpiration ( ) ; } 
tlong getDefault ( ) ; tint getExpiration ( ) ; } 
private String first ( Collection < String > keys ) { treturn keys . iterator ( ) . next ( ) ; } 
public Collection < Operation > clone ( KeyedOperation op ) { tassert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; tassert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; tassert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; tCollection < Operation > rv = new ArrayList < Operation > ( top . getKeys ( ) . size ( ) ) ; tif ( op instanceof GetOperation ) { tthrow new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof GetsOperation ) { tthrow new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof CASOperation ) { tCASOperation cop = ( CASOperation ) op ; trv . add ( cas ( first ( op . getKeys ( ) ) , tcop . getCasValue ( ) , cop . getFlags ( ) , cop . getExpiration ( ) , tcop . getBytes ( ) , cop . getCallback ( ) ) ) ; } else if ( op instanceof DeleteOperation ) { trv . add ( delete ( first ( op . getKeys ( ) ) , op . getCallback ( ) ) ) ; } else if ( op instanceof MutatatorOperation ) { tMutatatorOperation mo = ( MutatatorOperation ) op ; trv . add ( mutate ( mo . getType ( ) , first ( op . getKeys ( ) ) , tmo . getBy ( ) , mo . getDefault ( ) , mo . getExpiration ( ) , top . getCallback ( ) ) ) ; } else if ( op instanceof StoreOperation ) { tStoreOperation so = ( StoreOperation ) op ; trv . add ( store ( so . getStoreType ( ) , first ( op . getKeys ( ) ) , so . getFlags ( ) , tso . getExpiration ( ) , so . getData ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof ConcatenationOperation ) { tConcatenationOperation c = ( ConcatenationOperation ) op ; trv . add ( cat ( c . getStoreType ( ) , c . getCasValue ( ) , first ( op . getKeys ( ) ) , tc . getData ( ) , c . getCallback ( ) ) ) ; } else { tassert false : " Unhandled operation type: " + op . getClass ( ) ; } treturn rv ; } 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public Collection < Operation > clone ( KeyedOperation op ) { tassert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; tassert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; tassert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; tCollection < Operation > rv = new ArrayList < Operation > ( top . getKeys ( ) . size ( ) ) ; tif ( op instanceof GetOperation ) { tthrow new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof GetsOperation ) { tthrow new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof CASOperation ) { tCASOperation cop = ( CASOperation ) op ; trv . add ( cas ( cop . getStoreType ( ) , first ( op . getKeys ( ) ) , tcop . getCasValue ( ) , cop . getFlags ( ) , cop . getExpiration ( ) , tcop . getBytes ( ) , cop . getCallback ( ) ) ) ; } else if ( op instanceof DeleteOperation ) { trv . add ( delete ( first ( op . getKeys ( ) ) , op . getCallback ( ) ) ) ; } else if ( op instanceof MutatatorOperation ) { tMutatatorOperation mo = ( MutatatorOperation ) op ; trv . add ( mutate ( mo . getType ( ) , first ( op . getKeys ( ) ) , tmo . getBy ( ) , mo . getDefault ( ) , mo . getExpiration ( ) , top . getCallback ( ) ) ) ; } else if ( op instanceof StoreOperation ) { tStoreOperation so = ( StoreOperation ) op ; trv . add ( store ( so . getStoreType ( ) , first ( op . getKeys ( ) ) , so . getFlags ( ) , tso . getExpiration ( ) , so . getData ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof ConcatenationOperation ) { tConcatenationOperation c = ( ConcatenationOperation ) op ; trv . add ( cat ( c . getStoreType ( ) , c . getCasValue ( ) , first ( op . getKeys ( ) ) , tc . getData ( ) , c . getCallback ( ) ) ) ; } else { tassert false : " Unhandled operation type: " + op . getClass ( ) ; } treturn rv ; } 
tStoreType getStoreType ( ) ; tbyte [ ] getBytes ( ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) { treturn new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) { treturn new StoreOperationImpl ( type , key , flags , exp , data , tcasId , cb ) ; 
public Collection < Operation > clone ( KeyedOperation op ) { tassert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; tassert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; tassert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; tCollection < Operation > rv = new ArrayList < Operation > ( top . getKeys ( ) . size ( ) ) ; tif ( op instanceof GetOperation ) { } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tofact = getOperationFactory ( ) ; tgenericCallback = new OperationCallback ( ) { public void complete ( ) { tfail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { tfail ( " Unexpected status: " + status ) ; } } ; ttestData = new byte [ 64 ] ; tnew Random ( ) . nextBytes ( testData ) ; } 
public void complete ( ) { tfail ( " Unexpected invocation " ) ; } 
public void receivedStatus ( OperationStatus status ) { tfail ( " Unexpected status: " + status ) ; } 
public void testDeleteOperationCloning ( ) { tDeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; tDeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; tassertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; tassertCallback ( op2 ) ; } 
public void testCASOperationCloning ( ) { tCASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; tCASOperation op2 = cloneOne ( CASOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( 727582 , op2 . getCasValue ( ) ) ; tassertEquals ( 8174 , op2 . getFlags ( ) ) ; tassertEquals ( 7175 , op2 . getExpiration ( ) ) ; tassertBytes ( op2 . getBytes ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( def , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . incr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( def , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . decr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testStoreOperationAddCloning ( ) { tint exp = 823862 ; tint flags = 7735 ; tStoreOperation op = ofact . store ( StoreType . add , TEST_KEY , tflags , exp , testData , genericCallback ) ; tStoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( flags , op2 . getFlags ( ) ) ; tassertSame ( StoreType . add , op2 . getStoreType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testStoreOperationSetCloning ( ) { tint exp = 823862 ; tint flags = 7735 ; tStoreOperation op = ofact . store ( StoreType . set , TEST_KEY , tflags , exp , testData , genericCallback ) ; tStoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( flags , op2 . getFlags ( ) ) ; tassertSame ( StoreType . set , op2 . getStoreType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testConcatenationOperationAppendCloning ( ) { tlong casId = 82757248 ; tConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , tTEST_KEY , testData , genericCallback ) ; tConcatenationOperation op2 = cloneOne ( tConcatenationOperation . class , op ) ; tassertKey ( op2 ) ; tassertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testConcatenationOperationPrependCloning ( ) { tlong casId = 82757248 ; tConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , tTEST_KEY , testData , genericCallback ) ; tConcatenationOperation op2 = cloneOne ( tConcatenationOperation . class , op ) ; tassertKey ( op2 ) ; tassertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; tassertCallback ( op2 ) ; } 
tprotected void assertKey ( KeyedOperation op ) { tassertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } 
tprotected void assertCallback ( Operation op ) { tassertSame ( genericCallback , op . getCallback ( ) ) ; } 
private void assertBytes ( byte [ ] bytes ) { tassertTrue ( Arrays . equals ( testData , bytes ) ) ; } 
private < T > T assertOne ( Class < T > class1 , tCollection < Operation > ops ) { tassertEquals ( 1 , ops . size ( ) ) ; tOperation op = ops . iterator ( ) . next ( ) ; treturn ( T ) op ; } 
tprotected < T > T cloneOne ( Class < T > c , KeyedOperation ) { treturn assertOne ( c , ofact . clone ( ) ) ; } 
public void testMutatorOperationIncrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( - 1 , op2 . getExpiration ( ) ) ; tassertEquals ( - 1 , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . incr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( - 1 , op2 . getExpiration ( ) ) ; tassertEquals ( - 1 , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . decr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
tprotected abstract Collection < ? extends Operation > cloneGet ( tKeyedOperation op ) ; } 
public void testSingleGetOperationCloning ( ) { tGetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; tGetOperation op = ofact . get ( TEST_KEY , callback ) ; tGetOperation op2 = cloneOne ( GetOperation . class , op ) ; tassertKey ( op2 ) ; tassertSame ( callback , op . getCallback ( ) ) ; } 
public void testSingleGetsOperationCloning ( ) { tGetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; tGetsOperation op = ofact . gets ( TEST_KEY , callback ) ; tGetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; tassertKey ( op2 ) ; tassertSame ( callback , op . getCallback ( ) ) ; } 
public void testMultipleGetOperationCloning ( ) { tCollection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; tGetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; tGetOperation op = ofact . get ( keys , callback ) ; tCollection < Operation > ops = ofact . clone ( op ) ; tassertEquals ( 3 , ops . size ( ) ) ; tCollection < String > mutableKeys = new ArrayList < String > ( keys ) ; tint i = 3 ; tfor ( Operation o : ops ) { tassertEquals ( i , mutableKeys . size ( ) ) ; Starting size 
public void gotData ( String key , int flags , byte [ ] data ) { ( ( GetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; } 
public void gotData ( String key , int flags , long cas , byte [ ] data ) { ( ( GetsOperation . Callback ) originalCallback ) . gotData ( tkey , flags , cas , data ) ; 
public void complete ( ) { tif ( - - remaining = = 0 ) { toriginalCallback . receivedStatus ( mostRecentStatus ) ; 
public void receivedStatus ( OperationStatus status ) { tmostRecentStatus = status ; } 
public void testMultipleGetOperationFanout ( ) { tCollection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; tMock m = mock ( GetOperation . Callback . class ) ; tOperationStatus st = new OperationStatus ( true , " blah " ) ; tm . expects ( once ( ) ) . method ( " complete " ) ; tm . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; tm . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; tm . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; tm . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; tGetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; tGetOperation op = ofact . get ( keys , callback ) ; GetOperation.Callback cb = (GetOperation.Callback)o.getCallback(); 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public MutatorOperation mutate ( Mutator m , String key , int by , tlong exp , int def , OperationCallback cb ) { treturn new MutatorOperationImpl ( m , key , by , cb ) ; } 
public MutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) { treturn new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; } 
public void testMutatorOperationIncrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( def , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . incr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( exp , op2 . getExpiration ( ) ) ; tassertEquals ( def , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . decr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( - 1 , op2 . getExpiration ( ) ) ; tassertEquals ( - 1 , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . incr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { tint exp = 823862 ; tlong def = 28775 ; tint by = 7735 ; tMutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , texp , genericCallback ) ; tMutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( - 1 , op2 . getExpiration ( ) ) ; tassertEquals ( - 1 , op2 . getDefault ( ) ) ; tassertEquals ( by , op2 . getBy ( ) ) ; tassertSame ( Mutator . decr , op2 . getType ( ) ) ; tassertCallback ( op2 ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { tassertEquals ( " Cannot cache data larger than 1MB " + " (you tried to cache a " + data . length + " byte object) " , te . getMessage ( ) ) ; } } 
private void cancelOperations ( Collection < Operation > ops ) { tfor ( Operation op : ops ) { top . cancel ( ) ; 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { tplaceIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { to . cancel ( ) ; } else { addOperation(placeIn, o); 
public void testQueueingToDownServer ( ) throws Exception { tFuture < Boolean > f = client . add ( " someKey " , 0 , " some object " ) ; ttry { tboolean b = f . get ( ) ; tfail ( " Should've thrown an exception, returned " + b ) ; } catch ( ExecutionException e ) { } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tlong getOperationTimeout ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tboolean isDaemon ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tFailureMode getFailureMode ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
public void clear ( ) { } 
public boolean containsKey ( Object key ) { treturn get ( key ) ! = null ; } 
public boolean containsValue ( Object value ) { treturn false ; } 
public Set < Map . Entry < String , V > > entrySet ( ) { treturn Collections . emptySet ( ) ; } 
public V get ( Object key ) { tV rv = null ; ttry { trv = client . get ( getKey ( ( String ) key ) , transcoder ) ; } catch ( ClassCastException e ) { } 
public Set < String > keySet ( ) { treturn Collections . emptySet ( ) ; } 
public void putAll ( Map < ? extends String , ? extends V > ) { tfor ( Map . Entry < ? extends String , ? extends V > me : . entrySet ( ) ) { tclient . set ( getKey ( me . getKey ( ) ) , exp , me . getValue ( ) ) ; 
public V remove ( Object key ) { tV rv = null ; ttry { trv = get ( key ) ; tclient . delete ( getKey ( ( String ) key ) ) ; } catch ( ClassCastException e ) { } 
public Collection < V > values ( ) { treturn Collections . emptySet ( ) ; } 
public V put ( String key , V value ) { tV rv = get ( key ) ; tclient . set ( getKey ( key ) , exp , value ) ; treturn rv ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; ttranscoder = new SerializingTranscoder ( ) ; tclientMock = mock ( MemcachedClientIF . class ) ; tclientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; tclient = ( MemcachedClientIF ) clientMock . proxy ( ) ; tcacheMap = new CacheMap ( client , EXP , " blah " ) ; } 
private void expectGetAndReturn ( String k , Object value ) { tclientMock . expects ( once ( ) ) . method ( " get " ) . with ( eq ( k ) , same ( transcoder ) ) 
public void testNoExpConstructor ( ) throws Exception { tclientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; tCacheMap cm = new CacheMap ( client , " blah " ) ; tField f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; tf . setAccessible ( true ) ; tassertEquals ( 0 , f . getInt ( cm ) ) ; } 
public void testBaseConstructor ( ) throws Exception { tBaseCacheMap < Integer > bcm = new BaseCacheMap < Integer > ( client , tEXP , " base " , new IntegerTranscoder ( ) ) ; tField f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; tf . setAccessible ( true ) ; tassertEquals ( EXP , f . getInt ( bcm ) ) ; } 
public void testGetPositive ( ) { texpectGetAndReturn ( " blaha " , " something " ) ; tassertEquals ( " something " , cacheMap . get ( " a " ) ) ; } 
public void testGetNegative ( ) { texpectGetAndReturn ( " blaha " , null ) ; tassertNull ( cacheMap . get ( " a " ) ) ; } 
public void testGetNotString ( ) { tassertNull ( cacheMap . get ( new Object ( ) ) ) ; } 
public void testContainsPositive ( ) { texpectGetAndReturn ( " blaha " , new Object ( ) ) ; tassertTrue ( cacheMap . containsKey ( " a " ) ) ; } 
public void testContainsNegative ( ) { texpectGetAndReturn ( " blaha " , null ) ; tassertFalse ( cacheMap . containsKey ( " a " ) ) ; } 
public void testContainsValue ( ) { tassertFalse ( cacheMap . containsValue ( " anything " ) ) ; } 
public void testEntrySet ( ) { tassertEquals ( 0 , cacheMap . entrySet ( ) . size ( ) ) ; } 
public void testKeySet ( ) { tassertEquals ( 0 , cacheMap . keySet ( ) . size ( ) ) ; } 
public void testtIsEmpty ( ) { tassertFalse ( cacheMap . isEmpty ( ) ) ; } 
public void testPutAll ( ) { tclientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " vala " ) ) ; tclientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blahb " ) , eq ( EXP ) , eq ( " valb " ) ) ; tMap < String , Object > m = new HashMap < String , Object > ( ) ; tm . put ( " a " , " vala " ) ; tm . put ( " b " , " valb " ) ; tcacheMap . putAll ( m ) ; } 
public void testSize ( ) { tassertEquals ( 0 , cacheMap . size ( ) ) ; } 
public void testValues ( ) { tassertEquals ( 0 , cacheMap . values ( ) . size ( ) ) ; } 
public void testRemove ( ) { texpectGetAndReturn ( " blaha " , " olda " ) ; tclientMock . expects ( once ( ) ) . method ( " delete " ) . with ( eq ( " blaha " ) ) ; tassertEquals ( " olda " , cacheMap . remove ( " a " ) ) ; } 
public void testRemoveNotString ( ) { tassertNull ( cacheMap . remove ( new Object ( ) ) ) ; } 
public void testPut ( ) { texpectGetAndReturn ( " blaha " , " olda " ) ; tclientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; tassertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; } 
private void validateKey ( String key ) { tbyte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tif ( keyBytes . length > MAX_KEY_LENGTH ) { tthrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } tif ( keyBytes . length = = 0 ) { tthrow new IllegalArgumentException ( " Key must contain at least one character. " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) { 
public void testInvalidKeyBlank ( ) throws Exception { ttry { tObject val = client . get ( " " ) ; 
public void connectionEstablished ( SocketAddress sa , tint reconnectCount ) { tSystem . out . println ( " *** Established: " + sa + " count= " + reconnectCount ) ; 
public void connectionLost ( SocketAddress sa ) { tSystem . out . println ( " *** Lost connection: " + sa ) ; } 
public void testGetStatsCacheDump ( ) throws Exception { } 
public void testGetStatsSizes ( ) throws Exception { } 
public void testGetStatsCacheDump ( ) throws Exception { } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( tc , latch , operationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private CachedData val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CachedData ( flags , data , tc . getMaxSize ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = new CachedData ( flags , data , tc . getMaxSize ( ) ) ; } 
public < T > Future < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , CachedData > m = new ConcurrentHashMap < String , CachedData > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } 
public CachedData encode ( java . lang . Integer l ) { treturn new CachedData ( flags , tu . encodeInt ( l ) , getMaxSize ( ) ) ; } 
public CachedData encode ( java . lang . Long l ) { treturn new CachedData ( flags , tu . encodeLong ( l ) , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = tu . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
tCachedData encode ( T o ) ; tint getMaxSize ( ) ; } 
tT decode ( CachedData d ) ; tint getMaxSize ( ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; tflags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { tflags | = SPECIAL_STRINGBUFFER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { tflags | = SPECIAL_STRINGBUILDER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Short ) { tb = tu . encodeInt ( ( Short ) o ) ; tflags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { tb = this . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { tb = tu . encodeInt ( ( Character ) o ) ; tflags | = SPECIAL_CHARACTER ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { tb = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { tb = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { tb = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { tb = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { tb = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { tb = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof byte [ ] ) { tthrow new IllegalArgumentException ( " Cannot handle byte arrays. " ) ; } else if ( o instanceof Character ) { tb = encodeCharacter ( ( Character ) o ) ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 10 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { tassertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , te . getMessage ( ) ) ; } } 
public CachedData encode ( String o ) { treturn new CachedData ( flags , o . getBytes ( ) , getMaxSize ( ) ) ; } 
public void testToString ( ) throws Exception { tString exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; tCachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) , tCachedData . MAX_SIZE ) ; tassertEquals ( exp , String . valueOf ( cd ) ) ; } 
public void testBadFlags ( ) throws Exception { tCachedData cd = tc . encode ( 9284 ) ; tassertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , tCachedData . MAX_SIZE ) ) ) ; 
public void testBadFlags ( ) throws Exception { tCachedData cd = tc . encode ( 9284L ) ; tassertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , tCachedData . MAX_SIZE ) ) ) ; 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( tSerializingTranscoder . COMPRESSED , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tSystem . out . println ( " got " + tc . decode ( cd ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeable ( ) throws Exception { tCachedData cd = new CachedData ( tInteger . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { tCachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , ttu . encodeInt ( Integer . MAX_VALUE ) , ttc . getMaxSize ( ) ) ; tassertNull ( tc . decode ( cd ) ) ; } 
public void log ( Level level , Object message , Throwable e ) { torg . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; tswitch ( level = = null ? Level . FATAL : level ) { tcase DEBUG : tpLevel = org . apache . log4j . Level . DEBUG ; tbreak ; tcase INFO : tpLevel = org . apache . log4j . Level . INFO ; tbreak ; tcase WARN : tpLevel = org . apache . log4j . Level . WARN ; tbreak ; tcase ERROR : tpLevel = org . apache . log4j . Level . ERROR ; tbreak ; tcase FATAL : tpLevel = org . apache . log4j . Level . FATAL ; tbreak ; tdefault : } 
public void testLog4j ( ) { public void testNoExceptionArg() throws Exception { Object[] args=new Object[]{"a", 42, new Exception("test"), "x"}; Throwable t=((AbstractLogger)logger).getThrowable(args); assertNull(t); }} 
public final void fixupOps ( ) { int iops=getSelectionOps(); 
public T cas ( final String key , final T initial , int initialExp , tfinal CASMutation < T > m ) throws Exception { tT rv = initial ; tboolean done = false ; tfor ( int i = 0 ; ! done & & i < max ; i + + ) { tCASValue < T > casval = client . gets ( key , transcoder ) ; tT current = null ; } 
public void testCASUpdateWithNullInitial ( ) throws Throwable { tclient . set ( " x " , 0 , 1L ) ; tLong rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; tassertEquals ( rv , ( Long ) 2L ) ; } 
public void testCASUpdateWithNullInitialNoExistingVal ( ) throws Throwable { tassertNull ( client . get ( " x " ) ) ; tLong rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; tassertNull ( rv ) ; tassertNull ( client . get ( " x " ) ) ; } 
public void testReallyLongCASId ( ) throws Exception { tString key = " this-is-my-key " ; tassertSame ( " Expected error CASing with no existing value. " , tCASResponse . NOT_FOUND , 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tlong getOperationTimeout ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tboolean isDaemon ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
tboolean useNagleAlgorithm ( ) ; tTranscoder < Object > getDefaultTranscoder ( ) ; } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = TranscodeService . getInstance ( ) . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = TranscodeService . getInstance ( ) . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , TranscodeService . getInstance ( ) . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = OperationState . WRITING ; top . cancel ( ) ; } tfor ( Future < T > v : rvMap . values ( ) ) { tv . cancel ( ign ) ; } tcancelled = true ; treturn rv ; } 
public Map < String , T > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( timeout , unit ) ) { tthrow new TimeoutException ( " Operation timed out. " ) ; } tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } tMap < String , T > m = new HashMap < String , T > ( ) ; tfor ( Map . Entry < String , Future < T > > me : rvMap . entrySet ( ) ) { tm . put ( me . getKey ( ) , me . getValue ( ) . get ( ) ) ; } treturn m ; } 
public T get ( ) throws InterruptedException , ExecutionException { tFuture < T > v = rv . get ( ) ; treturn v = = null ? null : v . get ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tFuture < T > v = rv . get ( duration , units ) ; treturn v = = null ? null : v . get ( ) ; } 
public boolean asyncDecode ( CachedData d ) { treturn false ; } 
public < T > Future < T > decode ( final Transcoder < T > tc , final CachedData cachedData ) { tTranscodeService . Task < T > task = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return tc . decode ( cachedData ) ; } } ) ; tif ( tc . asyncDecode ( cachedData ) ) { tthis . pool . execute ( task ) ; } treturn task ; } 
tTranscodeService . Task < T > task = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return tc . decode ( cachedData ) ; } } ) ; tif ( tc . asyncDecode ( cachedData ) ) { 
public T get ( ) throws InterruptedException , ExecutionException { tthis . run ( ) ; treturn super . get ( ) ; } 
public T get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { tthis . run ( ) ; treturn super . get ( timeout , unit ) ; } 
public void run ( ) { tif ( this . isRunning . compareAndSet ( false , true ) ) { tsuper . run ( ) ; 
tboolean asyncDecode ( CachedData d ) ; tint getMaxSize ( ) ; } 
public boolean asyncDecode ( CachedData d ) { treturn false ; } 
public < T > Future < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; 
public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tm . put ( k , tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public < T > Future < T > decode ( final Transcoder < T > tc , tfinal CachedData cachedData ) { tassert ! pool . isShutdown ( ) : " Pool has already shut down. " ; tTranscodeService . Task < T > task = new TranscodeService . Task < T > ( tnew Callable < T > ( ) { public T call ( ) { treturn tc . decode ( cachedData ) ; } } ) ; tif ( tc . asyncDecode ( cachedData ) ) { tthis . pool . execute ( task ) ; } treturn task ; } 
public T call ( ) { treturn tc . decode ( cachedData ) ; } 
public T get ( long timeout , TimeUnit unit ) throws InterruptedException , tExecutionException , TimeoutException { tthis . run ( ) ; treturn super . get ( timeout , unit ) ; } 
public boolean isShutdown ( ) { treturn pool . isShutdown ( ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tts = new TranscodeService ( ) ; } 
tprotected void tearDown ( ) throws Exception { tts . shutdown ( ) ; tassertTrue ( ts . isShutdown ( ) ) ; tsuper . tearDown ( ) ; } 
public void testNonExecuting ( ) throws Exception { tCachedData cd = new CachedData ( 0 , new byte [ 0 ] , 0 ) ; tFuture < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; tassertEquals ( " Stuff! " , fs . get ( ) ) ; } 
public void testExecuting ( ) throws Exception { tCachedData cd = new CachedData ( 1 , new byte [ 0 ] , 0 ) ; tFuture < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; tassertEquals ( " Stuff! " , fs . get ( ) ) ; } 
public boolean asyncDecode ( CachedData d ) { treturn d . getFlags ( ) = = 1 ; } 
public String decode ( CachedData d ) { treturn " Stuff! " ; } 
public CachedData encode ( String o ) { tthrow new RuntimeException ( " Not invoked. " ) ; } 
public void receivedStatus ( OperationStatus s ) { }} 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = OperationState . WRITING ; top . cancel ( ) ; } tfor ( Future < T > v : rvMap . values ( ) ) { tv . cancel ( ign ) ; } tcancelled = true ; treturn rv ; } 
public Map < String , T > get ( ) tthrows InterruptedException , ExecutionException { ttry { treturn get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
public Map < String , T > get ( long timeout , TimeUnit unit ) tthrows InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( timeout , unit ) ) { tthrow new TimeoutException ( " Operation timed out. " ) ; } tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( tnew RuntimeException ( " Cancelled " ) ) ; } tif ( op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } } tMap < String , T > m = new HashMap < String , T > ( ) ; tfor ( Map . Entry < String , Future < T > > me : rvMap . entrySet ( ) ) { tm . put ( me . getKey ( ) , me . getValue ( ) . get ( ) ) ; } treturn m ; } 
public boolean isDone ( ) { treturn latch . getCount ( ) = = 0 ; } 
public boolean cancel ( boolean ign ) { treturn rv . cancel ( ign ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { tFuture < T > v = rv . get ( ) ; treturn v = = null ? null : v . get ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tFuture < T > v = rv . get ( duration , units ) ; treturn v = = null ? null : v . get ( ) ; } 
public boolean isCancelled ( ) { treturn rv . isCancelled ( ) ; } 
public boolean cancel ( boolean ign ) { tassert op ! = null : " No operation " ; top . cancel ( ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { ttry { treturn get ( timeout , TimeUnit . MILLISECONDS ) ; 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
public boolean isCancelled ( ) { tassert op ! = null : " No operation " ; treturn op . isCancelled ( ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn latch . getCount ( ) = = 0 | | top . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ; 
public void addOperation ( final MemcachedNode node , final Operation o ) { to . setHandlingNode ( node ) ; to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { tfor ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { tfinal MemcachedNode node = me . getKey ( ) ; tOperation o = me . getValue ( ) ; to . setHandlingNode ( node ) ; to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; } tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; } 
private static String createMessage ( String message , tCollection < Operation > ops ) { tStringBuilder rv = new StringBuilder ( message ) ; trv . append ( " - failing node " ) ; trv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; tboolean first = true ; tfor ( Operation op : ops ) { tif ( first ) { tfirst = false ; } else { trv . append ( " , " ) ; } trv . append ( op . getHandlingNode ( ) . getSocketAddress ( ) ) ; } treturn rv . toString ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { tthrow new CheckedOperationTimeoutException ( " Timed out waiting for operation " , op ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
tboolean isCancelled ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tboolean hasErrored ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tOperationException getException ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tOperationCallback getCallback ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tvoid cancel ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tOperationState getState ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tByteBuffer getBuffer ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tvoid writeComplete ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tvoid initialize ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tvoid readFromBuffer ( ByteBuffer data ) throws IOException ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tvoid handleRead ( ByteBuffer data ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
tMemcachedNode getHandlingNode ( ) ; tvoid setHandlingNode ( MemcachedNode to ) ; } 
public int hashCode ( ) { treturn ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; } 
public Operation removeCurrentWriteOp ( ) { return null ; } public boolean hasReadOp ( ) { return false ; } 
public boolean hasReadOp ( ) { return false ; } public boolean hasWriteOp ( ) { return false ; } 
public boolean hasWriteOp ( ) { return false ; } public void addOp ( Operation op ) { 
public boolean isActive ( ) { return false ; } public void reconnecting ( ) { 
public int writeSome ( ) throws IOException { return 0 ; } public void fixupOps ( ) { 
public void fixupOps ( ) { }} 
public Collection < Operation > destroyInputQueue ( ) { treturn null ; } 
public void testSingleOperation ( ) { tOperation op = buildOp ( 11211 ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: localhost:11211 " , 
public void testMultipleOperation ( ) { tCollection < Operation > ops = new ArrayList < Operation > ( ) ; tops . add ( buildOp ( 11211 ) ) ; tops . add ( buildOp ( 11212 ) ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: localhost:11211, localhost:11212 " , 
private TestOperation buildOp ( int portNum ) { tTestOperation op = new TestOperation ( ) ; tMockMemcachedNode node = new MockMemcachedNode ( tInetSocketAddress . createUnresolved ( " localhost " , portNum ) ) ; top . setHandlingNode ( node ) ; treturn op ; } 
public void initialize ( ) { tthrow new RuntimeException ( " Not implemented. " ) ; } 
public void readFromBuffer ( ByteBuffer data ) throws IOException { tthrow new RuntimeException ( " Not implemented " ) ; } 
private static String createMessage ( String message , tCollection < Operation > ops ) { tStringBuilder rv = new StringBuilder ( message ) ; trv . append ( " - failing node " ) ; trv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; tboolean first = true ; tfor ( Operation op : ops ) { tif ( first ) { tfirst = false ; } else { trv . append ( " , " ) ; } tMemcachedNode node = op = = null ? null : op . getHandlingNode ( ) ; trv . append ( node = = null ? " <unknown> " : node . getSocketAddress ( ) ) ; } treturn rv . toString ( ) ; } 
public void testNullNode ( ) { tOperation op = new TestOperation ( ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " , 
public void testNullOperation ( ) { tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " , 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tboolean shouldOptimize ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tboolean shouldOptimize ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tboolean shouldOptimize ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tboolean shouldOptimize ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tboolean shouldOptimize ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tboolean shouldOptimize ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tboolean shouldOptimize ( ) ; } 
tlong getOperationTimeout ( ) ; tboolean shouldOptimize ( ) ; } 
tboolean isDaemon ( ) ; tboolean shouldOptimize ( ) ; } 
tboolean useNagleAlgorithm ( ) ; tboolean shouldOptimize ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tboolean shouldOptimize ( ) ; } 
tFailureMode getFailureMode ( ) ; tboolean shouldOptimize ( ) ; } 
tTranscoder < Object > getDefaultTranscoder ( ) ; tboolean shouldOptimize ( ) ; } 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tqa . fillWriteBuffer ( shouldOptimize ) ; tboolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; twhile ( canWriteMore ) { tint wrote = qa . writeSome ( ) ; 
public final void fillWriteBuffer ( boolean shouldOptimize ) { tif ( toWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { tgetWbuf ( ) . clear ( ) ; 
public MemcachedConnection createConnection ( tList < InetSocketAddress > addrs ) throws IOException { tMemcachedConnection rv = super . createConnection ( addrs ) ; treturn rv ; } 
public boolean shouldOptimize ( ) { treturn false ; } 
public boolean cancel ( boolean mayInterruptIfRunning ) { treturn false ; } 
public Boolean get ( ) throws InterruptedException , ExecutionException { tif ( exception ! = null ) { tthrow exception ; } treturn value ; } 
public Boolean get ( long timeout , TimeUnit unit ) tthrows InterruptedException , ExecutionException , tTimeoutException { tif ( exception ! = null ) { tthrow exception ; } treturn value ; } 
public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { tFuture < Boolean > mostRecent = null ; twhile ( i . hasNext ( ) ) { tMap . Entry < String , T > e = i . next ( ) ; tboolean stored = false ; twhile ( ! stored ) { ttry { tmostRecent = client . set ( e . getKey ( ) , expiration , te . getValue ( ) ) ; tstored = true ; twatch ( e . getKey ( ) , mostRecent ) ; } catch ( IllegalStateException ex ) { } 
public < T > Future < ? > loadData ( Map < String , T > map ) { treturn loadData ( map . entrySet ( ) . iterator ( ) ) ; } 
private void watch ( final String key , final Future < Boolean > f ) { tif ( executorService ! = null & & storageListener ! = null ) { texecutorService . execute ( new Runnable ( ) { 
public void run ( ) { ttry { tstorageListener . storeResult ( key , f . get ( ) ) ; 
tvoid storeResult ( String k , boolean result ) ; tvoid errorStoring ( String k , Exception e ) ; } } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tBlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; tes = new ThreadPoolExecutor ( 10 , 10 , 5 , TimeUnit . MINUTES , wq ) ; } 
tprotected void tearDown ( ) throws Exception { tes . shutdownNow ( ) ; tsuper . tearDown ( ) ; } 
public void testSimpleLoading ( ) throws Exception { tMock m = mock ( MemcachedClientIF . class ) ; tLoadCounter sl = new LoadCounter ( ) ; tCacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , tes , sl , 0 ) ; tm . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( true ) ) ) ; tm . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( throwException ( new IllegalStateException ( " Full up " ) ) ) ; tm . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; tm . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; tMap < String , Object > map = new HashMap < String , Object > ( ) ; tmap . put ( " a " , 1 ) ; tmap . put ( " b " , 2 ) ; tmap . put ( " c " , 3 ) ; } 
public void errorStoring ( String k , Exception e ) { texceptions + + ; } 
public void storeResult ( String k , boolean result ) { tif ( result ) { tsuccess + + ; 
public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { tFuture < Boolean > mostRecent = null ; twhile ( i . hasNext ( ) ) { tMap . Entry < String , T > e = i . next ( ) ; tmostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; twatch ( e . getKey ( ) , mostRecent ) ; } treturn mostRecent = = null ? new ImmediateFuture ( true ) : mostRecent ; } 
public < T > Future < Boolean > push ( String k , T value ) { tFuture < Boolean > rv = null ; twhile ( rv = = null ) { ttry { trv = client . set ( k , expiration , value ) ; } catch ( IllegalStateException ex ) { } 
public void init ( ) throws Exception { tclient = new MemcachedClient ( tnew BinaryConnectionFactory ( ) , 
public void shutdown ( ) throws Exception { tclient . shutdown ( ) ; } 
public void run ( ) { tCacheLoader cl = new CacheLoader ( client ) ; tFuture < Boolean > f = null ; tfor ( int i = 0 ; i < count ; i + + ) { tf = cl . push ( " k " + i , " some value " ) ; } tif ( f ! = null ) { ttry { 
public static void main ( String [ ] a ) throws Exception { tLoaderTest lt = new LoaderTest ( 1000000 ) ; tlt . init ( ) ; tlong start = System . currentTimeMillis ( ) ; ttry { tlt . run ( ) ; } finally { tlt . shutdown ( ) ; } tlong end = System . currentTimeMillis ( ) ; tSystem . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; } 
public final Operation removeCurrentWriteOp ( ) { tOperation rv = optimizedOp ; tif ( rv = = null ) { trv = writeQ . remove ( ) ; } else { toptimizedOp = null ; } treturn rv ; } 
public final boolean hasWriteOp ( ) { treturn ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; } 
tprotected void optimize ( ) { optimizedOp=writeQ.remove(); 
tprotected void optimize ( ) { tOperation firstOp = writeQ . peek ( ) ; tif ( firstOp instanceof GetOperation ) { toptimizeGets ( ) ; 
private void optimizeGets ( ) { OptimizedGetImpl og=new OptimizedGetImpl( 
private void optimizeSets ( ) { OptimizedSetImpl og=new OptimizedSetImpl( 
public void addOperation ( CASOperation op ) { tops . add ( op ) ; } 
public void initialize ( ) { } 
private static int cmdMap ( StoreType ) { tint rv = - 1 ; tswitch ( ) { tcase set : rv = StoreOperationImpl . SETQ ; break ; tcase add : rv = StoreOperationImpl . ADDQ ; break ; tcase replace : rv = StoreOperationImpl . REPLACEQ ; break ; } } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tfor ( OperationCallback cb : callbacks . values ( ) ) { tcb . receivedStatus ( STATUS_OK ) ; tcb . complete ( ) ; } ttransitionState ( OperationState . COMPLETE ) ; } else { tSystem . out . println ( " Got " + errorCode + " for " + responseOpaque ) ; tOperationCallback cb = callbacks . remove ( responseOpaque ) ; tassert errorCode ! = 0 : " Got no error on a quiet mutation. " ; tOperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; tassert status ! = null : " Got no status for a quiet mutation error " ; tcb . receivedStatus ( status ) ; tcb . complete ( ) ; } tresetInput ( ) ; } 
tprotected boolean opaqueIsValid ( ) { treturn responseOpaque = = terminalOpaque | | callbacks . containsKey ( responseOpaque ) ; 
public void complete ( ) { }} 
public void receivedStatus ( OperationStatus status ) { }} 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; public HashAlgorithm getHashAlg ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; public HashAlgorithm getHashAlg ( ) ; } 
tOperationFactory getOperationFactory ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tlong getOperationTimeout ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tboolean isDaemon ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tboolean useNagleAlgorithm ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tFailureMode getFailureMode ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tTranscoder < Object > getDefaultTranscoder ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tboolean shouldOptimize ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tint getReadBufSize ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
public ConnectionFactoryBuilder setInitialObservers ( tCollection < ConnectionObserver > obs ) { tinitialObservers = obs ; treturn this ; } 
public ConnectionFactory build ( ) { treturn new DefaultConnectionFactory ( ) { 
public BlockingQueue < Operation > createOperationQueue ( ) { treturn opQueue = = null ? tsuper . createOperationQueue ( ) : opQueue ; 
public BlockingQueue < Operation > createReadOperationQueue ( ) { treturn readOpQueue = = null ? tsuper . createReadOperationQueue ( ) : readOpQueue ; 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { treturn writeOpQueue = = null ? tsuper . createWriteOperationQueue ( ) : writeOpQueue ; 
public boolean shouldOptimize ( ) { treturn shouldOptimize ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tb = new ConnectionFactoryBuilder ( ) ; } 
public void testDefaults ( ) { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tassertTrue ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; } 
public void testModifications ( ) { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { } 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public void testCorrectTypes ( ) { tConnectionFactory factory = new KetamaConnectionFactory ( ) ; tNodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; tassertTrue ( locator instanceof KetamaNodeLocator ) ; tassertEquals ( HashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; } 
public BlockingQueue < Operation > createOperationQueue ( ) { treturn opQueueFactory = = null ? tsuper . createOperationQueue ( ) : opQueueFactory . create ( ) ; 
public BlockingQueue < Operation > createReadOperationQueue ( ) { treturn readQueueFactory = = null ? tsuper . createReadOperationQueue ( ) 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { treturn writeQueueFactory = = null ? tsuper . createReadOperationQueue ( ) 
public BlockingQueue < Operation > create ( ) { treturn new ArrayBlockingQueue < Operation > ( capacity ) ; } 
public BlockingQueue < Operation > create ( ) { treturn new LinkedBlockingQueue < Operation > ( ) ; } 
public void testModifications ( ) { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { } 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public BlockingQueue < Operation > create ( ) { treturn queue ; } 
public boolean useNagleAlgorithm ( ) { treturn useNagle ; } 
public void testDefaults ( ) { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tassertTrue ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; tassertFalse ( f . useNagleAlgorithm ( ) ) ; } 
public void testModifications ( ) { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { } 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { tOperationFactory of = getOperationFactory ( ) ; tif ( of instanceof AsciiOperationFactory ) { treturn new AsciiMemcachedNodeImpl ( sa , c , bufSize , 
public void testDefaults ( ) throws Exception { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tSocketChannel sc = SocketChannel . open ( ) ; ttry { tassertTrue ( f . createMemcachedNode ( tInetSocketAddress . createUnresolved ( " localhost " , 11211 ) , tsc , 1 ) tinstanceof AsciiMemcachedNodeImpl ) ; } finally { tsc . close ( ) ; } tassertTrue ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; tassertFalse ( f . useNagleAlgorithm ( ) ) ; } 
public void testModifications ( ) throws Exception { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public void testProtocolSetterBinary ( ) { tassertTrue ( tb . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( ) 
public void testProtocolSetterText ( ) { tassertTrue ( tb . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( ) 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; public HashAlgorithm getHashAlg ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { tswitch ( locator ) { tcase ARRAY_MOD : 
public void testDefaults ( ) throws Exception { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tMemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; tassertTrue ( f . createLocator ( Collections . singletonList ( ) ) tinstanceof ArrayModNodeLocator ) ; tSocketChannel sc = SocketChannel . open ( ) ; ttry { tassertTrue ( f . createMemcachedNode ( tInetSocketAddress . createUnresolved ( " localhost " , 11211 ) , tsc , 1 ) tinstanceof AsciiMemcachedNodeImpl ) ; } finally { tsc . close ( ) ; } tassertTrue ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; tassertFalse ( f . useNagleAlgorithm ( ) ) ; } 
public void testModifications ( ) throws Exception { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public void addOperation ( CASOperation op ) { tops . add ( op ) ; + keylen + op.getBytes().length; 
public void initialize ( ) { } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tDeleteOperation delete ( String key , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tFlushOperation flush ( int delay , OperationCallback operationCallback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; } 
public String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; } 
tstatic int generateOpaque ( ) { tint rv = seqNumber . incrementAndGet ( ) ; twhile ( rv < 0 ) { tseqNumber . compareAndSet ( rv , 0 ) ; trv = seqNumber . incrementAndGet ( ) ; } treturn rv ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tlong getMaxReconnectDelay ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tlong getMaxReconnectDelay ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tlong getMaxReconnectDelay ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tlong getOperationTimeout ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tboolean isDaemon ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tboolean useNagleAlgorithm ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tFailureMode getFailureMode ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tTranscoder < Object > getDefaultTranscoder ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tboolean shouldOptimize ( ) ; tlong getMaxReconnectDelay ( ) ; } 
tint getReadBufSize ( ) ; tlong getMaxReconnectDelay ( ) ; } 
public HashAlgorithm getHashAlg ( ) ; tlong getMaxReconnectDelay ( ) ; } 
public void testOverflowingReadQueue ( ) throws Exception { tbyte [ ] b = new byte [ 8192 ] ; tRandom r = new Random ( ) ; tr . nextBytes ( b ) ; tclient . set ( " x " , 0 , b ) ; tCollection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; ttry { tfor ( int i = 0 ; i < 1000 ; i + + ) { tc . add ( client . asyncGet ( " x " ) ) ; } tfail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tfor ( OperationCallback cb : callbacks . values ( ) ) { tcb . receivedStatus ( STATUS_OK ) ; tcb . complete ( ) ; } ttransitionState ( OperationState . COMPLETE ) ; } else { tOperationCallback cb = callbacks . remove ( responseOpaque ) ; tassert errorCode ! = 0 : " Got no error on a quiet mutation. " ; tOperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; tassert status ! = null : " Got no status for a quiet mutation error " ; tcb . receivedStatus ( status ) ; tcb . complete ( ) ; } tresetInput ( ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { tb = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { tb = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { tb = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { tb = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { tb = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { tb = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { tb = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { tb = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { tb = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { tb = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { tb = encodeCharacter ( ( Character ) o ) ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . info ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public void testByteArray ( ) throws Exception { tbyte [ ] a = { 'a' , 'b' , 'c' } ; tCachedData cd = getTranscoder ( ) . encode ( a ) ; tbyte [ ] decoded = ( byte [ ] ) getTranscoder ( ) . decode ( cd ) ; tassertNotNull ( decoded ) ; tassertTrue ( Arrays . equals ( a , decoded ) ) ; } 
public final void transitionWriteItem ( ) { tOperation op = removeCurrentWriteOp ( ) ; tassert op ! = null : " There is no write item to transition " ; tgetLogger ( ) . debug ( " Finished writing %s " , op ) ; } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( responseOpaque = = terminalOpaque ) { tfor ( OperationCallback cb : callbacks . values ( ) ) { tcb . receivedStatus ( STATUS_OK ) ; tcb . complete ( ) ; } ttransitionState ( OperationState . COMPLETE ) ; } else { tOperationCallback cb = callbacks . remove ( responseOpaque ) ; tassert cb ! = null : " No callback for " + responseOpaque ; tassert errorCode ! = 0 : " Got no error on a quiet mutation. " ; tOperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; tassert status ! = null : " Got no status for a quiet mutation error " ; tcb . receivedStatus ( status ) ; tcb . complete ( ) ; } tresetInput ( ) ; } 
public void run ( ) { tint nullKey = 0 ; + " (" + nullKey + " were null)"); 
public static void main ( String [ ] args ) throws Exception { tnew ExcessivelyLargeGetTest ( ) . run ( ) ; } 
public void testThree ( ) throws Exception { tList < InetSocketAddress > addrs = tAddrUtil . getAddresses ( " , www.google.com:80 ,, ,, www.yahoo.com:81 , ,, " ) ; tassertEquals ( 2 , addrs . size ( ) ) ; tassertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; tassertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; tassertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; tassertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; } 
public void testIPv6Host ( ) throws Exception { tList < InetSocketAddress > addrs = tAddrUtil . getAddresses ( " ::1:80 " ) ; tassertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; tvalidLocalhostNames . add ( " localhost " ) ; tvalidLocalhostNames . add ( " ip6-localhost " ) ; tvalidLocalhostNames . add ( " localhost6.localdomain6 " ) ; tassert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; tassertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
public void authenticate ( final String username , final String password ) tthrows OperationException { tfinal ConcurrentLinkedQueue < OperationStatus > statuses = tnew ConcurrentLinkedQueue < OperationStatus > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , tn . toString ( ) , null , tnew PlainCallbackHandler ( username , password , tlatch , statuses ) ) ; treturn op ; } } ) ; ttry { tblatch . await ( ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tfor ( OperationStatus status : statuses ) { tif ( ! status . isSuccess ( ) ) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , tn . toString ( ) , null , tnew PlainCallbackHandler ( username , password , tlatch , statuses ) ) ; treturn op ; } } ) ; 
public void receivedStatus ( OperationStatus s ) { }} 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tvoid authenticate ( String username , String password ) tthrows OperationException ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , AuthHandlerBridge cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLStepOperation saslStep ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public void handle ( Callback [ ] callbacks ) throws IOException , tUnsupportedCallbackException { tfor ( Callback cb : callbacks ) { if ( cb instanceof TextOutputCallback ) { 
public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } 
public SASLMechsOperation saslMechs ( OperationCallback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLStepOperation saslStep ( OperationCallback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , AuthHandlerBridge cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , AuthHandlerBridge cb ) { treturn new SASLAuthOperationImpl ( mech , serverName , props , cb ) ; } 
public SASLMechsOperation saslMechs ( OperationCallback cb ) { treturn new SASLMechsOperationImpl ( cb ) ; } 
public void initialize ( ) { ttry { tSaslClient sc = Sasl . createSaslClient ( mech , null , 
tprotected void decodePayload ( byte [ ] pl ) { tgetLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tgetCallback ( ) . receivedStatus ( tnew OperationStatus ( true , new String ( pl ) ) ) ; 
public void run ( ) { ttry { tclient . authenticate ( username , password ) ; 
public static void main ( String [ ] a ) throws Exception { tAuthTest lt = new AuthTest ( " testuser " , " testpass " ) ; tlt . init ( ) ; tlong start = System . currentTimeMillis ( ) ; ttry { tlt . run ( ) ; } finally { tlt . shutdown ( ) ; } tlong end = System . currentTimeMillis ( ) ; tSystem . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; } 
public void authenticate ( final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentLinkedQueue < OperationStatus > statuses = tnew ConcurrentLinkedQueue < OperationStatus > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , tn . toString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; treturn op ; } } ) ; ttry { tblatch . await ( ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tfor ( OperationStatus status : statuses ) { tif ( ! status . isSuccess ( ) ) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , tn . toString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; treturn op ; } } ) ; 
public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tvoid authenticate ( final CallbackHandler cbh ) tthrows OperationException ; } 
tGetOperation get ( String key , GetOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { treturn new SASLAuthOperationImpl ( mech , serverName , props , cbh , cb ) ; } 
public void run ( ) { ttry { tclient . authenticate ( new PlainCallbackHandler ( username , password ) ) ; 
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentLinkedQueue < OperationStatus > statuses = tnew ConcurrentLinkedQueue < OperationStatus > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( mechs , tn . toString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; treturn op ; } } ) ; ttry { tblatch . await ( ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tfor ( OperationStatus status : statuses ) { tif ( ! status . isSuccess ( ) ) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . saslAuth ( mechs , tn . toString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . add ( status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; treturn op ; } } ) ; 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tboolean removeObserver ( ConnectionObserver obs ) ; tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; } 
public void run ( ) { ttry { tclient . authenticate ( new String [ ] { " PLAIN " } , 
tCountDownLatch broadcastOp ( final BroadcastOpFactory of ) { treturn broadcastOp ( of , conn . getLocator ( ) . getAll ( ) , true ) ; } 
tCountDownLatch broadcastOp ( final BroadcastOpFactory of , tCollection < MemcachedNode > nodes ) { treturn broadcastOp ( of , nodes , true ) ; } 
private CountDownLatch broadcastOp ( BroadcastOpFactory of , tCollection < MemcachedNode > nodes , tboolean checkShuttingDown ) { tif ( checkShuttingDown & & shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } treturn conn . broadcastOperation ( of , nodes ) ; } 
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = tnew ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; tCollection < MemcachedNode > todo = conn . getLocator ( ) . getAll ( ) ; tBroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tif ( statuses . containsKey ( ) ) { treturn opFact . saslStep ( null ) ; if (!status.isSuccess()) { 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tif ( statuses . containsKey ( ) ) { treturn opFact . saslStep ( null ) ; TODO 
public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . noop ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here 
public void receivedStatus ( OperationStatus s ) { }} 
public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { treturn broadcastOperation ( of , locator . getAll ( ) ) ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , tCollection < MemcachedNode > nodes ) { tfinal CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; tfor ( MemcachedNode node : nodes ) { tOperation op = of . newOp ( node , latch ) ; top . initialize ( ) ; tnode . addOp ( op ) ; top . setHandlingNode ( node ) ; taddedQueue . offer ( node ) ; } tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; treturn latch ; } 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( errorCode = = SASL_CONTINUE ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , 
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = tnew ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; tCollection < MemcachedNode > todo = new ArrayList < MemcachedNode > ( tconn . getLocator ( ) . getAll ( ) ) ; tBroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ; tif ( statuses . containsKey ( ) ) { tOperationStatus priorStatus = statuses . remove ( ) ; treturn opFact . saslStep ( mechs , priorStatus . getMessage ( ) , tn . toString ( ) , null , cbh , cb ) ; } else { treturn opFact . saslAuth ( mechs , . toString ( ) , null , cbh , cb ) ; } } } ; tboolean done = false ; twhile ( ! done ) { tCountDownLatch blatch = broadcastOp ( bfact , todo ) ; 
public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ; tif ( statuses . containsKey ( ) ) { tOperationStatus priorStatus = statuses . remove ( ) ; 
public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } 
public void complete ( ) { tlatch . countDown ( ) ; } 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLStepOperation saslStep ( String [ ] mech , String challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public SASLStepOperation saslStep ( String [ ] mech , String challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLStepOperation saslStep ( String [ ] mech , String challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) { treturn new SASLStepOperationImpl ( mech , challenge , serverName , tprops , cbh , cb ) ; 
public void run ( ) { ttry { tclient . authenticate ( new String [ ] { " CRAM-MD5 " } , 
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = tnew ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; tCollection < MemcachedNode > todo = new ArrayList < MemcachedNode > ( tconn . getLocator ( ) . getAll ( ) ) ; tBroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ; tif ( statuses . containsKey ( ) ) { tOperationStatus priorStatus = statuses . remove ( ) ; treturn opFact . saslStep ( mechs , tKeyUtil . getKeyBytes ( priorStatus . getMessage ( ) ) , tn . toString ( ) , null , cbh , cb ) ; } else { treturn opFact . saslAuth ( mechs , . toString ( ) , null , cbh , cb ) ; } } } ; tboolean done = false ; twhile ( ! done ) { tCountDownLatch blatch = broadcastOp ( bfact , todo ) ; 
tGetsOperation gets ( String key , GetsOperation . Callback callback ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tConcatenationOperation cat ( ConcatenationType catType , long casId , tString key , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tSASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) { tthrow new UnsupportedOperationException ( ) ; } 
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) { treturn new SASLStepOperationImpl ( mech , challenge , serverName , tprops , cbh , cb ) ; 
public Operation newOp ( MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . saslMechs ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tvoid authenticate ( String mechs [ ] , CallbackHandler cbh ) tthrows OperationException ; tSet < String > listSaslMechanisms ( ) ; } 
public void run ( ) { ttry { tSystem . out . println ( " Available mechs: " 
public void handle ( Callback [ ] callbacks ) throws IOException , tUnsupportedCallbackException { tfor ( Callback cb : callbacks ) { tif ( cb instanceof TextOutputCallback ) { 
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) tthrows OperationException { tfinal ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = tnew ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; tCollection < MemcachedNode > todo = new ArrayList < MemcachedNode > ( tconn . getLocator ( ) . getAll ( ) ) ; tBroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tfinal OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { tstatuses . put ( , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ; tif ( statuses . containsKey ( ) ) { tOperationStatus priorStatus = statuses . remove ( ) ; treturn opFact . saslStep ( mechs , tKeyUtil . getKeyBytes ( priorStatus . getMessage ( ) ) , tn . getSocketAddress ( ) . toString ( ) , null , cbh , cb ) ; } else { treturn opFact . saslAuth ( mechs , . getSocketAddress ( ) . toString ( ) , null , cbh , cb ) ; } } } ; tboolean done = false ; twhile ( ! done ) { tCountDownLatch blatch = broadcastOp ( bfact , todo ) ; 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tlong getOperationTimeout ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tboolean isDaemon ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tboolean useNagleAlgorithm ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tFailureMode getFailureMode ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tTranscoder < Object > getDefaultTranscoder ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tboolean shouldOptimize ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tint getReadBufSize ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
public HashAlgorithm getHashAlg ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tlong getMaxReconnectDelay ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { tif ( authDescriptor ! = null ) { tnew AuthThread ( conn , opFact , authDescriptor , findNode ( sa ) ) ; 
public void connectionLost ( SocketAddress sa ) { }} 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
public void insertOperation ( final MemcachedNode node , final Operation o ) { to . setHandlingNode ( node ) ; to . initialize ( ) ; tnode . insertOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
tvoid copyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
tCollection < Operation > destroyInputQueue ( ) ; tvoid fixupOps ( ) ; } 
tvoid setupResend ( ) ; tvoid fixupOps ( ) ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tvoid fixupOps ( ) ; } 
tvoid transitionWriteItem ( ) ; tvoid fixupOps ( ) ; } 
tOperation getCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation removeCurrentReadOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation getCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tOperation removeCurrentWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasReadOp ( ) ; tvoid fixupOps ( ) ; } 
tboolean hasWriteOp ( ) ; tvoid fixupOps ( ) ; } 
tvoid addOp ( Operation op ) ; tvoid fixupOps ( ) ; } 
tvoid insertOp ( Operation o ) ; tvoid fixupOps ( ) ; } 
public void insertOp ( Operation op ) { tthrow new UnsupportedOperationException ( ) ; } 
public static AuthDescriptor typical ( String u , String p ) { treturn new AuthDescriptor ( new String [ ] { " CRAM-MD5 " , " PLAIN " } , tnew PlainCallbackHandler ( u , p ) ) ; 
public void run ( ) { tOperationStatus priorStatus = null ; tfinal AtomicBoolean done = new AtomicBoolean ( ) ; twhile ( ! done . get ( ) ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; 
private Operation buildOperation ( OperationStatus st , OperationCallback cb ) { tif ( st = = null ) { treturn opFact . saslAuth ( authDescriptor . mechs , 
public final void insertOp ( Operation op ) { tArrayList < Operation > tmp = new ArrayList < Operation > ( tinputQueue . size ( ) + 1 ) ; ttmp . add ( op ) ; tinputQueue . drainTo ( tmp ) ; tinputQueue . addAll ( tmp ) ; } 
public void init ( ) throws Exception { tclient = new MemcachedClient ( tnew ConnectionFactoryBuilder ( ) 
public void run ( ) { tSystem . out . println ( " Available mechs: " + client . listSaslMechanisms ( ) ) ; ttry { tThread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { te . printStackTrace ( ) ; } tclient . getVersions ( ) ; } 
public final void addOp ( Operation op ) { tif ( opQueueMaxBlockTimeNs = = null ) { tif ( ! inputQueue . offer ( op ) ) 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 , null , HashAlgorithm . FNV1_64_HASH ) ; } 
private void runOverflowTest ( byte b [ ] ) throws Exception { tCollection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; ttry { tfor ( int i = 0 ; i < 1000 ; i + + ) { tc . add ( client . set ( " k " + i , 0 , b ) ) ; } tfail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { client.set("kx", 0, "woo").get(10, TimeUnit.SECONDS)); 
public final void addOp ( Operation op ) { ttry { tif ( ! inputQueue . offer ( op , opQueueMaxBlockTime , 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 , 0 , tHashAlgorithm . FNV1_64_HASH ) ; 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
tlong getOpQueueMaxBlockTime ( ) ; tAuthDescriptor getAuthDescriptor ( ) ; } 
public void testDefaults ( ) throws Exception { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tMemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; tassertTrue ( f . createLocator ( Collections . singletonList ( ) ) tinstanceof ArrayModNodeLocator ) ; tSocketChannel sc = SocketChannel . open ( ) ; ttry { tassertTrue ( f . createMemcachedNode ( tInetSocketAddress . createUnresolved ( " localhost " , 11211 ) , tsc , 1 ) tinstanceof AsciiMemcachedNodeImpl ) ; } finally { tsc . close ( ) ; } tassertTrue ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; tassertFalse ( f . useNagleAlgorithm ( ) ) ; tassertEquals ( f . getOpQueueMaxBlockTime ( ) , tDefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; 
public void testModifications ( ) throws Exception { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { tnew BinaryConnectionFactory ( 5 , 5 , tHashAlgorithm . FNV1_64_HASH ) ; 
tprotected byte [ ] buildResponse ( SaslClient sc ) throws SaslException { treturn sc . hasInitialResponse ( ) ? tsc . evaluateChallenge ( challenge ) 
tprotected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override tprotected void decodePayload ( byte [ ] pl ) { tgetLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( errorCode = = SASL_CONTINUE ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tnew String ( pl ) ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , " " ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } else { tsuper . finishedPayload ( pl ) ; } } } 
tprotected byte [ ] buildResponse ( SaslClient sc ) throws SaslException { treturn sc . evaluateChallenge ( challenge ) ; 
private MemcachedNode [ ] mockNodes ( String servers [ ] ) { tsetupNodes ( servers . length ) ; tfor ( int i = 0 ; i < nodeMocks . length ; i + + ) { tList < InetSocketAddress > a = AddrUtil . getAddresses ( servers [ i ] ) ; tnodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( a . iterator ( ) . next ( ) ) ) ; } treturn nodes ; } 
tMemcachedConnection createConnection ( List < InetSocketAddress > addrs ) tthrows IOException ; tint getTimeoutExceptionThreshold ( ) ; } 
tMemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tBlockingQueue < Operation > createOperationQueue ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tBlockingQueue < Operation > createReadOperationQueue ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tBlockingQueue < Operation > createWriteOperationQueue ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tlong getOpQueueMaxBlockTime ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tNodeLocator createLocator ( List < MemcachedNode > nodes ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tOperationFactory getOperationFactory ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tlong getOperationTimeout ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tboolean isDaemon ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tboolean useNagleAlgorithm ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tCollection < ConnectionObserver > getInitialObservers ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tFailureMode getFailureMode ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tTranscoder < Object > getDefaultTranscoder ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tboolean shouldOptimize ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tint getReadBufSize ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
public HashAlgorithm getHashAlg ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tlong getMaxReconnectDelay ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
tAuthDescriptor getAuthDescriptor ( ) ; tint getTimeoutExceptionThreshold ( ) ; } 
public void handleIO ( ) throws IOException { tif ( shutDown ) { tthrow new IOException ( " No IO while shut down " ) ; } attemptReconnects(); 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { } 
public void testDefaults ( ) throws Exception { tConnectionFactory f = b . build ( ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , tf . getOperationTimeout ( ) ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , tf . getReadBufSize ( ) ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; tassertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; tassertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , tf . getFailureMode ( ) ) ; tassertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; tassertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; tBlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; tassertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; tassertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , topQueue . remainingCapacity ( ) ) ; tBlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; tassertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; tBlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; tassertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; tMemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; tassertTrue ( f . createLocator ( Collections . singletonList ( ) ) tinstanceof ArrayModNodeLocator ) ; tSocketChannel sc = SocketChannel . open ( ) ; ttry { tassertTrue ( f . createMemcachedNode ( tInetSocketAddress . createUnresolved ( " localhost " , 11211 ) , tsc , 1 ) tinstanceof AsciiMemcachedNodeImpl ) ; } finally { tsc . close ( ) ; } tassertFalse ( f . isDaemon ( ) ) ; tassertTrue ( f . shouldOptimize ( ) ) ; tassertFalse ( f . useNagleAlgorithm ( ) ) ; tassertEquals ( f . getOpQueueMaxBlockTime ( ) , tDefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; 
public void testModifications ( ) throws Exception { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; tByteBuffer rbuf = qa . getRbuf ( ) ; tfinal SocketChannel channel = qa . getChannel ( ) ; tint read = channel . read ( rbuf ) ; tif ( read < 0 ) { getLogger().debug("Read %d bytes", read); 
public MemcachedNode createMemcachedNode ( SocketAddress sa , tSocketChannel c , int bufSize ) { tboolean doAuth = false ; treturn new BinaryMemcachedNodeImpl ( sa , c , bufSize , tcreateReadOperationQueue ( ) , 
tCollection < Operation > destroyInputQueue ( ) ; tvoid setupForAuth ( ) ; } 
tvoid setupResend ( ) ; tvoid setupForAuth ( ) ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tvoid setupForAuth ( ) ; } 
tvoid transitionWriteItem ( ) ; tvoid setupForAuth ( ) ; } 
tOperation getCurrentReadOp ( ) ; tvoid setupForAuth ( ) ; } 
tOperation removeCurrentReadOp ( ) ; tvoid setupForAuth ( ) ; } 
tOperation getCurrentWriteOp ( ) ; tvoid setupForAuth ( ) ; } 
tOperation removeCurrentWriteOp ( ) ; tvoid setupForAuth ( ) ; } 
tboolean hasReadOp ( ) ; tvoid setupForAuth ( ) ; } 
tboolean hasWriteOp ( ) ; tvoid setupForAuth ( ) ; } 
tvoid addOp ( Operation op ) ; tvoid setupForAuth ( ) ; } 
tvoid insertOp ( Operation o ) ; tvoid setupForAuth ( ) ; } 
tint getSelectionOps ( ) ; tvoid setupForAuth ( ) ; } 
tByteBuffer getRbuf ( ) ; tvoid setupForAuth ( ) ; } 
tByteBuffer getWbuf ( ) ; tvoid setupForAuth ( ) ; } 
tSocketAddress getSocketAddress ( ) ; tvoid setupForAuth ( ) ; } 
tboolean isActive ( ) ; tvoid setupForAuth ( ) ; } 
tvoid reconnecting ( ) ; tvoid setupForAuth ( ) ; } 
tvoid connected ( ) ; tvoid setupForAuth ( ) ; } 
tint getReconnectCount ( ) ; tvoid setupForAuth ( ) ; } 
tvoid registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; tvoid setupForAuth ( ) ; } 
tvoid setChannel ( SocketChannel to ) ; tvoid setupForAuth ( ) ; } 
tSocketChannel getChannel ( ) ; tvoid setupForAuth ( ) ; } 
tvoid setSk ( SelectionKey to ) ; tvoid setupForAuth ( ) ; } 
tSelectionKey getSk ( ) ; tvoid setupForAuth ( ) ; } 
tint getBytesRemainingToWrite ( ) ; tvoid setupForAuth ( ) ; } 
tint writeSome ( ) throws IOException ; tvoid setupForAuth ( ) ; } 
tvoid fixupOps ( ) ; tvoid setupForAuth ( ) ; } 
tvoid authComplete ( ) ; tvoid setupForAuth ( ) ; } 
public void authComplete ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public void setupForAuth ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public final void addOp ( Operation op ) { ttry { tauthLatch . await ( ) ; 
public final void authComplete ( ) { tif ( reconnectBlocked ! = null & & reconnectBlocked . size ( ) > 0 ) { inputQueue . addAll ( reconnectBlocked ) ; } tauthLatch . countDown ( ) ; } 
public final void setupForAuth ( ) { tif ( shouldAuth ) { tauthLatch = new CountDownLatch ( 1 ) ; 
public void fixupOps ( ) { }} 
public void authComplete ( ) { }} 
public void verifySetAndGet ( ) { tint iterations = 20 ; tfor ( int i = 0 ; i < iterations ; i + + ) { mc . set ( " test " + i , 0 , " test " + i ) ; } tfor ( int i = 0 ; i < iterations ; i + + ) { Object res = mc . get ( " test " + i ) ; 
public void verifySetAndGet2 ( ) { ttry { int iterations = 50000 ; 
public void testModifications ( ) throws Exception { tConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }} 
public boolean hasReadOp ( ) { treturn root . hasReadOp ( ) ; } 
public boolean hasWriteOp ( ) { treturn root . hasReadOp ( ) ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { tif ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) { 
public boolean authThresholdReached ( ) { tif ( allowedAuthAttempts < 0 ) { treturn false ; negative value means auth forever 
public synchronized void authConnection ( MemcachedConnection conn , tOperationFactory opFact , AuthDescriptor authDescriptor , MemcachedNode node ) { tinterruptOldAuth ( node ) ; tAuthThread newSASLAuthenticator = new AuthThread ( conn , opFact , tauthDescriptor , node ) ; tnodeMap . put ( node , newSASLAuthenticator ) ; } 
private void interruptOldAuth ( MemcachedNode nodeToStop ) { tAuthThread toStop = nodeMap . get ( nodeToStop ) ; tif ( toStop ! = null ) { tif ( toStop . isAlive ( ) ) { 
public final void addOp ( Operation op ) { ttry { tif ( ! authLatch . await ( 1 , TimeUnit . SECONDS ) ) { 
public void verifySetAndGet2 ( int iterations ) { ttry { for ( int i = 0 ; i < = iterations ; i + + ) { 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( " 127.0.0.1:64213 " ) ) ; 
public void testUnavailableServers ( ) { tclient . asyncGet ( " x " ) ; tassertEquals ( new ArrayList < String > ( tCollections . singleton ( " /127.0.0.1:64213 " ) ) , 
public void testMultipleOperation ( ) { tCollection < Operation > ops = new ArrayList < Operation > ( ) ; tops . add ( buildOp ( 11211 ) ) ; tops . add ( buildOp ( 64212 ) ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: localhost:11211, localhost:64212 " , 
tvoid setupResend ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid fillWriteBuffer ( boolean optimizeGets ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid transitionWriteItem ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tOperation getCurrentReadOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tOperation removeCurrentReadOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tOperation getCurrentWriteOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tOperation removeCurrentWriteOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tboolean hasReadOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tboolean hasWriteOp ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid addOp ( Operation op ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid insertOp ( Operation o ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tint getSelectionOps ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tByteBuffer getRbuf ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tByteBuffer getWbuf ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tSocketAddress getSocketAddress ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tboolean isActive ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid reconnecting ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid connected ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tint getReconnectCount ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid setChannel ( SocketChannel to ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tSocketChannel getChannel ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid setSk ( SelectionKey to ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tSelectionKey getSk ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tint getBytesRemainingToWrite ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tint writeSome ( ) throws IOException ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid fixupOps ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid authComplete ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid setupForAuth ( ) ; tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
tvoid setContinuousTimeout ( boolean timedOut ) ; tint getContinuousTimeout ( ) ; } 
public final void reconnecting ( ) { treconnectAttempt + + ; tcontinuousTimeout . set ( 0 ) ; } 
public final void connected ( ) { treconnectAttempt = 0 ; tcontinuousTimeout . set ( 0 ) ; } 
public final void initialize ( ) { } 
public static byte [ ] computeMd5 ( String k ) { tMessageDigest md5 ; ttry { tmd5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { tthrow new RuntimeException ( " MD5 not supported " , e ) ; } tmd5 . update ( KeyUtil . getKeyBytes ( k ) ) ; treturn md5 . digest ( ) ; } 
public static byte [ ] computeMd5 ( String k ) { tMessageDigest md5 ; ttry { tmd5 = ( MessageDigest ) MD5_DIGEST . clone ( ) ; } catch ( CloneNotSupportedException e ) { tthrow new RuntimeException ( " clone of MD5 not supported " , e ) ; } tmd5 . update ( KeyUtil . getKeyBytes ( k ) ) ; treturn md5 . digest ( ) ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tBlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; tes = new ThreadPoolExecutor ( 10 , 10 , 5 * 60 , TimeUnit . SECONDS , wq ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tfinal Transcoder < T > tc ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { treturn asyncGetBulk ( keys , transcoder ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; } 
public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { treturn asyncGetBulk ( Arrays . asList ( keys ) , transcoder ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
public boolean isTimeout ( ) ; public V getSome ( long timeout , TimeUnit unit ) tthrows InterruptedException , ExecutionException ; } 
public V getSome ( long timeout , TimeUnit unit ) tthrows InterruptedException , ExecutionException ; } 
public Map < String , T > getSome ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { timeout = true ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( " Operation timed out: " , timedoutOps ) . getMessage ( ) ) ; } return ret ; 
public Map < String , T > get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( timeout , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; } 
public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; } 
public Thread newThread ( Runnable r ) { tThread = new Thread ( r , namePrefix + threadNumber . getAndIncrement ( ) ) ; tt . setDaemon ( daemon ) ; treturn ; } 
tprotected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tts = new TranscodeService ( false ) ; } 
public void remove ( ) { tthrow new UnsupportedOperationException ( " Cannot remove from this iterator. " ) ; } 
public void testHasNextAndNext ( ) { tfor ( int i = 0 ; i < 100 ; + + i ) { tassertTrue ( iterator . hasNext ( ) ) ; 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { tTranscoder < T > tc = tc_map . get ( k ) ; tm . put ( k , tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) { treturn asyncGetBulk ( keys , new SingleElementInfiniteIterator ( tc ) ) ; } 
tCollection < SocketAddress > getAvailableServers ( ) ; tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCollection < SocketAddress > getUnavailableServers ( ) ; tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tTranscoder < Object > getTranscoder ( ) ; tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tNodeLocator getNodeLocator ( ) ; tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) ; tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
public void testAsyncGetBulkWithTranscoderIterator ( ) throws Exception { tArrayList < String > keys = new ArrayList < String > ( ) ; tkeys . add ( " test1 " ) ; tkeys . add ( " test2 " ) ; tkeys . add ( " test3 " ) ; tArrayList < Transcoder < String > > tcs = new ArrayList < Transcoder < String > > ( keys . size ( ) ) ; tfor ( String key : keys ) { ttcs . add ( new TestWithKeyTranscoder ( key ) ) ; } client.asyncGetBulk(keys, tcs.listIterator()).get(); 
public String decode ( CachedData d ) { tassert d . getFlags ( ) = = flags : " expected " + flags + " got " + d . getFlags ( ) ; tByteBuffer bb = ByteBuffer . wrap ( d . getData ( ) ) ; tint keyLength = bb . getInt ( ) ; tbyte [ ] keyBytes = new byte [ keyLength ] ; tbb . get ( keyBytes ) ; tString k = new String ( keyBytes ) ; tassertEquals ( key , k ) ; tint valueLength = bb . getInt ( ) ; tbyte [ ] valueBytes = new byte [ valueLength ] ; tbb . get ( valueBytes ) ; treturn new String ( valueBytes ) ; } 
public CachedData encode ( String o ) { tbyte [ ] keyBytes = key . getBytes ( ) ; tbyte [ ] valueBytes = o . getBytes ( ) ; tint length = 4 + keyBytes . length + 4 + valueBytes . length ; tbyte [ ] bytes = new byte [ length ] ; tByteBuffer bb = ByteBuffer . wrap ( bytes ) ; tbb . putInt ( keyBytes . length ) . put ( keyBytes ) ; tbb . putInt ( valueBytes . length ) . put ( valueBytes ) ; treturn new CachedData ( flags , bytes , getMaxSize ( ) ) ; } 
public static void opTimedOut ( Operation op ) { MemcachedConnection . setTimeout ( op , true ) ; } 
public static void opSucceeded ( Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { } 
tboolean isCancelled ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tboolean hasErrored ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tOperationException getException ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tOperationCallback getCallback ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid cancel ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tOperationState getState ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tByteBuffer getBuffer ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid writeComplete ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid initialize ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid readFromBuffer ( ByteBuffer data ) throws IOException ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid handleRead ( ByteBuffer data ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tMemcachedNode getHandlingNode ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
tvoid setHandlingNode ( MemcachedNode to ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
public void timeOut ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
public boolean isTimedOut ( ) ; public boolean isTimedOut ( long ttlMillis ) ; } 
public void timeOut ( ) { timedout = true ; } 
public boolean isTimedOut ( ) { return timedout ; } 
public boolean isTimedOut ( long ttlMillis ) { tlong elapsed = System . nanoTime ( ) ; tlong ttlNanos = ttlMillis * 1000 * 1000 ; tif ( elapsed - creationTime > ttlNanos ) { ttimedout = true ; } else { return timedout; } 
public void testTimeoutDontwrite ( ) { tOperation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { tSystem . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { tSystem . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { tSystem . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; ttry { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } tclient . addOp ( " x " , op ) ; tSystem . err . println ( " Operation attempted: " ) ; tSystem . err . println ( op ) ; tSystem . err . println ( " Trying to get: " ) ; ttry { tbyte [ ] retVal = ( byte [ ] ) client . get ( " x " ) ; tString retValString = new String ( ) ; tSystem . err . println ( retValString ) ; } tcatch ( net . spy . memcached . OperationTimeoutException ex ) { tSystem . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } tSystem . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; tassert ( op . isTimedOut ( ) = = true ) ; } 
public void testGetStatsSizes ( ) throws Exception { } 
public void testGetStatsCacheDump ( ) throws Exception { } 
tprotected final void transitionState ( OperationState newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; cmd = null; 
public void timeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; this . transitionState ( OperationState . TIMEDOUT ) ; timedout = true ; } 
public boolean isTimedOut ( long ttlMillis ) { tlong elapsed = System . nanoTime ( ) ; tlong ttlNanos = ttlMillis * 1000 * 1000 ; tif ( elapsed - creationTime > ttlNanos ) { tassert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; tthis . transitionState ( OperationState . TIMEDOUT ) ; ttimedout = true ; } else { return timedout; } 
private void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ; 
tprotected Object deserialize ( byte [ ] in ) { tObject rv = null ; ttry { tif ( in ! = null ) { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tObjectInputStream is = new ObjectInputStream ( bis ) ; trv = is . readObject ( ) ; tis . close ( ) ; tbis . close ( ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , tin = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { tgetLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , tin = = null ? 0 : in . length , e ) ; } treturn rv ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { tb = tu . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . debug ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { tbyte [ ] b = null ; tint flags = 0 ; tif ( o instanceof String ) { tb = encodeString ( ( String ) o ) ; tflags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { tflags | = SPECIAL_STRINGBUFFER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { tflags | = SPECIAL_STRINGBUILDER ; tb = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { tb = tu . encodeLong ( ( Long ) o ) ; tflags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { tb = tu . encodeInt ( ( Integer ) o ) ; tflags | = SPECIAL_INT ; } else if ( o instanceof Short ) { tb = tu . encodeInt ( ( Short ) o ) ; tflags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { tb = this . encodeBoolean ( ( Boolean ) o ) ; tflags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { tb = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; tflags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { tb = tu . encodeByte ( ( Byte ) o ) ; tflags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { tb = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; tflags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { tb = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; tflags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { tb = ( byte [ ] ) o ; tflags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { tb = tu . encodeInt ( ( Character ) o ) ; tflags | = SPECIAL_CHARACTER ; } else { tb = serialize ( o ) ; tflags | = SERIALIZED ; } tassert b ! = null ; tif ( b . length > compressionThreshold ) { tbyte [ ] compressed = compress ( b ) ; tif ( compressed . length < b . length ) { tgetLogger ( ) . debug ( " Compressed %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; tb = compressed ; tflags | = COMPRESSED ; } else { tgetLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , to . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } treturn new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public MemcachedClient getObject ( ) throws Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( " localhost:22211 localhost:22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = factory . getObject ( ) ; Assert . assertEquals ( " deamon " , true , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; } 
public void testGetObjectType ( ) { Assert . assertEquals ( " object type " , MemcachedClient . class , new MemcachedClientFactoryBean ( ) . getObjectType ( ) ) ; } 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { tplaceIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { to . cancel ( ) ; } else { addOperation(placeIn, o); 
tboolean isCancelled ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tboolean hasErrored ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationException getException ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationCallback getCallback ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid cancel ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationState getState ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tByteBuffer getBuffer ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid writeComplete ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid initialize ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid readFromBuffer ( ByteBuffer data ) throws IOException ; public boolean isTimedOutUnsent ( ) ; } 
tvoid handleRead ( ByteBuffer data ) ; public boolean isTimedOutUnsent ( ) ; } 
tMemcachedNode getHandlingNode ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid setHandlingNode ( MemcachedNode to ) ; public boolean isTimedOutUnsent ( ) ; } 
public void timeOut ( ) ; public boolean isTimedOutUnsent ( ) ; } 
public boolean isTimedOut ( ) ; public boolean isTimedOutUnsent ( ) ; } 
public boolean isTimedOut ( long ttlMillis ) ; public boolean isTimedOutUnsent ( ) ; } 
public boolean isTimedOut ( long ttlMillis ) { tlong elapsed = System . nanoTime ( ) ; tlong ttlNanos = ttlMillis * 1000 * 1000 ; tif ( elapsed - creationTime > ttlNanos ) { tassert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; tthis . transitionState ( OperationState . TIMEDOUT ) ; ttimedOutUnsent = true ; ttimedout = true ; } else { return timedout; } 
public boolean isTimedOutUnsent ( ) { treturn timedOutUnsent ; } 
private void nextHash ( ) { remainingTries--; } 
public boolean hasNext ( ) { treturn remainingTries > 0 ; } 
public MemcachedNode next ( ) { ttry { return getNodeForKey ( hashVal ) ; 
public void remove ( ) { tthrow new UnsupportedOperationException ( " remove not supported " ) ; } 
private void runThisManyNodes ( final int totalNodes ) { tfinal String [ ] stringNodes = generateAddresses ( totalNodes ) ; tList < MemcachedNode > smaller = createNodes ( tAddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; tList < MemcachedNode > larger = createNodes ( tAddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; tassertTrue ( larger . containsAll ( smaller ) ) ; tMemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; tassertFalse ( smaller . contains ( oddManOut ) ) ; tKetamaNodeLocator lgLocator = new KetamaNodeLocator ( tlarger , HashAlgorithm . KETAMA_HASH ) ; tKetamaNodeLocator smLocator = new KetamaNodeLocator ( tsmaller , HashAlgorithm . KETAMA_HASH ) ; tSortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; tSortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; assertFalse(failed); 
public void testSequence1 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; } 
public void testSequence2 ( ) { tsetupNodes ( 4 ) ; tassertSequence ( " noelani " , 2 , 1 , 1 , 3 , 2 , 2 , 3 ) ; } 
public void testFNV1A_32 ( ) { tHashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; tsetupNodes ( alg , 5 ) ; tassertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; tassertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; tassertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; tassertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 21 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { tSystem . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public void testStupidlyLargeSet ( ) throws Exception { tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 21 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { tassertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , te . getMessage ( ) ) ; } } 
public Object getObject ( ) throws Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( " localhost:22211 localhost:22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " deamon " , true , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; } 
int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();} 
int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();} 
int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();} 
HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();} 
String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();} 
int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; } 
public boolean isSequenceChanged ( ) { return sequenceChanged ; } 
Config create ( File file ) ; Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; } 
Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; } 
public int foundIncorrectMaster ( int vbucket , int wrongServer ) { int mappedServer = this . vbuckets . get ( vbucket ) . getMaster ( ) ; int rv = mappedServer ; if ( mappedServer = = wrongServer ) { rv = ( rv + 1 ) % this . serversCount ; this . vbuckets . get ( vbucket ) . setMaster ( rv ) ; } return rv ; } 
public Config create ( String data ) { try { JSONObject jsonObject = new JSONObject ( data ) ; 
public Config create ( JSONObject jsonObject ) { try { return parseJSON ( jsonObject ) ; 
private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = HashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . KETAMA_HASH ; } else { throw new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; } 
private Config parseJSON ( JSONObject jsonObject ) throws JSONException { Allows clients to have a JSON envelope. if (jsonObject.has("vBucketServerMap")) { return parseJSON(jsonObject.getJSONObject("vBucketServerMap")); } HashAlgorithm hashAlgorithm = lookupHashAlgorithm(jsonObject .getString("hashAlgorithm")); int replicasCount = jsonObject.getInt("numReplicas"); if (replicasCount > VBucket.MAX_REPLICAS) { throw new ConfigParsingException("Expected number <= " + VBucket.MAX_REPLICAS + " for replicas."); } JSONArray servers = jsonObject.getJSONArray("serverList"); if (servers.length() <= 0) { throw new ConfigParsingException("Empty servers list."); } int serversCount = servers.length(); JSONArray vbuckets = jsonObject.getJSONArray("vBucketMap"); int vbucketsCount = vbuckets.length(); if (vbucketsCount == 0 || (vbucketsCount & (vbucketsCount - 1)) != 0) { throw new ConfigParsingException( "Number of buckets must be a power of two, > 0 and <= " + VBucket.MAX_BUCKETS); } Config config = new DefaultConfig(hashAlgorithm, serversCount, replicasCount, vbucketsCount, populateServers(servers), populateVbuckets(servers)); return config; } 
private List < String > populateServers ( JSONArray servers ) throws JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; } 
private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) throws JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int replicas [ ] = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; } 
public < T > Future < Boolean > touch ( final String key , final int exp ) { treturn touch ( key , exp , transcoder ) ; } 
public < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tOperation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { trv . set ( status . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus status ) { trv . set ( status . isSuccess ( ) ) ; } 
tGetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tMutatorOperation mutate ( Mutator m , String key , int by , tlong def , int exp , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStatsOperation stats ( String arg , StatsOperation . Callback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tStoreOperation store ( StoreType storeType , String key , int flags , int exp , tbyte [ ] data , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
tKeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; tCollection < Operation > clone ( KeyedOperation op ) ; } 
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " Touch is only supported in " + " the binary protocol " ) ; 
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { treturn new TouchOperationImpl ( key , expiration , cb ) ; } 
public void initialize ( ) { tprepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; } 
public < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; tOperation op = opFact . getl ( key , exp , tnew GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { treturn asyncGetAndLock ( key , exp , transcoder ) ; } 
public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { treturn new GetlOperationImpl ( key , exp , cb ) ; } 
public final void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; do { 
public final void initialize ( ) { } 
public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { treturn new GetOperationImpl ( key , exp , cb ) ; } 
public void initialize ( ) { tif ( hasExp ) { tprepareBuffer ( key , 0 , EMPTY_BYTES , 0 , exp ) ; 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
public Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { treturn asyncGetAndTouch ( key , exp , transcoder ) ; } 
public void gotData ( String key , int flags , long cas , byte [ ] data ) { tassert key . equals ( key ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public GetAndTouchOperation getAndTouch ( String key , int expiration , tGetAndTouchOperation . Callback cb ) { tthrow new UnsupportedOperationException ( " Get and Touch not supported " + " with ascii protocol " ) ; 
public final void handleRead ( ByteBuffer b ) { tassert currentKey ! = null ; tassert data ! = null ; do { 
public GetAndTouchOperation getAndTouch ( String key , int expiration , tGetAndTouchOperation . Callback cb ) { treturn new GetOperationImpl ( key , expiration , cb ) ; } 
public void initialize ( ) { tif ( cmd = = GETL_CMD ) { tprepareBuffer ( key , 0 , EMPTY_BYTES , 0 , exp ) ; 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Bucket bucket = ( Bucket ) o ; if ( ! name . equals ( bucket . name ) ) return false ; if ( ! nodes . equals ( bucket . nodes ) ) return false ; if ( ! vbuckets . equals ( bucket . vbuckets ) ) return false ; return true ; } 
public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + vbuckets . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; } 
Map < String , Pool > parseBase ( final String base ) throws ParseException ; Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException ; Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException ; Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
public Map < String , Pool > parseBase ( String base ) throws ParseException { Map < String , Pool > parsedBase = new HashMap < String , Pool > ( ) ; JSONArray poolsJA = null ; try { JSONObject baseJO = new JSONObject ( base ) ; poolsJA = baseJO . getJSONArray ( " pools " ) ; } catch ( JSONException e ) { throw new ParseException ( " Can not read base " + base , 0 ) ; } for ( int i = 0 ; i < poolsJA . length ( ) ; + + i ) { try { JSONObject poolJO = poolsJA . getJSONObject ( i ) ; String name = ( String ) poolJO . get ( NAME_ATTR ) ; if ( name = = null | | " " . equals ( name ) ) { throw new ParseException ( " Pool's name is missing. " , 0 ) ; } String uri = ( String ) poolJO . get ( URI_ATTR ) ; if ( uri = = null | | " " . equals ( uri ) ) { throw new ParseException ( " Pool's uri is missing. " , 0 ) ; } String streamingUri = ( String ) poolJO . get ( STREAMING_URI_ATTR ) ; Pool pool = new Pool ( name , new URI ( uri ) , new URI ( streamingUri ) ) ; parsedBase . put ( name , pool ) ; } catch ( JSONException e ) { getLogger ( ) . error ( " One of the pool configuration can not be parsed. " , e ) ; } catch ( URISyntaxException e ) { getLogger ( ) . error ( " Server provided an incorrect uri. " , e ) ; } } return parsedBase ; 
public void loadPool ( Pool pool , String sPool ) throws ParseException { try { JSONObject poolJO = new JSONObject ( sPool ) ; 
public Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException { Map < String , Bucket > bucketsMap = new HashMap < String , Bucket > ( ) ; try { JSONArray bucketsJA = new JSONArray ( buckets ) ; for ( int i = 0 ; i < bucketsJA . length ( ) ; + + i ) { JSONObject bucketJO = bucketsJA . getJSONObject ( i ) ; Bucket bucket = parseBucketFromJSON ( bucketJO ) ; bucketsMap . put ( bucket . getName ( ) , bucket ) ; } } catch ( JSONException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return bucketsMap ; } 
public Bucket parseBucket ( String sBucket ) throws ParseException { try { return parseBucketFromJSON ( new JSONObject ( sBucket ) ) ; 
private Bucket parseBucketFromJSON ( JSONObject bucketJO ) throws ParseException { try { String bucketname = bucketJO . get ( " name " ) . toString ( ) ; 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Node node = ( Node ) o ; if ( ! hostname . equals ( node . hostname ) ) return false ; if ( status ! = node . status ) return false ; if ( ! ports . equals ( node . ports ) ) return false ; return true ; } 
public int hashCode ( ) { int result = status ! = null ? status . hashCode ( ) : 0 ; result = 31 * result + hostname . hashCode ( ) ; result = 31 * result + ports . hashCode ( ) ; return result ; } 
public void testParseBase ( ) throws Exception { Map < String , Pool > base = configParser . parseBase ( baseString ) ; assertNotNull ( base ) ; assertTrue ( ! base . isEmpty ( ) ) ; Pool pool = base . get ( DEFAULT_POOL_NAME ) ; assertNotNull ( pool ) ; assertEquals ( DEFAULT_POOL_NAME , pool . getName ( ) ) ; assertNotNull ( pool . getUri ( ) ) ; } 
public void testParseBuckets ( ) throws Exception { Map < String , Bucket > buckets = configParser . parseBuckets ( bucketsString ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ; 
public void testParseBucket ( ) throws Exception { Bucket bucket = configParser . parseBucket ( bucketString ) ; checkBucket ( bucket ) ; } 
public void testLoadPool ( ) throws Exception { Pool pool = new Pool ( null , null , null ) ; configParser . loadPool ( pool , poolString ) ; assertNotNull ( pool . getBucketsUri ( ) ) ; } 
private void checkBucket ( Bucket bucket ) throws Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getVbuckets ( ) ) ; } 
public Map < String , Pool > parseBase ( String base ) throws ParseException { Map < String , Pool > result = new HashMap < String , Pool > ( ) ; try { parseBaseCalled = true ; Pool pool = new Pool ( poolName , new URI ( poolUri ) , new URI ( poolStreamingUri ) ) ; result . put ( poolName , pool ) ; } catch ( URISyntaxException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; } 
public Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException { Map < String , Bucket > result = new HashMap < String , Bucket > ( ) ; try { parseBucketsCalled = true ; Bucket bucket = new Bucket ( bucketName , vbuckets , new URI ( bucketStreamingUri ) , nodes ) ; result . put ( bucketName , bucket ) ; } catch ( URISyntaxException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; } 
public Bucket parseBucket ( String sBucket ) throws ParseException { parseBucketCalled = true ; try { parseBucketsCalled = true ; 
public void loadPool ( Pool pool , String sPool ) throws ParseException { try { loadPoolCalled = true ; 
public boolean isParseBaseCalled ( ) { return parseBaseCalled ; } 
public boolean isParseBucketsCalled ( ) { return parseBucketsCalled ; } 
public boolean isParseBucketCalled ( ) { return parseBucketCalled ; } 
public boolean isLoadPoolCalled ( ) { return loadPoolCalled ; } 
tprotected void flushPause ( ) throws InterruptedException { }} 
tprotected boolean isMembase ( ) { if ( membase ! = null ) { return membase . booleanValue ( ) ; } tMap < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; tfor ( Map < String , String > node : stats . values ( ) ) { tif ( node . get ( " ep_version " ) ! = null ) { tmembase = true ; System . err . println ( " Found membase! " ) ; tbreak ; } else { tmembase = false ; System . err . println ( " Found memcached! " ) ; } } return membase . booleanValue ( ) ; } 
public void testGetStats ( ) throws Exception { tMap < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; tSystem . out . println ( " Stats: " + stats ) ; tassertEquals ( 1 , stats . size ( ) ) ; tMap < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; tassertTrue ( oneStat . containsKey ( " curr_items " ) ) ; } 
public void testGetStatsSlabs ( ) throws Exception { tif ( isMembase ( ) ) { return ; } } 
public void testGetStatsSizes ( ) throws Exception { tif ( isMembase ( ) ) { treturn ; } } 
public void testGetStatsCacheDump ( ) throws Exception { tif ( isMembase ( ) ) { treturn ; } } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tif ( isMembase ( ) ) { return ; } tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 21 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { tSystem . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public void startMonitor ( ) { if ( channel ! = null ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . WARNING , " Bucket monitor is already started. " ) ; return ; } createChannel ( ) ; this . handler = channel . getPipeline ( ) . get ( BucketUpdateResponseHandler . class ) ; handler . setBucketMonitor ( this ) ; HttpRequest request = prepareRequest ( cometStreamURI , host ) ; channel . write ( request ) ; try { String response = this . handler . getLastResponse ( ) ; 
protected void createChannel ( ) { Configure the client. ClientBootstrap bootstrap = new ClientBootstrap(factory); Set up the event pipeline factory. bootstrap.setPipelineFactory(new BucketMonitorPipelineFactory()); Start the connection attempt. ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)); Wait until the connection attempt succeeds or fails. channel = future.awaitUninterruptibly().getChannel(); if (!future.isSuccess()) { bootstrap.releaseExternalResources(); throw new ConnectionException("Could not connect to any pool member."); } assert(channel != null); } 
private void logFiner ( String msg ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . FINER , msg ) ; } 
public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; } 
public void shutdown ( long timeout , TimeUnit unit ) { deleteObservers ( ) ; if ( channel ! = null ) { channel . close ( ) . awaitUninterruptibly ( timeout , unit ) ; } factory . releaseExternalResources ( ) ; } 
protected void invalidate ( ) { try { String response = handler . getLastResponse ( ) ; 
public void messageReceived ( final ChannelHandlerContext context , final MessageEvent event ) { ChannelFuture channelFuture = event . getFuture ( ) ; setReceivedFuture ( channelFuture ) ; if ( this . partialResponse = = null ) { this . partialResponse = new StringBuilder ( ) ; } if ( readingChunks ) { HttpChunk chunk = ( HttpChunk ) event . getMessage ( ) ; 
private void finerLog ( String message ) { LOGGER . log ( Level . FINER , message ) ; } 
public void handleUpstream ( ChannelHandlerContext context , ChannelEvent event ) throws Exception { if ( event instanceof ChannelStateEvent ) { LOGGER . log ( Level . FINEST , " Channel state changed: " + event + " " ) ; } super . handleUpstream ( context , event ) ; } 
public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { LOGGER . log ( Level . INFO , " Exception occurred: " ) ; if ( monitor ! = null ) { monitor . invalidate ( ) ; 
public void testGetPipeline ( ) throws Exception { BucketMonitorPipelineFactory factory = new BucketMonitorPipelineFactory ( ) ; ChannelPipeline pipeline = factory . getPipeline ( ) ; ChannelHandler decoder = pipeline . get ( " decoder " ) ; ChannelHandler encoder = pipeline . get ( " encoder " ) ; ChannelHandler handler = pipeline . get ( " handler " ) ; assertTrue ( decoder instanceof HttpResponseDecoder ) ; assertTrue ( encoder instanceof HttpRequestEncoder ) ; assertTrue ( handler instanceof BucketUpdateResponseHandler ) ; assertEquals ( handler , pipeline . getLast ( ) ) ; assertEquals ( decoder , pipeline . getFirst ( ) ) ; } 
public void testInstantiate ( ) throws Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( streamingUri ) , bucketname , username , password , configParser ) ; assertEquals ( username , bucketMonitor . getHttpUser ( ) ) ; assertEquals ( password , bucketMonitor . getHttpPass ( ) ) ; } 
public void testObservable ( ) throws Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( streamingUri ) , bucketname , username , password , configParser ) ; BucketObserverMock observer = new BucketObserverMock ( ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . startMonitor ( ) ; assertTrue ( " Update for observer was not called. " , observer . isUpdateCalled ( ) ) ; bucketMonitor . shutdown ( ) ; } 
public void update ( Observable o , Object arg ) { updateCalled = true ; } 
public boolean isUpdateCalled ( ) { return updateCalled ; } 
public void testSetGetRecievedFuture ( ) throws Throwable { ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; replay ( futureMock ) ; BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler ( ) ; PrivateAccessor . setField ( handler , " receivedFuture " , futureMock ) ; PrivateAccessor . invoke ( handler , " setReceivedFuture " , new Class [ ] { ChannelFuture . class } , new Object [ ] { futureMock } ) ; assertEquals ( futureMock , PrivateAccessor . getField ( handler , " receivedFuture " ) ) ; verify ( futureMock ) ; } 
public void testMessageReceived ( ) throws NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); String lastResponse = (String) PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); } 
Bucket getBucketConfiguration ( String bucketname ) throws ConfigurationException ; void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException ; void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException ; void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
public Bucket getBucketConfiguration ( final String bucketname ) throws ConfigurationException { if ( bucketname = = null | | bucketname . isEmpty ( ) ) { throw new IllegalArgumentException ( " Bucket name can not be blank. " ) ; } Bucket bucket = this . buckets . get ( bucketname ) ; if ( bucket = = null ) { readPools ( bucketname ) ; } return this . buckets . get ( bucketname ) ; } 
private void readPools ( String bucketToFind ) throws ConfigurationException { and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try { 
public List < InetSocketAddress > getServerList ( final String bucketname ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; List < String > servers = bucket . getVbuckets ( ) . getServers ( ) ; StringBuilder serversString = new StringBuilder ( ) ; for ( String server : servers ) { serversString . append ( server ) . append ( ' ' ) ; } return AddrUtil . getAddresses ( serversString . toString ( ) ) ; } 
public void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = this . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ; 
public void unsubscribe ( String vbucketName , Reconfigurable rec ) { BucketMonitor monitor = this . monitors . get ( vbucketName ) ; if ( monitor ! = null ) { monitor . deleteObserver ( new ReconfigurableObserver ( rec ) ) ; 
public Config getLatestConfig ( String bucketname ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; return bucket . getVbuckets ( ) ; } 
public void shutdown ( ) { for ( BucketMonitor monitor : this . monitors . values ( ) ) { monitor . shutdown ( ) ; 
private URLConnection urlConnBuilder ( URI base , URI resource ) throws IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } if ( restUsr ! = null ) { Authenticator . setDefault ( new PoolAuthenticator ( this . restUsr , this . restPwd ) ) ; } else { Authenticator . setDefault ( null ) ; } URL specURL = resource . toURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; return connection ; 
private String readToString ( URLConnection connection ) throws IOException { tBufferedReader reader = null ; ttry { tInputStream inStream = connection . getInputStream ( ) ; 
public void update ( Observable o , Object arg ) { rec . reconfigure ( ( Bucket ) arg ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; ReconfigurableObserver that = ( ReconfigurableObserver ) o ; if ( ! rec . equals ( that . rec ) ) return false ; return true ; } 
public int hashCode ( ) { return rec . hashCode ( ) ; } 
private Config parseJSON ( JSONObject jsonObject ) throws JSONException { List<VBucket> populateVbuckets = populateVbuckets(vbuckets); Config config = new DefaultConfig(hashAlgorithm, serversCount, replicasCount, vbucketsCount, populateServers, populateVbuckets); return config; } 
public void replaceBuckets ( Map < String , Bucket > replacingMap ) { tHashMap < String , Bucket > swapMap = new HashMap < String , Bucket > ( replacingMap ) ; currentBuckets.set(swapMap); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; } 
public void testGetBucketConfiguration ( ) throws Exception { Bucket bucket = configProvider . getBucketConfiguration ( DEFAULT_BUCKET_NAME ) ; assertNotNull ( bucket ) ; } 
public void testSubscribe ( ) throws Exception { configProvider . subscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; } 
public void testUnsubscribe ( ) throws Exception { configProvider . unsubscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; } 
public void testShutdown ( ) throws Exception { configProvider . shutdown ( ) ; } 
public void testGetAnonymousAuthBucket ( ) throws Exception { assertEquals ( " default " , configProvider . getAnonymousAuthBucket ( ) ) ; } 
public void testPoolAuthenticator ( ) throws Exception { final String username = " test_username " ; final String password = " test_password " ; PoolAuthenticator authenticator = new PoolAuthenticator ( username , password ) ; assertNotNull ( authenticator . getPasswordAuthentication ( ) ) ; try { authenticator = new PoolAuthenticator ( null , null ) ; 
public void testParseBucketsClustered ( ) throws Exception { tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( bucketsClusterString ) ; tsb . append ( bucketsClusterString2 ) ; Map < String , Bucket > buckets = configParser . parseBuckets ( sb . toString ( ) ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ; 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { tplaceIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { to . cancel ( ) ; } else { if(placeIn != null) { add the vbucketIndex to the operation 
tprotected void prepareBuffer ( String key , long cas , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tfinal byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tint bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
public void updateLocator ( final List < MemcachedNode > nodes , final Config config ) { setNodes ( nodes ) ; setConfig ( config ) ; } 
public void testGetPrimary ( ) { MemcachedNode node1 = createMock ( MemcachedNode . class ) ; MemcachedNode node2 = createMock ( MemcachedNode . class ) ; MemcachedNode node3 = createMock ( MemcachedNode . class ) ; InetSocketAddress address1 = new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ; InetSocketAddress address2 = new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ; InetSocketAddress address3 = new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ; expect ( node1 . getSocketAddress ( ) ) . andReturn ( address1 ) ; expect ( node2 . getSocketAddress ( ) ) . andReturn ( address2 ) ; expect ( node3 . getSocketAddress ( ) ) . andReturn ( address3 ) ; replay ( node1 , node2 , node3 ) ; ConfigFactory factory = new DefaultConfigFactory ( ) ; Config config = factory . create ( configInEnvelope ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( node1 , node2 , node3 ) , config ) ; MemcachedNode resultNode = locator . getPrimary ( " key1 " ) ; assertEquals ( node1 , resultNode ) ; verify ( node1 , node2 , node3 ) ; } 
public void reconfigure ( Bucket bucket ) { treconfiguring = true ; ttry { tconn . reconfigure ( bucket ) ; 
public void run ( ) { twhile ( running ) { if ( ! reconfiguring ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
private List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) tthrows IOException { tList < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; tfor ( SocketAddress sa : a ) { tSocketChannel ch = SocketChannel . open ( ) ; tch . configureBlocking ( false ) ; tMemcachedNode qa = this . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; tint ops = 0 ; tch . socket ( ) . setTcpNoDelay ( ! this . connectionFactory . useNagleAlgorithm ( ) ) ; } 
public void reconfigure ( Bucket bucket ) { ttry { tif ( ! ( locator instanceof VBucketNodeLocator ) ) { 
public void addOperation ( final String key , final Operation o ) { tMemcachedNode placeIn = null ; tMemcachedNode primary = locator . getPrimary ( key ) ; tif ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { tplaceIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { to . cancel ( ) ; } else { add the vbucketIndex to the operation 
void setVBucket ( int vbucket ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
public void addNotMyVbucketNode ( MemcachedNode node ) { tnotMyVbucketNodes . add ( node ) ; } 
public Collection < Operation > destroyInputQueue ( ) { return null ; } 
public boolean hasReadOp ( ) { return true ; } 
public boolean hasWriteOp ( ) { return true ; } 
public Operation removeCurrentReadOp ( ) { return null ; } 
public Operation removeCurrentWriteOp ( ) { return null ; } 
public int writeSome ( ) throws IOException { return 0 ; } 
public void testGetAlternative ( ) { MemcachedNodeMockImpl node1 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node2 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node3 = new MemcachedNodeMockImpl ( ) ; node1 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; node2 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ) ; node3 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ) ; ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( ( MemcachedNode ) node1 , node2 , node3 ) , config ) ; MemcachedNode primary = locator . getPrimary ( " k1 " ) ; MemcachedNode alternative = locator . getAlternative ( " k1 " , Arrays . asList ( primary ) ) ; alternative . getSocketAddress ( ) ; } 
public void initialize ( ) { } 
Bucket getBucketConfiguration ( String bucketname ) throws ConfigurationException ; String getAnonymousAuthBucket ( ) ; } 
void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException ; String getAnonymousAuthBucket ( ) ; } 
void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; } 
void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
public void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = this . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ; 
public void testOps ( ) throws Exception { MemcachedClient mc = null ; try { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " , true ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { Future result = mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
tprotected void flushPause ( ) throws InterruptedException { }} 
tprotected boolean isMembase ( ) { if ( membase ! = null ) { return membase . booleanValue ( ) ; } tMap < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; tfor ( Map < String , String > node : stats . values ( ) ) { tif ( node . get ( " ep_version " ) ! = null ) { tmembase = true ; System . err . println ( " Found membase " ) ; tbreak ; } else { tmembase = false ; System . err . println ( " Found memcached " ) ; } } return membase . booleanValue ( ) ; } 
tprotected boolean isMoxi ( ) { if ( moxi ! = null ) { return moxi . booleanValue ( ) ; } } 
public void testGetStatsSlabs ( ) throws Exception { tif ( isMembase ( ) | | isMoxi ( ) ) { return ; } } 
public void testGetStatsSizes ( ) throws Exception { tif ( isMembase ( ) | | isMoxi ( ) ) { treturn ; } } 
public void testGetStatsCacheDump ( ) throws Exception { tif ( isMembase ( ) | | isMoxi ( ) ) { treturn ; } } 
public List < InetSocketAddress > getServerList ( final String bucketname ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; List < String > servers = bucket . getConfig ( ) . getServers ( ) ; StringBuilder serversString = new StringBuilder ( ) ; for ( String server : servers ) { serversString . append ( server ) . append ( ' ' ) ; } return AddrUtil . getAddresses ( serversString . toString ( ) ) ; } 
public Config getLatestConfig ( String bucketname ) throws ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; return bucket . getConfig ( ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Bucket bucket = ( Bucket ) o ; if ( ! name . equals ( bucket . name ) ) return false ; if ( ! nodes . equals ( bucket . nodes ) ) return false ; if ( ! configuration . equals ( bucket . configuration ) ) return false ; return true ; } 
public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + configuration . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; } 
private void checkBucket ( Bucket bucket ) throws Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getConfig ( ) ) ; } 
int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
public int foundIncorrectMaster ( int vbucket , int wrongServer ) { throw new IllegalArgumentException ( " TODO: refactor this " ) ; } 
private Config parseJSON ( JSONObject jsonObject ) throws JSONException { return parseEpJSON(jsonObject.getJSONObject("vBucketServerMap")); } 
private Config parseCacheJSON ( JSONObject jsonObject ) throws JSONException { tJSONArray nodes = jsonObject . getJSONArray ( " nodes " ) ; if ( nodes . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty nodes list. " ) ; } int serversCount = nodes . length ( ) ; tCacheConfig config = new CacheConfig ( serversCount ) ; populateServers ( config , nodes ) ; treturn config ; } 
private Config parseEpJSON ( JSONObject jsonObject ) throws JSONException { HashAlgorithm hashAlgorithm = lookupHashAlgorithm ( jsonObject . getString ( " hashAlgorithm " ) ) ; int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { throw new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { throw new ConfigParsingException ( " Number of buckets must be a power of two, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } tList < String > populateServers = populateServers ( servers ) ; tList < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; } 
private List < String > populateServers ( JSONArray servers ) throws JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; } 
private void populateServers ( CacheConfig config , JSONArray nodes ) throws JSONException { tList < String > serverNames = new ArrayList < String > ( ) ; tfor ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; String webHostPort = node . getString ( " hostname " ) ; String [ ] splitHostPort = webHostPort . split ( " : " ) ; JSONObject portsList = node . getJSONObject ( " ports " ) ; int port = portsList . getInt ( " direct " ) ; serverNames . add ( splitHostPort [ 0 ] + " : " + port ) ; } tconfig . setServers ( serverNames ) ; } 
private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) throws JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int replicas [ ] = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; } 
public void testGetPrimary ( ) { } public void testGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; tconfig . getServersCount ( ) ; tList < String > servers = config . getServers ( ) ; tSystem . out . println ( servers ) ; } } 
public void testGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; tconfig . getServersCount ( ) ; tList < String > servers = config . getServers ( ) ; tSystem . out . println ( servers ) ; } 
public void testOps ( ) throws Exception { MemcachedClient mc = null ; try { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { Future result = mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
protected static String buildAuthHeader ( String username , String password ) { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } and apache base64 codec has extra \l we have to strip off String encodedText = org.apache.commons.codec.binary.Base64.encodeBase64String(clearText.toString().getBytes()); char[] encodedWoNewline = new char[encodedText.length() - 2]; encodedText.getChars(0, encodedText.length() - 2, encodedWoNewline, 0); String authVal = "Basic " + new String(encodedWoNewline); return authVal; } 
private URLConnection urlConnBuilder ( URI base , URI resource ) throws IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . toURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; tif ( restUsr ! = null ) { connection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } return connection ; 
public void testBuildAuthHeader ( ) { tConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ; 
public GetAndTouchOperation getAndTouch ( String key , int expiration , tGetAndTouchOperation . Callback cb ) { tthrow new UnsupportedOperationException ( " Get and touch is not supported " + " for ASCII protocol " ) ; 
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " Touch is not supported for " + " ASCII protocol " ) ; 
public SASLMechsOperation saslMechs ( OperationCallback cb ) { tthrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) { tthrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public void testGATTimeout ( ) throws Exception { tif ( isMembase ( ) ) { tassertNull ( client . get ( " gatkey " ) ) ; 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; } 
public void initialize ( ) { tif ( exp > 0 ) { tprepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; 
public void testTouchTimeout ( ) throws Exception { tif ( isMembase ( ) ) { tassertNull ( client . get ( " touchkey " ) ) ; 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) , val ) ; } 
private OperationFuture < Boolean > asyncStore ( StoreType storeType , tString key , int exp , Object value ) { treturn asyncStore ( storeType , key , exp , value , transcoder ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( tConcatenationType catType , long cas , String key , tT value , Transcoder < T > tc ) { tCachedData co = tc . encode ( value ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tOperation op = opFact . cat ( catType , cas , key , co . getData ( ) , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) , val ) ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp ) { treturn touch ( key , exp , transcoder ) ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tOperation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { trv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus status ) { trv . set ( status . isSuccess ( ) , status ) ; } 
public OperationFuture < Boolean > append ( long cas , String key , Object val ) { treturn append ( cas , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > append ( long cas , String key , T val , tTranscoder < T > tc ) { treturn asyncCat ( ConcatenationType . append , cas , key , val , tc ) ; } 
public OperationFuture < Boolean > prepend ( long cas , String key , Object val ) { treturn prepend ( cas , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > prepend ( long cas , String key , T val , tTranscoder < T > tc ) { treturn asyncCat ( ConcatenationType . prepend , cas , key , val , tc ) ; } 
public void receivedStatus ( OperationStatus val ) { tif ( val instanceof CASOperationStatus ) { trv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) , val ) ; 
public < T > OperationFuture < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) { treturn asyncStore ( StoreType . add , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > add ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . add , key , exp , o , transcoder ) ; } 
public < T > OperationFuture < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) { treturn asyncStore ( StoreType . set , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > set ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . set , key , exp , o , transcoder ) ; } 
public < T > OperationFuture < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) { treturn asyncStore ( StoreType . replace , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { treturn asyncStore ( StoreType . replace , key , exp , o , transcoder ) ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } 
public GetFuture < Object > asyncGet ( final String key ) { treturn asyncGet ( key , transcoder ) ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public OperationFuture < CASValue < Object > > asyncGets ( final String key ) { treturn asyncGets ( key , transcoder ) ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; tOperation op = opFact . getl ( key , exp , tnew GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public OperationFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { treturn asyncGetAndLock ( key , exp , transcoder ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void receivedStatus ( OperationStatus status ) { trv . setStatus ( status ) ; tif ( ! status . isSuccess ( ) ) { tgetLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ; 
public OperationFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { treturn asyncGetAndTouch ( key , exp , transcoder ) ; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , tint exp ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Long > rv = new OperationFuture < Long > ( tlatch , operationTimeout ) ; tOperation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; trv . setOperation ( op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus s ) { trv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } 
public OperationFuture < Long > asyncIncr ( String key , int by ) { treturn asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , int by ) { treturn asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public OperationFuture < Boolean > delete ( String key , int hold ) { treturn delete ( key ) ; } 
public OperationFuture < Boolean > delete ( String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , toperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) , s ) ; } 
public OperationFuture < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( blatch , flushResult , toperationTimeout ) { 
public Boolean get ( long duration , TimeUnit units ) throws InterruptedException , tTimeoutException , ExecutionException { tstatus = new OperationStatus ( true , " OK " ) ; treturn super . get ( duration , units ) ; } 
public OperationFuture < Boolean > flush ( ) { treturn flush ( - 1 ) ; } 
public boolean isTimeout ( ) ; public OperationStatus getStatus ( ) ; } 
public V getSome ( long timeout , TimeUnit unit ) tthrows InterruptedException , ExecutionException ; public OperationStatus getStatus ( ) ; } 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = OperationState . WRITING ; top . cancel ( ) ; } tfor ( Future < T > v : rvMap . values ( ) ) { tv . cancel ( ign ) ; } tcancelled = true ; tstatus = new OperationStatus ( false , " Cancelled " ) ; treturn rv ; } 
public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; status = new OperationStatus ( false , " Timed out " ) ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; } 
public void set ( Future < T > d , OperationStatus s ) { trv . set ( d , s ) ; } 
public T get ( long duration , TimeUnit units ) tthrows InterruptedException , TimeoutException , ExecutionException { tif ( ! latch . await ( duration , units ) ) { } 
public void set ( T o , OperationStatus s ) { tobjRef . set ( o ) ; tstatus = s ; } 
public void testDelayedFlush ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tassert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; tassert client . set ( " test2 " , 5 , " test2value " ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassertEquals ( " test2value " , client . get ( " test2 " ) ) ; tassert client . flush ( 2 ) . getStatus ( ) . isSuccess ( ) ; tThread . sleep ( 2100 ) ; tassertNull ( client . get ( " test1 " ) ) ; tassertNull ( client . get ( " test2 " ) ) ; tassert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; tassert ! client . asyncGet ( " test2 " ) . getStatus ( ) . isSuccess ( ) ; } 
public void testSimpleCASGets ( ) throws Exception { tassertNull ( client . gets ( " test1 " ) ) ; tassert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " test1value " , client . gets ( " test1 " ) . getValue ( ) ) ; } 
public void testExtendedUTF8Key ( ) throws Exception { tString key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; tassertNull ( client . get ( key ) ) ; tassert client . set ( key , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " test1value " , client . get ( key ) ) ; } 
public Boolean call ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { tassert client . set ( " test " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } tfor ( int i = 0 ; i < 10 ; i + + ) { tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } treturn Boolean . TRUE ; } } ) ; 
public Boolean call ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { tassert client . set ( " test " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " value " + i , client . get ( " test " + i ) ) ; } tMap < String , Object > m = client . getBulk ( " test0 " , " test1 " , " test2 " , " test3 " , " test4 " , " test5 " , " test6 " , " test7 " , " test8 " , " test9 " , " test10 " ) ; }}); 
public Boolean call ( ) throws Exception { tassert client . set ( " testparallel " , 5 , " parallelvalue " ) . getStatus ( ) . isSuccess ( ) ; tfor ( int i = 0 ; i < 10 ; i + + ) { tassertEquals ( " parallelvalue " , client . get ( " testparallel " ) ) ; } treturn Boolean . TRUE ; } } ) ; 
public void testAdd ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tassert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; tassertTrue ( client . set ( " test1 " , 5 , " test1value " ) . get ( ) ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassert client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; tassertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " ) . get ( ) ) ; tassert ! client . add ( " test1 " , 5 , " ignoredvalue " ) . getStatus ( ) . isSuccess ( ) ; } 
public void testAddWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertNull ( client . get ( " test1 " , ) ) ; tassert ! client . asyncGet ( " test1 " , ) . getStatus ( ) . isSuccess ( ) ; tassertTrue ( client . set ( " test1 " , 5 , " test1value " , ) . get ( ) ) ; tassertEquals ( " test1value " , client . get ( " test1 " , ) ) ; tassertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; tassert ! client . add ( " test1 " , 5 , " ignoredvalue " , ) . getStatus ( ) . isSuccess ( ) ; } 
public void testUpdate ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . replace ( " test1 " , 5 , " test1value " ) ; tassert ! client . replace ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testUpdateWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertNull ( client . get ( " test1 " , ) ) ; tclient . replace ( " test1 " , 5 , " test1value " , ) ; tassert ! client . replace ( " test1 " , 5 , " test1value " , ) . getStatus ( ) . isSuccess ( ) ; tassertNull ( client . get ( " test1 " , ) ) ; } 
public void testGetBulk ( ) throws Exception { tCollection < String > keys = Arrays . asList ( " test1 " , " test2 " , " test3 " ) ; tassertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " ) ; tclient . set ( " test2 " , 5 , " val2 " ) ; tMap < String , Object > vals = client . getBulk ( keys ) ; tassert client . asyncGetBulk ( keys ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetBulkVararg ( ) throws Exception { tassertEquals ( 0 , client . getBulk ( " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " ) ; tclient . set ( " test2 " , 5 , " val2 " ) ; tMap < String , Object > vals = client . getBulk ( " test1 " , " test2 " , " test3 " ) ; tassert client . asyncGetBulk ( " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetBulkVarargWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " , ) ; tclient . set ( " test2 " , 5 , " val2 " , ) ; tMap < String , String > vals = client . getBulk ( , " test1 " , " test2 " , " test3 " ) ; tassert client . asyncGetBulk ( , " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( 2 , vals . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testAsyncGetBulkVarargWithTranscoder ( ) throws Exception { tTranscoder < String > = new TestTranscoder ( ) ; tassertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; tclient . set ( " test1 " , 5 , " val1 " , ) ; tclient . set ( " test2 " , 5 , " val2 " , ) ; tBulkFuture < Map < String , String > > vals = client . asyncGetBulk ( , " test1 " , " test2 " , " test3 " ) ; tassert vals . getStatus ( ) . isSuccess ( ) ; tassertEquals ( 2 , vals . get ( ) . size ( ) ) ; tassertEquals ( " val1 " , vals . get ( ) . get ( " test1 " ) ) ; tassertEquals ( " val2 " , vals . get ( ) . get ( " test2 " ) ) ; } 
public void testNonexistentMutate ( ) throws Exception { tassertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; tassert ! client . asyncIncr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; tassertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; tassert ! client . asyncDecr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; } 
public void testMutateWithDefaultAndExp ( ) throws Exception { tassertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; tassertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; tassertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; tassertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; tThread . sleep ( 2000 ) ; tassertNull ( client . get ( " mtest " ) ) ; tassert ! client . asyncGet ( " mtest " ) . getStatus ( ) . isSuccess ( ) ; } 
public void testImmediateDelete ( ) throws Exception { tassertNull ( client . get ( " test1 " ) ) ; tclient . set ( " test1 " , 5 , " test1value " ) ; tassertEquals ( " test1value " , client . get ( " test1 " ) ) ; tassert client . delete ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; tassertNull ( client . get ( " test1 " ) ) ; } 
public void testABunchOfCancelledOperations ( ) throws Exception { tfinal String k = " bunchOCancel " ; tCollection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; tfor ( int i = 0 ; i < 1000 ; i + + ) { tfutures . add ( client . set ( k , 5 , " xval " ) ) ; tfutures . add ( client . asyncGet ( k ) ) ; } tOperationFuture < Boolean > sf = client . set ( k , 5 , " myxval " ) ; tGetFuture < Object > gf = client . asyncGet ( k ) ; tfor ( Future < ? > f : futures ) { tf . cancel ( true ) ; } tassertTrue ( sf . get ( ) ) ; tassert sf . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " myxval " , gf . get ( ) ) ; tassert gf . getStatus ( ) . isSuccess ( ) ; } 
public void testAppend ( ) throws Exception { tfinal String key = " append.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tOperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; tassertTrue ( op . get ( ) ) ; tassert op . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " testes " , client . get ( key ) ) ; } 
public void testPrepend ( ) throws Exception { tfinal String key = " prepend.key " ; tassertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; tOperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; tassertTrue ( op . get ( ) ) ; tassert op . getStatus ( ) . isSuccess ( ) ; tassertEquals ( " estest " , client . get ( key ) ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( tConcatenationType catType , long cas , String key , tT value , Transcoder < T > tc ) { tCachedData co = tc . encode ( value ) ; tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , toperationTimeout ) ; tOperation op = opFact . cat ( catType , cas , key , co . getData ( ) , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { trv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , toperationTimeout ) ; tOperation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { trv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; tOperation op = opFact . get ( key , tnew GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tval = tcService . decode ( tc , tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; tOperation op = opFact . gets ( key , tnew GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < CASValue < T > > rv = tnew OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; tOperation op = opFact . getl ( key , exp , tnew GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { trv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert key . equals ( k ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , tint exp ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Long > rv = new OperationFuture < Long > ( key , tlatch , operationTimeout ) ; tOperation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ) ; trv . setOperation ( op ) ; treturn rv ; } 
public OperationFuture < Boolean > delete ( String key ) { tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , toperationTimeout ) ; tDeleteOperation op = opFact . delete ( key , tnew OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { trv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; trv . setOperation ( op ) ; taddOp ( key , op ) ; treturn rv ; } 
public OperationFuture < Boolean > flush ( final int delay ) { tfinal AtomicReference < Boolean > flushResult = tnew AtomicReference < Boolean > ( null ) ; tfinal ConcurrentLinkedQueue < Operation > ops = tnew ConcurrentLinkedQueue < Operation > ( ) ; tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { tOperation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { tflushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tops . add ( op ) ; treturn op ; } } ) ; treturn new OperationFuture < Boolean > ( null , blatch , flushResult , toperationTimeout ) { 
tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tOperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; tif ( status = = null ) { thandleError ( OperationErrorType . SERVER , new String ( pl ) ) ; 
public void testErrorCodes ( ) throws Exception { tHashMap < Byte , String > err_map = new HashMap < Byte , String > ( ) ; tOperationFactory opFact = new BinaryOperationFactory ( ) ; terr_map . put ( new Byte ( ( byte ) 0x01 ) , " NOT FOUND " ) ; terr_map . put ( new Byte ( ( byte ) 0x02 ) , " EXISTS " ) ; terr_map . put ( new Byte ( ( byte ) 0x03 ) , " 2BIG " ) ; terr_map . put ( new Byte ( ( byte ) 0x04 ) , " INVAL " ) ; terr_map . put ( new Byte ( ( byte ) 0x05 ) , " NOT STORED " ) ; terr_map . put ( new Byte ( ( byte ) 0x06 ) , " DELTA BAD VAL " ) ; terr_map . put ( new Byte ( ( byte ) 0x07 ) , " NOT MY VBUCKET " ) ; terr_map . put ( new Byte ( ( byte ) 0x81 ) , " UNKNOWN COMMAND " ) ; terr_map . put ( new Byte ( ( byte ) 0x82 ) , " NO MEM " ) ; terr_map . put ( new Byte ( ( byte ) 0x83 ) , " NOT SUPPORTED " ) ; terr_map . put ( new Byte ( ( byte ) 0x84 ) , " INTERNAL ERROR " ) ; terr_map . put ( new Byte ( ( byte ) 0x85 ) , " BUSY " ) ; terr_map . put ( new Byte ( ( byte ) 0x86 ) , " TEMP FAIL " ) ; tint opaque = 0 ; tfor ( final Entry < Byte , String > err : err_map . entrySet ( ) ) { tbyte [ ] b = new byte [ 24 + err . getValue ( ) . length ( ) ] ; 
public void receivedStatus ( OperationStatus s ) { tassert ! s . isSuccess ( ) ; tassert err . getValue ( ) . equals ( s . getMessage ( ) ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { } public void complete ( ) { } } ) ; tByteBuffer bb = ByteBuffer . wrap ( b ) ; tbb . flip ( ) ; top . readFromBuffer ( bb ) ; } } } 
public void complete ( ) { } } ) ; tByteBuffer bb = ByteBuffer . wrap ( b ) ; tbb . flip ( ) ; top . readFromBuffer ( bb ) ; } } } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) { treturn asyncGetBulk ( keys , new SingleElementInfiniteIterator < Transcoder < T > > ( tc ) ) ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { tassert k . equals ( key ) : " Wrong key returned " ; tassert cas > 0 : " CAS was less than zero: " + cas ; tval = new CASValue < T > ( cas , tc . decode ( tnew CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) { setNodes ( nodes ) ; setConfig ( conf ) ; } 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; getLogger().debug("Read %d bytes", read); 
tCASOperation cas ( StoreType , String key , long casId , int flags , tint exp , byte [ ] data , OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tVersionOperation version ( OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tSASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tCollection < Operation > clone ( KeyedOperation op ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tTapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tTapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; } 
public boolean hasMoreMessages ( ) { tif ( ! rqueue . isEmpty ( ) ) { treturn true ; } else { tsynchronized ( omap ) { tIterator < Operation > itr = omap . keySet ( ) . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tOperation op = itr . next ( ) ; tif ( op . getState ( ) . equals ( OperationState . COMPLETE ) | | top . isCancelled ( ) | | op . hasErrored ( ) ) { tomap . get ( op ) . shutdown ( ) ; tomap . remove ( op ) ; } } tif ( omap . size ( ) > 0 ) { treturn true ; } } } treturn false ; } 
public Operation tapCustom ( String id , RequestMessage message , tString keyFilter , String valueFilter ) tthrows ConfigurationException , IOException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapCustom ( id , message , tnew TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { ttapAck ( conn , opcode , opaque , this ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; treturn op ; } 
public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } 
public void gotAck ( TapOpcode opcode , int opaque ) { ttapAck ( conn , opcode , opaque , this ) ; } 
public Operation tapBackfill ( String id , final int runTime , final TimeUnit timeunit ) tthrows IOException , ConfigurationException { treturn tapBackfill ( id , - 1 , runTime , timeunit ) ; } 
public Operation tapBackfill ( final String id , final long date , final int runTime , tfinal TimeUnit timeunit ) throws IOException , ConfigurationException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapBackfill ( id , date , tnew TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { ttapAck ( conn , opcode , opaque , this ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; tif ( runTime > 0 ) { tRunnable r = new Runnable ( ) { @Override public void run ( ) { ttry { tThread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tconn . shutdown ( ) ; tsynchronized ( omap ) { tomap . remove ( op ) ; } } } ; tnew Thread ( r ) . start ( ) ; } treturn op ; } 
public void run ( ) { ttry { tThread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tconn . shutdown ( ) ; tsynchronized ( omap ) { tomap . remove ( op ) ; 
private void tapAck ( TapConnectionProvider conn , TapOpcode opcode , int opaque , tOperationCallback cb ) { tfinal Operation op = conn . opFact . tapAck ( opcode , opaque , cb ) ; tconn . addOp ( op ) ; } 
public void shutdown ( ) { tsynchronized ( omap ) { tfor ( Map . Entry < Operation , TapConnectionProvider > me : omap . entrySet ( ) ) { 
public void run ( ) { twhile ( running ) { tif ( ! reconfiguring ) { ttry { tconn . handleIO ( ) ; } catch ( IOException e ) { tlogRunException ( e ) ; } catch ( CancelledKeyException e ) { tlogRunException ( e ) ; } catch ( ClosedSelectorException e ) { tlogRunException ( e ) ; } catch ( IllegalStateException e ) { tlogRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
tOperation addOp ( final Operation op ) { tcheckState ( ) ; tconn . addOperation ( " " , op ) ; treturn op ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { tif ( authDescriptor ! = null ) { tif ( authDescriptor . authThresholdReached ( ) ) { 
public void connectionLost ( SocketAddress sa ) { }} 
public void reconfigure ( Bucket bucket ) { this . reconfiguring = true ; this . conn . reconfigure ( bucket ) ; this . reconfiguring = false ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public void receivedStatus ( OperationStatus s ) { }} 
public static void printMessage ( BaseMessage message , PrintWriter p ) { tint colNum = 0 ; tbyte [ ] mbytes = message . getBytes ( ) . array ( ) ; tp . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; tp . print ( " ---------------------- " ) ; tfor ( int i = 0 ; i < mbytes . length ; i + + ) { tif ( ( i % 4 ) = = 0 ) { tp . printf ( " n%3d| " , colNum ) ; tcolNum + = 4 ; } tint field = mbytes [ i ] ; tif ( field < 0 ) tfield = field + 256 ; tp . printf ( " %5x " , field ) ; } tp . print ( " " ) ; } 
public void gotData ( ResponseMessage message ) ; public void gotAck ( TapOpcode opcode , int opaque ) ; } public void streamClosed ( OperationState state ) ; } 
public void gotAck ( TapOpcode opcode , int opaque ) ; } public void streamClosed ( OperationState state ) ; } 
public TapOperation tapBackfill ( String id , long date , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapCustom ( String id , RequestMessage message , tOperationCallback cb ) { tthrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapBackfill ( String id , long date , OperationCallback cb ) { treturn new TapBackfillOperationImpl ( id , date , cb ) ; } 
public TapOperation tapCustom ( String id , RequestMessage message , tOperationCallback cb ) { treturn new TapCustomOperationImpl ( id , message , cb ) ; } 
public TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { treturn new TapAckOperationImpl ( opcode , opaque , cb ) ; } 
public void initialize ( ) { tRequestMessage message = new RequestMessage ( ) ; tmessage . setMagic ( TapMagic . PROTOCOL_BINARY_RES ) ; tmessage . setOpcode ( opcode ) ; tmessage . setOpaque ( opaque ) ; tsetBuffer ( message . getBytes ( ) ) ; } 
public void streamClosed ( OperationState state ) { ttransitionState ( state ) ; } 
public void initialize ( ) { tRequestMessage message = new RequestMessage ( ) ; tmessage . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; tmessage . setOpcode ( TapOpcode . REQUEST ) ; tmessage . setFlags ( TapFlag . BACKFILL ) ; tmessage . setFlags ( TapFlag . SUPPORT_ACK ) ; tif ( id ! = null ) { tmessage . setName ( id ) ; } else { tmessage . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } tmessage . setBackfill ( date ) ; tsetBuffer ( message . getBytes ( ) ) ; } 
public void initialize ( ) { tif ( id ! = null ) { tmessage . setName ( id ) ; } else { tmessage . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } tsetBuffer ( message . getBytes ( ) ) ; } 
public void readFromBuffer ( ByteBuffer data ) throws IOException { twhile ( data . remaining ( ) > 0 ) { tif ( bytesProcessed < BaseMessage . HEADER_LENGTH ) { 
public void doBackfill ( long date ) { tmessage . setBackfill ( date ) ; tmessage . setFlags ( TapFlag . BACKFILL ) ; } 
public void doDump ( ) { tmessage . setFlags ( TapFlag . DUMP ) ; } 
public void specifyVbuckets ( int [ ] vbucketlist ) { tmessage . setVbucketlist ( vbucketlist ) ; tmessage . setFlags ( TapFlag . LIST_VBUCKETS ) ; } 
public void supportAck ( ) { tmessage . setFlags ( TapFlag . SUPPORT_ACK ) ; } 
public void keysOnly ( ) { tmessage . setFlags ( TapFlag . KEYS_ONLY ) ; } 
public void takeoverVbuckets ( int [ ] vbucketlist ) { tmessage . setVbucketlist ( vbucketlist ) ; tmessage . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; } 
tboolean hasFlag ( int f ) { tif ( ( f & ( int ) flag ) = = 1 ) { treturn false ; } treturn true ; } 
public static long fieldToValue ( byte [ ] buffer , int offset , int length ) { tlong total = 0 ; tlong val = 0 ; tfor ( int i = 0 ; i < length ; i + + ) { tval = buffer [ offset + i ] ; tif ( val < 0 ) tval = val + 256 ; ttotal + = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) * val ; } treturn total ; } 
public static void valueToFieldOffest ( byte [ ] buffer , int offset , int length , long l ) { tlong divisor ; tfor ( int i = 0 ; i < length ; i + + ) { tdivisor = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) ; 
public void testTapBucketDoesNotExist ( ) throws Exception { tTapClient client = new TapClient ( Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) , " abucket " , " abucket " , " apassword " ) ; ttry { tclient . tapBackfill ( null , 5 , TimeUnit . SECONDS ) ; 
public void testTimeoutDontwrite ( ) { tOperation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { tSystem . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { tSystem . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { tSystem . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { tsetBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; ttry { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } tclient . addOp ( " x " , op ) ; tSystem . err . println ( " Operation attempted: " ) ; tSystem . err . println ( op ) ; tSystem . err . println ( " Trying to get: " ) ; ttry { tclient . get ( " x " ) ; tString retValString = new String ( ) ; tSystem . err . println ( retValString ) ; } tcatch ( net . spy . memcached . OperationTimeoutException ex ) { tSystem . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } tSystem . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; tassert ( op . isTimedOut ( ) = = true ) ; } 
public void testOps ( ) throws Exception { MemcachedClient mc = null ; try { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
public void testMessageReceived ( ) throws NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); } 
void setVBucket ( String key , short vbucket ) ; short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
tprotected int addKey ( String k ) { tInteger rv = rkeys . get ( k ) ; tif ( rv = = null ) { trv = generateOpaque ( ) ; tkeys . put ( rv , k ) ; tbkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; trkeys . put ( k , rv ) ; tvbmap . put ( k , new Short ( ( short ) 0 ) ) ; } treturn rv ; } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( byte [ ] b : bkeys . values ( ) ) { tsize + = b . length ; } } 
tprotected void prepareBuffer ( String key , long cas , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tfinal byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tint bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
public void initialize ( ) { } 
private void addOperation ( final MemcachedNode node , final Operation o ) { to . setHandlingNode ( node ) ; to . initialize ( ) ; tnode . addOp ( o ) ; taddedQueue . offer ( node ) ; tSelector s = selector . wakeup ( ) ; tassert s = = selector : " Wakeup returned the wrong selector. " ; tgetLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { tfor ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { tfinal MemcachedNode node = me . getKey ( ) ; tOperation o = me . getValue ( ) ; } 
public void testGATTimeout ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tassertNull ( client . get ( " gatkey " ) ) ; 
public void testTouchTimeout ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tassertNull ( client . get ( " touchkey " ) ) ; 
tprotected void flushPause ( ) throws InterruptedException { }} 
public void testGetStatsSlabs ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { return ; } } 
public void testGetStatsSizes ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { treturn ; } } 
public void testGetStatsCacheDump ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { treturn ; } } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { return ; } tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 21 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { tSystem . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
private static String resolveIpv6Addr ( ) { tString ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; ; tif ( IPV4_ADDR . equals ( ipv6 ) ) { treturn " ::ffff: " + ipv6 ; } treturn ipv6 ; } 
public static final boolean isMemcached ( ) { treturn TYPE . equals ( TYPE_MEMCACHED ) ; } 
public static final boolean isMembase ( ) { treturn TYPE . equals ( TYPE_MEMBASE ) ; } 
public GetAndTouchOperation getAndTouch ( String key , int expiration , tGetAndTouchOperation . Callback cb ) { treturn new GetAndTouchOperationImpl ( key , expiration , cb ) ; } 
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { treturn new GetsOperationImpl ( key , cb ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; tGetAndTouchOperation . Callback gcb = ( GetAndTouchOperation . Callback ) getCallback ( ) ; tgcb . gotData ( key , flags , responseCas , data ) ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; tGetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; tgcb . gotData ( key , flags , data ) ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; tGetlOperation . Callback gcb = ( GetlOperation . Callback ) getCallback ( ) ; tgcb . gotData ( key , flags , responseCas , data ) ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
tprotected void decodePayload ( byte [ ] pl ) { tfinal int flags = decodeInt ( pl , 0 ) ; tfinal byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; tSystem . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; tGetsOperation . Callback gcb = ( GetsOperation . Callback ) getCallback ( ) ; tgcb . gotData ( key , flags , responseCas , data ) ; tgetCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public void readFromBuffer ( ByteBuffer data ) { }} 
public void testBackfill ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tTapClient tc = new TapClient ( AddrUtil . getAddresses ( " 127.0.0.1:11210 " ) ) ; 
public void testTapBucketDoesNotExist ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tTapClient client = new TapClient ( Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) , 
tprotected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) tthrows IOException { tswitch ( errCode ) { tcase SUCCESS : 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " :11211 " ) ) ; 
tprotected void setUp ( ) throws Exception { tserverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; tsuper . setUp ( ) ; } 
tprotected void tearDown ( ) throws Exception { tserverList = TestConfig . IPV4_ADDR + " :11211 " ; tsuper . tearDown ( ) ; } 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :64213 " ) ) ; 
public void testUnavailableServers ( ) { tclient . asyncGet ( " x " ) ; tassertEquals ( new ArrayList < String > ( tCollections . singleton ( " / " + TestConfig . IPV4_ADDR + " :64213 " ) ) , 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MemcachedClient ( cf , tAddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; 
public static void main ( String [ ] args ) throws Exception { } 
private void assertWorking ( ) throws Exception { tMap < SocketAddress , String > versions = client . getVersions ( ) ; tassertEquals ( " / " + TestConfig . IPV4_ADDR + " :11211 " , tversions . keySet ( ) . iterator ( ) . next ( ) . toString ( ) ) ; 
public void testVarargConstructor ( ) throws Exception { tclient = new MemcachedClient ( tnew InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , 11211 ) ) ; tassertWorking ( ) ; } 
public void testArraymodNodeLocatorAccessor ( ) throws Exception { tclient = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; tassertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; tassertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) tinstanceof MemcachedNodeROImpl ) ; 
public void testKetamaNodeLocatorAccessor ( ) throws Exception { tclient = new MemcachedClient ( new KetamaConnectionFactory ( ) , tAddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; tassertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; tassertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) tinstanceof MemcachedNodeROImpl ) ; 
tprotected void setUp ( ) throws Exception { tserverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; tsuper . setUp ( ) ; } 
tprotected void tearDown ( ) throws Exception { tserverList = TestConfig . IPV4_ADDR + " :11211 " ; tsuper . tearDown ( ) ; } 
public void testBackfill ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tTapClient tc = new TapClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11210 " ) ) ; 
public void testTapBucketDoesNotExist ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tTapClient client = new TapClient ( Arrays . asList ( 
private static final String resolveIpv6Addr ( ) { tString ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; } 
public static final boolean defaultToIPV4 ( ) { tif ( ( " ::ffff: " + IPV4_ADDR ) . equals ( IPV6_ADDR ) ) { treturn true ; } treturn false ; } 
public static final boolean isMembase ( ) { tSystem . out . println ( TYPE ) ; treturn TYPE . equals ( TYPE_MEMBASE ) ; } 
public void testOps ( ) throws Exception { MemcachedClient mc = null ; try { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
public void testSingleOperation ( ) { tOperation op = buildOp ( 11211 ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " :11211 " , 
public void testMultipleOperation ( ) { tCollection < Operation > ops = new ArrayList < Operation > ( ) ; tops . add ( buildOp ( 11211 ) ) ; tops . add ( buildOp ( 64212 ) ) ; tassertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " :11211, " 
private TestOperation buildOp ( int portNum ) { tTestOperation op = new TestOperation ( ) ; tMockMemcachedNode node = new MockMemcachedNode ( tInetSocketAddress . createUnresolved ( TestConfig . IPV4_ADDR , portNum ) ) ; top . setHandlingNode ( node ) ; treturn op ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " deamon " , true , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; } 
tboolean hasFlag ( int f ) { tif ( ( f & ( int ) flag ) > 0 ) { treturn true ; } treturn false ; } 
tSASLMechsOperation saslMechs ( OperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tSASLAuthOperation saslAuth ( String [ ] mech , String serverName , tMap < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tSASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , tString serverName , Map < String , ? > props , CallbackHandler cbh , tOperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tCollection < Operation > clone ( KeyedOperation op ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tTapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tTapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
tTapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; tTapOperation tapDump ( String id , OperationCallback cb ) ; } 
public Operation tapDump ( final String id ) throws IOException , ConfigurationException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { ttapAck ( conn , opcode , opaque , this ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; treturn op ; } 
public TapOperation tapDump ( String id , OperationCallback cb ) { tthrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapDump ( String id , OperationCallback cb ) { treturn new TapDumpOperationImpl ( id , cb ) ; } 
public void initialize ( ) { tRequestMessage message = new RequestMessage ( ) ; tmessage . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; tmessage . setOpcode ( TapOpcode . REQUEST ) ; tmessage . setFlags ( TapFlag . DUMP ) ; tmessage . setFlags ( TapFlag . SUPPORT_ACK ) ; tif ( id ! = null ) { tmessage . setName ( id ) ; } else { tmessage . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } tsetBuffer ( message . getBytes ( ) ) ; } 
public void testTapDump ( ) throws Exception { tif ( TestConfig . isMembase ( ) ) { tTapClient tc = new TapClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11210 " ) ) ; 
public Operation tapCustom ( String id , RequestMessage message , tString keyFilter , String valueFilter ) tthrows ConfigurationException , IOException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapCustom ( id , message , tnew TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { trqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; treturn op ; } 
public void gotAck ( TapOpcode opcode , int opaque ) { trqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } 
public Operation tapBackfill ( final String id , final long date , final int runTime , tfinal TimeUnit timeunit ) throws IOException , ConfigurationException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapBackfill ( id , date , tnew TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { trqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; tif ( runTime > 0 ) { tRunnable r = new Runnable ( ) { @Override public void run ( ) { ttry { tThread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { tThread . currentThread ( ) . interrupt ( ) ; } tconn . shutdown ( ) ; tsynchronized ( omap ) { tomap . remove ( op ) ; } } } ; tnew Thread ( r ) . start ( ) ; } treturn op ; } 
public Operation tapDump ( final String id ) throws IOException , ConfigurationException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { trqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; treturn op ; } 
private URLConnection urlConnBuilder ( URI base , URI resource ) throws IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . toURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; tif ( restUsr ! = null ) { try { tconnection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } catch ( UnsupportedEncodingException ex ) { tthrow new IOException ( " Could not encode specified credentials for HTTP request. " , ex ) ; } } return connection ; 
protected static String buildAuthHeader ( String username , String password ) throws UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); return headerResult; } 
public void testBuildAuthHeader ( ) throws UnsupportedEncodingException { tConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ; } 
public void testBuildAuthHeaderUTF8 ( ) throws UnsupportedEncodingException { tString result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); } 
private Map < String , MemcachedNode > fillNodesEntries ( Collection < MemcachedNode > nodes ) { HashMap < String , MemcachedNode > vbnodesMap = new HashMap < String , MemcachedNode > ( ) ; getLogger ( ) . debug ( " Updating nodesMap in VBucketNodeLocator. " ) ; for ( MemcachedNode node : nodes ) { InetSocketAddress addr = ( InetSocketAddress ) node . getSocketAddress ( ) ; String address = addr . getAddress ( ) . getHostName ( ) + " : " + addr . getPort ( ) ; String hostname = addr . getAddress ( ) . getHostAddress ( ) + " : " + addr . getPort ( ) ; getLogger ( ) . debug ( " Adding node with hostname %s and address %s. " , hostname , address ) ; getLogger ( ) . debug ( " Node added is %s. " , node ) ; vbnodesMap . put ( address , node ) ; vbnodesMap . put ( hostname , node ) ; } return Collections . unmodifiableMap ( vbnodesMap ) ; } 
public MemcachedNode next ( ) { tthrow new NoSuchElementException ( " VBucketNodeLocators have no alternate nodes. " ) ; } 
public void remove ( ) { tthrow new UnsupportedOperationException ( " VBucketNodeLocators have no alternate nodes; cannot remove. " ) ; } 
public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { tthis . nodes = nodes . toArray ( new MemcachedNode [ nodes . size ( ) ] ) ; } 
public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { tsetKetamaNodes ( nodes ) ; } 
public void reconfigure ( Bucket bucket ) { ttry { get a new collection of addresses from the received config 
tMemcachedNode getPrimary ( String k ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
tIterator < MemcachedNode > getSequence ( String k ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
tCollection < MemcachedNode > getAll ( ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
tNodeLocator getReadonlyCopy ( ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
public MembaseConnectionFactory buildMembaseConnection ( final List < URI > baseList , tfinal String bucketName , final String usr , final String pwd ) throws IOException { treturn new MembaseConnectionFactory ( baseList , bucketName , usr , pwd ) { 
public void run ( ) { twhile ( running ) { if ( ! reconfiguring ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down membase client " ) ; } 
tFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; } 
< T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , tfinal Transcoder < T > tc ) ; public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; } 
public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; tCASValue < Object > getAndLock ( String key , int exp ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { tswitch ( locator ) { tcase CONSISTENT : 
tprotected void logRunException ( Exception e ) { tif ( shuttingDown ) { There are a couple types of errors that occur during the 
public void run ( ) { twhile ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , tTranscoder < T > tc ) ; tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , tTranscoder < T > tc ) throws OperationTimeoutException ; tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tCASResponse cas ( String key , long casId , Object value ) tthrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , tTranscoder < T > tc ) ; tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tFuture < Object > asyncGet ( String key ) ; tFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; tCASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , tTranscoder < T > tc ) ; tFuture < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tCASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) tthrows OperationTimeoutException ; tObject get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tTranscoder < T > tc ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , tString . . . keys ) ; tBulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( Collection < String > keys ) tthrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) tthrows OperationTimeoutException ; tMap < String , Object > getBulk ( String . . . keys ) tthrows OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , tfinal Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; tMap < SocketAddress , String > getVersions ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( ) ; tMap < SocketAddress , Map < String , String > > getStats ( String prefix ) ; tlong incr ( String key , int by ) throws OperationTimeoutException ; tlong decr ( String key , int by ) throws OperationTimeoutException ; tlong incr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def , int exp ) tthrows OperationTimeoutException ; tFuture < Long > asyncIncr ( String key , int by ) ; tFuture < Long > asyncDecr ( String key , int by ) ; tlong incr ( String key , int by , long def ) tthrows OperationTimeoutException ; tlong decr ( String key , int by , long def ) tthrows OperationTimeoutException ; tFuture < Boolean > delete ( String key ) ; tFuture < Boolean > flush ( int delay ) ; tFuture < Boolean > flush ( ) ; tvoid shutdown ( ) ; tboolean shutdown ( long timeout , TimeUnit unit ) ; tboolean waitForQueues ( long timeout , TimeUnit unit ) ; tboolean addObserver ( ConnectionObserver obs ) ; tboolean removeObserver ( ConnectionObserver obs ) ; tSet < String > listSaslMechanisms ( ) ; } 
tprotected void syncGetTimeoutsInitClient ( ) throws Exception { tinitClient ( new BinaryConnectionFactory ( ) { @Override 
tprotected void initClient ( ) throws Exception { tinitClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) , " default " , " default " , " " ) ) ; 
tprotected void initClient ( ConnectionFactory cf ) throws Exception { tclient = new MembaseClient ( ( MembaseConnectionFactory ) cf ) ; } 
public void testAvailableServers ( ) { } 
tprotected void syncGetTimeoutsInitClient ( ) throws Exception { tinitClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http:localhost:8091/pools " ) ) , " default " , " default " , " " ) { 
tprotected void syncGetTimeoutsInitClient ( ) throws Exception { tinitClient ( new DefaultConnectionFactory ( ) { @Override 
public void testSyncGetTimeouts ( ) throws Exception { tfinal String key = " timeoutTestKey " ; tfinal String value = " timeoutTestValue " ; tint j = 0 ; tboolean set = false ; tdo { tset = client . set ( key , 0 , value ) . get ( ) ; tj + + ; } while ( ! set & & j < 10 ) ; tassert set = = true ; if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) { 
tprotected void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ; 
public void testOps ( ) throws Exception { MembaseClient mc = null ; try { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
public void reconfigure ( Bucket bucket ) { treconfiguring = true ; ttry { tmconn . reconfigure ( bucket ) ; 
public void run ( ) { twhile ( running ) { if ( ! reconfiguring ) { try { mconn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down membase client " ) ; } 
tOperation addOp ( final String key , final Operation op ) { tvalidateKey ( key ) ; tcheckState ( ) ; tmconn . addOperation ( key , op ) ; treturn op ; } 
tCountDownLatch broadcastOp ( final BroadcastOpFactory of ) { treturn broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , true ) ; } 
private CountDownLatch broadcastOp ( BroadcastOpFactory of , tCollection < MemcachedNode > nodes , tboolean checkShuttingDown ) { tif ( checkShuttingDown & & shuttingDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } treturn mconn . broadcastOperation ( of , nodes ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void run ( ) { twhile ( running ) { try { mconn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { tCountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , tfinal CountDownLatch latch ) { treturn opFact . noop ( tnew OperationCallback ( ) { public void complete ( ) { tlatch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here 
public boolean removeObserver ( ConnectionObserver obs ) { treturn mconn . removeObserver ( obs ) ; } 
tOperation addOp ( final String key , final Operation op ) { tvalidateKey ( key ) ; tmconn . checkState ( ) ; tmconn . addOperation ( key , op ) ; treturn op ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public void reconfigure ( Bucket bucket ) { treconfiguring = true ; ttry { get a new collection of addresses from the received config 
public void checkState ( ) { tif ( shutDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; } 
public void run ( ) { twhile ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
private void logRunException ( Exception e ) { tif ( shutDown ) { There are a couple types of errors that occur during the 
tOperation addOp ( final Operation op ) { tconn . checkState ( ) ; tconn . addOperation ( " " , op ) ; treturn op ; } 
public void connectionLost ( SocketAddress sa ) { }} 
public void reconfigure ( Bucket bucket ) { this . conn . reconfigure ( bucket ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; } 
public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) { tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < List < View > > crv = tnew HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new HttpOperation ( request , new HttpCallback ( ) { @Override public void complete ( String response ) { ttry { tcrv . set ( DocParserUtils . parseDesignDocumentForViews ( bucketName , designDocumentName , response ) ) ; } catch ( ParseException e ) { tgetLogger ( ) . error ( e . getMessage ( ) ) ; } tcouchLatch . countDown ( ) ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void complete ( String response ) { ttry { tcrv . set ( DocParserUtils . parseDesignDocumentForViews ( bucketName , designDocumentName , response ) ) ; } catch ( ParseException e ) { tgetLogger ( ) . error ( e . getMessage ( ) ) ; } tcouchLatch . countDown ( ) ; } 
public void addOp ( final HttpOperation op ) { tcconn . checkState ( ) ; tcconn . addOp ( op ) ; } 
public boolean shutdown ( long duration , TimeUnit units ) { ttry { treturn super . shutdown ( duration , units ) & & cconn . shutdown ( ) ; 
private List < CouchbaseNode > createConnections ( List < InetSocketAddress > addrs ) tthrows IOException { tList < CouchbaseNode > nodeList = new LinkedList < CouchbaseNode > ( ) ; tfor ( InetSocketAddress a : addrs ) { tHttpParams params = new SyncBasicHttpParams ( ) ; tparams . setIntParameter ( CoreConnectionPNames . SO_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . CONNECTION_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . SOCKET_BUFFER_SIZE , 8 * 1024 ) . setBooleanParameter ( CoreConnectionPNames . STALE_CONNECTION_CHECK , false ) . setBooleanParameter ( CoreConnectionPNames . TCP_NODELAY , true ) . setParameter ( CoreProtocolPNames . USER_AGENT , " Spymemcached Client/1.1 " ) ; tHttpProcessor httpproc = new ImmutableHttpProcessor ( tnew HttpRequestInterceptor [ ] { new RequestContent ( ) , tnew RequestTargetHost ( ) , new RequestConnControl ( ) , tnew RequestUserAgent ( ) , new RequestExpectContinue ( ) } ) ; tAsyncNHttpClientHandler protocolHandler = new AsyncNHttpClientHandler ( thttpproc , new MyHttpRequestExecutionHandler ( ) , tnew DefaultConnectionReuseStrategy ( ) , tnew DirectByteBufferAllocator ( ) , params ) ; tprotocolHandler . setEventListener ( new EventLogger ( ) ) ; tAsyncConnectionManager connMgr = new AsyncConnectionManager ( tnew HttpHost ( a . getHostName ( ) , a . getPort ( ) ) , NUM_CONNS , tprotocolHandler , params ) ; tgetLogger ( ) . info ( " Added %s to connect queue " , a ) ; tCouchbaseNode node = connFactory . createCouchDBNode ( a , connMgr ) ; tnode . init ( ) ; tnodeList . add ( node ) ; } treturn nodeList ; } 
public void addOp ( final HttpOperation op ) { tnodes . get ( getNextNode ( ) ) . addOp ( op ) ; } 
public void handleIO ( ) { tfor ( CouchbaseNode node : nodes ) { tnode . doWrites ( ) ; 
tprotected void checkState ( ) { tif ( shutDown ) { tthrow new IllegalStateException ( " Shutting down " ) ; } tassert isAlive ( ) : " IO Thread is not running. " ; } 
public boolean shutdown ( ) throws IOException { tif ( shutDown ) { tgetLogger ( ) . info ( " Suppressing duplicate attempt to shut down " ) ; treturn false ; } tshutDown = true ; trunning = false ; tfor ( CouchbaseNode : nodes ) { tif ( ! = null ) { tn . shutdown ( ) ; tif ( . hasWriteOps ( ) ) { tgetLogger ( ) . warn ( " Shutting down with ops waiting to be written " ) ; } } } treturn true ; } 
public void reconfigure ( Bucket bucket ) { }} 
public void run ( ) { twhile ( running ) { tif ( ! reconfiguring ) { ttry { thandleIO ( ) ; } catch ( Exception e ) { tlogRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
private void logRunException ( Exception e ) { tif ( shutDown ) { There are a couple types of errors that occur during the 
public CouchbaseNode createCouchDBNode ( InetSocketAddress addr , tAsyncConnectionManager connMgr ) { treturn new CouchbaseNode ( addr , connMgr , tnew LinkedBlockingQueue < HttpOperation > ( opQueueLen ) , 
public MemcachedConnection createMemcachedConnection ( tList < InetSocketAddress > addrs ) throws IOException { treturn new MemcachedConnection ( getReadBufSize ( ) , this , addrs , tgetInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ; 
public CouchbaseConnection createCouchDBConnection ( tList < InetSocketAddress > addrs ) throws IOException { treturn new CouchbaseConnection ( this , addrs , getInitialObservers ( ) ) ; } 
public void init ( ) throws IOReactorException { } 
public void run ( ) { ttry { tconnMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { tgetLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { tgetLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; te . printStackTrace ( ) ; } tSystem . out . println ( " I/O reactor terminated " ) ; } 
public void doWrites ( ) { tHttpOperation op ; twhile ( ( op = writeQ . poll ( ) ) ! = null ) { tif ( ! op . isTimedOut ( ) & & ! op . isCancelled ( ) ) { 
public boolean hasWriteOps ( ) { treturn ! writeQ . isEmpty ( ) ; } 
public void addOp ( HttpOperation op ) { ttry { tif ( ! writeQ . offer ( op , opQueueMaxBlockTime , TimeUnit . MILLISECONDS ) ) { 
public void shutdown ( ) throws IOException { tshutdown ( 0 , TimeUnit . MILLISECONDS ) ; } 
public void shutdown ( long time , TimeUnit unit ) throws IOException { tif ( unit ! = TimeUnit . MILLISECONDS ) { tconnMgr . shutdown ( TimeUnit . MILLISECONDS . convert ( time , unit ) ) ; 
public void initalizeContext ( final HttpContext context , tfinal Object attachment ) { } public void finalizeContext ( final HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tif ( handle ! = null ) { thandle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { tHttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; tif ( op = = null ) { treturn null ; } treturn op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , tfinal HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tHttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; tif ( handle ! = null ) { thandle . completed ( ) ; tif ( ! op . isTimedOut ( ) & & ! op . hasErrored ( ) & & ! op . isCancelled ( ) ) { ttry { tString json = EntityUtils . toString ( response . getEntity ( ) ) ; top . getCallback ( ) . complete ( json ) ; } catch ( ParseException e ) { top . setException ( new OperationException ( OperationErrorType . GENERAL , " Bad http headers " ) ) ; } catch ( IOException e ) { top . setException ( new OperationException ( OperationErrorType . GENERAL , " Error reading response " ) ) ; } catch ( IllegalArgumentException e ) { top . setException ( new OperationException ( OperationErrorType . GENERAL , " No entity " ) ) ; } } } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , tHttpContext context ) throws IOException { treturn new BufferingNHttpEntity ( response . getEntity ( ) , tnew HeapByteBufferAllocator ( ) ) ; } } tstatic class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { tgetLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } } 
public void finalizeContext ( final HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tif ( handle ! = null ) { thandle . cancel ( ) ; 
public HttpRequest submitRequest ( final HttpContext context ) { tHttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; tif ( op = = null ) { treturn null ; } treturn op . getRequest ( ) ; } 
public void handleResponse ( final HttpResponse response , tfinal HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tHttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; tif ( handle ! = null ) { thandle . completed ( ) ; 
public ConsumingNHttpEntity responseEntity ( HttpResponse response , tHttpContext context ) throws IOException { treturn new BufferingNHttpEntity ( response . getEntity ( ) , tnew HeapByteBufferAllocator ( ) ) ; 
public void connectionOpen ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection open: " + conn ) ; } 
public void connectionTimeout ( final NHttpConnection conn ) { tgetLogger ( ) . error ( " Connection timed out: " + conn ) ; } 
public void connectionClosed ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection closed: " + conn ) ; } 
public void fatalIOException ( final IOException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } 
public void fatalProtocolException ( final HttpException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } 
public void execute ( ) throws IOException { tIOEventDispatch dispatch = new DefaultClientIOEventDispatch ( tnew ManagedClientHandler ( this . handler , this ) , this . params ) ; tthis . ioreactor . execute ( dispatch ) ; } 
public void shutdown ( long waitMs ) throws IOException { tsynchronized ( this . lock ) { tif ( ! this . shutdown ) { tthis . shutdown = true ; twhile ( ! this . pendingRequests . isEmpty ( ) ) { tAsyncConnectionRequest request = this . pendingRequests . remove ( ) ; trequest . cancel ( ) ; } tthis . availableConns . clear ( ) ; tthis . allConns . clear ( ) ; } } tthis . ioreactor . shutdown ( waitMs ) ; } 
tvoid addConnection ( NHttpClientConnection conn ) { tif ( conn = = null ) { treturn ; } tif ( this . shutdown ) { treturn ; } tsynchronized ( this . lock ) { tthis . allConns . add ( conn ) ; 
tvoid removeConnection ( NHttpClientConnection conn ) { tif ( conn = = null ) { treturn ; } tif ( this . shutdown ) { treturn ; } tsynchronized ( this . lock ) { tif ( this . allConns . remove ( conn ) ) { 
public AsyncConnectionRequest requestConnection ( ) { tif ( this . shutdown ) { tthrow new IllegalStateException ( " Connection manager has been shut down " ) ; } tAsyncConnectionRequest request = new AsyncConnectionRequest ( ) ; tsynchronized ( this . lock ) { twhile ( ! this . availableConns . isEmpty ( ) ) { tNHttpClientConnection conn = this . availableConns . remove ( ) ; tif ( conn . isOpen ( ) ) { tgetLogger ( ) . debug ( " Re-using persistent connection " ) ; trequest . setConnection ( conn ) ; tbreak ; } else { tthis . allConns . remove ( conn ) ; } } tif ( ! request . isCompleted ( ) ) { tthis . pendingRequests . add ( request ) ; tprocessConnectionRequests ( ) ; } } treturn request ; } 
public void releaseConnection ( NHttpClientConnection conn ) { tif ( conn = = null ) { treturn ; } tif ( this . shutdown ) { treturn ; } tsynchronized ( this . lock ) { tif ( this . allConns . contains ( conn ) ) { 
private void processConnectionRequests ( ) { twhile ( this . allConns . size ( ) < this . maxConnections ) { tAsyncConnectionRequest request = this . pendingRequests . poll ( ) ; 
public void connected ( NHttpClientConnection conn , Object attachment ) { tAsyncConnectionRequest request = ( AsyncConnectionRequest ) attachment ; tthis . handler . connected ( conn , attachment ) ; tthis . connMgr . addConnection ( conn ) ; trequest . setConnection ( conn ) ; } 
public void closed ( NHttpClientConnection conn ) { tthis . connMgr . removeConnection ( conn ) ; tthis . handler . closed ( conn ) ; } 
public void requestReady ( NHttpClientConnection conn ) { tthis . handler . requestReady ( conn ) ; } 
public void outputReady ( NHttpClientConnection conn , tContentEncoder encoder ) { tthis . handler . outputReady ( conn , encoder ) ; } 
public void responseReceived ( NHttpClientConnection conn ) { tthis . handler . responseReceived ( conn ) ; } 
public void inputReady ( NHttpClientConnection conn , tContentDecoder decoder ) { tthis . handler . inputReady ( conn , decoder ) ; } 
public void exception ( NHttpClientConnection conn , HttpException ex ) { tthis . handler . exception ( conn , ex ) ; } 
public void exception ( NHttpClientConnection conn , IOException ex ) { tthis . handler . exception ( conn , ex ) ; } 
public void timeout ( NHttpClientConnection conn ) { tthis . handler . timeout ( conn ) ; } 
public void completed ( SessionRequest request ) { tgetLogger ( ) . info ( trequest . getRemoteAddress ( ) 
public void cancelled ( SessionRequest request ) { tgetLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request cancelled " ) ; tthis . request . cancel ( ) ; } 
public void failed ( SessionRequest request ) { tgetLogger ( ) . error ( trequest . getRemoteAddress ( ) + " - Session request failed " ) ; tIOException ex = request . getException ( ) ; tif ( ex ! = null ) { tex . printStackTrace ( ) ; } tthis . request . cancel ( ) ; } 
public void timeout ( SessionRequest request ) { tgetLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request timed out " ) ; tthis . request . cancel ( ) ; } 
public boolean isCompleted ( ) { treturn this . completed ; } 
public void cancel ( ) { tif ( this . completed ) { treturn ; } tthis . completed = true ; tsynchronized ( this ) { tnotifyAll ( ) ; 
public void waitFor ( ) throws InterruptedException { tif ( this . completed ) { treturn ; } tsynchronized ( this ) { twhile ( ! this . completed ) { 
public void completed ( ) { tif ( this . completed ) { treturn ; } tthis . completed = true ; tthis . connMgr . releaseConnection ( this . conn ) ; tsynchronized ( this ) { tnotifyAll ( ) ; 
public boolean isCompleted ( ) { return this . completed ; } 
public boolean cancel ( boolean c ) { top . cancel ( ) ; treturn true ; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tif ( op ! = null ) { top . timeOut ( ) ; } tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op . isCancelled ( ) ) { tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } treturn objRef . get ( ) ; } 
public boolean isDone ( ) { } 
public static List < View > parseDesignDocumentForViews ( String dn , String ddn , String json ) tthrows ParseException { tList < View > viewList = new LinkedList < View > ( ) ; ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " views " ) ) { tJSONObject views = base . getJSONObject ( " views " ) ; tIterator < ? > itr = views . keys ( ) ; twhile ( itr . hasNext ( ) ) { tString viewname = ( String ) itr . next ( ) ; tboolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; tboolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; tviewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } treturn viewList ; } 
public void testGetStatsSlabs ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } } 
public void testGetStatsSizes ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { treturn ; } } 
public void testGetStatsCacheDump ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { treturn ; } } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { tif ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) ) { return ; } tRandom r = new Random ( ) ; tSerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; tst . setCompressionThreshold ( Integer . MAX_VALUE ) ; tbyte data [ ] = new byte [ 21 * 1024 * 1024 ] ; tr . nextBytes ( data ) ; ttry { tclient . set ( " bigassthing " , 60 , data , st ) . get ( ) ; tfail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { tSystem . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; te . printStackTrace ( ) ; tOperationException oe = ( OperationException ) e . getCause ( ) ; tassertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } } 
public static final boolean isCouchbase ( ) { treturn TYPE . equals ( TYPE_COUCHBASE ) ; } 
public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) { tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < View > crv = tnew HttpFuture < View > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewOperationImpl ( request , bucketName , tdesignDocumentName , viewName , new ViewCallback ( ) { tView view = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( view , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { tview = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void receivedStatus ( OperationStatus status ) { tcrv . set ( view , status ) ; } 
public void complete ( ) { tcouchLatch . countDown ( ) ; } 
public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) { tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < List < View > > crv = tnew HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewsOperationImpl ( request , bucketName , tdesignDocumentName , new ViewsCallback ( ) { tList < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( views , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { tviews = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void receivedStatus ( OperationStatus status ) { tcrv . set ( views , status ) ; } 
public ViewFuture query ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal ViewFuture crv = new ViewFuture ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { tViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tCollection < String > ids = new LinkedList < String > ( ) ; tIterator < RowWithDocs > itr = vr . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tids . add ( itr . next ( ) . getId ( ) ) ; } tcrv . set ( vr , asyncGetBulk ( ids ) , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void receivedStatus ( OperationStatus status ) { tCollection < String > ids = new LinkedList < String > ( ) ; tIterator < RowWithDocs > itr = vr . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tids . add ( itr . next ( ) . getId ( ) ) ; } tcrv . set ( vr , asyncGetBulk ( ids ) , status ) ; } 
public void gotData ( ViewResponseWithDocs response ) { tvr = response ; } 
public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tparams + = " &include_docs=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseNoDocs > crv = tnew HttpFuture < ViewResponseNoDocs > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { tViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } 
public void gotData ( ViewResponseNoDocs response ) { tvr = response ; } 
public HttpFuture < ViewResponseReduced > queryAndReduce ( final View view , final Query query ) { tif ( ! view . hasReduce ( ) ) { tthrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } tString uri = view . getURI ( ) + query . toString ( ) ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseReduced > crv = tnew HttpFuture < ViewResponseReduced > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { tViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void gotData ( ViewResponseReduced response ) { tvr = response ; } 
public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public HttpFuture<ViewResponseReduced> queryAndReduce(View view, Query query);} 
public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public HttpFuture<ViewResponseReduced> queryAndReduce(View view, Query query);} 
public ViewFuture query ( View view , Query query ) ; public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; } 
public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; } 
public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; } 
public void init ( ) throws IOReactorException { } 
public void run ( ) { ttry { tconnMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { tgetLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { tgetLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; te . printStackTrace ( ) ; } tgetLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; } 
public void initalizeContext ( final HttpContext context , tfinal Object attachment ) { } public void finalizeContext ( final HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tif ( handle ! = null ) { thandle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { tHttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; tif ( op = = null ) { treturn null ; } treturn op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , tfinal HttpContext context ) { tRequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; tHttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; tif ( handle ! = null ) { thandle . completed ( ) ; top . handleResponse ( response ) ; } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , tHttpContext context ) throws IOException { treturn new BufferingNHttpEntity ( response . getEntity ( ) , tnew HeapByteBufferAllocator ( ) ) ; } } tstatic class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { tgetLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { tgetLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , tfinal NHttpConnection conn ) { tgetLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , tExecutionException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tif ( op ! = null ) { top . timeOut ( ) ; } tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tstatus = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op . isCancelled ( ) ) { tstatus = new OperationStatus ( false , " Operation Cancelled " ) ; tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . isTimedOut ( ) ) { tstatus = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } treturn objRef . get ( ) ; } 
public void set ( T op , OperationStatus s ) { tobjRef . set ( op ) ; tstatus = s ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn latch . getCount ( ) = = 0 | | top . isCancelled ( ) | | op . hasErrored ( ) ; 
public ViewResponseWithDocs get ( ) throws InterruptedException , tExecutionException { ttry { treturn get ( timeout , TimeUnit . MILLISECONDS ) ; 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) tthrows InterruptedException , ExecutionException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tif ( op ! = null ) { top . timeOut ( ) ; } tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tstatus = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op . isCancelled ( ) ) { tstatus = new OperationStatus ( false , " Operation Cancelled " ) ; tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . isTimedOut ( ) ) { tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } tMap < String , Object > docMap = multigetRef . get ( ) . get ( ) ; tfinal ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; tCollection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; tIterator < RowWithDocs > itr = view . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tRowWithDocs r = itr . next ( ) ; trows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , tdocMap . get ( r . getId ( ) ) ) ) ; } treturn new ViewResponseWithDocs ( rows ) ; } 
public boolean isDone ( ) { tassert op ! = null : " No operation " ; treturn latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . hasErrored ( ) ; } 
public void set ( ViewResponseWithDocs viewResponse , tBulkFuture < Map < String , Object > > op , OperationStatus s ) { tviewRef . set ( viewResponse ) ; tmultigetRef . set ( op ) ; tstatus = s ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseWithDocs vr = parseDocsViewResult ( json ) ; ( ( DocsCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
private ViewResponseWithDocs parseDocsViewResult ( String json ) tthrows ParseException { tfinal Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tString id = ids . getJSONObject ( i ) . getString ( " id " ) ; tString key = ids . getJSONObject ( i ) . getString ( " key " ) ; tString value = ids . getJSONObject ( i ) . getString ( " value " ) ; trows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseWithDocs ( rows ) ; } 
public HttpRequest getRequest ( ) ; tOperationCallback getCallback ( ) ; tboolean isCancelled ( ) ; tboolean hasErrored ( ) ; tboolean isTimedOut ( ) ; tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tOperationCallback getCallback ( ) ; tboolean isCancelled ( ) ; tboolean hasErrored ( ) ; tboolean isTimedOut ( ) ; tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tboolean isCancelled ( ) ; tboolean hasErrored ( ) ; tboolean isTimedOut ( ) ; tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tboolean hasErrored ( ) ; tboolean isTimedOut ( ) ; tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tboolean isTimedOut ( ) ; tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tvoid cancel ( ) ; tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tvoid timeOut ( ) ; tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tOperationException getException ( ) ; tvoid handleResponse ( HttpResponse response ) ; } 
tprotected OperationStatus parseViewForStatus ( String json , int errorcode ) tthrows ParseException { tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " error " ) ) { tString error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; tif ( base . has ( " reason " ) ) { terror + = " Reason: " + base . getString ( " reason " ) ; } treturn new OperationStatus ( false , error ) ; } else { treturn new OperationStatus ( true , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json ) ; } } treturn new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ; 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseNoDocs vr = parseNoDocsViewResult ( json ) ; ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) tthrows ParseException { tfinal Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tString id = ids . getJSONObject ( i ) . getString ( " id " ) ; tString key = ids . getJSONObject ( i ) . getString ( " key " ) ; tString value = ids . getJSONObject ( i ) . getString ( " value " ) ; trows . add ( new RowNoDocs ( id , key , value ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseNoDocs ( rows ) ; } 
public String toString ( ) { tboolean first = true ; tString result = " " ; tfor ( Entry < String , Object > arg : args . entrySet ( ) ) { tif ( first ) { tresult + = " ? " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; tfirst = false ; } else { tresult + = " & " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; } } treturn result ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseReduced vr = parseReducedViewResult ( json ) ; ( ( ReducedCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
private ViewResponseReduced parseReducedViewResult ( String json ) tthrows ParseException { tfinal Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tString key = ids . getJSONObject ( i ) . getString ( " key " ) ; tString value = ids . getJSONObject ( i ) . getString ( " value " ) ; trows . add ( new RowReduced ( key , value ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseReduced ( rows ) ; } 
 public String toString ( ) { return " ok " ; } 
 public String toString ( ) { return " update_after " ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; ttry { tView view = parseDesignDocumentForView ( bucketName , designDocName , tviewName , json ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; tif ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewCallback ) callback ) . gotData ( view ) ; tcallback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { tcallback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
private View parseDesignDocumentForView ( String dn , String ddn , tString viewName , String json ) throws ParseException { tView view = null ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " error " ) ) { treturn null ; } tif ( base . has ( " views " ) ) { tJSONObject views = base . getJSONObject ( " views " ) ; tIterator < ? > itr = views . keys ( ) ; twhile ( itr . hasNext ( ) ) { tString curView = ( String ) itr . next ( ) ; tif ( curView . equals ( viewName ) ) { tboolean map = views . getJSONObject ( curView ) . has ( " map " ) ; tboolean reduce = views . getJSONObject ( curView ) . has ( " reduce " ) ; tview = new View ( dn , ddn , viewName , map , reduce ) ; tbreak ; } } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn view ; } 
public Iterator < RowNoDocs > iterator ( ) { treturn rows . iterator ( ) ; } 
public String toString ( ) { tStringBuilder s = new StringBuilder ( ) ; tfor ( RowNoDocs r : rows ) { ts . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } treturn s . toString ( ) ; } 
public Iterator < RowReduced > iterator ( ) { treturn rows . iterator ( ) ; } 
public String toString ( ) { tStringBuilder s = new StringBuilder ( ) ; tfor ( RowReduced r : rows ) { ts . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } treturn s . toString ( ) ; } 
public Iterator < RowWithDocs > iterator ( ) { treturn rows . iterator ( ) ; } 
public String toString ( ) { tStringBuilder s = new StringBuilder ( ) ; tfor ( RowWithDocs r : rows ) { ts . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDoc ( ) + " " ) ; } treturn s . toString ( ) ; } 
public void clear ( ) { tthrow new UnsupportedOperationException ( " clear() is not supported " ) ; } 
public boolean containsKey ( Object key ) { treturn map . containsKey ( key ) ; } 
public boolean containsValue ( Object value ) { treturn map . containsValue ( value ) ; } 
public Set < Entry < String , Object > > entrySet ( ) { tSet < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; tfor ( RowWithDocs r : rows ) { tset . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } treturn null ; } 
public Set < String > keySet ( ) { tSet < String > set = new TreeSet < String > ( ) ; tfor ( RowWithDocs r : rows ) { tset . add ( r . getId ( ) ) ; } treturn null ; } 
public Object put ( String key , Object value ) { tthrow new UnsupportedOperationException ( " put() is not supported " ) ; } 
public void putAll ( Map < ? extends String , ? extends Object > m ) { tthrow new UnsupportedOperationException ( " putAll() is not supported " ) ; 
public Object remove ( Object key ) { tthrow new UnsupportedOperationException ( " remove() is not supported " ) ; } 
public int size ( ) { tassert rows . size ( ) = = map . size ( ) ; treturn rows . size ( ) ; } 
public Collection < Object > values ( ) { tCollection < Object > values = new LinkedList < Object > ( ) ; tfor ( RowWithDocs r : rows ) { tvalues . add ( r . getDoc ( ) ) ; } treturn values ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; ttry { tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; tif ( errorcode = = HttpURLConnection . HTTP_OK ) { tList < View > views = parseDesignDocumentForViews ( bucketName , tdesignDocName , json ) ; ( ( ViewsCallback ) callback ) . gotData ( views ) ; tcallback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { tcallback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
private List < View > parseDesignDocumentForViews ( String dn , String ddn , tString json ) throws ParseException { tList < View > viewList = new LinkedList < View > ( ) ; ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " error " ) ) { treturn null ; } tif ( base . has ( " views " ) ) { tJSONObject views = base . getJSONObject ( " views " ) ; tIterator < ? > itr = views . keys ( ) ; twhile ( itr . hasNext ( ) ) { tString viewname = ( String ) itr . next ( ) ; tboolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; tboolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; tviewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } treturn viewList ; } 
tprotected void initClient ( ) throws Exception { tList < URI > uris = new LinkedList < URI > ( ) ; turis . add ( URI . create ( SERVER_URI ) ) ; tclient = new TestingClient ( uris , " default " , " " ) ; } 
public static void before ( ) throws Exception { } 
public void beforeTest ( ) throws Exception { tinitClient ( ) ; } 
public void afterTest ( ) throws Exception { } 
public static void after ( ) throws Exception { } 
private static String generateDoc ( String type , String small , String large ) { treturn " { \" type \" : \" " + type + " \" " + " \" small range \" : \" " + small + " \" " + " \" large range \" : \" " + large + " \" } " ; 
public void testReduce ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , tquery ) ; tViewResponseReduced reduce = future . get ( ) ; tIterator < RowReduced > itr = reduce . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tRowReduced row = itr . next ( ) ; 
public void testReduceWhenNoneExists ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; ttry { tclient . queryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { treturn ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; tif ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( TestCallback ) callback ) . getData ( json ) ; tcallback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { tcallback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } tcallback . complete ( ) ; } 
public void receivedStatus ( OperationStatus status ) { tcrv . set ( json , status ) ; } 
public void complete ( ) { tcouchLatch . countDown ( ) ; } 
public boolean isTimeout ( ) ; public OperationStatus getStatus ( ) ; } 
Bucket getBucketConfiguration ( String bucketname ) throws ConfigurationException ; String getAnonymousAuthBucket ( ) ; } 
void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException ; String getAnonymousAuthBucket ( ) ; } 
void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; } 
void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
public void handleIO ( ) { tfor ( CouchbaseNode node : nodes ) { tnode . doWrites ( ) ; } tfor ( CouchbaseNode qa : nodesToShutdown ) { tnodesToShutdown . remove ( qa ) ; 
private void redistributeOperations ( Collection < HttpOperation > ops ) { tint added = 0 ; tfor ( HttpOperation op : ops ) { taddOp ( op ) ; tadded + + ; } tassert added > 0 : " Didn't add any new operations when redistributing " ; 
public Collection < HttpOperation > destroyWriteQueue ( ) { tCollection < HttpOperation > rv = new ArrayList < HttpOperation > ( ) ; twriteQ . drainTo ( rv ) ; treturn rv ; } 
public void run ( ) { twhile ( running ) { tif ( ! reconfiguring ) { ttry { thandleIO ( ) ; } catch ( IOException e ) { tlogRunException ( e ) ; } catch ( CancelledKeyException e ) { tlogRunException ( e ) ; } catch ( ClosedSelectorException e ) { tlogRunException ( e ) ; } catch ( IllegalStateException e ) { tlogRunException ( e ) ; } } } tgetLogger ( ) . info ( " Shut down memcached client " ) ; } 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) tthrows InterruptedException , ExecutionException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tif ( op ! = null ) { top . timeOut ( ) ; } tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tstatus = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op . isCancelled ( ) ) { tstatus = new OperationStatus ( false , " Operation Cancelled " ) ; tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . isTimedOut ( ) ) { tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } tMap < String , Object > docMap = multigetRef . get ( ) . get ( ) ; tfinal ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; tCollection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; tIterator < RowWithDocs > itr = view . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tRowWithDocs r = itr . next ( ) ; trows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , tdocMap . get ( r . getId ( ) ) ) ) ; } treturn new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
private ViewResponseWithDocs parseDocsViewResult ( String json ) tthrows ParseException { tfinal Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; tfinal Collection < RowError > errors = new LinkedList < RowError > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString id = elem . getString ( " id " ) ; tString key = elem . getString ( " key " ) ; tString value = elem . getString ( " value " ) ; trows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } tif ( base . has ( " errors " ) ) { tJSONArray ids = base . getJSONArray ( " errors " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString from = elem . getString ( " from " ) ; tString reason = elem . getString ( " reason " ) ; terrors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseWithDocs ( rows , errors ) ; } 
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) tthrows ParseException { tfinal Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; tfinal Collection < RowError > errors = new LinkedList < RowError > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString id = elem . getString ( " id " ) ; tString key = elem . getString ( " key " ) ; tString value = elem . getString ( " value " ) ; trows . add ( new RowNoDocs ( id , key , value ) ) ; } } tif ( base . has ( " errors " ) ) { tJSONArray ids = base . getJSONArray ( " errors " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString from = elem . getString ( " from " ) ; tString reason = elem . getString ( " reason " ) ; terrors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseNoDocs ( rows , errors ) ; } 
private ViewResponseReduced parseReducedViewResult ( String json ) tthrows ParseException { tfinal Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; tfinal Collection < RowError > errors = new LinkedList < RowError > ( ) ; tif ( json ! = null ) { ttry { tJSONObject base = new JSONObject ( json ) ; tif ( base . has ( " rows " ) ) { tJSONArray ids = base . getJSONArray ( " rows " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString key = elem . getString ( " key " ) ; tString value = elem . getString ( " value " ) ; trows . add ( new RowReduced ( key , value ) ) ; } } tif ( base . has ( " errors " ) ) { tJSONArray ids = base . getJSONArray ( " errors " ) ; tfor ( int i = 0 ; i < ids . length ( ) ; i + + ) { tJSONObject elem = ids . getJSONObject ( i ) ; tString from = elem . getString ( " from " ) ; tString reason = elem . getString ( " reason " ) ; terrors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { tthrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } treturn new ViewResponseReduced ( rows , errors ) ; } 
public void testViewDocsWithErrors ( ) throws Exception { tHttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { tassert status . isSuccess ( ) ; } @Override public void complete ( ) { } 
public void receivedStatus ( OperationStatus status ) { tassert status . isSuccess ( ) ; } 
public void complete ( ) { }} 
public void gotData ( ViewResponseWithDocs response ) { tassert response . getErrors ( ) . size ( ) = = 2 ; tIterator < RowError > row = response . getErrors ( ) . iterator ( ) ; tassert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; tassert response . size ( ) = = 0 ; } 
public void testViewNoDocsWithErrors ( ) throws Exception { tHttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { tassert status . isSuccess ( ) ; } @Override public void complete ( ) { } 
public void complete ( ) { }} 
public void gotData ( ViewResponseNoDocs response ) { tassert response . getErrors ( ) . size ( ) = = 2 ; tIterator < RowError > row = response . getErrors ( ) . iterator ( ) ; tassert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; tassert response . size ( ) = = 0 ; } 
public void testViewReducedWithErrors ( ) throws Exception { tHttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { tassert status . isSuccess ( ) ; } @Override public void complete ( ) { } 
public void complete ( ) { }} 
public void gotData ( ViewResponseReduced response ) { tassert response . getErrors ( ) . size ( ) = = 2 ; tIterator < RowError > row = response . getErrors ( ) . iterator ( ) ; tassert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; tassert response . size ( ) = = 0 ; } 
public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { tdesignDocumentName = MODE_PREFIX + designDocumentName ; tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < View > crv = tnew HttpFuture < View > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewOperationImpl ( request , bucketName , tdesignDocumentName , viewName , new ViewCallback ( ) { tView view = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( view , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { tview = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { tdesignDocumentName = MODE_PREFIX + designDocumentName ; tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < List < View > > crv = tnew HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewsOperationImpl ( request , bucketName , tdesignDocumentName , new ViewsCallback ( ) { tList < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( views , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { tviews = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public static void before ( ) throws Exception { } 
public static void after ( ) throws Exception { + DESIGN_DOC_WO_REDUCE + "?rev=" + rev).get(); 
public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { tdesignDocumentName = MODE_PREFIX + designDocumentName ; tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < View > crv = tnew HttpFuture < View > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewOperationImpl ( request , bucketName , tdesignDocumentName , viewName , new ViewCallback ( ) { tView view = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( view , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { tview = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { tdesignDocumentName = MODE_PREFIX + designDocumentName ; tString uri = " / " + bucketName + " /_design/ " + designDocumentName ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < List < View > > crv = tnew HttpFuture < List < View > > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ViewsOperationImpl ( request , bucketName , tdesignDocumentName , new ViewsCallback ( ) { tList < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( views , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { tviews = v ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public ViewFuture query ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { tViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tCollection < String > ids = new LinkedList < String > ( ) ; tIterator < RowWithDocs > itr = vr . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tids . add ( itr . next ( ) . getId ( ) ) ; } tcrv . set ( vr , asyncGetBulk ( ids ) , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tparams + = " &include_docs=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseNoDocs > crv = tnew HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { tViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < ViewResponseReduced > queryAndReduce ( final View view , final Query query ) { tif ( ! view . hasReduce ( ) ) { tthrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } tString uri = view . getURI ( ) + query . toString ( ) ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseReduced > crv = tnew HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { tViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public ViewFuture query ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { tViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tif ( vr ! = null ) { tCollection < String > ids = new LinkedList < String > ( ) ; tIterator < RowWithDocs > itr = vr . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tids . add ( itr . next ( ) . getId ( ) ) ; } tcrv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { tcrv . set ( null , null , status ) ; } } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public void receivedStatus ( OperationStatus status ) { tif ( vr ! = null ) { tCollection < String > ids = new LinkedList < String > ( ) ; 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) tthrows InterruptedException , ExecutionException , TimeoutException { tif ( ! latch . await ( duration , units ) ) { tif ( op ! = null ) { top . timeOut ( ) ; } tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new TimeoutException ( " Timed out waiting for operation " ) ; } tif ( op ! = null & & op . hasErrored ( ) ) { tstatus = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; tthrow new ExecutionException ( op . getException ( ) ) ; } tif ( op . isCancelled ( ) ) { tstatus = new OperationStatus ( false , " Operation Cancelled " ) ; tthrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } tif ( op ! = null & & op . isTimedOut ( ) ) { tstatus = new OperationStatus ( false , " Timed out " ) ; tthrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } tif ( multigetRef . get ( ) = = null ) { treturn null ; } tMap < String , Object > docMap = multigetRef . get ( ) . get ( ) ; tfinal ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; tCollection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; tIterator < RowWithDocs > itr = view . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tRowWithDocs r = itr . next ( ) ; trows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , tdocMap . get ( r . getId ( ) ) ) ) ; } treturn new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseWithDocs vr = null ; tif ( status . isSuccess ( ) ) { tvr = parseDocsViewResult ( json ) ; } ( ( DocsCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseNoDocs vr = null ; tif ( status . isSuccess ( ) ) { tvr = parseNoDocsViewResult ( json ) ; } ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
public void handleResponse ( HttpResponse response ) { tString json = getEntityString ( response ) ; tint errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ttry { tOperationStatus status = parseViewForStatus ( json , errorcode ) ; tViewResponseReduced vr = null ; tif ( status . isSuccess ( ) ) { tvr = parseReducedViewResult ( json ) ; } ( ( ReducedCallback ) callback ) . gotData ( vr ) ; tcallback . receivedStatus ( status ) ; } catch ( ParseException e ) { texception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } tcallback . complete ( ) ; } 
public static void before ( ) throws Exception { } 
public void afterTest ( ) throws Exception { } 
public static void after ( ) throws Exception { } 
public void testQuerySetDescending ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setDescending ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setEndkeyDocID ( " an_id " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroup ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , tquery . setGroup ( true ) ) ; tViewResponseReduced response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroupWithLevel ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , tquery . setGroup ( true , 1 ) ) ; tViewResponseReduced response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setInclusiveEnd ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setKey ( " a_key " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setLimit ( 10 ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setRange ( " key0 " , " key2 " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setRangeStart ( " start " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setRangeEnd ( " end " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setSkip ( 0 ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setStale ( Stale . OK ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setStartkeyDocID ( " key0 " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . query ( view , query . setUpdateSeq ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public ViewFuture asyncQuery ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { tViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tif ( vr ! = null ) { tCollection < String > ids = new LinkedList < String > ( ) ; tIterator < RowWithDocs > itr = vr . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tids . add ( itr . next ( ) . getId ( ) ) ; } tcrv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { tcrv . set ( null , null , status ) ; } } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) { tString queryString = query . toString ( ) ; tString params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; tparams + = " &include_docs=false " ; tString uri = view . getURI ( ) + queryString + params ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseNoDocs > crv = tnew HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { tViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( final View view , final Query query ) { tif ( ! view . hasReduce ( ) ) { tthrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } tString uri = view . getURI ( ) + query . toString ( ) ; tfinal CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; tfinal HttpFuture < ViewResponseReduced > crv = tnew HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; tfinal HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; tfinal HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { tViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { tcrv . set ( vr , status ) ; } @Override public void complete ( ) { tcouchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { tvr = response ; } } ) ; tcrv . setOperation ( op ) ; taddOp ( op ) ; treturn crv ; } 
public ViewResponseWithDocs query ( View view , Query query ) { ttry { treturn asyncQuery ( view , query ) . get ( ) ; 
public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) { ttry { treturn asyncQueryAndExcludeDocs ( view , query ) . get ( ) ; 
public ViewResponseReduced queryAndReduce ( View view , Query query ) { ttry { treturn asyncQueryAndReduce ( view , query ) . get ( ) ; 
public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);} 
public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);} 
public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);} 
public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);} 
public ViewFuture asyncQuery ( View view , Query query ) ; public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public void testReduce ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , tquery ) ; tViewResponseReduced reduce = future . get ( ) ; tIterator < RowReduced > itr = reduce . iterator ( ) ; twhile ( itr . hasNext ( ) ) { tRowReduced row = itr . next ( ) ; 
public void testQuerySetDescending ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setDescending ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroup ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , tquery . setGroup ( true ) ) ; tViewResponseReduced response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroupWithLevel ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tHttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , tquery . setGroup ( true , 1 ) ) ; tViewResponseReduced response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; tViewFuture future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; tViewResponseWithDocs response = future . get ( ) ; tassert response ! = null : future . getStatus ( ) ; } 
public void testReduceWhenNoneExists ( ) throws Exception { tQuery query = new Query ( ) ; tView view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; ttry { tclient . asyncQueryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { treturn ; } 
public void updateLocator ( List < MemcachedNode > newNodes , Config conf ) { this . nodes = newNodes . toArray ( new MemcachedNode [ newNodes . size ( ) ] ) ; } 
public boolean hasNext ( ) { return next > = 0 ; } 
private void computeNext ( ) { if ( + + next > = nodes . length ) { next = 0 ; } if ( next = = start ) { next = - 1 ; 
public MemcachedNode next ( ) { try { return nodes [ next ] ; 
public void remove ( ) { throw new UnsupportedOperationException ( " Can't remove a node " ) ; } 
public void clear ( ) { TODO: Support a rolling key generation. throw new UnsupportedOperationException(); } 
public boolean containsKey ( Object key ) { return get ( key ) ! = null ; } 
public boolean containsValue ( Object value ) { return false ; } 
public Set < Map . Entry < String , V > > entrySet ( ) { return Collections . emptySet ( ) ; } 
public V get ( Object key ) { V rv = null ; try { rv = client . get ( getKey ( ( String ) key ) , transcoder ) ; } catch ( ClassCastException e ) { Most likely, this is because the key wasn't a String. Either way, it's a no. } return rv; } 
public Set < String > keySet ( ) { return Collections . emptySet ( ) ; } 
public void putAll ( Map < ? extends String , ? extends V > ) { for ( Map . Entry < ? extends String , ? extends V > me : . entrySet ( ) ) { client . set ( getKey ( me . getKey ( ) ) , exp , me . getValue ( ) ) ; 
public V remove ( Object key ) { V rv = null ; try { rv = get ( key ) ; client . delete ( getKey ( ( String ) key ) ) ; } catch ( ClassCastException e ) { Not a string key. Ignore. } return rv; } 
public Collection < V > values ( ) { return Collections . emptySet ( ) ; } 
public V put ( String key , V value ) { V rv = get ( key ) ; client . set ( getKey ( key ) , exp , value ) ; return rv ; } 
public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { boolean doAuth = false ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , createWriteOperationQueue ( ) , 
Operation newOp ( MemcachedNode , CountDownLatch latch ) ; } 
public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) throws Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , transcoder ) ; T current = null ; If there were a CAS value, check to see if it's compatible. if (casval != null) { T tmp = casval.getValue(); current = tmp; } If we have anything mutate and CAS, else add. if (current != null) { Declaring this impossible since the only way current can be non-null is if casval was set. assert casval != null : "casval was null with a current value"; rv = m.getNewValue(current); There are three possibilities here: 1) It worked and we're done. 2) It collided and we need to reload and try again. 3) It disappeared between our fetch and our cas. We're ignoring #3 because it's *extremely* unlikely and the behavior will be fine in this code -- we'll do another gets and follow it up with either an add or another cas depending on whether it exists the next time. if (client.cas(key, casval.getCas(), rv, transcoder) == CASResponse.OK) { done = true; } } else { No value found, try an add. if (initial == null) { done = true; rv = null; } else if (client.add(key, initialExp, initial, transcoder).get()) { done = true; rv = initial; } } } if (!done) { throw new RuntimeException("Couldn't get a CAS in " + max + " attempts"); } return rv; } 
public String toString ( ) { return " {CasValue " + cas + " / " + value + " } " ; } 
public String toString ( ) { return " {CachedData flags= " + flags + " data= " + Arrays . toString ( data ) + " } " ; 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; int getTimeoutExceptionThreshold ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; int getTimeoutExceptionThreshold ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
NodeLocator createLocator ( List < MemcachedNode > nodes ) ; int getTimeoutExceptionThreshold ( ) ; } 
OperationFactory getOperationFactory ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
long getOperationTimeout ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
boolean isDaemon ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
boolean useNagleAlgorithm ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
Collection < ConnectionObserver > getInitialObservers ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
FailureMode getFailureMode ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
Transcoder < Object > getDefaultTranscoder ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
boolean shouldOptimize ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
int getReadBufSize ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
HashAlgorithm getHashAlg ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
long getMaxReconnectDelay ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; } 
public ConnectionFactoryBuilder setInitialObservers ( Collection < ConnectionObserver > obs ) { initialObservers = obs ; return this ; } 
public ConnectionFactory build ( ) { return new DefaultConnectionFactory ( ) { 
public BlockingQueue < Operation > createOperationQueue ( ) { return opQueueFactory = = null ? super . createOperationQueue ( ) : opQueueFactory . create ( ) ; 
public BlockingQueue < Operation > createReadOperationQueue ( ) { return readQueueFactory = = null ? super . createReadOperationQueue ( ) : readQueueFactory . create ( ) ; 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return writeQueueFactory = = null ? super . createReadOperationQueue ( ) : writeQueueFactory . create ( ) ; 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case ARRAY_MOD : 
public boolean isDaemon ( ) { return isDaemon ; } 
public boolean shouldOptimize ( ) { return shouldOptimize ; } 
public boolean useNagleAlgorithm ( ) { return useNagle ; } 
public MembaseConnectionFactory buildMembaseConnection ( final List < URI > baseList , final String bucketName , final String usr , final String pwd ) throws IOException { return new MembaseConnectionFactory ( baseList , bucketName , usr , pwd ) { 
void connectionEstablished ( SocketAddress sa , int reconnectCount ) ; void connectionLost ( SocketAddress sa ) ; } 
public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { private View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } 
public void complete ( ) { couchLatch . countDown ( ) ; } 
public void gotData ( View v ) { view = v ; } 
public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsOperationImpl ( request , bucketName , designDocumentName , new ViewsCallback ( ) { private List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } 
public void complete ( ) { couchLatch . countDown ( ) ; } 
public void gotData ( List < View > v ) { views = v ; } 
public ViewFuture asyncQuery ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; 
public void complete ( ) { couchLatch . countDown ( ) ; } 
public void gotData ( ViewResponseWithDocs response ) { vr = response ; } 
public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseNoDocs > crv = new HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { private ViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } 
public void gotData ( ViewResponseNoDocs response ) { vr = response ; } 
public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { private ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void gotData ( ViewResponseReduced response ) { vr = response ; } 
public ViewResponseWithDocs query ( View view , Query query ) { try { return asyncQuery ( view , query ) . get ( ) ; 
public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) { try { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ; 
public ViewResponseReduced queryAndReduce ( View view , Query query ) { try { return asyncQueryAndReduce ( view , query ) . get ( ) ; 
public void addOp ( final HttpOperation op ) { cconn . checkState ( ) ; cconn . addOp ( op ) ; } 
public void reconfigure ( Bucket bucket ) { reconfiguring = true ; try { mconn . reconfigure ( bucket ) ; 
public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; } 
public boolean shutdown ( long duration , TimeUnit units ) { try { return super . shutdown ( duration , units ) & & cconn . shutdown ( ) ; 
HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
ViewFuture asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
private List < CouchbaseNode > createConnections ( List < InetSocketAddress > addrs ) throws IOException { List < CouchbaseNode > nodeList = new LinkedList < CouchbaseNode > ( ) ; for ( InetSocketAddress a : addrs ) { HttpParams params = new SyncBasicHttpParams ( ) ; params . setIntParameter ( CoreConnectionPNames . SO_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . CONNECTION_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . SOCKET_BUFFER_SIZE , 8 * 1024 ) . setBooleanParameter ( CoreConnectionPNames . STALE_CONNECTION_CHECK , false ) . setBooleanParameter ( CoreConnectionPNames . TCP_NODELAY , true ) . setParameter ( CoreProtocolPNames . USER_AGENT , " Spymemcached Client/1.1 " ) ; HttpProcessor httpproc = new ImmutableHttpProcessor ( new HttpRequestInterceptor [ ] { new RequestContent ( ) , new RequestTargetHost ( ) , new RequestConnControl ( ) , new RequestUserAgent ( ) , new RequestExpectContinue ( ) , } ) ; AsyncNHttpClientHandler protocolHandler = new AsyncNHttpClientHandler ( httpproc , new MyHttpRequestExecutionHandler ( ) , new DefaultConnectionReuseStrategy ( ) , new DirectByteBufferAllocator ( ) , params ) ; protocolHandler . setEventListener ( new EventLogger ( ) ) ; AsyncConnectionManager connMgr = new AsyncConnectionManager ( new HttpHost ( a . getHostName ( ) , a . getPort ( ) ) , NUM_CONNS , protocolHandler , params ) ; getLogger ( ) . info ( " Added %s to connect queue " , a ) ; CouchbaseNode node = connFactory . createCouchDBNode ( a , connMgr ) ; node . init ( ) ; nodeList . add ( node ) ; } return nodeList ; } 
public void addOp ( final HttpOperation op ) { nodes . get ( getNextNode ( ) ) . addOp ( op ) ; } 
public void handleIO ( ) { for ( CouchbaseNode node : nodes ) { node . doWrites ( ) ; } for ( CouchbaseNode qa : nodesToShutdown ) { nodesToShutdown . remove ( qa ) ; 
private void redistributeOperations ( Collection < HttpOperation > ops ) { int added = 0 ; for ( HttpOperation op : ops ) { addOp ( op ) ; added + + ; } assert added > 0 : " Didn't add any new operations when redistributing " ; } 
protected void checkState ( ) { if ( shutDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; } 
public boolean shutdown ( ) throws IOException { if ( shutDown ) { getLogger ( ) . info ( " Suppressing duplicate attempt to shut down " ) ; return false ; } shutDown = true ; running = false ; for ( CouchbaseNode : nodes ) { if ( ! = null ) { . shutdown ( ) ; if ( . hasWriteOps ( ) ) { getLogger ( ) . warn ( " Shutting down with ops waiting to be written " ) ; } } } return true ; } 
public void reconfigure ( Bucket bucket ) { reconfiguring = true ; try { get a new collection of addresses from the received config 
public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( Exception e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
private void logRunException ( Exception e ) { if ( shutDown ) { There are a couple types of errors that occur during the 
public CouchbaseNode createCouchDBNode ( InetSocketAddress addr , AsyncConnectionManager connMgr ) { return new CouchbaseNode ( addr , connMgr , new LinkedBlockingQueue < HttpOperation > ( opQueueLen ) , 
public MemcachedConnection createMemcachedConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , this , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ; 
public CouchbaseConnection createCouchDBConnection ( List < InetSocketAddress > addrs ) throws IOException { return new CouchbaseConnection ( this , addrs , getInitialObservers ( ) ) ; } 
public void init ( ) throws IOReactorException { Start the I/O reactor in a separate thread Thread t = new Thread(new Runnable() { public void run() { try { connMgr.execute(); } catch (InterruptedIOException ex) { getLogger().error("I/O reactor Interrupted"); } catch (IOException e) { getLogger().error("I/O error: " + e.getMessage()); e.printStackTrace(); } getLogger().info("Couchbase I/O reactor terminated"); } }); t.start(); } 
public void run ( ) { try { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } getLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; } 
public void doWrites ( ) { HttpOperation op ; while ( ( op = writeQ . poll ( ) ) ! = null ) { if ( ! op . isTimedOut ( ) & & ! op . isCancelled ( ) ) { 
public Collection < HttpOperation > destroyWriteQueue ( ) { Collection < HttpOperation > rv = new ArrayList < HttpOperation > ( ) ; writeQ . drainTo ( rv ) ; return rv ; } 
public boolean hasWriteOps ( ) { return ! writeQ . isEmpty ( ) ; } 
public void addOp ( HttpOperation op ) { try { if ( ! writeQ . offer ( op , opQueueMaxBlockTime , TimeUnit . MILLISECONDS ) ) { 
public void shutdown ( ) throws IOException { shutdown ( 0 , TimeUnit . MILLISECONDS ) ; } 
public void shutdown ( long time , TimeUnit unit ) throws IOException { if ( unit ! = TimeUnit . MILLISECONDS ) { connMgr . shutdown ( TimeUnit . MILLISECONDS . convert ( time , unit ) ) ; 
public void initalizeContext ( final HttpContext context , final Object attachment ) { } public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ; op . handleResponse ( response ) ; } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) throws IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ; } } static class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } } 
public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ; 
public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; } 
public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ; 
public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) throws IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ; 
public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; } 
public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; } 
public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; } 
public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } 
public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } 
public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { OperationFactory of = getOperationFactory ( ) ; if ( of instanceof AsciiOperationFactory ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , this , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ; 
public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } 
public BlockingQueue < Operation > createReadOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; } 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; } 
public boolean useNagleAlgorithm ( ) { return false ; } 
public long hash ( final String k ) { long rv = 0 ; switch ( this ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < k.length(); i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < k.length(); i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < k.length(); i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < k.length(); i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; } 
public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) MD5_DIGEST . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; } 
private void nextHash ( ) { this.calculateHash(Integer.toString(tries)+key).hashCode(); long tmpKey = hashAlg.hash((numTries++) + key); This echos the implementation of Long.hashCode() hashVal += (int) (tmpKey ^ (tmpKey >>> 32)); hashVal &= 0xffffffffL; remainingTries--; } 
public boolean hasNext ( ) { return remainingTries > 0 ; } 
public MemcachedNode next ( ) { try { return getNodeForKey ( hashVal ) ; 
public void remove ( ) { throw new UnsupportedOperationException ( " remove not supported " ) ; } 
public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { setKetamaNodes ( nodes ) ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc 
public void complete ( ) { latch . countDown ( ) ; } 
public OperationFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { return asyncGetAndLock ( key , exp , transcoder ) ; } 
Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; } 
< T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; } 
< T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case CONSISTENT : 
private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { throw new IllegalArgumentException ( " Key must contain at least one character. " ) ; } Validate the key for (byte b : keyBytes) { if (b == ' ' || b == '' || b == '\r' || b == 0) { 
Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; mconn . checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , true ) ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , true ) ; } 
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return mconn . broadcastOperation ( of , nodes ) ; } 
public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } 
public void complete ( ) { latch . countDown ( ) ; } 
private OperationFuture < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , transcoder ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } 
public void complete ( ) { latch . countDown ( ) ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp ) { return touch ( key , exp , transcoder ) ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } 
public OperationFuture < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . append , cas , key , val , tc ) ; } 
public OperationFuture < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , tc ) ; } 
public < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) { return asyncCAS ( key , casId , 0 , value , tc ) ; } 
public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) , val ) ; 
public Future < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , transcoder ) ; } 
public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) { return cas ( key , casId , 0 , value , tc ) ; } 
public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) { try { return asyncCAS ( key , casId , exp , value , tc ) . get ( operationTimeout , 
public CASResponse cas ( String key , long casId , Object value ) { return cas ( key , casId , value , transcoder ) ; } 
public < T > OperationFuture < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . add , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , transcoder ) ; } 
public < T > OperationFuture < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . set , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , transcoder ) ; } 
public < T > OperationFuture < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) { return asyncStore ( StoreType . replace , key , exp , o , tc ) ; } 
public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , transcoder ) ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; 
public GetFuture < Object > asyncGet ( final String key ) { return asyncGet ( key , transcoder ) ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , 
public OperationFuture < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , transcoder ) ; } 
public < T > CASValue < T > gets ( String key , Transcoder < T > tc ) { try { return asyncGets ( key , tc ) . get ( operationTimeout , TimeUnit . MILLISECONDS ) ; 
public CASValue < Object > gets ( String key ) { return gets ( key , transcoder ) ; } 
public < T > T get ( String key , Transcoder < T > tc ) { try { return asyncGet ( key , tc ) . get ( operationTimeout , TimeUnit . MILLISECONDS ) ; 
public Object get ( String key ) { return get ( key , transcoder ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); if (!status.isSuccess()) { getLogger().warn("Unsuccessful get: %s", status); } } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ; 
public void gotData ( String k , int flags , byte [ ] data ) { Transcoder < T > tc = tcMap . get ( k ) ; m . put ( k , tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) { return asyncGetBulk ( keys , new SingleElementInfiniteIterator < Transcoder < T > > ( tc ) ) ; 
public BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , transcoder ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; } 
public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , transcoder ) ; } 
public OperationFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { return asyncGetAndTouch ( key , exp , transcoder ) ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , 
public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) { try { return asyncGetBulk ( keys , tc ) . get ( operationTimeout , 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { 
public void receivedStatus ( OperationStatus s ) { rv . put ( sa , s . getMessage ( ) ) ; } 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) { public void gotStat ( String name , String val ) { 
public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; } 
public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful stat fetch: %s " , status ) ; 
private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); } 
public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } 
public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; } 
public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; } 
private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; The ascii protocol doesn't support defaults, so I added them manually here. if (rv == -1) { Future<Boolean> f = asyncStore(StoreType.add, key, exp, String.valueOf(def)); try { if (f.get(operationTimeout, TimeUnit.MILLISECONDS)) { rv = def; } else { rv = mutate(t, key, by, 0, exp); assert rv != -1 : "Failed to mutate or init value"; } } catch (InterruptedException e) { throw new RuntimeException("Interrupted waiting for store", e); } catch (ExecutionException e) { throw new RuntimeException("Failed waiting for store", e); } catch (TimeoutException e) { throw new OperationTimeoutException("Timeout waiting to mutate or init" + " value", e); } } return rv; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; } 
public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } 
public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
public OperationFuture < Boolean > delete ( String key , int hold ) { return delete ( key ) ; } 
public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } 
public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout ) { 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } 
public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITING ; } return rv ; } 
public Boolean get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( true , " OK " ) ; return super . get ( duration , units ) ; } 
public boolean isCancelled ( ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . isCancelled ( ) ; } return rv ; } 
public boolean isDone ( ) { boolean rv = true ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv | | isCancelled ( ) ; } 
public OperationFuture < Boolean > flush ( ) { return flush ( - 1 ) ; } 
public Operation newOp ( MemcachedNode , final CountDownLatch latch ) { return opFact . saslMechs ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, mconn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { 
public boolean removeObserver ( ConnectionObserver obs ) { return mconn . removeObserver ( obs ) ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) { 
public void connectionLost ( SocketAddress sa ) { Don't care. }} 
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
private List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = this . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! this . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; } 
private void handleInputQueue ( ) { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ; 
public boolean addObserver ( ConnectionObserver obs ) { return connObservers . add ( obs ) ; } 
public boolean removeObserver ( ConnectionObserver obs ) { return connObservers . remove ( obs ) ; } 
private void connected ( MemcachedNode qa ) { assert qa . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = qa . getReconnectCount ( ) ; qa . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( qa . getSocketAddress ( ) , rt ) ; 
private void lostConnection ( MemcachedNode qa ) { queueReconnect ( qa ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionLost ( qa . getSocketAddress ( ) ) ; 
private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( shouldOptimize ) ; boolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ; 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; queueReconnect(qa); currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read); 
static String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . toHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . toString ( ) ; } 
private void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , qa , 
private void cancelOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { op . cancel ( ) ; 
private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op instanceof KeyedOperation ) { 
public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { add the vbucketIndex to the operation 
public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
private void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; add the vbucketIndex to the operation if (locator instanceof VBucketNodeLocator) { if (o instanceof KeyedOperation && o instanceof VBucketAware) { Collection<String> keys = ((KeyedOperation) o).getKeys(); VBucketNodeLocator vbucketLocator = (VBucketNodeLocator) locator; for (String key : keys) { short vbucketIndex = (short) vbucketLocator.getVBucketIndex(key); VBucketAware vbucketAwareOp = (VBucketAware) o; vbucketAwareOp.setVBucket(key, vbucketIndex); } } } o.setHandlingNode(node); o.initialize(); node.addOp(o); addedQueue.offer(node); } Selector s = selector.wakeup(); assert s == selector : "Wakeup returned the wrong selector."; } 
public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; for ( MemcachedNode node : nodes ) { Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; } 
public static void opTimedOut ( Operation op ) { MemcachedConnection . setTimeout ( op , true ) ; } 
public static void opSucceeded ( Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; } 
public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
void setupResend ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void fillWriteBuffer ( boolean optimizeGets ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void transitionWriteItem ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void addOp ( Operation op ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
int getSelectionOps ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean isActive ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void reconnecting ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void connected ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
int getReconnectCount ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void setChannel ( SocketChannel to ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
SocketChannel getChannel ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void setSk ( SelectionKey to ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
SelectionKey getSk ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
int getBytesRemainingToWrite ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
int writeSome ( ) throws IOException ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void fixupOps ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void authComplete ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
public String toString ( ) { return root . toString ( ) ; } 
public void addOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void insertOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void connected ( ) { throw new UnsupportedOperationException ( ) ; } 
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; } 
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; } 
public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; } 
public boolean isActive ( ) { return root . isActive ( ) ; } 
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; } 
public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; } 
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; } 
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; } 
MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; } 
SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; } 
public boolean hasMoreMessages ( ) { if ( ! rqueue . isEmpty ( ) ) { return true ; } else { synchronized ( omap ) { Iterator < Operation > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Operation op = itr . next ( ) ; if ( op . getState ( ) . equals ( OperationState . COMPLETE ) | | op . isCancelled ( ) | | op . hasErrored ( ) ) { omap . get ( op ) . shutdown ( ) ; omap . remove ( op ) ; } } if ( omap . size ( ) > 0 ) { return true ; } } } return false ; } 
public Operation tapCustom ( String id , RequestMessage message , String keyFilter , String valueFilter ) throws ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; } 
public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } 
public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } 
public Operation tapBackfill ( String id , final int runTime , final TimeUnit timeunit ) throws IOException , ConfigurationException { return tapBackfill ( id , - 1 , runTime , timeunit ) ; } 
public Operation tapBackfill ( final String id , final long date , final int runTime , final TimeUnit timeunit ) throws IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; } 
public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; 
public Operation tapDump ( final String id ) throws IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; } 
public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } 
public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } 
public void complete ( ) { latch . countDown ( ) ; } 
private void tapAck ( TapConnectionProvider conn , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . tapAck ( opcode , opaque , cb ) ; conn . addOp ( op ) ; } 
public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < Operation , TapConnectionProvider > me : omap . entrySet ( ) ) { 
Operation addOp ( final Operation op ) { conn . checkState ( ) ; conn . addOperation ( " " , op ) ; return op ; } 
public boolean removeObserver ( ConnectionObserver obs ) { return conn . removeObserver ( obs ) ; } 
public void reconfigure ( Bucket bucket ) { this . conn . reconfigure ( bucket ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = conn.getName(); conn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { conn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { conn.setName(baseName + " - SHUTTING DOWN (telling client)"); conn.shutdown(); conn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); if (this.configurationProvider != null) { this.configurationProvider.shutdown(); } } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, conn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here 
CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , conn . getLocator ( ) . getAll ( ) , true ) ; } 
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; } 
public static void printMessage ( BaseMessage message , PrintWriter p ) { int colNum = 0 ; byte [ ] mbytes = message . getBytes ( ) . array ( ) ; p . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; p . print ( " ---------------------- " ) ; for ( int i = 0 ; i < mbytes . length ; i + + ) { if ( ( i % 4 ) = = 0 ) { p . printf ( " n%3d| " , colNum ) ; colNum + = 4 ; } int field = mbytes [ i ] ; if ( field < 0 ) { field = field + 256 ; } p . printf ( " %5x " , field ) ; } p . print ( " " ) ; } 
public static AuthDescriptor typical ( String u , String p ) { return new AuthDescriptor ( new String [ ] { " CRAM-MD5 " , " PLAIN " } , new PlainCallbackHandler ( u , p ) ) ; 
public boolean authThresholdReached ( ) { if ( allowedAuthAttempts < 0 ) { return false ; negative value means auth forever 
private Operation buildOperation ( OperationStatus st , OperationCallback cb ) { if ( st = = null ) { return opFact . saslAuth ( authDescriptor . getMechs ( ) , 
public synchronized void authConnection ( MemcachedConnection conn , OperationFactory opFact , AuthDescriptor authDescriptor , MemcachedNode node ) { interruptOldAuth ( node ) ; AuthThread newSASLAuthenticator = new AuthThread ( conn , opFact , authDescriptor , node ) ; nodeMap . put ( node , newSASLAuthenticator ) ; } 
private void interruptOldAuth ( MemcachedNode nodeToStop ) { AuthThread toStop = nodeMap . get ( nodeToStop ) ; if ( toStop ! = null ) { if ( toStop . isAlive ( ) ) { 
public void handle ( Callback [ ] callbacks ) throws IOException , UnsupportedCallbackException { for ( Callback cb : callbacks ) { if ( cb instanceof TextOutputCallback ) { 
public static void close ( Closeable closeable ) { if ( closeable ! = null ) { try { 
public void run ( ) { try { barrier . await ( ) ; rv = callable . call ( ) ; } catch ( Throwable ) { throwable = ; } latch . countDown ( ) ; } 
public T getResult ( ) throws Throwable { latch . await ( ) ; if ( throwable ! = null ) { throw throwable ; } return rv ; } 
public static < T > Collection < SyncThread < T > > getCompletedThreads ( int num , Callable < T > callable ) throws InterruptedException { Collection < SyncThread < T > > rv = new ArrayList < SyncThread < T > > ( num ) ; CyclicBarrier barrier = new CyclicBarrier ( num ) ; for ( int i = 0 ; i < num ; i + + ) { rv . add ( new SyncThread < T > ( barrier , callable ) ) ; } for ( SyncThread < T > : rv ) { . join ( ) ; } return rv ; } 
public static < T > int getDistinctResultCount ( int num , Callable < T > callable ) throws Throwable { IdentityHashMap < T , Object > found = new IdentityHashMap < T , Object > ( ) ; Collection < SyncThread < T > > threads = getCompletedThreads ( num , callable ) ; for ( SyncThread < T > s : threads ) { found . put ( s . getResult ( ) , new Object ( ) ) ; } return found . size ( ) ; } 
public void debug ( Object message , Throwable exception ) { log ( Level . DEBUG , message , exception ) ; } 
public void debug ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { debug ( String . format ( message , args ) , getThrowable ( args ) ) ; 
public void debug ( Object message ) { debug ( message , null ) ; } 
public void info ( Object message , Throwable exception ) { log ( Level . INFO , message , exception ) ; } 
public void info ( String message , Object . . . args ) { if ( isInfoEnabled ( ) ) { info ( String . format ( message , args ) , getThrowable ( args ) ) ; 
public void info ( Object message ) { info ( message , null ) ; } 
public void warn ( Object message , Throwable exception ) { log ( Level . WARN , message , exception ) ; } 
public void warn ( String message , Object . . . args ) { warn ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void warn ( Object message ) { warn ( message , null ) ; } 
public void error ( Object message , Throwable exception ) { log ( Level . ERROR , message , exception ) ; } 
public void error ( String message , Object . . . args ) { error ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void error ( Object message ) { error ( message , null ) ; } 
public void fatal ( Object message , Throwable exception ) { log ( Level . FATAL , message , exception ) ; } 
public void fatal ( String message , Object . . . args ) { fatal ( String . format ( message , args ) , getThrowable ( args ) ) ; } 
public void fatal ( Object message ) { fatal ( message , null ) ; } 
public void log ( Level level , Object message ) { log ( level , message , null ) ; } 
public abstract void log ( Level level , Object message , Throwable e ) ; } 
public boolean isDebugEnabled ( ) { return ( false ) ; } 
public synchronized void log ( Level level , Object message , Throwable e ) { if ( level = = Level . INFO | | level = = Level . WARN 
public String toString ( ) { return ( " {LogLevel: " + name ( ) + " } " ) ; } 
public boolean isDebugEnabled ( ) { return ( l4jLogger . isDebugEnabled ( ) ) ; } 
public boolean isInfoEnabled ( ) { return ( l4jLogger . isInfoEnabled ( ) ) ; } 
public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : I don't know what this is, so consider it fatal pLevel = org.apache.log4j.Level.FATAL; l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, "Unhandled " + "log level: " + level + " for the following message", null); } l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, message, e); } 
String getName ( ) ; void fatal ( String message , Object . . . args ) ; } 
boolean isDebugEnabled ( ) ; void fatal ( String message , Object . . . args ) ; } 
boolean isInfoEnabled ( ) ; void fatal ( String message , Object . . . args ) ; } 
void log ( Level level , Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void log ( Level level , Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void debug ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void debug ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void debug ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; } 
void info ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void info ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void info ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; } 
void warn ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void warn ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void warn ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; } 
void error ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void error ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void error ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; } 
void fatal ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
private static void init ( ) { if ( instance = = null ) { instance = new LoggerFactory ( ) ; 
private Logger internalGetLogger ( String name ) { assert name ! = null : " Name was null " ; Logger rv = instances . get ( name ) ; if ( rv = = null ) { Logger newLogger = null ; try { newLogger = getNewInstance ( name ) ; } catch ( Exception e ) { throw new RuntimeException ( " Problem getting logger " , e ) ; } Logger tmp = instances . putIfAbsent ( name , newLogger ) ; Return either the new logger we've just made, or one that was created while we were waiting rv = tmp == null ? newLogger : tmp; } return (rv); } 
private Logger getNewInstance ( String name ) throws InstantiationException , IllegalAccessException , InvocationTargetException { if ( instanceConstructor = = null ) { getConstructor ( ) ; } Object [ ] args = { name } ; Logger rv = instanceConstructor . newInstance ( args ) ; return ( rv ) ; } 
public boolean isDebugEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINE ) ) ; } 
public boolean isInfoEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . INFO ) ) ; } 
public void execute ( ) throws IOException { IOEventDispatch dispatch = new DefaultClientIOEventDispatch ( new ManagedClientHandler ( this . handler , this ) , this . params ) ; this . ioreactor . execute ( dispatch ) ; } 
public void shutdown ( long waitMs ) throws IOException { synchronized ( this . lock ) { if ( ! this . shutdown ) { this . shutdown = true ; while ( ! this . pendingRequests . isEmpty ( ) ) { AsyncConnectionRequest request = this . pendingRequests . remove ( ) ; request . cancel ( ) ; } this . availableConns . clear ( ) ; this . allConns . clear ( ) ; } } this . ioreactor . shutdown ( waitMs ) ; } 
void addConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( this . shutdown ) { return ; } synchronized ( this . lock ) { this . allConns . add ( conn ) ; 
void removeConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( this . shutdown ) { return ; } synchronized ( this . lock ) { if ( this . allConns . remove ( conn ) ) { 
public AsyncConnectionRequest requestConnection ( ) { if ( this . shutdown ) { throw new IllegalStateException ( " Connection manager has been shut down " ) ; } AsyncConnectionRequest request = new AsyncConnectionRequest ( ) ; synchronized ( this . lock ) { while ( ! this . availableConns . isEmpty ( ) ) { NHttpClientConnection conn = this . availableConns . remove ( ) ; if ( conn . isOpen ( ) ) { getLogger ( ) . debug ( " Re-using persistent connection " ) ; request . setConnection ( conn ) ; break ; } else { this . allConns . remove ( conn ) ; } } if ( ! request . isCompleted ( ) ) { this . pendingRequests . add ( request ) ; processConnectionRequests ( ) ; } } return request ; } 
public void releaseConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( this . shutdown ) { return ; } synchronized ( this . lock ) { if ( this . allConns . contains ( conn ) ) { 
private void processConnectionRequests ( ) { while ( this . allConns . size ( ) < this . maxConnections ) { AsyncConnectionRequest request = this . pendingRequests . poll ( ) ; 
public void connected ( NHttpClientConnection conn , Object attachment ) { AsyncConnectionRequest request = ( AsyncConnectionRequest ) attachment ; this . handler . connected ( conn , attachment ) ; this . connMgr . addConnection ( conn ) ; request . setConnection ( conn ) ; } 
public void closed ( NHttpClientConnection conn ) { this . connMgr . removeConnection ( conn ) ; this . handler . closed ( conn ) ; } 
public void requestReady ( NHttpClientConnection conn ) { this . handler . requestReady ( conn ) ; } 
public void outputReady ( NHttpClientConnection conn , ContentEncoder encoder ) { this . handler . outputReady ( conn , encoder ) ; } 
public void responseReceived ( NHttpClientConnection conn ) { this . handler . responseReceived ( conn ) ; } 
public void inputReady ( NHttpClientConnection conn , ContentDecoder decoder ) { this . handler . inputReady ( conn , decoder ) ; } 
public void exception ( NHttpClientConnection conn , HttpException ex ) { this . handler . exception ( conn , ex ) ; } 
public void exception ( NHttpClientConnection conn , IOException ex ) { this . handler . exception ( conn , ex ) ; } 
public void timeout ( NHttpClientConnection conn ) { this . handler . timeout ( conn ) ; } 
public void completed ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request successful " ) ; 
public void cancelled ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request cancelled " ) ; connRequest . cancel ( ) ; } 
public void failed ( SessionRequest request ) { getLogger ( ) . error ( request . getRemoteAddress ( ) + " - Session request failed " ) ; IOException ex = request . getException ( ) ; if ( ex ! = null ) { ex . printStackTrace ( ) ; } connRequest . cancel ( ) ; } 
public void timeout ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request timed out " ) ; connRequest . cancel ( ) ; } 
public boolean isCompleted ( ) { return this . completed ; } 
public void cancel ( ) { if ( this . completed ) { return ; } this . completed = true ; synchronized ( this ) { notifyAll ( ) ; 
public void waitFor ( ) throws InterruptedException { if ( this . completed ) { return ; } synchronized ( this ) { while ( ! this . completed ) { 
public void completed ( ) { if ( this . completed ) { return ; } this . completed = true ; this . connMgr . releaseConnection ( this . conn ) ; synchronized ( this ) { notifyAll ( ) ; 
public Thread newThread ( Runnable r ) { Thread = new Thread ( r , namePrefix + threadNumber . getAndIncrement ( ) ) ; . setDaemon ( daemon ) ; return ; } 
boolean isTimeout ( ) ; OperationStatus getStatus ( ) ; } 
V getSome ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; OperationStatus getStatus ( ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; } 
public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; 
public Map < String , T > getSome ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { timeout = true ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( " Operation timed out: " , timedoutOps ) . getMessage ( ) ) ; } return ret ; 
public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; status = new OperationStatus ( false , " Timed out " ) ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; } 
public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; } 
private static String createMessage ( String message , Collection < Operation > ops ) { StringBuilder rv = new StringBuilder ( message ) ; rv . append ( " - failing node " ) ; rv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; boolean first = true ; for ( Operation op : ops ) { if ( first ) { first = false ; } else { rv . append ( " , " ) ; } MemcachedNode node = op = = null ? null : op . getHandlingNode ( ) ; rv . append ( node = = null ? " <unknown> " : node . getSocketAddress ( ) ) ; } return rv . toString ( ) ; } 
public boolean cancel ( boolean ign ) { return rv . cancel ( ign ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { Future < T > v = rv . get ( ) ; return v = = null ? null : v . get ( ) ; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { Future < T > v = rv . get ( duration , units ) ; return v = = null ? null : v . get ( ) ; } 
public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; } 
public boolean isCancelled ( ) { return rv . isCancelled ( ) ; } 
public boolean cancel ( boolean c ) { op . cancel ( ) ; return true ; } 
public T get ( ) throws InterruptedException , ExecutionException { try { return get ( timeout , TimeUnit . MILLISECONDS ) ; 
public T get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } return objRef . get ( ) ; } 
public void set ( T oper , OperationStatus s ) { objRef . set ( oper ) ; status = s ; } 
public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . hasErrored ( ) ; } 
public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; } 
public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; } 
public Boolean get ( ) throws InterruptedException , ExecutionException { if ( exception ! = null ) { throw exception ; } return value ; } 
public Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( exception ! = null ) { throw exception ; } return value ; } 
public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; This isn't exactly correct, but it's close enough. If we're in a writing state, we *probably* haven't started. return op.getState() == OperationState.WRITING; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } status = new OperationStatus(false, "Timed out"); throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { status = new OperationStatus(false, op.getException().getMessage()); throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { status = new OperationStatus(false, "Timed out"); throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); } 
public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; } 
public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ; 
public void remove ( ) { throw new UnsupportedOperationException ( " Cannot remove from this " + " iterator. " ) ; 
public ViewResponseWithDocs get ( ) throws InterruptedException , ExecutionException { try { return get ( timeout , TimeUnit . MILLISECONDS ) ; 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; Iterator < RowWithDocs > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { RowWithDocs r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
public void set ( ViewResponseWithDocs viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { viewRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; } 
public BlockingQueue < Operation > create ( ) { return new ArrayBlockingQueue < Operation > ( capacity ) ; } 
private String first ( Collection < String > keys ) { return keys . iterator ( ) . next ( ) ; } 
protected abstract Collection < ? extends Operation > cloneGet ( KeyedOperation op ) ; } 
StoreType getStoreType ( ) ; byte [ ] getBytes ( ) ; } 
long getCasValue ( ) ; byte [ ] getBytes ( ) ; } 
int getFlags ( ) ; byte [ ] getBytes ( ) ; } 
int getExpiration ( ) ; byte [ ] getBytes ( ) ; } 
ConcatenationType getStoreType ( ) ; byte [ ] getData ( ) ; } 
long getCasValue ( ) ; byte [ ] getData ( ) ; } 
void gotData ( String key , int flags , long cas , byte [ ] data ) ; } } 
void gotData ( String key , int flags , byte [ ] data ) ; } } 
public BlockingQueue < Operation > create ( ) { return new LinkedBlockingQueue < Operation > ( ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { ( ( GetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; } 
public void gotData ( String key , int flags , long cas , byte [ ] data ) { ( ( GetsOperation . Callback ) originalCallback ) . gotData ( key , flags , cas , data ) ; } 
public void complete ( ) { if ( - - remaining = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ; 
public void receivedStatus ( OperationStatus status ) { mostRecentStatus = status ; } 
Mutator getType ( ) ; int getExpiration ( ) ; } 
int getBy ( ) ; int getExpiration ( ) ; } 
long getDefault ( ) ; int getExpiration ( ) ; } 
boolean isCancelled ( ) ; boolean isTimedOutUnsent ( ) ; } 
boolean hasErrored ( ) ; boolean isTimedOutUnsent ( ) ; } 
OperationException getException ( ) ; boolean isTimedOutUnsent ( ) ; } 
OperationCallback getCallback ( ) ; boolean isTimedOutUnsent ( ) ; } 
void cancel ( ) ; boolean isTimedOutUnsent ( ) ; } 
OperationState getState ( ) ; boolean isTimedOutUnsent ( ) ; } 
ByteBuffer getBuffer ( ) ; boolean isTimedOutUnsent ( ) ; } 
void writeComplete ( ) ; boolean isTimedOutUnsent ( ) ; } 
void initialize ( ) ; boolean isTimedOutUnsent ( ) ; } 
void readFromBuffer ( ByteBuffer data ) throws IOException ; boolean isTimedOutUnsent ( ) ; } 
void handleRead ( ByteBuffer data ) ; boolean isTimedOutUnsent ( ) ; } 
MemcachedNode getHandlingNode ( ) ; boolean isTimedOutUnsent ( ) ; } 
void setHandlingNode ( MemcachedNode to ) ; boolean isTimedOutUnsent ( ) ; } 
void timeOut ( ) ; boolean isTimedOutUnsent ( ) ; } 
boolean isTimedOut ( ) ; boolean isTimedOutUnsent ( ) ; } 
boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; } 
void receivedStatus ( OperationStatus status ) ; void complete ( ) ; } 
public String toString ( ) { String rv = null ; if ( type = = OperationErrorType . GENERAL ) { rv = " OperationException: " + type ; } else { rv = " OperationException: " + type + " : " + getMessage ( ) ; } return rv ; } 
public String toString ( ) { return " {OperationStatus success= " + isSuccess + " : " + message + " } " ; } 
StoreType getStoreType ( ) ; byte [ ] getData ( ) ; } 
int getFlags ( ) ; byte [ ] getData ( ) ; } 
int getExpiration ( ) ; byte [ ] getData ( ) ; } 
void gotData ( ResponseMessage message ) ; void gotAck ( TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; } 
void gotAck ( TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; } 
void setVBucket ( String key , short vbucket ) ; short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; } 
public final boolean isCancelled ( ) { return cancelled ; } 
public final boolean hasErrored ( ) { return exception ! = null ; } 
public final void cancel ( ) { cancelled = true ; wasCancelled ( ) ; callback . complete ( ) ; } 
protected void wasCancelled ( ) { getLogger ( ) . debug ( " was cancelled. " ) ; } 
protected final void transitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; Discard our buffer when we no longer need it. if (state != OperationState.WRITING) { cmd = null; } if (state == OperationState.COMPLETE) { callback.complete(); } if (state == OperationState.TIMEDOUT) { cmd = null; 
public final void writeComplete ( ) { transitionState ( OperationState . READING ) ; } 
protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
public void handleRead ( ByteBuffer data ) { assert false ; } 
public void timeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; this . transitionState ( OperationState . TIMEDOUT ) ; timedout = true ; } 
public boolean isTimedOut ( long ttlMillis ) { long elapsed = System . nanoTime ( ) ; long ttlNanos = ttlMillis * 1000 * 1000 ; if ( elapsed - creationTime > ttlNanos ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; this . transitionState ( OperationState . TIMEDOUT ) ; timedOutUnsent = true ; timedout = true ; } else { timedout would be false, but we cannot allow you to untimeout an operation if (timedout) { throw new IllegalArgumentException("Operation has already timed out;" + " ttl specified would allow it to be valid."); } } return timedout; } 
public boolean isTimedOutUnsent ( ) { return timedOutUnsent ; } 
public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line 
public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ; 
public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = true ; } 
public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ; 
public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ; 
public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ; 
public int numCallbacks ( ) { return allCallbacks . size ( ) ; } 
public final void copyInputQueue ( ) { Collection < Operation > tmp = new ArrayList < Operation > ( ) ; don't drain more than we have space to place inputQueue.drainTo(tmp, writeQ.remainingCapacity()); writeQ.addAll(tmp); } 
public Collection < Operation > destroyInputQueue ( ) { Collection < Operation > rv = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( rv ) ; return rv ; } 
private boolean preparePending ( ) { Copy the input queue into the write queue. copyInputQueue(); Now check the ops Operation nextOp = getCurrentWriteOp(); while (nextOp != null && nextOp.isCancelled()) { getLogger().info("Removing cancelled operation: %s", nextOp); removeCurrentWriteOp(); nextOp = getCurrentWriteOp(); } return nextOp != null; } 
public final void fillWriteBuffer ( boolean shouldOptimize ) { if ( toWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { getWbuf ( ) . clear ( ) ; 
public final void transitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Finished writing %s " , op ) ; } 
public final Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; } 
public final Operation removeCurrentWriteOp ( ) { Operation rv = optimizedOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { optimizedOp = null ; } return rv ; } 
public final boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; } 
public final boolean hasWriteOp ( ) { return ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; } 
public final void addOp ( Operation op ) { try { if ( ! authLatch . await ( 1 , TimeUnit . SECONDS ) ) { 
public final void insertOp ( Operation op ) { ArrayList < Operation > tmp = new ArrayList < Operation > ( inputQueue . size ( ) + 1 ) ; tmp . add ( op ) ; inputQueue . drainTo ( tmp ) ; inputQueue . addAll ( tmp ) ; } 
public final boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
public final void reconnecting ( ) { reconnectAttempt + + ; continuousTimeout . set ( 0 ) ; } 
public final void connected ( ) { reconnectAttempt = 0 ; continuousTimeout . set ( 0 ) ; } 
public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { setChannel ( ch ) ; setSk ( skey ) ; } 
public final int writeSome ( ) throws IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert toWrite > = 0 : " toWrite went negative after writing " + wrote + " bytes for " + this ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; } 
public final void fixupOps ( ) { As the selection key can be changed at any point due to node failure, we'll grab the current volatile value and configure it. SelectionKey s = sk; if (s != null && s.isValid()) { int iops = getSelectionOps(); 
public final void authComplete ( ) { if ( reconnectBlocked ! = null & & reconnectBlocked . size ( ) > 0 ) { inputQueue . addAll ( reconnectBlocked ) ; } authLatch . countDown ( ) ; } 
public final void setupForAuth ( ) { if ( shouldAuth ) { authLatch = new CountDownLatch ( 1 ) ; 
protected void optimize ( ) { make sure there are at least two get operations in a row before attempting to optimize them. if (writeQ.peek() instanceof GetOperation) { optimizedOp = writeQ.remove(); 
public DeleteOperation delete ( String key , OperationCallback cb ) { return new DeleteOperationImpl ( key , cb ) ; } 
public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; } 
public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { throw new UnsupportedOperationException ( " Get and touch is not supported " + " for ASCII protocol " ) ; 
public GetOperation get ( String key , GetOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; } 
public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { return new GetOperationImpl ( keys , cb ) ; } 
public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { return new GetlOperationImpl ( key , exp , cb ) ; } 
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; } 
public MutatorOperation mutate ( Mutator m , String key , int by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; } 
public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; } 
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; } 
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { throw new UnsupportedOperationException ( " Touch is not supported for " + " ASCII protocol " ) ; 
public VersionOperation version ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; } 
public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; } 
public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , cb ) ; } 
public SASLMechsOperation saslMechs ( OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ; 
public TapOperation tapBackfill ( String id , long date , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public TapOperation tapDump ( String id , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ; 
public final void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ; 
public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; This will be the case, because we'll clear them when it's not. assert readOffset <= data.length : "readOffset is " + readOffset + " data.length is " + data.length; getLogger().debug("readOffset: %d, length: %d", readOffset, data.length); If we're not looking for termination, we're still looking for data if (lookingFor == '\0') { int toRead = data.length - readOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d bytes", toRead); b.get(data, readOffset, toRead); readOffset += toRead; } Transition us into a ``looking for \r'' kind of state if we've read enough and are still in a data state. if (readOffset == data.length && lookingFor == '\0') { The callback is most likely a get callback. If it's not, then it's a gets callback. OperationCallback cb = getCallback(); if (cb instanceof GetOperation.Callback) { GetOperation.Callback gcb = (GetOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, data); } else if (cb instanceof GetsOperation.Callback) { GetsOperation.Callback gcb = (GetsOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else if (cb instanceof GetlOperation.Callback) { GetlOperation.Callback gcb = (GetlOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else if (cb instanceof GetAndTouchOperation.Callback) { GetAndTouchOperation.Callback gcb = (GetAndTouchOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else { throw new ClassCastException("Couldn't convert " + cb + "to a relevent op"); } lookingFor = '\r'; } If we're looking for an ending byte, let's go find it. if (lookingFor != '\0' && b.hasRemaining()) { do { 
public final void initialize ( ) { Figure out the length of the request int size = 6; Enough for gets\r Collection<byte[]> keyBytes = KeyUtil.getKeyBytes(keys); for (byte[] k : keyBytes) { size += k.length; size++; } byte[] e = String.valueOf(exp).getBytes(); if (hasExp) { size += e.length + 1; } ByteBuffer b = ByteBuffer.allocate(size); b.put(cmd.getBytes()); for (byte[] k : keyBytes) { b.put((byte) ' '); b.put(k); } if (hasExp) { b.put((byte) ' '); b.put(e); } b.put(RN_BYTES); b.flip(); setBuffer(b); } 
protected final void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; } 
public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , type , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, " + " need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
protected void wasCancelled ( ) { XXX: Replace this comment with why I did this getCallback().receivedStatus(CANCELLED); } 
public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , " cas " , key , flags , exp , data . length , casValue ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, " + " need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key ) ; b . flip ( ) ; setBuffer ( b ) ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; b . flip ( ) ; } setBuffer ( b ) ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( true , line ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { int size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; } 
protected void wasCancelled ( ) { XXX: Replace this comment with why the hell I did this. getCallback().receivedStatus(CANCELLED); } 
OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; } 
public void addOperation ( GetOperation o ) { getKeys ( ) . addAll ( o . getKeys ( ) ) ; pcb . addCallbacks ( o ) ; } 
public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( END ) ; 
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( msg ) ) ; } 
protected void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; } 
public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , line . substring ( " VERSION " . length ( ) ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; } 
protected void optimize ( ) { Operation firstOp = writeQ . peek ( ) ; if ( firstOp instanceof GetOperation ) { optimizeGets ( ) ; 
private void optimizeGets ( ) { make sure there are at least two get operations in a row before attempting to optimize them. optimizedOp = writeQ.remove(); if (writeQ.peek() instanceof GetOperation) { OptimizedGetImpl og = new OptimizedGetImpl((GetOperation) optimizedOp); 
private void optimizeSets ( ) { make sure there are at least two get operations in a row before attempting to optimize them. optimizedOp = writeQ.remove(); if (writeQ.peek() instanceof CASOperation) { OptimizedSetImpl og = new OptimizedSetImpl((CASOperation) optimizedOp); 
public DeleteOperation delete ( String key , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; } 
public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( cb ) ; } 
public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { return new GetAndTouchOperationImpl ( key , expiration , cb ) ; } 
public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; } 
public GetOperation get ( Collection < String > value , Callback cb ) { return new MultiGetOperationImpl ( value , cb ) ; } 
public MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; } 
public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; } 
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; } 
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; } 
public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( type , key , flags , exp , data , casId , cb ) ; } 
public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; } 
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLAuthOperationImpl ( mech , serverName , props , cbh , cb ) ; } 
public SASLMechsOperation saslMechs ( OperationCallback cb ) { return new SASLMechsOperationImpl ( cb ) ; } 
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLStepOperationImpl ( mech , challenge , serverName , props , cbh , cb ) ; 
public TapOperation tapBackfill ( String id , long date , OperationCallback cb ) { return new TapBackfillOperationImpl ( id , date , cb ) ; } 
public TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) { return new TapCustomOperationImpl ( id , message , cb ) ; } 
public TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { return new TapAckOperationImpl ( opcode , opaque , cb ) ; } 
public TapOperation tapDump ( String id , OperationCallback cb ) { return new TapDumpOperationImpl ( id , cb ) ; } 
private static int cmdMap ( ConcatenationType ) { int rv ; switch ( ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; } 
public void initialize ( ) { prepareBuffer ( key , cas , data ) ; } 
public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES ) ; } 
public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; } 
public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetAndTouchOperation . Callback gcb = ( GetAndTouchOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetlOperation . Callback gcb = ( GetlOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetsOperation . Callback gcb = ( GetsOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; vbmap . put ( k , Short . valueOf ( ( short ) 0 ) ) ; } return rv ; } 
public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(size); for (Map.Entry<Integer, byte[]> me : bkeys.entrySet()) { final byte[] keyBytes = me.getValue(); final String key = keys.get(me.getKey()); Custom header bb.put(REQ_MAGIC); bb.put((byte) CMD_GETQ); bb.putShort((short) keyBytes.length); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort(vbmap.get(key).shortValue()); vbucket bb.putInt(keyBytes.length); bb.putInt(me.getKey()); bb.putLong(0); cas the actual key bb.put(keyBytes); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( responseOpaque = = terminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; } 
protected boolean opaqueIsValid ( ) { return responseOpaque = = terminalOpaque | | keys . containsKey ( responseOpaque ) ; } 
public void addNotMyVbucketNode ( MemcachedNode node ) { notMyVbucketNodes . add ( node ) ; } 
public void initialize ( ) { We're passing around a long so we can cover an unsigned integer. byte[] defBytes = new byte[8]; defBytes[0] = (byte) ((def >> 56) & 0xff); defBytes[1] = (byte) ((def >> 48) & 0xff); defBytes[2] = (byte) ((def >> 40) & 0xff); defBytes[3] = (byte) ((def >> 32) & 0xff); defBytes[4] = (byte) ((def >> 24) & 0xff); defBytes[5] = (byte) ((def >> 16) & 0xff); defBytes[6] = (byte) ((def >> 8) & 0xff); defBytes[7] = (byte) (def & 0xff); prepareBuffer(key, 0, EMPTY_BYTES, by, defBytes, exp); } 
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ; 
public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES ) ; } 
protected void resetInput ( ) { payload = null ; payloadOffset = 0 ; headerOffset = 0 ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == -1 || responseCmd == cmd : "Unexpected response" + " command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES); 
protected void finishedPayload ( byte [ ] pl ) throws IOException { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; if ( status = = null ) { handleError ( OperationErrorType . SERVER , new String ( pl ) ) ; 
protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) throws IOException { switch ( errCode ) { case SUCCESS : 
protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { getLogger ( ) . warn ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; } 
static int decodeShort ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ; } 
static int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 
static long decodeUnsignedInt ( byte [ ] data , int i ) { return ( ( long ) ( data [ i ] & 0xff ) < < 24 ) | ( ( data [ i + 1 ] & 0xff ) < < 16 ) 
static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56 | ( data [ i + 1 ] & 0xff ) < < 48 
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put((byte) cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); } 
static int generateOpaque ( ) { int rv = SEQ_NUMBER . incrementAndGet ( ) ; while ( rv < 0 ) { SEQ_NUMBER . compareAndSet ( rv , 0 ) ; rv = SEQ_NUMBER . incrementAndGet ( ) ; } return rv ; } 
public void addOperation ( CASOperation op ) { ops . add ( op ) ; Count the bytes required by this operation. Iterator<String> is = op.getKeys().iterator(); String k = is.next(); int keylen = KeyUtil.getKeyBytes(k).length; byteCount += MIN_RECV_PACKET + StoreOperationImpl.EXTRA_LEN + keylen + op.getBytes().length; 
public void initialize ( ) { Now create a buffer. ByteBuffer bb = ByteBuffer.allocate(byteCount); for (CASOperation so : ops) { Iterator<String> is = so.getKeys().iterator(); String k = is.next(); byte[] keyBytes = KeyUtil.getKeyBytes(k); assert !is.hasNext(); int myOpaque = generateOpaque(); callbacks.put(myOpaque, so.getCallback()); byte[] data = so.getBytes(); Custom header bb.put(REQ_MAGIC); bb.put((byte) cmdMap(so.getStoreType())); bb.putShort((short) keyBytes.length); bb.put((byte) StoreOperationImpl.EXTRA_LEN); extralen bb.put((byte) 0); data type bb.putShort(((VBucketAware) so).getVBucket(k)); vbucket bb.putInt(keyBytes.length + data.length + StoreOperationImpl.EXTRA_LEN); bb.putInt(myOpaque); bb.putLong(so.getCasValue()); cas Extras bb.putInt(so.getFlags()); bb.putInt(so.getExpiration()); the actual key bb.put(keyBytes); And the value bb.put(data); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); } 
private static int cmdMap ( StoreType ) { int rv ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( responseOpaque = = terminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; assert status ! = null : " Got no status for a quiet mutation error " ; cb . receivedStatus ( status ) ; cb . complete ( ) ; } resetInput ( ) ; } 
protected boolean opaqueIsValid ( ) { return responseOpaque = = terminalOpaque | | callbacks . containsKey ( responseOpaque ) ; 
public void complete ( ) { noop } public void receivedStatus(OperationStatus status) { noop } }} 
public void receivedStatus ( OperationStatus status ) { noop } }} 
protected byte [ ] buildResponse ( SaslClient sc ) throws SaslException { return sc . hasInitialResponse ( ) ? sc . evaluateChallenge ( challenge ) : EMPTY_BYTES ; 
public void initialize ( ) { try { SaslClient sc = Sasl . createSaslClient ( mech , null , " memcached " , 
protected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , " " ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } } 
protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ; 
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ; } 
protected byte [ ] buildResponse ( SaslClient sc ) throws SaslException { return sc . evaluateChallenge ( challenge ) ; } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( keyLen > 0 ) { final byte [ ] keyBytes = new byte [ keyLen ] ; final byte [ ] data = new byte [ pl . length - keyLen ] ; System . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; System . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotStat ( new String ( keyBytes , " UTF-8 " ) , new String ( data , " UTF-8 " ) ) ; } else { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } resetInput ( ) ; } 
private static int cmdMap ( StoreType ) { int rv ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; } 
public void initialize ( ) { prepareBuffer ( key , cas , data , flags , exp ) ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_RES ) ; message . setOpcode ( opcode ) ; message . setOpaque ( opaque ) ; setBuffer ( message . getBytes ( ) ) ; } 
public void readFromBuffer ( ByteBuffer data ) { Do Nothing } @Override public void streamClosed(OperationState state) { transitionState(state); }} 
public void streamClosed ( OperationState state ) { transitionState ( state ) ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . BACKFILL ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; } 
public void initialize ( ) { if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . DUMP ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; } 
public void readFromBuffer ( ByteBuffer data ) throws IOException { while ( data . remaining ( ) > 0 ) { if ( bytesProcessed < BaseMessage . HEADER_LENGTH ) { 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseWithDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseDocsViewResult ( json ) ; } ( ( DocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; } 
HttpRequest getRequest ( ) ; OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; } 
protected OperationStatus parseViewForStatus ( String json , int errorcode ) { if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { String error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; if ( base . has ( " reason " ) ) { error + = " Reason: " + base . getString ( " reason " ) ; } return new OperationStatus ( false , error ) ; } else { return new OperationStatus ( true , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json ) ; } } return new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ; 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseNoDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseNoDocsViewResult ( json ) ; } ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; } 
public String toString ( ) { boolean first = true ; String result = " " ; for ( Entry < String , Object > arg : args . entrySet ( ) ) { if ( first ) { result + = " ? " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; first = false ; } else { result + = " & " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; } } return result ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseReduced vr = null ; if ( status . isSuccess ( ) ) { vr = parseReducedViewResult ( json ) ; } ( ( ReducedCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
private ViewResponseReduced parseReducedViewResult ( String json ) throws ParseException { final Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; } 
public String toString ( ) { return " update_after " ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
private View parseDesignDocumentForView ( String dn , String ddn , String viewname , String json ) throws ParseException { View view = null ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String curView = ( String ) itr . next ( ) ; if ( curView . equals ( viewname ) ) { boolean map = views . getJSONObject ( curView ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( curView ) . has ( " reduce " ) ; view = new View ( dn , ddn , viewname , map , reduce ) ; break ; } } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return view ; } 
public Iterator < RowNoDocs > iterator ( ) { return rows . iterator ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowNoDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . toString ( ) ; } 
public Iterator < RowReduced > iterator ( ) { return rows . iterator ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowReduced r : rows ) { s . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . toString ( ) ; } 
public void addError ( RowError r ) { errors . add ( r ) ; } 
public Iterator < RowWithDocs > iterator ( ) { return rows . iterator ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowWithDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDoc ( ) + " " ) ; } return s . toString ( ) ; } 
public void clear ( ) { throw new UnsupportedOperationException ( " clear() is not supported " ) ; } 
public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; } 
public boolean containsValue ( Object value ) { return map . containsValue ( value ) ; } 
public Set < Entry < String , Object > > entrySet ( ) { Set < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; for ( RowWithDocs r : rows ) { set . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } return null ; } 
public Object get ( Object key ) { return map . get ( key ) ; } 
public Set < String > keySet ( ) { Set < String > set = new TreeSet < String > ( ) ; for ( RowWithDocs r : rows ) { set . add ( r . getId ( ) ) ; } return null ; } 
public Object put ( String key , Object value ) { throw new UnsupportedOperationException ( " put() is not supported " ) ; } 
public void putAll ( Map < ? extends String , ? extends Object > m ) { throw new UnsupportedOperationException ( " putAll() is not supported " ) ; 
public Object remove ( Object key ) { throw new UnsupportedOperationException ( " remove() is not supported " ) ; } 
public int size ( ) { assert rows . size ( ) = = map . size ( ) ; return rows . size ( ) ; } 
public Collection < Object > values ( ) { Collection < Object > values = new LinkedList < Object > ( ) ; for ( RowWithDocs r : rows ) { values . add ( r . getDoc ( ) ) ; } return values ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { List < View > views = parseDesignDocumentForViews ( bucketName , designDocName , json ) ; ( ( ViewsCallback ) callback ) . gotData ( views ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
private List < View > parseDesignDocumentForViews ( String dn , String ddn , String json ) throws ParseException { List < View > viewList = new LinkedList < View > ( ) ; try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String viewname = ( String ) itr . next ( ) ; boolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; viewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } return viewList ; } 
public Object getObject ( ) throws Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; 
public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapFlag . BACKFILL ) ; } 
public void doDump ( ) { message . setFlags ( TapFlag . DUMP ) ; } 
public void specifyVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . LIST_VBUCKETS ) ; } 
public void supportAck ( ) { message . setFlags ( TapFlag . SUPPORT_ACK ) ; } 
public void keysOnly ( ) { message . setFlags ( TapFlag . KEYS_ONLY ) ; } 
public void takeoverVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; } 
boolean hasFlag ( int f ) { if ( ( f & ( int ) flag ) > 0 ) { return true ; } return false ; } 
public static long fieldToValue ( byte [ ] buffer , int offset , int length ) { long total = 0 ; long val = 0 ; for ( int i = 0 ; i < length ; i + + ) { val = buffer [ offset + i ] ; if ( val < 0 ) { val = val + 256 ; } total + = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) * val ; } return total ; } 
public static void valueToFieldOffest ( byte [ ] buffer , int offset , int length , long l ) { long divisor ; for ( int i = 0 ; i < length ; i + + ) { divisor = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) ; 
public boolean asyncDecode ( CachedData d ) { return false ; } 
protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . toByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; } 
protected Object deserialize ( byte [ ] in ) { Object rv = null ; try { if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } return rv ; } 
protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { throw new NullPointerException ( " Can't compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . toByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; } 
protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } } return bos = = null ? null : bos . toByteArray ( ) ; } 
protected String decodeString ( byte [ ] data ) { String rv = null ; try { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; } 
protected byte [ ] encodeString ( String in ) { byte [ ] rv = null ; try { rv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; } 
public CachedData encode ( java . lang . Integer l ) { return new CachedData ( FLAGS , tu . encodeInt ( l ) , getMaxSize ( ) ) ; } 
public CachedData encode ( java . lang . Long l ) { return new CachedData ( FLAGS , tu . encodeLong ( l ) , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = tu . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = tu . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = tu . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = tu . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public < T > Future < T > decode ( final Transcoder < T > tc , final CachedData cachedData ) { assert ! pool . isShutdown ( ) : " Pool has already shut down. " ; TranscodeService . Task < T > task = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return tc . decode ( cachedData ) ; } } ) ; if ( tc . asyncDecode ( cachedData ) ) { this . pool . execute ( task ) ; } return task ; } 
public T call ( ) { return tc . decode ( cachedData ) ; } 
public boolean isShutdown ( ) { return pool . isShutdown ( ) ; } 
public T get ( ) throws InterruptedException , ExecutionException { this . run ( ) ; return super . get ( ) ; } 
public T get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { this . run ( ) ; return super . get ( timeout , unit ) ; } 
public void run ( ) { if ( this . isRunning . compareAndSet ( false , true ) ) { super . run ( ) ; 
boolean asyncDecode ( CachedData d ) ; int getMaxSize ( ) ; } 
CachedData encode ( T o ) ; int getMaxSize ( ) ; } 
T decode ( CachedData d ) ; int getMaxSize ( ) ; } 
public byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } if ( packZeros ) { int firstNon0 = 0 ; Just looking for what we can reduce while (firstNon0 < rv.length && rv[firstNon0] == 0) { firstNon0++; } if (firstNon0 > 0) { byte[] tmp = new byte[rv.length - firstNon0]; System.arraycopy(rv, firstNon0, tmp, 0, rv.length - firstNon0); rv = tmp; } } return rv; } 
public byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; } 
public long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; } 
public byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; } 
public int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; } 
public byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; } 
public byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; } 
public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; } 
public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = tu . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = tu . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = tu . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = this . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = tu . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = tu . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
protected Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) tu . decodeInt ( b ) ) ; } 
public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? 1 : 0 ) ; return rv ; } 
public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = 1 ; } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
private Short decodeShort ( byte [ ] data ) { return Short . valueOf ( ( short ) decodeInteger ( data ) . intValue ( ) ) ; } 
private Byte decodeByte ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a byte " ; byte value = in [ 1 ] ; return Byte . valueOf ( value ) ; 
private Integer decodeInteger ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for an int " ; return Integer . valueOf ( ( int ) decodeLong ( in ) . longValue ( ) ) ; 
private Float decodeFloat ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for a float " ; Integer l = decodeInteger ( in ) ; return Float . valueOf ( Float . intBitsToFloat ( l . intValue ( ) ) ) ; } 
private Double decodeDouble ( byte [ ] in ) { assert in . length = = 9 : " Wrong length for a double " ; Long l = decodeLong ( in ) ; return Double . valueOf ( Double . longBitsToDouble ( l . longValue ( ) ) ) ; } 
private Boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a boolean " ; return Boolean . valueOf ( in [ 1 ] = = 1 ) ; } 
private Long decodeLong ( byte [ ] in ) { long rv = 0 L ; for ( int idx = 1 ; idx < in . length ; idx + + ) { byte i = in [ idx ] ; rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return Long . valueOf ( rv ) ; } 
private Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) decodeInteger ( b ) . intValue ( ) ) ; } 
private String decodeW1String ( byte [ ] b ) { try { return new String ( b , 1 , b . length - 1 , charset ) ; 
private byte [ ] encodeByte ( Byte value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BYTE ; b [ 1 ] = value . byteValue ( ) ; return b ; } 
private byte [ ] encodeBoolean ( Boolean value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BOOLEAN ; b [ 1 ] = ( byte ) ( value . booleanValue ( ) ? 1 : 0 ) ; return b ; } 
private byte [ ] encodeInteger ( Integer value ) { byte [ ] b = encodeNum ( value , 4 ) ; b [ 0 ] = SPECIAL_INTEGER ; return b ; } 
private byte [ ] encodeLong ( Long value , int type ) { byte [ ] b = encodeNum ( value , 8 ) ; b [ 0 ] = ( byte ) type ; return b ; } 
private byte [ ] encodeLong ( Long value ) { return encodeLong ( value , SPECIAL_LONG ) ; } 
private byte [ ] encodeShort ( Short value ) { byte [ ] b = encodeInteger ( ( int ) value . shortValue ( ) ) ; b [ 0 ] = SPECIAL_SHORT ; return b ; } 
private byte [ ] encodeFloat ( Float value ) { byte [ ] b = encodeInteger ( Float . floatToIntBits ( value ) ) ; b [ 0 ] = SPECIAL_FLOAT ; return b ; } 
private byte [ ] encodeDouble ( Double value ) { byte [ ] b = encodeLong ( Double . doubleToLongBits ( value ) ) ; b [ 0 ] = SPECIAL_DOUBLE ; return b ; } 
private byte [ ] encodeCharacter ( Character value ) { byte [ ] result = encodeInteger ( ( int ) value . charValue ( ) ) ; result [ 0 ] = SPECIAL_CHARACTER ; return result ; } 
private byte [ ] encodeStringBuffer ( StringBuffer value ) { byte [ ] b = encodeW1String ( value . toString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUFFER ; return b ; } 
private byte [ ] encodeStringbuilder ( StringBuilder value ) { byte [ ] b = encodeW1String ( value . toString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUILDER ; return b ; } 
private byte [ ] encodeW1String ( String value ) { byte [ ] svalue = null ; try { svalue = value . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } byte [ ] result = new byte [ svalue . length + 1 ] ; System . arraycopy ( svalue , 0 , result , 1 , svalue . length ) ; result [ 0 ] = SPECIAL_STRING ; return result ; } 
private byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes + 1 ] ; for ( int i = 0 ; i < rv . length - 1 ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } return rv ; } 
public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; mostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; watch ( e . getKey ( ) , mostRecent ) ; } return mostRecent = = null ? new ImmediateFuture ( true ) : mostRecent ; } 
public < T > Future < ? > loadData ( Map < String , T > map ) { return loadData ( map . entrySet ( ) . iterator ( ) ) ; } 
public < T > Future < Boolean > push ( String k , T value ) { Future < Boolean > rv = null ; while ( rv = = null ) { try { rv = client . set ( k , expiration , value ) ; } catch ( IllegalStateException ex ) { Need to slow down a bit when we start getting rejections. try { if (rv != null) { rv.get(250, TimeUnit.MILLISECONDS); } else { Thread.sleep(250); } } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } catch (Exception e2) { Ignore exceptions here. We're just trying to slow down input. } } } return rv; } 
private void watch ( final String key , final Future < Boolean > f ) { if ( executorService ! = null & & storageListener ! = null ) { executorService . execute ( new Runnable ( ) { 
public void run ( ) { try { storageListener . storeResult ( key , f . get ( ) ) ; 
void storeResult ( String k , boolean result ) ; void errorStoring ( String k , Exception e ) ; } } 
String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; } 
public void startMonitor ( ) { if ( channel ! = null ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . WARNING , " Bucket monitor is already started. " ) ; return ; } createChannel ( ) ; this . handler = channel . getPipeline ( ) . get ( BucketUpdateResponseHandler . class ) ; handler . setBucketMonitor ( this ) ; HttpRequest request = prepareRequest ( cometStreamURI , host ) ; channel . write ( request ) ; try { String response = this . handler . getLastResponse ( ) ; 
protected void createChannel ( ) { Configure the client. ClientBootstrap bootstrap = new ClientBootstrap(factory); Set up the event pipeline factory. bootstrap.setPipelineFactory(new BucketMonitorPipelineFactory()); Start the connection attempt. ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)); Wait until the connection attempt succeeds or fails. channel = future.awaitUninterruptibly().getChannel(); if (!future.isSuccess()) { bootstrap.releaseExternalResources(); throw new ConnectionException("Could not connect to any pool member."); } assert (channel != null); } 
private void logFiner ( String msg ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . FINER , msg ) ; } 
public void shutdown ( long timeout , TimeUnit unit ) { deleteObservers ( ) ; if ( channel ! = null ) { channel . close ( ) . awaitUninterruptibly ( timeout , unit ) ; } factory . releaseExternalResources ( ) ; } 
protected void invalidate ( ) { try { String response = handler . getLastResponse ( ) ; 
public void messageReceived ( final ChannelHandlerContext context , final MessageEvent event ) { ChannelFuture channelFuture = event . getFuture ( ) ; setReceivedFuture ( channelFuture ) ; if ( this . partialResponse = = null ) { this . partialResponse = new StringBuilder ( ) ; } if ( readingChunks ) { HttpChunk chunk = ( HttpChunk ) event . getMessage ( ) ; 
private void finerLog ( String message ) { LOGGER . log ( Level . FINER , message ) ; } 
public void handleUpstream ( ChannelHandlerContext context , ChannelEvent event ) throws Exception { if ( event instanceof ChannelStateEvent ) { LOGGER . log ( Level . FINEST , " Channel state changed: " + event + " " ) ; } super . handleUpstream ( context , event ) ; } 
public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { LOGGER . log ( Level . INFO , " Exception occurred: " ) ; if ( monitor ! = null ) { monitor . invalidate ( ) ; 
Bucket getBucketConfiguration ( String bucketname ) ; String getAnonymousAuthBucket ( ) ; } 
void subscribe ( String bucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; } 
void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; } 
void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; } 
private void readPools ( String bucketToFind ) { the intent with this method is to encapsulate all of the walking of URIs and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try { 
public void subscribe ( String bucketName , Reconfigurable rec ) { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = this . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ; 
public void unsubscribe ( String vbucketName , Reconfigurable rec ) { BucketMonitor monitor = this . monitors . get ( vbucketName ) ; if ( monitor ! = null ) { monitor . deleteObserver ( new ReconfigurableObserver ( rec ) ) ; 
public void shutdown ( ) { for ( BucketMonitor monitor : this . monitors . values ( ) ) { monitor . shutdown ( ) ; 
private URLConnection urlConnBuilder ( URI base , URI resource ) throws IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . toURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client- " + " Specification-Version " , CLIENT_SPEC_VER ) ; if ( restUsr ! = null ) { try { connection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new IOException ( " Could not encode specified credentials for " + " HTTP request. " , ex ) ; } } return connection ; } 
private String readToString ( URLConnection connection ) throws IOException { BufferedReader reader = null ; try { InputStream inStream = connection . getInputStream ( ) ; 
protected static String buildAuthHeader ( String username , String password ) throws UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); return headerResult; } 
public void update ( Observable o , Object arg ) { rec . reconfigure ( ( Bucket ) arg ) ; } 
private Map < String , MemcachedNode > fillNodesEntries ( Collection < MemcachedNode > nodes ) { HashMap < String , MemcachedNode > vbnodesMap = new HashMap < String , MemcachedNode > ( ) ; getLogger ( ) . debug ( " Updating nodesMap in VBucketNodeLocator. " ) ; for ( MemcachedNode node : nodes ) { InetSocketAddress addr = ( InetSocketAddress ) node . getSocketAddress ( ) ; String address = addr . getAddress ( ) . getHostName ( ) + " : " + addr . getPort ( ) ; String hostname = addr . getAddress ( ) . getHostAddress ( ) + " : " + addr . getPort ( ) ; getLogger ( ) . debug ( " Adding node with hostname %s and address %s. " , hostname , address ) ; getLogger ( ) . debug ( " Node added is %s. " , node ) ; vbnodesMap . put ( address , node ) ; vbnodesMap . put ( hostname , node ) ; } return Collections . unmodifiableMap ( vbnodesMap ) ; } 
public MemcachedNode getAlternative ( String k , Collection < MemcachedNode > notMyVbucketNodes ) { it's safe to only copy the map here, only removing references found to be incorrect, and trying remaining Map<String, MemcachedNode> nodesMap = new HashMap<String, MemcachedNode>(fullConfig.get().getNodesMap()); Collection<MemcachedNode> nodes = nodesMap.values(); nodes.removeAll(notMyVbucketNodes); if (nodes.isEmpty()) { return null; 
public MemcachedNode next ( ) { throw new NoSuchElementException ( " VBucketNodeLocators have no alternate nodes. " ) ; 
public void remove ( ) { throw new UnsupportedOperationException ( " VBucketNodeLocators have no alternate nodes; cannot remove. " ) ; 
public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + configuration . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; } 
public int foundIncorrectMaster ( int vbucket , int wrongServer ) { throw new IllegalArgumentException ( " TODO: refactor this " ) ; } 
int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
public boolean isSequenceChanged ( ) { return sequenceChanged ; } 
Config create ( File file ) ; Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; } 
Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; } 
Map < String , Pool > parseBase ( final String base ) throws ParseException ; Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException ; Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException ; Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
Bucket parseBucket ( String sBucket ) throws ParseException ; void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
void loadPool ( Pool pool , String sPool ) throws ParseException ; } 
public Map < String , Pool > parseBase ( String base ) throws ParseException { Map < String , Pool > parsedBase = new HashMap < String , Pool > ( ) ; JSONArray poolsJA = null ; try { JSONObject baseJO = new JSONObject ( base ) ; poolsJA = baseJO . getJSONArray ( " pools " ) ; } catch ( JSONException e ) { throw new ParseException ( " Can not read base " + base , 0 ) ; } for ( int i = 0 ; i < poolsJA . length ( ) ; + + i ) { try { JSONObject poolJO = poolsJA . getJSONObject ( i ) ; String name = ( String ) poolJO . get ( NAME_ATTR ) ; if ( name = = null | | " " . equals ( name ) ) { throw new ParseException ( " Pool's name is missing. " , 0 ) ; } String uri = ( String ) poolJO . get ( URI_ATTR ) ; if ( uri = = null | | " " . equals ( uri ) ) { throw new ParseException ( " Pool's uri is missing. " , 0 ) ; } String streamingUri = ( String ) poolJO . get ( STREAMING_URI_ATTR ) ; Pool pool = new Pool ( name , new URI ( uri ) , new URI ( streamingUri ) ) ; parsedBase . put ( name , pool ) ; } catch ( JSONException e ) { getLogger ( ) . error ( " One of the pool configuration can not be parsed. " , e ) ; } catch ( URISyntaxException e ) { getLogger ( ) . error ( " Server provided an incorrect uri. " , e ) ; } } return parsedBase ; } 
public void loadPool ( Pool pool , String sPool ) throws ParseException { try { JSONObject poolJO = new JSONObject ( sPool ) ; 
public Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException { Map < String , Bucket > bucketsMap = new HashMap < String , Bucket > ( ) ; try { JSONArray bucketsJA = new JSONArray ( buckets ) ; for ( int i = 0 ; i < bucketsJA . length ( ) ; + + i ) { JSONObject bucketJO = bucketsJA . getJSONObject ( i ) ; Bucket bucket = parseBucketFromJSON ( bucketJO ) ; bucketsMap . put ( bucket . getName ( ) , bucket ) ; } } catch ( JSONException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return bucketsMap ; } 
public Bucket parseBucket ( String sBucket ) throws ParseException { try { return parseBucketFromJSON ( new JSONObject ( sBucket ) ) ; 
private Bucket parseBucketFromJSON ( JSONObject bucketJO ) throws ParseException { try { String bucketname = bucketJO . get ( " name " ) . toString ( ) ; 
public int foundIncorrectMaster ( int vbucket , int wrongServer ) { int mappedServer = this . vbuckets . get ( vbucket ) . getMaster ( ) ; int rv = mappedServer ; if ( mappedServer = = wrongServer ) { rv = ( rv + 1 ) % this . serversCount ; this . vbuckets . get ( vbucket ) . setMaster ( rv ) ; } return rv ; } 
public Config create ( String data ) { try { JSONObject jsonObject = new JSONObject ( data ) ; 
public Config create ( JSONObject jsonObject ) { try { return parseJSON ( jsonObject ) ; 
private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = HashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . KETAMA_HASH ; } else { throw new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; } 
private Config parseJSON ( JSONObject jsonObject ) throws JSONException { the incoming config could be cache or EP object types, JSON envelope picked apart if (!jsonObject.has("vBucketServerMap")) { return parseCacheJSON(jsonObject); } return parseEpJSON(jsonObject.getJSONObject("vBucketServerMap")); } 
private Config parseCacheJSON ( JSONObject jsonObject ) throws JSONException { JSONArray nodes = jsonObject . getJSONArray ( " nodes " ) ; if ( nodes . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty nodes list. " ) ; } int serversCount = nodes . length ( ) ; CacheConfig config = new CacheConfig ( serversCount ) ; populateServers ( config , nodes ) ; return config ; } 
private Config parseEpJSON ( JSONObject jsonObject ) throws JSONException { HashAlgorithm hashAlgorithm = lookupHashAlgorithm ( jsonObject . getString ( " hashAlgorithm " ) ) ; int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { throw new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { throw new ConfigParsingException ( " Number of buckets must be a power of " + " two, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; } 
private List < String > populateServers ( JSONArray servers ) throws JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; } 
private void populateServers ( CacheConfig config , JSONArray nodes ) throws JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; String webHostPort = node . getString ( " hostname " ) ; String [ ] splitHostPort = webHostPort . split ( " : " ) ; JSONObject portsList = node . getJSONObject ( " ports " ) ; int port = portsList . getInt ( " direct " ) ; serverNames . add ( splitHostPort [ 0 ] + " : " + port ) ; } config . setServers ( serverNames ) ; } 
private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) throws JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int [ ] replicas = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; } 
public int hashCode ( ) { int result = status ! = null ? status . hashCode ( ) : 0 ; result = 31 * result + hostname . hashCode ( ) ; result = 31 * result + ports . hashCode ( ) ; return result ; } 
public void replaceBuckets ( Map < String , Bucket > replacingMap ) { TODO: replace this with a deep copy HashMap<String, Bucket> swapMap = new HashMap<String, Bucket>(replacingMap); currentBuckets.set(swapMap); } 
public final void testCloningGetPrimary ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getPrimary ( " hi " ) instanceof MemcachedNodeROImpl ) ; 
public final void testCloningGetAll ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getAll ( ) . iterator ( ) . next ( ) instanceof MemcachedNodeROImpl ) ; 
public final void testCloningGetSequence ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getSequence ( " hi " ) . next ( ) instanceof MemcachedNodeROImpl ) ; 
protected final void assertSequence ( String k , int . . . seq ) { runSequenceAssertion ( locator , k , seq ) ; runSequenceAssertion ( locator . getReadonlyCopy ( ) , k , seq ) ; } 
protected void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; 
public void testSingle ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
public void testTwo ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 www.yahoo.com:81 " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; } 
public void testThree ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " , www.google.com:80 ,, ,, www.yahoo.com:81 , ,, " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; } 
public void testBrokenHost ( ) throws Exception { String s = " www.google.com:80 www.yahoo.com:81:more " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenHost2 ( ) throws Exception { String s = " www.google.com:80 www.yahoo.com " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenList ( ) throws Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testBrokenList2 ( ) throws Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testNullList ( ) throws Exception { String s = null ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ; 
public void testIPv6Host ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6-localhost " ) ; validLocalhostNames . add ( " localhost6.localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ; 
public void testPrimary ( ) throws Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; } 
public void testPrimaryClone ( ) throws Exception { setupNodes ( 4 ) ; assertEquals ( nodes [ 3 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . toString ( ) ) ; assertEquals ( nodes [ 0 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " x " ) . toString ( ) ) ; assertEquals ( nodes [ 1 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " y " ) . toString ( ) ) ; 
public void testAll ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; } 
public void testAllClone ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; } 
public void testSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 2 ) ; } 
public void testSeq2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 1 , 2 , 3 ) ; } 
public void testSeqOnlyOneServer ( ) { setupNodes ( 1 ) ; assertSequence ( " noelani " ) ; } 
public void testSeqWithTwoNodes ( ) { setupNodes ( 2 ) ; assertSequence ( " dustin " , 0 ) ; } 
public void testBadOperation ( ) throws Exception { client . addOp ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { 
public void complete ( ) { System . err . println ( " Complete. " ) ; } 
public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } 
public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } 
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " :11211 " ) ) ; 
protected void initClient ( ) throws Exception { initClient ( new BinaryConnectionFactory ( ) { @Override 
public void testGetStatsCacheDump ( ) throws Exception { XXX: Cachedump isn't returning anything from the server in binprot assertTrue(true); } 
public void testCASAppendFail ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " test " , client . get ( key ) ) ; } 
public void testCASAppendSuccess ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " testes " , client . get ( key ) ) ; } 
public void testCASPrependFail ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " test " , client . get ( key ) ) ; } 
public void testCASPrependSuccess ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
public void testGATTimeout ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " gatkey " ) ) ; 
public void testTouchTimeout ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " touchkey " ) ) ; 
protected void syncGetTimeoutsInitClient ( ) throws Exception { initClient ( new BinaryConnectionFactory ( ) { @Override 
public void testDefaultConstructor ( ) { Just validate that this doesn't throw an exception. new CASMutator<Long>(client, new LongTranscoder()); } 
public Long call ( ) throws Exception { return mutator . cas ( " test.cas.concurrent " , 0 L , 0 , mutation ) ; } 
public void testIncorrectTypeInCAS ( ) throws Throwable { Stick something for this CAS in the cache. client.set("x", 0, "not a long"); try { Long rv = mutator.cas("x", 1L, 0, mutation); 
public void testCASUpdateWithNullInitial ( ) throws Throwable { client . set ( " x " , 0 , 1L ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertEquals ( rv , ( Long ) 2L ) ; } 
public void testCASUpdateWithNullInitialNoExistingVal ( ) throws Throwable { assertNull ( client . get ( " x " ) ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertNull ( rv ) ; assertNull ( client . get ( " x " ) ) ; } 
public void testCASValueToString ( ) { CASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; assertEquals ( " {CasValue 717/hi} " , c . toString ( ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; transcoder = new SerializingTranscoder ( ) ; clientMock = mock ( MemcachedClientIF . class ) ; clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; client = ( MemcachedClientIF ) clientMock . proxy ( ) ; cacheMap = new CacheMap ( client , EXP , " blah " ) ; } 
private void expectGetAndReturn ( String k , Object value ) { clientMock . expects ( once ( ) ) . method ( " get " ) . with ( eq ( k ) , same ( transcoder ) ) . will ( returnValue ( value ) ) ; 
public void testNoExpConstructor ( ) throws Exception { clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( transcoder ) ) ; CacheMap cm = new CacheMap ( client , " blah " ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( true ) ; assertEquals ( 0 , f . getInt ( cm ) ) ; } 
public void testBaseConstructor ( ) throws Exception { BaseCacheMap < Integer > bcm = new BaseCacheMap < Integer > ( client , EXP , " base " , new IntegerTranscoder ( ) ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( true ) ; assertEquals ( EXP , f . getInt ( bcm ) ) ; } 
public void testClear ( ) { try { cacheMap . clear ( ) ; 
public void testGetPositive ( ) { expectGetAndReturn ( " blaha " , " something " ) ; assertEquals ( " something " , cacheMap . get ( " a " ) ) ; } 
public void testGetNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertNull ( cacheMap . get ( " a " ) ) ; } 
public void testGetNotString ( ) { assertNull ( cacheMap . get ( new Object ( ) ) ) ; } 
public void testContainsPositive ( ) { expectGetAndReturn ( " blaha " , new Object ( ) ) ; assertTrue ( cacheMap . containsKey ( " a " ) ) ; } 
public void testContainsNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertFalse ( cacheMap . containsKey ( " a " ) ) ; } 
public void testContainsValue ( ) { assertFalse ( cacheMap . containsValue ( " anything " ) ) ; } 
public void testEntrySet ( ) { assertEquals ( 0 , cacheMap . entrySet ( ) . size ( ) ) ; } 
public void testKeySet ( ) { assertEquals ( 0 , cacheMap . keySet ( ) . size ( ) ) ; } 
public void testtIsEmpty ( ) { assertFalse ( cacheMap . isEmpty ( ) ) ; } 
public void testPutAll ( ) { clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " vala " ) ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blahb " ) , eq ( EXP ) , eq ( " valb " ) ) ; Map < String , Object > m = new HashMap < String , Object > ( ) ; m . put ( " a " , " vala " ) ; m . put ( " b " , " valb " ) ; cacheMap . putAll ( m ) ; } 
public void testSize ( ) { assertEquals ( 0 , cacheMap . size ( ) ) ; } 
public void testValues ( ) { assertEquals ( 0 , cacheMap . values ( ) . size ( ) ) ; } 
public void testRemove ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " delete " ) . with ( eq ( " blaha " ) ) ; assertEquals ( " olda " , cacheMap . remove ( " a " ) ) ; } 
public void testRemoveNotString ( ) { assertNull ( cacheMap . remove ( new Object ( ) ) ) ; } 
public void testPut ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; assertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; } 
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; } 
protected void tearDown ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " ; super . tearDown ( ) ; } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; } 
protected void initClient ( ) throws Exception { initClient ( new DefaultConnectionFactory ( ) { @Override 
protected void flushPause ( ) throws InterruptedException { Thread . sleep ( 100 ) ; } 
public void testQueueingToDownServer ( ) throws Exception { Future < Boolean > f = client . add ( " someKey " , 0 , " some object " ) ; try { boolean b = f . get ( ) ; fail ( " Should've thrown an exception, returned " + b ) ; } catch ( ExecutionException e ) { probably OK } assertTrue(f.isCancelled()); } 
protected void tearDown ( ) throws Exception { override teardown to avoid the flush phase client.shutdown(); } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :64213 " ) ) ; 
private void tryCancellation ( Future < ? > f ) throws Exception { f . cancel ( true ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try { Object o = f . get ( ) ; 
public void testAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; } 
public void testUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " / " + TestConfig . IPV4_ADDR + " :64213 " ) ) , stringify ( 
private void tryTimeout ( Future < ? > f ) throws Exception { try { Object o = f . get ( 10 , TimeUnit . MILLISECONDS ) ; 
protected void tryTestSequence ( Future < ? > f ) throws Exception { tryTimeout ( f ) ; tryCancellation ( f ) ; } 
public void testAsyncGetCancellation ( ) throws Exception { tryTestSequence ( client . asyncGet ( " k " ) ) ; } 
public void testAsyncGetsCancellation ( ) throws Exception { tryTestSequence ( client . asyncGets ( " k " ) ) ; } 
public void testAsyncGetBulkCancellationCollection ( ) throws Exception { tryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; } 
public void testAsyncGetBulkCancellationVararg ( ) throws Exception { tryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; } 
public void testDeleteCancellation ( ) throws Exception { tryTestSequence ( client . delete ( " x " ) ) ; } 
public void testflushCancellation ( ) throws Exception { tryTestSequence ( client . flush ( ) ) ; } 
public void testDelayedflushCancellation ( ) throws Exception { tryTestSequence ( client . flush ( 3 ) ) ; } 
public void testReplaceCancellation ( ) throws Exception { tryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; } 
public void testAddCancellation ( ) throws Exception { tryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; } 
public void testSetCancellation ( ) throws Exception { tryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; } 
public void testCASCancellation ( ) throws Exception { tryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; 
protected Collection < String > stringify ( Collection < ? > c ) { Collection < String > rv = new ArrayList < String > ( ) ; for ( Object o : c ) { rv . add ( String . valueOf ( o ) ) ; } return rv ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; initClient ( ) ; } 
protected void tearDown ( ) throws Exception { Shut down, start up, flush, and shut down again. Error tests have unpredictable timing issues. client.shutdown(); client = null; initClient(); flushPause(); assertTrue(client.flush().get()); client.shutdown(); client = null; super.tearDown(); } 
protected void flushPause ( ) throws InterruptedException { nothing useful } protected boolean isMoxi() { if (moxi != null) { return moxi.booleanValue(); } some tests are invalid if using moxi Map<SocketAddress, Map<String, String>> stats = client.getStats("proxy"); for (Map<String, String> node : stats.values()) { if (node.get("basic:version") != null) { moxi = true; System.err.println("Using proxy"); break; } else { moxi = false; System.err.println("Not using proxy"); } } return moxi.booleanValue(); }} 
protected boolean isMoxi ( ) { if ( moxi ! = null ) { return moxi . booleanValue ( ) ; } some tests are invalid if using moxi Map<SocketAddress, Map<String, String>> stats = client.getStats("proxy"); for (Map<String, String> node : stats.values()) { if (node.get("basic:version") != null) { moxi = true; System.err.println("Using proxy"); break; } else { moxi = false; System.err.println("Not using proxy"); } } return moxi.booleanValue(); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; b = new ConnectionFactoryBuilder ( ) ; } 
public void testDefaults ( ) throws Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; 
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
public void testProtocolSetterBinary ( ) { assertTrue ( b . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; 
public void testProtocolSetterText ( ) { assertTrue ( b . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; 
public BlockingQueue < Operation > create ( ) { return queue ; } 
public void testBinaryEmptyCons ( ) { new BinaryConnectionFactory ( ) ; } 
public void testBinaryTwoIntCons ( ) { new BinaryConnectionFactory ( 5 , 5 ) ; } 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ; } 
public void testQueueSizes ( ) { ConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; assertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ; 
public void testSmallSet ( ) { runThisManyNodes ( 3 ) ; } 
public void testLargeSet ( ) { runThisManyNodes ( 100 ) ; } 
private void runThisManyNodes ( final int totalNodes ) { final String [ ] stringNodes = generateAddresses ( totalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , HashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , HashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; SortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; Verify that EVERY entry in the smaller map has an equivalent mapping in the larger map. boolean failed = false; for (final Long key : smMap.keySet()) { final MemcachedNode largeNode = lgMap.get(key); final MemcachedNode smallNode = smMap.get(key); if (!largeNode.equals(smallNode)) { failed = true; System.out.println("---------------"); System.out.println("Key: " + key); System.out.println("Small: " + smallNode.getSocketAddress()); System.out.println("Large: " + largeNode.getSocketAddress()); } } assertFalse(failed); for (final Map.Entry<Long, MemcachedNode> entry : lgMap.entrySet()) { final Long key = entry.getKey(); final MemcachedNode node = entry.getValue(); if (node.equals(oddManOut)) { final MemcachedNode newNode = smLocator.getNodeForKey(key); if (!smaller.contains(newNode)) { System.out.println("Error - " + key + " -> " + newNode.getSocketAddress()); failed = true; } } } assertFalse(failed); } 
private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; Generate a pseudo-random set of addresses. long now = new Date().getTime(); int first = (int) ((now % 250) + 3); int second = (int) (((now / 250) % 250) + 3); String port = ":11211 "; int last = (int) ((now % 100) + 3); StringBuffer prefix = new StringBuffer(); prefix.append(first); prefix.append("."); prefix.append(second); prefix.append(".1."); Don't protect the possible range too much, as we are our own client. StringBuffer buf = new StringBuffer(); for (int ix = 0; ix < maxSize - 1; ix++) { buf.append(prefix); buf.append(last + ix); buf.append(port); } results[0] = buf.toString(); buf.append(prefix); buf.append(last + maxSize - 1); buf.append(port); results[1] = buf.toString(); return results; } 
private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { List < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; for ( InetSocketAddress addr : addresses ) { results . add ( new MockMemcachedNode ( addr ) ) ; } return results ; } 
public static void main ( String [ ] args ) throws Exception { Create a client with a queue big enough to hold the 300,000 items we're going to add. MemcachedClient client = new MemcachedClient(new DefaultConnectionFactory(350000, 32768), AddrUtil.getAddresses(TestConfig.IPV4_ADDR + ":11211")); long start = System.currentTimeMillis(); byte[] toStore = new byte[26]; Arrays.fill(toStore, (byte) 'a'); for (int i = 0; i < 300000; i++) { client.set("k" + i, 300, toStore); } long added = System.currentTimeMillis(); System.err.printf("Finished queuing in %sms%n", added - start); client.waitForQueues(Long.MAX_VALUE, TimeUnit.MILLISECONDS); long end = System.currentTimeMillis(); System.err.printf("Completed everything in %sms (%sms to flush)%n", end - start, end - added); Map<String, Object> m = client.getBulk("k1", "k2", "k3", "k4", "k5", "k299999", "k299998", "k299997", "k299996"); assert m.size() == 9 : "Expected 9 results, got " + m; client.shutdown(); } 
public void testErrorCodes ( ) throws Exception { HashMap < Byte , String > errMap = new HashMap < Byte , String > ( ) ; OperationFactory opFact = new BinaryOperationFactory ( ) ; errMap . put ( new Byte ( ( byte ) 0x01 ) , " NOT FOUND " ) ; errMap . put ( new Byte ( ( byte ) 0x02 ) , " EXISTS " ) ; errMap . put ( new Byte ( ( byte ) 0x03 ) , " 2BIG " ) ; errMap . put ( new Byte ( ( byte ) 0x04 ) , " INVAL " ) ; errMap . put ( new Byte ( ( byte ) 0x05 ) , " NOT STORED " ) ; errMap . put ( new Byte ( ( byte ) 0x06 ) , " DELTA BAD VAL " ) ; errMap . put ( new Byte ( ( byte ) 0x07 ) , " NOT MY VBUCKET " ) ; errMap . put ( new Byte ( ( byte ) 0x81 ) , " UNKNOWN COMMAND " ) ; errMap . put ( new Byte ( ( byte ) 0x82 ) , " NO MEM " ) ; errMap . put ( new Byte ( ( byte ) 0x83 ) , " NOT SUPPORTED " ) ; errMap . put ( new Byte ( ( byte ) 0x84 ) , " INTERNAL ERROR " ) ; errMap . put ( new Byte ( ( byte ) 0x85 ) , " BUSY " ) ; errMap . put ( new Byte ( ( byte ) 0x86 ) , " TEMP FAIL " ) ; int opaque = 0 ; for ( final Entry < Byte , String > err : errMap . entrySet ( ) ) { byte [ ] b = new byte [ 24 + err . getValue ( ) . length ( ) ] ; 
public void receivedStatus ( OperationStatus s ) { assert ! s . isSuccess ( ) ; assert err . getValue ( ) . equals ( s . getMessage ( ) ) ; } 
public void gotData ( String k , int flags , byte [ ] data ) { } public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } } 
public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } } 
private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; System.out.println(ha + "(" + key + ") = " + exp); assertEquals("Invalid " + ha + " for key ``" + key + "''", exp, ha.hash(key)); 
private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
public void testNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ; 
public void testCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testFNV164 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_64_HASH , me . getKey ( ) , 
public void testFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) , 
public void testFNV132 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) , 
public void testFNV1A32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_32_HASH , me . getKey ( ) , 
public void testKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . KETAMA_HASH , me . getKey ( ) , 
public void testCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; assertEquals ( HashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; } 
protected void setupNodes ( HashAlgorithm alg , int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; } 
protected void setupNodes ( int ) { setupNodes ( HashAlgorithm . KETAMA_HASH , ) ; } 
public void testAll ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; 
public void testAllClone ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; } 
public void testLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testLookupsClone ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . toString ( ) ) ; assertSame ( nodes [ 2 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " noelani " ) . toString ( ) ) ; assertSame ( nodes [ 0 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " some other key " ) . toString ( ) ) ; 
public void testContinuumWrapping ( ) { setupNodes ( 4 ) ; This is the method by which I found something that would wrap assertEquals(4294887009L, ((KetamaNodeLocator) locator).getMaxKey()); assertSame(nodes[3], locator.getPrimary("V5XS8C8N")); assertSame(nodes[3], locator.getPrimary("8KR2DKR2")); assertSame(nodes[3], locator.getPrimary("L9KH6X4X")); } 
public void testClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; } 
public void testSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 , 2 , 2 , 3 ) ; } 
private void assertPosForKey ( String k , int nid ) { assertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; } 
public void testLibKetamaCompat ( ) { setupNodes ( 5 ) ; assertPosForKey ( " 36 " , 2 ) ; assertPosForKey ( " 10037 " , 3 ) ; assertPosForKey ( " 22051 " , 1 ) ; assertPosForKey ( " 49044 " , 4 ) ; } 
public void testFNV1A32 ( ) { HashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
private MemcachedNode [ ] mockNodes ( String [ ] servers ) { setupNodes ( servers . length ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { List < InetSocketAddress > a = AddrUtil . getAddresses ( servers [ i ] ) ; nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( a . iterator ( ) . next ( ) ) ) ; } return nodes ; } 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; return rv ; } 
public boolean shouldOptimize ( ) { return false ; } 
public Integer call ( ) throws Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte [ ] b = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode : " Expected " + hashcode + " was " + Arrays . hashCode ( b ) ; } } return hashcode ; } 
protected void initClient ( ) throws Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) , " default " , " default " , " " ) ) ; 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MembaseClient ( ( MembaseConnectionFactory ) cf ) ; } 
public void testAvailableServers ( ) { MembaseClient tracks hostname and ip address of servers need to make sure the available server list is 2 * (num servers) try { Thread.sleep(10); Let the client warm up } catch (InterruptedException e) { fail("Interrupted while client was warming up"); } assert client.getAvailableServers().size() == 2; } 
protected void syncGetTimeoutsInitClient ( ) throws Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http:localhost:8091/pools " ) ) , " default " , " default " , " " ) { 
protected void tearDown ( ) throws Exception { if ( client ! = null ) { try { client . shutdown ( ) ; } catch ( NullPointerException e ) { This is a workaround for a disagreement betweewn how things should work in eclipse and buildr. My plan is to upgrade to junit4 all around and write some tests that are a bit easier to follow. The actual problem here is a client that isn't properly initialized is attempting to be shut down. } } super.tearDown(); } 
private void assertWorking ( ) throws Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " / " + TestConfig . IPV4_ADDR + " :11211 " , versions . keySet ( ) . iterator ( ) . next ( ) . toString ( ) ) ; 
private void assertArgRequired ( IllegalArgumentException e ) { assertEquals ( " You must have at least one server to connect to " , e . getMessage ( ) ) ; 
public void testVarargConstructor ( ) throws Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , 11211 ) ) ; assertWorking ( ) ; } 
public void testEmptyVarargConstructor ( ) throws Exception { try { client = new MemcachedClient ( ) ; 
public void testNulListConstructor ( ) throws Exception { try { List < InetSocketAddress > l = null ; 
public void testEmptyListConstructor ( ) throws Exception { try { client = new MemcachedClient ( Collections . < InetSocketAddress > emptyList ( ) ) ; 
public void testNullFactoryConstructor ( ) throws Exception { try { client = 
public void testNegativeTimeout ( ) throws Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public void testZeroTimeout ( ) throws Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public void testConnFactoryWithoutOpFactory ( ) throws Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public void testConnFactoryWithoutConns ( ) throws Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { 
public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return null ; } 
public void testArraymodNodeLocatorAccessor ( ) throws Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ; 
public void testKetamaNodeLocatorAccessor ( ) throws Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ; 
public void testDebugBuffer ( ) throws Exception { String input = " this is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " this is a test \\ x5f " , s ) ; } 
private void fillArgs ( Class < ? > [ ] parameterTypes , Object [ ] args ) { int i = 0 ; for ( Class < ? > c : parameterTypes ) { if ( c = = Boolean . TYPE ) { 
public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; } 
public Operation removeCurrentReadOp ( ) { return null ; } 
public Operation removeCurrentWriteOp ( ) { return null ; } 
public int writeSome ( ) throws IOException { return 0 ; } 
public Collection < Operation > destroyInputQueue ( ) { return null ; } 
public void testConnectionObserver ( ) throws Exception { ConnectionObserver obs = new LoggingObserver ( ) ; assertTrue ( " Didn't add observer. " , client . addObserver ( obs ) ) ; assertTrue ( " Didn't remove observer. " , client . removeObserver ( obs ) ) ; assertFalse ( " Removed observer more than once. " , client . removeObserver ( obs ) ) ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { latch . countDown ( ) ; } 
public void connectionLost ( SocketAddress sa ) { assert false : " Should not see this. " ; } 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { getLogger ( ) . info ( " Connection established to %s (%s) " , sa , reconnectCount ) ; } 
public void connectionLost ( SocketAddress sa ) { getLogger ( ) . info ( " Connection lost from %s " , sa ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; } 
public void complete ( ) { fail ( " Unexpected invocation " ) ; } 
public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } 
public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; } 
public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getBytes ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } 
public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } 
public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } 
public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } 
public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } 
public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } 
public void testMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; Starting size 
public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback(); 
protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } 
protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } 
private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } 
private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } 
protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; } 
public void testAssertions ( ) { boolean caught = false ; try { assert false ; } catch ( AssertionError e ) { caught = true ; } assertTrue ( " Assertions are not enabled! " , caught ) ; } 
public void testGetStats ( ) throws Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats: " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " curr_items " ) ) ; } 
public void testGetStatsSlabs ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no slabs to check. client.set("slabinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("slabs"); System.out.println("Stats: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); assertTrue(oneStat.containsKey("1:chunk_size")); } 
public void testGetStatsSizes ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no sizes to check. Note the protocol says flushed/expired items may come back in stats sizes and we use flush when testing, so we check that there's at least one. client.set("sizeinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("sizes"); System.out.println("Stats sizes: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String noItemsSmall = oneStat.get("96"); assertTrue(Integer.parseInt(noItemsSmall) >= 1); } 
public void testGetStatsCacheDump ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there won't be anything to dump client.set("dumpinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("cachedump 1 10000"); System.out.println("Stats cachedump: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String val = oneStat.get("dumpinitializer"); assertTrue(val + "doesn't match", val.matches("\\[2 b; \\d+ s\\]")); } 
public void testDelayedFlush ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; assert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assert client . set ( " test2 " , 5 , " test2value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assertEquals ( " test2value " , client . get ( " test2 " ) ) ; assert client . flush ( 2 ) . getStatus ( ) . isSuccess ( ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " test1 " ) ) ; assertNull ( client . get ( " test2 " ) ) ; assert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assert ! client . asyncGet ( " test2 " ) . getStatus ( ) . isSuccess ( ) ; } 
public void testDoubleShutdown ( ) { client . shutdown ( ) ; client . shutdown ( ) ; } 
public void testSimpleGet ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; } 
public void testSimpleCASGets ( ) throws Exception { assertNull ( client . gets ( " test1 " ) ) ; assert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . gets ( " test1 " ) . getValue ( ) ) ; } 
public void testCAS ( ) throws Exception { final String key = " castestkey " ; First, make sure it doesn't work for a non-existing value. assertSame("Expected error CASing with no existing value.", CASResponse.NOT_FOUND, client.cas(key, 0x7fffffffffL, "bad value")); OK, stick a value in here. assertTrue(client.add(key, 5, "original value").get()); CASValue<?> getsVal = client.gets(key); assertEquals("original value", getsVal.getValue()); Now try it with an existing value, but wrong CAS id assertSame("Expected error CASing with invalid id", CASResponse.EXISTS, client.cas(key, getsVal.getCas() + 1, "broken value")); Validate the original value is still in tact. assertEquals("original value", getsVal.getValue()); OK, now do a valid update assertSame("Expected successful CAS with correct id (" + getsVal.getCas() + ")", CASResponse.OK, client.cas(key, getsVal.getCas(), "new value")); assertEquals("new value", client.get(key)); Test a CAS replay assertSame("Expected unsuccessful CAS with replayed id", CASResponse.EXISTS, client.cas(key, getsVal.getCas(), "crap value")); assertEquals("new value", client.get(key)); } 
public void testReallyLongCASId ( ) throws Exception { String key = " this-is-my-key " ; assertSame ( " Expected error CASing with no existing value. " , CASResponse . NOT_FOUND , 
public void testExtendedUTF8Key ( ) throws Exception { String key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; assertNull ( client . get ( key ) ) ; assert client . set ( key , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . get ( key ) ) ; } 
public void testInvalidKey1 ( ) throws Exception { try { client . get ( " key with spaces " ) ; 
public void testInvalidKey2 ( ) throws Exception { try { StringBuilder longKey = new StringBuilder ( ) ; 
public void testInvalidKey3 ( ) throws Exception { try { Object val = client . get ( " Key " ) ; 
public void testInvalidKey4 ( ) throws Exception { try { Object val = client . get ( " Key r " ) ; 
public void testInvalidKey5 ( ) throws Exception { try { Object val = client . get ( " Key 0 " ) ; 
public void testInvalidKeyBlank ( ) throws Exception { try { Object val = client . get ( " " ) ; 
public void testInvalidKeyBulk ( ) throws Exception { try { Object val = client . getBulk ( " Key key2 " ) ; 
public Boolean call ( ) throws Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " test " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " test " + i ) ) ; } for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , client . get ( " test " + i ) ) ; } return Boolean . TRUE ; } 
public Boolean call ( ) throws Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " test " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " test " + i ) ) ; } Yes, I intentionally ran over. Map<String, Object> m = client.getBulk("test0", "test1", "test2", "test3", "test4", "test5", "test6", "test7", "test8", "test9", "test10"); for (int i = 0; i < 10; i++) { assertEquals("value" + i, m.get("test" + i)); } return Boolean.TRUE; } 
public Boolean call ( ) throws Exception { assert client . set ( " testparallel " , 5 , " parallelvalue " ) . getStatus ( ) . isSuccess ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " testparallel " ) ) ; } return Boolean . TRUE ; } 
public void testAdd ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; assert ! client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " test1 " , 5 , " test1value " ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assert client . asyncGet ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " ) . get ( ) ) ; assert ! client . add ( " test1 " , 5 , " ignoredvalue " ) . getStatus ( ) . isSuccess ( ) ; Should return the original value assertEquals("test1value", client.get("test1")); } 
public void testAddWithTranscoder ( ) throws Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " test1 " , ) ) ; assert ! client . asyncGet ( " test1 " , ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " test1 " , 5 , " test1value " , ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " , ) ) ; assertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; assert ! client . add ( " test1 " , 5 , " ignoredvalue " , ) . getStatus ( ) . isSuccess ( ) ; Should return the original value assertEquals("test1value", client.get("test1", t)); } 
public void testAddNotSerializable ( ) throws Exception { try { client . add ( " t1 " , 5 , new Object ( ) ) ; 
public void testSetNotSerializable ( ) throws Exception { try { client . set ( " t1 " , 5 , new Object ( ) ) ; 
public void testReplaceNotSerializable ( ) throws Exception { try { client . replace ( " t1 " , 5 , new Object ( ) ) ; 
public void testUpdate ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . replace ( " test1 " , 5 , " test1value " ) ; assert ! client . replace ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " ) ) ; } 
public void testUpdateWithTranscoder ( ) throws Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " test1 " , ) ) ; client . replace ( " test1 " , 5 , " test1value " , ) ; assert ! client . replace ( " test1 " , 5 , " test1value " , ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " , ) ) ; } 
public void testMixedSetsAndUpdates ( ) throws Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( ) ) ; 
public void testGetBulk ( ) throws Exception { Collection < String > keys = Arrays . asList ( " test1 " , " test2 " , " test3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " ) ; client . set ( " test2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assert client . asyncGetBulk ( keys ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetBulkVararg ( ) throws Exception { assertEquals ( 0 , client . getBulk ( " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " ) ; client . set ( " test2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " test1 " , " test2 " , " test3 " ) ; assert client . asyncGetBulk ( " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , ) ; client . set ( " test2 " , 5 , " val2 " , ) ; Map < String , String > vals = client . getBulk ( , " test1 " , " test2 " , " test3 " ) ; assert client . asyncGetBulk ( , " test1 " , " test2 " , " test3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; } 
public void testAsyncGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , ) ; client . set ( " test2 " , 5 , " val2 " , ) ; BulkFuture < Map < String , String > > vals = client . asyncGetBulk ( , " test1 " , " test2 " , " test3 " ) ; assert vals . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " test2 " ) ) ; } 
public void testAsyncGetBulkWithTranscoderIterator ( ) throws Exception { ArrayList < String > keys = new ArrayList < String > ( ) ; keys . add ( " test1 " ) ; keys . add ( " test2 " ) ; keys . add ( " test3 " ) ; ArrayList < Transcoder < String > > tcs = new ArrayList < Transcoder < String > > ( keys . size ( ) ) ; for ( String key : keys ) { tcs . add ( new TestWithKeyTranscoder ( key ) ) ; } Any transcoders listed after list of keys should be ignored. for (String key : keys) { tcs.add(new TestWithKeyTranscoder(key)); } assertEquals(0, client.asyncGetBulk(keys, tcs.listIterator()).get().size()); client.set(keys.get(0), 5, "val1", tcs.get(0)); client.set(keys.get(1), 5, "val2", tcs.get(1)); Future<Map<String, String>> vals = client.asyncGetBulk(keys, tcs.listIterator()); assertEquals(2, vals.get().size()); assertEquals("val1", vals.get().get(keys.get(0))); assertEquals("val2", vals.get().get(keys.get(1))); Set with one transcoder with the proper key and get with another transcoder with the wrong key. keys.add(0, "test4"); Transcoder<String> encodeTranscoder = new TestWithKeyTranscoder(keys.get(0)); client.set(keys.get(0), 5, "val4", encodeTranscoder).get(); Transcoder<String> decodeTranscoder = new TestWithKeyTranscoder("not " + keys.get(0)); tcs.add(0, decodeTranscoder); try { client.asyncGetBulk(keys, tcs.listIterator()).get(); 
public void testAvailableServers ( ) { client . getVersions ( ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( getExpectedVersionSource ( ) ) ) , 
public void testUnavailableServers ( ) { client . getVersions ( ) ; assertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; } 
public void testGetVersions ( ) throws Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . toString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; } 
public void testNonexistentMutate ( ) throws Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assert ! client . asyncIncr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; assert ! client . asyncDecr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; } 
public void testMutateWithDefault ( ) throws Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; } 
public void testMutateWithDefaultAndExp ( ) throws Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; assert ! client . asyncGet ( " mtest " ) . getStatus ( ) . isSuccess ( ) ; } 
public void testAsyncIncrement ( ) throws Exception { String k = " async-incr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; } 
public void testAsyncIncrementNonExistent ( ) throws Exception { String k = " async-incr-non-existent " ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrement ( ) throws Exception { String k = " async-decr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrementNonExistent ( ) throws Exception { String k = " async-decr-non-existent " ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
public Long call ( ) throws Exception { return client . incr ( " mtest " , 1 , 11 ) ; } 
public void testImmediateDelete ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assert client . delete ( " test1 " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " test1 " ) ) ; } 
public void testFlush ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; client . set ( " test2 " , 5 , " test2value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; assertEquals ( " test2value " , client . get ( " test2 " ) ) ; assertTrue ( client . flush ( ) . get ( ) ) ; assertNull ( client . get ( " test1 " ) ) ; assertNull ( client . get ( " test2 " ) ) ; } 
public void testGracefulShutdown ( ) throws Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; Get a new client initClient(); Collection<String> keys = new ArrayList<String>(); for (int i = 0; i < 1000; i++) { keys.add("t" + i); } Map<String, Object> m = client.getBulk(keys); assertEquals(1000, m.size()); for (int i = 0; i < 1000; i++) { assertEquals(i, m.get("t" + i)); 
protected void syncGetTimeoutsInitClient ( ) throws Exception { initClient ( new DefaultConnectionFactory ( ) { @Override 
public void testSyncGetTimeouts ( ) throws Exception { final String key = " timeoutTestKey " ; final String value = " timeoutTestValue " ; int j = 0 ; boolean set = false ; do { set = client . set ( key , 0 , value ) . get ( ) ; j + + ; } while ( ! set & & j < 10 ) ; assert set ; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) { 
protected void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ; 
public void xtestGracefulShutdownTooSlow ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } Get a new client initClient(); } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); } 
public void testStupidlyLargeSet ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); } 
public void testQueueAfterShutdown ( ) throws Exception { client . shutdown ( ) ; try { Object o = client . get ( " k " ) ; 
public void testMultiReqAfterShutdown ( ) throws Exception { client . shutdown ( ) ; try { Map < String , ? > m = client . getBulk ( " k1 " , " k2 " , " k3 " ) ; 
public void testBroadcastAfterShutdown ( ) throws Exception { client . shutdown ( ) ; try { Future < ? > f = client . flush ( ) ; 
public void testABunchOfCancelledOperations ( ) throws Exception { final String k = " bunchOCancel " ; Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( k , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( k ) ) ; } OperationFuture < Boolean > sf = client . set ( k , 5 , " myxval " ) ; GetFuture < Object > gf = client . asyncGet ( k ) ; for ( Future < ? > f : futures ) { f . cancel ( true ) ; } assertTrue ( sf . get ( ) ) ; assert sf . getStatus ( ) . isSuccess ( ) ; assertEquals ( " myxval " , gf . get ( ) ) ; assert gf . getStatus ( ) . isSuccess ( ) ; } 
public void testAppend ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; } 
public void testPrepend ( ) throws Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
public void testAppendNoSuchKey ( ) throws Exception { final String key = " append.missing " ; assertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; } 
public void testPrependNoSuchKey ( ) throws Exception { final String key = " prepend.missing " ; assertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; } 
public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; return new String ( d . getData ( ) ) ; } 
public CachedData encode ( String o ) { return new CachedData ( FLAGS , o . getBytes ( ) , getMaxSize ( ) ) ; } 
public boolean asyncDecode ( CachedData d ) { return false ; } 
public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; ByteBuffer bb = ByteBuffer . wrap ( d . getData ( ) ) ; int keyLength = bb . getInt ( ) ; byte [ ] keyBytes = new byte [ keyLength ] ; bb . get ( keyBytes ) ; String k = new String ( keyBytes ) ; assertEquals ( key , k ) ; int valueLength = bb . getInt ( ) ; byte [ ] valueBytes = new byte [ valueLength ] ; bb . get ( valueBytes ) ; return new String ( valueBytes ) ; } 
public CachedData encode ( String o ) { byte [ ] keyBytes = key . getBytes ( ) ; byte [ ] valueBytes = o . getBytes ( ) ; int length = 4 + keyBytes . length + 4 + valueBytes . length ; byte [ ] bytes = new byte [ length ] ; ByteBuffer bb = ByteBuffer . wrap ( bytes ) ; bb . putInt ( keyBytes . length ) . put ( keyBytes ) ; bb . putInt ( valueBytes . length ) . put ( valueBytes ) ; return new CachedData ( FLAGS , bytes , getMaxSize ( ) ) ; } 
protected void initClient ( ) throws Exception { We're creating artificially constrained queues with the explicit goal of overrunning them to verify the client will still be functional after such conditions occur. initClient(new DefaultConnectionFactory(5, 1024) { @Override 
public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } 
public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ; } 
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; } 
private void runOverflowTest ( byte [ ] b ) throws Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } try { Thread.sleep(50); for (Future<Boolean> f : c) { f.get(1, TimeUnit.SECONDS); } } catch (TimeoutException e) { OK, at least we got one back. } catch (ExecutionException e) { OK, at least we got one back. } Thread.sleep(500); assertTrue("Was not able to set a key after failure.", client.set("kx", 0, "woo").get(10, TimeUnit.SECONDS)); 
public void testOverflowingInputQueue ( ) throws Exception { runOverflowTest ( new byte [ ] { 1 } ) ; } 
public void testOverflowingWriteQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; runOverflowTest ( b ) ; } 
public void testOverflowingReadQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } try { Thread.sleep(50); for (Future<Object> f : c) { assertTrue(Arrays.equals(b, (byte[]) f.get(5, TimeUnit.SECONDS))); } } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); } 
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; } 
public void testMixedSetsAndUpdates ( ) throws Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; Thread . sleep ( 100 ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; assertFalse ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; } System . err . println ( getName ( ) + " complete. " ) ; } 
public void testBackfill ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { TapClient tc = 
public void testTapDump ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { TapClient tc = 
public void testTapBucketDoesNotExist ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { TapClient client = 
private static String resolveIpv6Addr ( ) { String ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; If the ipv4 address was set but the ipv6 address wasn't then set the ipv6 address to use ipv4. if (!IPV4_ADDR.equals("127.0.0.1") && !IPV4_ADDR.equals("localhost") && ipv6.equals("::1")) { return "::ffff:" + IPV4_ADDR; } return ipv6; } 
public static boolean defaultToIPV4 ( ) { if ( ( " ::ffff: " + IPV4_ADDR ) . equals ( IPV6_ADDR ) ) { return true ; } return false ; } 
public static boolean isMemcached ( ) { return TYPE . equals ( TYPE_MEMCACHED ) ; } 
public static boolean isMembase ( ) { return TYPE . equals ( TYPE_MEMBASE ) ; } 
public static boolean isCouchbase ( ) { return TYPE . equals ( TYPE_COUCHBASE ) ; } 
protected void initClient ( ) throws Exception { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override 
public void testTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . addOp ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; try { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; } 
private void tryTimeout ( String name , Runnable r ) { try { r . run ( ) ; 
public void testCasTimeout ( ) { tryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { 
public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; } 
public void testGetsTimeout ( ) { tryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { 
public void run ( ) { client . gets ( " k " ) ; } 
public void testGetTimeout ( ) { tryTimeout ( " get " , new Runnable ( ) { public void run ( ) { 
public void testGetBulkTimeout ( ) { tryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { 
public void run ( ) { client . getBulk ( " k " , " k2 " ) ; } 
public void testIncrTimeout ( ) { tryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { 
public void run ( ) { client . incr ( " k " , 1 ) ; } 
public void testIncrWithDefTimeout ( ) { tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { 
public void run ( ) { client . incr ( " k " , 1 , 5 ) ; } 
public void testOps ( ) throws Exception { MembaseClient mc = null ; try { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
public void testDebugLogging ( ) { assertTrue("Debug logging is not enabled", logger.isDebugEnabled()); logger.debug("debug message"); } 
public void testInfoLogging ( ) { assertTrue ( logger . isInfoEnabled ( ) ) ; logger . info ( " info message " ) ; } 
public void testOtherLogging ( ) { logger . warn ( " warn message " ) ; logger . warn ( " test %s " , " message " ) ; logger . error ( " error message " ) ; logger . error ( " test %s " , " message " ) ; logger . fatal ( " fatal message " ) ; logger . fatal ( " test %s " , " message " ) ; logger . log ( null , " test null " , null ) ; assertEquals ( getClass ( ) . getName ( ) , logger . getName ( ) ) ; } 
public void testLog4j ( ) { Logger l=LoggerFactory.getLogger(getClass()); assertEquals("net.spy.compat.log.Log4JLogger", l.getClass().getName()); } public void testNoExceptionArg() throws Exception { Object[] args = new Object[] { "a", 42, new Exception("test"), "x" }; Throwable t = ((AbstractLogger) logger).getThrowable(args); assertNull(t); }} 
public void testSunLogger ( ) { Logger l = new SunLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " test null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ; 
public void testMyLogger ( ) { Logger l = new DefaultLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " test null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ; try { l = new DefaultLogger ( null ) ; 
public void testLevelStrings ( ) { assertEquals ( " {LogLevel: DEBUG} " , String . valueOf ( Level . DEBUG ) ) ; assertEquals ( " {LogLevel: INFO} " , String . valueOf ( Level . INFO ) ) ; assertEquals ( " {LogLevel: WARN} " , String . valueOf ( Level . WARN ) ) ; assertEquals ( " {LogLevel: ERROR} " , String . valueOf ( Level . ERROR ) ) ; assertEquals ( " {LogLevel: FATAL} " , String . valueOf ( Level . FATAL ) ) ; assertEquals ( " DEBUG " , Level . DEBUG . name ( ) ) ; assertEquals ( " INFO " , Level . INFO . name ( ) ) ; assertEquals ( " WARN " , Level . WARN . name ( ) ) ; assertEquals ( " ERROR " , Level . ERROR . name ( ) ) ; assertEquals ( " FATAL " , Level . FATAL . name ( ) ) ; } 
public void testExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( ) ; assertEquals ( " test " , . getMessage ( ) ) ; } 
public void testNoExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) , " x " } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNull ( ) ; } 
protected void initClient ( ) throws Exception { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( URI . create ( SERVER_URI ) ) ; client = new TestingClient ( uris , " default " , " " ) ; } 
public static void before ( ) throws Exception { Create some design documents List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE; String view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_W_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc._id, 1)}\",\"reduce\":\"_sum\" }}}"; c.asyncHttpPut(docUri, view); docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE; view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_WO_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc._id, 1)}\"}}}"; for (Entry<String, Object> item : ITEMS.entrySet()) { assert c.set(item.getKey(), 0, (String) item.getValue()).get().booleanValue(); } c.asyncHttpPut(docUri, view); c.shutdown(); Thread.sleep(15000); } 
public void beforeTest ( ) throws Exception { initClient ( ) ; } 
public void afterTest ( ) throws Exception { Shut down, start up, flush, and shut down again. Error tests have unpredictable timing issues. client.shutdown(); client = null; } 
public static void after ( ) throws Exception { Delete all design documents I created List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String json = c.asyncHttpGet("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE).get(); String rev = (new JSONObject(json)).getString("_rev"); c.asyncHttpDelete("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE + "?rev=" + rev).get(); json = c.asyncHttpGet("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE).get(); rev = (new JSONObject(json)).getString("_rev"); c.asyncHttpDelete("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE + "?rev=" + rev).get(); assert c.flush().get().booleanValue(); } 
private static String generateDoc ( String type , String small , String large ) { return " { \" type \" : \" " + type + " \" " + " \" small range \" : \" " + small + " \" " + " \" large range \" : \" " + large + " \" } " ; 
public void testReduce ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < RowReduced > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { RowReduced row = itr . next ( ) ; 
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroup ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( true ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroupWithLevel ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( true , 1 ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testReduceWhenNoneExists ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; try { client . asyncQueryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { return ; Pass, no reduce exists. } assert false : ("No view exists and this query still happened"); } 
public void testViewDocsWithErrors ( ) throws Exception { HttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseWithDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseWithDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new NoDocsCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void gotData ( ViewResponseWithDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } 
public void testViewNoDocsWithErrors ( ) throws Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void gotData ( ViewResponseNoDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } 
public void testViewReducedWithErrors ( ) throws Exception { HttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void gotData ( ViewResponseReduced response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( TestCallback ) callback ) . getData ( json ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } callback . complete ( ) ; } 
public void receivedStatus ( OperationStatus status ) { crv . set ( json , status ) ; } 
public void testSingleOperation ( ) { Operation op = buildOp ( 11211 ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " :11211 " , 
public void testNullNode ( ) { Operation op = new TestOperation ( ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " , 
public void testNullOperation ( ) { assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " , 
public void testMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " :11211, " 
private TestOperation buildOp ( int portNum ) { TestOperation op = new TestOperation ( ) ; MockMemcachedNode node = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( TestConfig . IPV4_ADDR , portNum ) ) ; op . setHandlingNode ( node ) ; return op ; } 
public void initialize ( ) { throw new RuntimeException ( " Not implemented. " ) ; } 
public void readFromBuffer ( ByteBuffer data ) throws IOException { throw new RuntimeException ( " Not implemented " ) ; } 
public void testHasNextAndNext ( ) { for ( int i = 0 ; i < 100 ; + + i ) { assertTrue ( iterator . hasNext ( ) ) ; 
public void testRemove ( ) { try { iterator . remove ( ) ; 
public void testAssertions ( ) { try { assert false ; 
public void testDataReadType ( ) throws Exception { SimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; assertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; Make sure lines aren't handled try { op.handleLine("x"); fail("Handled a line in data mode"); } catch (AssertionError e) { ok } op.setBytesToRead(2); op.handleRead(ByteBuffer.wrap("hi".getBytes())); } 
public void testLineReadType ( ) throws Exception { SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; assertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; Make sure lines aren't handled try { op.handleRead(ByteBuffer.allocate(3)); fail("Handled data in line mode"); } catch (AssertionError e) { ok } op.handleLine("x"); } 
public void testLineParser ( ) throws Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . toString ( expected ) + " but got " + Arrays . toString ( op . getCurentBytes ( ) ) , 
public void testPartialLine ( ) throws Exception { String input1 = " this is a " ; String input2 = " test r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " this is a test " , op . getCurrentLine ( ) ) ; } 
public void handleLine ( String line ) { assert getReadType ( ) = = OperationReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationReadType . DATA ) ; 
public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ; 
public void initialize ( ) { setBuffer ( ByteBuffer . allocate ( 0 ) ) ; } 
public void testEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; } 
public void testServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: SERVER_ERROR figures " , String . valueOf ( oe ) ) ; 
public void testClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , String . valueOf ( oe ) ) ; 
public void testGeneral ( ) { General type doesn't have additional info OperationException oe = new OperationException(OperationErrorType.GENERAL, "GENERAL wtf"); assertSame(OperationErrorType.GENERAL, oe.getType()); assertEquals("OperationException: GENERAL", String.valueOf(oe)); } 
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testIntegerDecode ( ) { assertEquals ( 129 , decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
public void testUnsignedIntegerDecode ( ) { assertEquals ( 129 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129L * 256L * 256L * 256L , decodeUnsignedInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ; 
public void testOperationStatusString ( ) { String s = String . valueOf ( OperationImpl . STATUS_OK ) ; assertEquals ( " {OperationStatus success=true: OK} " , s ) ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; 
public void testGetObjectType ( ) { Assert . assertEquals ( " object type " , MemcachedClient . class , new MemcachedClientFactoryBean ( ) . getObjectType ( ) ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ex = new Exposer ( ) ; } 
public void testValidCharacterSet ( ) { ex . setCharset ( " KOI8 " ) ; } 
public void testInvalidCharacterSet ( ) { try { ex . setCharset ( " Dustin's Kick Ass Character Set " ) ; 
public void testCompressNull ( ) { try { ex . compress ( null ) ; 
public void testDecodeStringNull ( ) { assertNull ( ex . decodeString ( null ) ) ; } 
public void testDeserializeNull ( ) { assertNull ( ex . deserialize ( null ) ) ; } 
public void testEncodeStringNull ( ) { try { ex . encodeString ( null ) ; 
public void testSerializeNull ( ) { try { ex . serialize ( null ) ; 
public void testDecompressNull ( ) { assertNull ( ex . decompress ( null ) ) ; } 
public void testUndeserializable ( ) throws Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , 116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; assertNull ( ex . deserialize ( data ) ) ; } 
public void testDeserializable ( ) throws Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; assertEquals ( " hello " , ex . deserialize ( data ) ) ; } 
public void testBadCharsetDecode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . encodeString ( " Woo! " ) ; 
public void testBadCharsetEncode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . decodeString ( " Woo! " . getBytes ( ) ) ; 
public void overrideCharsetSet ( String to ) { charset = to ; } 
public byte [ ] compress ( byte [ ] in ) { return super . compress ( in ) ; } 
public String decodeString ( byte [ ] data ) { return super . decodeString ( data ) ; } 
public byte [ ] decompress ( byte [ ] in ) { return super . decompress ( in ) ; } 
public Object deserialize ( byte [ ] in ) { return super . deserialize ( in ) ; } 
public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; } 
public byte [ ] serialize ( Object o ) { return super . serialize ( o ) ; } 
public void testSomethingBigger ( ) throws Exception { Collection < Date > dates = new ArrayList < Date > ( ) ; for ( int i = 0 ; i < 1024 ; i + + ) { dates . add ( new Date ( ) ) ; } CachedData d = tc . encode ( dates ) ; assertEquals ( dates , tc . decode ( d ) ) ; } 
public void testDate ( ) throws Exception { Date d = new Date ( ) ; CachedData cd = tc . encode ( d ) ; assertEquals ( d , tc . decode ( cd ) ) ; } 
public void testLong ( ) throws Exception { assertEquals ( 923L , tc . decode ( tc . encode ( 923L ) ) ) ; } 
public void testInt ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) ) ; } 
public void testShort ( ) throws Exception { assertEquals ( ( short ) 923 , tc . decode ( tc . encode ( ( short ) 923 ) ) ) ; } 
public void testChar ( ) throws Exception { assertEquals ( 'c' , tc . decode ( tc . encode ( 'c' ) ) ) ; } 
public void testBoolean ( ) throws Exception { assertSame ( Boolean . TRUE , tc . decode ( tc . encode ( true ) ) ) ; assertSame ( Boolean . FALSE , tc . decode ( tc . encode ( false ) ) ) ; } 
public void testByte ( ) throws Exception { assertEquals ( ( byte ) - 127 , tc . decode ( tc . encode ( ( byte ) - 127 ) ) ) ; } 
public void testStringBuilder ( ) throws Exception { StringBuilder sb = new StringBuilder ( " test " ) ; StringBuilder sb2 = ( StringBuilder ) tc . decode ( tc . encode ( sb ) ) ; assertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; } 
public void testStringBuffer ( ) throws Exception { StringBuffer sb = new StringBuffer ( " test " ) ; StringBuffer sb2 = ( StringBuffer ) tc . decode ( tc . encode ( sb ) ) ; assertEquals ( sb . toString ( ) , sb2 . toString ( ) ) ; } 
private void assertFloat ( float f ) { assertEquals ( f , tc . decode ( tc . encode ( f ) ) ) ; } 
public void testFloat ( ) throws Exception { assertFloat ( 0f ) ; assertFloat ( Float . MIN_VALUE ) ; assertFloat ( Float . MAX_VALUE ) ; assertFloat ( 3.14f ) ; assertFloat ( - 3.14f ) ; assertFloat ( Float . NaN ) ; assertFloat ( Float . POSITIVE_INFINITY ) ; assertFloat ( Float . NEGATIVE_INFINITY ) ; } 
private void assertDouble ( double d ) { assertEquals ( d , tc . decode ( tc . encode ( d ) ) ) ; } 
public void testDouble ( ) throws Exception { assertDouble ( 0d ) ; assertDouble ( Double . MIN_VALUE ) ; assertDouble ( Double . MAX_VALUE ) ; assertDouble ( 3.14d ) ; assertDouble ( - 3.14d ) ; assertDouble ( Double . NaN ) ; assertDouble ( Double . POSITIVE_INFINITY ) ; assertDouble ( Double . NEGATIVE_INFINITY ) ; } 
private void assertLong ( long l ) { CachedData encoded = tc . encode ( l ) ; long decoded = ( Long ) tc . decode ( encoded ) ; assertEquals ( l , decoded ) ; } 
public void testLongEncoding ( ) throws Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 L ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; } 
private void assertInt ( int i ) { CachedData encoded = tc . encode ( i ) ; int decoded = ( Integer ) tc . decode ( encoded ) ; assertEquals ( i , decoded ) ; } 
public void testIntEncoding ( ) throws Exception { assertInt ( Integer . MIN_VALUE ) ; assertInt ( 83526 ) ; assertInt ( 1 ) ; assertInt ( 0 ) ; assertInt ( - 1 ) ; assertInt ( - 238526 ) ; assertInt ( Integer . MAX_VALUE ) ; } 
public void testBooleanEncoding ( ) throws Exception { assertTrue ( ( Boolean ) tc . decode ( tc . encode ( true ) ) ) ; assertFalse ( ( Boolean ) tc . decode ( tc . encode ( false ) ) ) ; } 
public void testByteArray ( ) throws Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = tc . encode ( a ) ; assertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; assertTrue ( Arrays . equals ( a , ( byte [ ] ) tc . decode ( cd ) ) ) ; } 
public void testStrings ( ) throws Exception { String s1 = " This is a simple test string. " ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testUTF8String ( ) throws Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; } 
public void testToString ( ) throws Exception { String exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; CachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) , CachedData . MAX_SIZE ) ; assertEquals ( exp , String . valueOf ( cd ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new IntegerTranscoder ( ) ; } 
public void testInt ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923 ) ) . intValue ( ) ) ; } 
public void testBadFlags ( ) throws Exception { CachedData cd = tc . encode ( 9284 ) ; assertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new LongTranscoder ( ) ; } 
public void testLong ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923L ) ) . longValue ( ) ) ; } 
public void testBadFlags ( ) throws Exception { CachedData cd = tc . encode ( 9284L ) ; assertNull ( tc . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; setTranscoder ( tc ) ; tu = new TranscoderUtils ( true ) ; } 
public void testNonserializable ( ) throws Exception { try { tc . encode ( new Object ( ) ) ; 
public void testCompressedStringNotSmaller ( ) throws Exception { String s1 = " This is a test simple string that will not be compressed. " ; Reduce the compression threshold so it'll attempt to compress it. tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); This should *not* be compressed because it is too small assertEquals(0, cd.getFlags()); assertTrue(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); } 
public void testCompressedString ( ) throws Exception { This one will actually compress String s1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); assertEquals(SerializingTranscoder.COMPRESSED, cd.getFlags()); assertFalse(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); } 
public void testObject ( ) throws Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; } 
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; } 
public void testUnencodeable ( ) throws Exception { try { CachedData cd = tc . encode ( new Object ( ) ) ; 
public void testUndecodeable ( ) throws Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; System . out . println ( " got " + tc . decode ( cd ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ts = new TranscodeService ( false ) ; } 
protected void tearDown ( ) throws Exception { ts . shutdown ( ) ; assertTrue ( ts . isShutdown ( ) ) ; super . tearDown ( ) ; } 
public void testNonExecuting ( ) throws Exception { CachedData cd = new CachedData ( 0 , new byte [ 0 ] , 0 ) ; Future < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; } 
public void testExecuting ( ) throws Exception { CachedData cd = new CachedData ( 1 , new byte [ 0 ] , 0 ) ; Future < String > fs = ts . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; } 
public boolean asyncDecode ( CachedData d ) { return d . getFlags ( ) = = 1 ; } 
public String decode ( CachedData d ) { return " Stuff! " ; } 
public CachedData encode ( String o ) { throw new RuntimeException ( " Not invoked. " ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tu = new TranscoderUtils ( true ) ; } 
public void testBooleanOverflow ( ) { try { boolean b = tu . decodeBoolean ( oversizeBytes ) ; 
public void testByteOverflow ( ) { try { byte b = tu . decodeByte ( oversizeBytes ) ; 
public void testIntOverflow ( ) { try { int b = tu . decodeInt ( oversizeBytes ) ; 
public void testLongOverflow ( ) { try { long b = tu . decodeLong ( oversizeBytes ) ; 
public void testPackedLong ( ) { assertEquals ( " [1] " , Arrays . toString ( tu . encodeLong ( 1 ) ) ) ; } 
public void testUnpackedLong ( ) { assertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , Arrays . toString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; setTranscoder ( tc ) ; tu = new TranscoderUtils ( false ) ; } 
public void testCompressedStringNotSmaller ( ) throws Exception { String s1 = " This is a test simple string that will not be compressed. " ; Reduce the compression threshold so it'll attempt to compress it. tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); This should *not* be compressed because it is too small assertEquals(WhalinTranscoder.SPECIAL_STRING, cd.getFlags()); assertTrue(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); } 
public void testCompressedString ( ) throws Exception { This one will actually compress String s1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); assertEquals(WhalinTranscoder.COMPRESSED | WhalinTranscoder.SPECIAL_STRING, cd.getFlags()); assertFalse(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); } 
public void testObject ( ) throws Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; } 
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; } 
public void testUndecodeable ( ) throws Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableSerialized ( ) throws Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
public void testUndecodeableCompressed ( ) throws Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( tc . decode ( cd ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; setTranscoder ( new WhalinV1Transcoder ( ) ) ; } 
public void testByteArray ( ) throws Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = getTranscoder ( ) . encode ( a ) ; byte [ ] decoded = ( byte [ ] ) getTranscoder ( ) . decode ( cd ) ; assertNotNull ( decoded ) ; assertTrue ( Arrays . equals ( a , decoded ) ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; BlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; es = new ThreadPoolExecutor ( 10 , 10 , 5 * 60 , TimeUnit . SECONDS , wq ) ; } 
protected void tearDown ( ) throws Exception { es . shutdownNow ( ) ; super . tearDown ( ) ; } 
public void testSimpleLoading ( ) throws Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( true ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( throwException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; Load the cache and wait for it to finish. cl.loadData(map).get(); es.shutdown(); es.awaitTermination(1, TimeUnit.SECONDS); assertEquals(1, sl.success); assertEquals(1, sl.exceptions); assertEquals(1, sl.failure); } 
public void errorStoring ( String k , Exception e ) { exceptions + + ; } 
public void storeResult ( String k , boolean result ) { if ( result ) { success + + ; 
public void testGetPipeline ( ) throws Exception { BucketMonitorPipelineFactory factory = new BucketMonitorPipelineFactory ( ) ; ChannelPipeline pipeline = factory . getPipeline ( ) ; ChannelHandler decoder = pipeline . get ( " decoder " ) ; ChannelHandler encoder = pipeline . get ( " encoder " ) ; ChannelHandler handler = pipeline . get ( " handler " ) ; assertTrue ( decoder instanceof HttpResponseDecoder ) ; assertTrue ( encoder instanceof HttpRequestEncoder ) ; assertTrue ( handler instanceof BucketUpdateResponseHandler ) ; assertEquals ( handler , pipeline . getLast ( ) ) ; assertEquals ( decoder , pipeline . getFirst ( ) ) ; } 
public void testInstantiate ( ) throws Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( STREAMING_URI ) , BUCKET_NAME , USERNAME , PASSWORD , CONFIG_PARSER ) ; assertEquals ( USERNAME , bucketMonitor . getHttpUser ( ) ) ; assertEquals ( PASSWORD , bucketMonitor . getHttpPass ( ) ) ; } 
public void testObservable ( ) throws Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( STREAMING_URI ) , BUCKET_NAME , USERNAME , PASSWORD , CONFIG_PARSER ) ; BucketObserverMock observer = new BucketObserverMock ( ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . startMonitor ( ) ; assertTrue ( " Update for observer was not called. " , observer . isUpdateCalled ( ) ) ; bucketMonitor . shutdown ( ) ; } 
public void update ( Observable o , Object arg ) { updateCalled = true ; } 
public boolean isUpdateCalled ( ) { return updateCalled ; } 
public void testSetGetRecievedFuture ( ) throws Throwable { ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; replay ( futureMock ) ; BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler ( ) ; PrivateAccessor . setField ( handler , " receivedFuture " , futureMock ) ; PrivateAccessor . invoke ( handler , " setReceivedFuture " , new Class [ ] { ChannelFuture . class } , new Object [ ] { futureMock } ) ; assertEquals ( futureMock , PrivateAccessor . getField ( handler , " receivedFuture " ) ) ; verify ( futureMock ) ; } 
public void testMessageReceived ( ) throws NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( true ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . toString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , REST_USER , REST_PWD ) ; assertNotNull ( configProvider ) ; } 
public void testGetBucketConfiguration ( ) throws Exception { Bucket bucket = configProvider . getBucketConfiguration ( DEFAULT_BUCKET_NAME ) ; assertNotNull ( bucket ) ; } 
public void testSubscribe ( ) throws Exception { configProvider . subscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; } 
public void testUnsubscribe ( ) throws Exception { configProvider . unsubscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; } 
public void testShutdown ( ) throws Exception { configProvider . shutdown ( ) ; } 
public void testGetAnonymousAuthBucket ( ) throws Exception { assertEquals ( " default " , configProvider . getAnonymousAuthBucket ( ) ) ; } 
public void testBuildAuthHeader ( ) throws UnsupportedEncodingException { ConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ; } 
public void testBuildAuthHeaderUTF8 ( ) throws UnsupportedEncodingException { String result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; string inspired by https:github.com/trondn/libcouchbase/issues/3 System.err.println("Authorization header for matt:this@here is " + result); assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); } 
public void testGetPrimary ( ) { } public void testGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; } } 
public void testGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; } 
public void testGetPrimary ( ) { MemcachedNode node1 = createMock ( MemcachedNode . class ) ; MemcachedNode node2 = createMock ( MemcachedNode . class ) ; MemcachedNode node3 = createMock ( MemcachedNode . class ) ; InetSocketAddress address1 = new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ; InetSocketAddress address2 = new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ; InetSocketAddress address3 = new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ; expect ( node1 . getSocketAddress ( ) ) . andReturn ( address1 ) ; expect ( node2 . getSocketAddress ( ) ) . andReturn ( address2 ) ; expect ( node3 . getSocketAddress ( ) ) . andReturn ( address3 ) ; replay ( node1 , node2 , node3 ) ; ConfigFactory factory = new DefaultConfigFactory ( ) ; Config config = factory . create ( CONFIG_IN_ENVELOPE ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( node1 , node2 , node3 ) , config ) ; MemcachedNode resultNode = locator . getPrimary ( " key1 " ) ; assertEquals ( node1 , resultNode ) ; verify ( node1 , node2 , node3 ) ; } 
public void testGetAlternative ( ) { MemcachedNodeMockImpl node1 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node2 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node3 = new MemcachedNodeMockImpl ( ) ; node1 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; node2 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ) ; node3 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ) ; ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( ( MemcachedNode ) node1 , node2 , node3 ) , config ) ; MemcachedNode primary = locator . getPrimary ( " k1 " ) ; MemcachedNode alternative = locator . getAlternative ( " k1 " , Arrays . asList ( primary ) ) ; alternative . getSocketAddress ( ) ; } 
public void testParseBase ( ) throws Exception { Map < String , Pool > base = configParser . parseBase ( BASE_STRING ) ; assertNotNull ( base ) ; assertTrue ( ! base . isEmpty ( ) ) ; Pool pool = base . get ( DEFAULT_POOL_NAME ) ; assertNotNull ( pool ) ; assertEquals ( DEFAULT_POOL_NAME , pool . getName ( ) ) ; assertNotNull ( pool . getUri ( ) ) ; } 
public void testParseBuckets ( ) throws Exception { Map < String , Bucket > buckets = configParser . parseBuckets ( BUCKETS_STRING ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ; 
public void testParseBucketsClustered ( ) throws Exception { StringBuilder sb = new StringBuilder ( ) ; sb . append ( BUCKETS_CLUSTER_STRING ) ; sb . append ( BUCKETS_CLUSTER_STRING2 ) ; Map < String , Bucket > buckets = configParser . parseBuckets ( sb . toString ( ) ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ; 
public void testParseBucket ( ) throws Exception { Bucket bucket = configParser . parseBucket ( BUCKET_STRING ) ; checkBucket ( bucket ) ; } 
public void testLoadPool ( ) throws Exception { Pool pool = new Pool ( null , null , null ) ; configParser . loadPool ( pool , POOL_STRING ) ; assertNotNull ( pool . getBucketsUri ( ) ) ; } 
private void checkBucket ( Bucket bucket ) throws Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getConfig ( ) ) ; } 
public Map < String , Pool > parseBase ( String base ) throws ParseException { Map < String , Pool > result = new HashMap < String , Pool > ( ) ; try { parseBaseCalled = true ; Pool pool = new Pool ( poolName , new URI ( poolUri ) , new URI ( poolStreamingUri ) ) ; result . put ( poolName , pool ) ; } catch ( URISyntaxException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; } 
public Map < String , Bucket > parseBuckets ( String buckets ) throws ParseException { Map < String , Bucket > result = new HashMap < String , Bucket > ( ) ; try { parseBucketsCalled = true ; Bucket bucket = new Bucket ( bucketName , vbuckets , new URI ( bucketStreamingUri ) , nodes ) ; result . put ( bucketName , bucket ) ; } catch ( URISyntaxException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; } 
public Bucket parseBucket ( String sBucket ) throws ParseException { parseBucketCalled = true ; try { parseBucketsCalled = true ; 
public void loadPool ( Pool pool , String sPool ) throws ParseException { try { loadPoolCalled = true ; 
public boolean isParseBaseCalled ( ) { return parseBaseCalled ; } 
public boolean isParseBucketsCalled ( ) { return parseBucketsCalled ; } 
public boolean isParseBucketCalled ( ) { return parseBucketCalled ; } 
public boolean isLoadPoolCalled ( ) { return loadPoolCalled ; } 
public void init ( ) throws Exception { client = new MemcachedClient ( new ConnectionFactoryBuilder ( ) . setProtocol ( Protocol . BINARY ) 
public void shutdown ( ) throws Exception { client . shutdown ( ) ; } 
public void run ( ) { System . out . println ( " Available mechs: " + client . listSaslMechanisms ( ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } client . getVersions ( ) ; } 
public static void main ( String [ ] a ) throws Exception { AuthTest lt = new AuthTest ( " testuser " , " testpass " ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; } 
public void run ( ) { int nullKey = 0 ; Load up a bunch of data. CacheLoader cl = new CacheLoader(client); for (int i = 0; i < N; i++) { String k = "multi." + i; keys.add(k); cl.push(k, value); } Map<String, Object> got = client.getBulk(keys); for (String k : keys) { if (got.containsKey(k)) { assert Arrays.equals(value, (byte[]) got.get(k)) : "Incorrect result at " + k; } else { nullKey++; } } System.out.println("Fetched " + got.size() + "/" + keys.size() + " (" + nullKey + " were null)"); 
public static void main ( String [ ] args ) throws Exception { new ExcessivelyLargeGetTest ( ) . run ( ) ; } 
public void init ( ) throws Exception { client = new MemcachedClient ( new ConnectionFactoryBuilder ( ) . setProtocol ( Protocol . BINARY ) . setOpQueueMaxBlockTime ( 1000 ) . build ( ) , 
public void run ( ) { CacheLoader cl = new CacheLoader ( client ) ; Future < Boolean > f = null ; for ( int i = 0 ; i < count ; i + + ) { f = cl . push ( " k " + i , " some value " ) ; } if ( f ! = null ) { try { 
public static void main ( String [ ] a ) throws Exception { LoaderTest lt = new LoaderTest ( 1000000 ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; } 
public void testCrap ( ) throws Exception { main ( new String [ ] { " 10000 " , " 100 " , " 11211 " , " 100 " } ) ; } 
public static void main ( String [ ] args ) throws Exception { if ( args . length ! = 4 ) { args = new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ; System . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; } int runs = Integer . parseInt ( args [ 0 ] ) ; int start = Integer . parseInt ( args [ 1 ] ) ; String serverlist = " 127.0.0.1: " + args [ 2 ] ; int threads = Integer . parseInt ( args [ 3 ] ) ; MemcachedClient client = new MemcachedClient ( new DefaultConnectionFactory ( 100000 , 32768 ) , AddrUtil . getAddresses ( serverlist ) ) ; WorkerStat [ ] statArray = new WorkerStat [ threads ] ; Thread [ ] threadArray = new Thread [ threads ] ; WorkerStat mainStat = new WorkerStat ( ) ; mainStat . runs = runs * threads ; long begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < threads ; i + + ) { statArray [ i ] = new WorkerStat ( ) ; statArray [ i ] . start = start + i * runs ; statArray [ i ] . runs = runs ; threadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < threads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . setterTime = System . currentTimeMillis ( ) - begin ; begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < threads ; i + + ) { threadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < threads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . getterTime = System . currentTimeMillis ( ) - begin ; client . shutdown ( ) ; WorkerStat totalStat = new WorkerStat ( ) ; System . out . println ( " Thread tstart truns tset time(ms) tget time(ms) " ) ; for ( int i = 0 ; i < threads ; i + + ) { System . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; totalStat . runs = totalStat . runs + statArray [ i ] . runs ; totalStat . setterTime = totalStat . setterTime + statArray [ i ] . setterTime ; totalStat . getterTime = totalStat . getterTime + statArray [ i ] . getterTime ; } System . out . println ( " nAvg " + runs + " " + totalStat . setterTime / threads + " " + totalStat . getterTime / threads ) ; System . out . println ( " nTotal " + totalStat . runs + " " + totalStat . setterTime + " " + totalStat . getterTime ) ; System . out . println ( " tReqPerSecond tset - " + 1000 * totalStat . runs / totalStat . setterTime + " tget - " + 1000 * totalStat . runs / totalStat . getterTime ) ; System . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; System . out . println ( " tReqPerSecond tset - " + 1000 * mainStat . runs / mainStat . setterTime + " tget - " + 1000 * mainStat . runs 
public void run ( ) { String keyBase = " testKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { mc . set ( " " + i + keyBase , 3600 , object ) ; if ( TOTAL . incrementAndGet ( ) > = MAX_QUEUE ) { flush ( ) ; } } long end = System . currentTimeMillis ( ) ; stat . setterTime = end - begin ; } 
private synchronized void flush ( ) { if ( TOTAL . intValue ( ) > = MAX_QUEUE ) { mc . waitForQueues ( 5 , TimeUnit . SECONDS ) ; 
public void run ( ) { String keyBase = " testKey " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { String str = ( String ) mc . get ( " " + i + keyBase ) ; assert str ! = null ; } long end = System . currentTimeMillis ( ) ; stat . getterTime = end - begin ; } 
public static void main ( String [ ] args ) throws Exception { Verify assertions try { assert false; throw new RuntimeException("Assertions not enabled."); } catch (AssertionError e) { OK } MemcachedClient c = new MemcachedClient(AddrUtil.getAddresses("localhost:11200")); boolean success = false; Random r = new Random(); byte[] somebytes = new byte[71849]; r.nextBytes(somebytes); try { for (int i = 0; i < 100000; i++) { c.set("k" + i, 3600, somebytes).get(); } } catch (ExecutionException e) { assert e.getCause() instanceof OperationException; OperationException oe = (OperationException) e.getCause(); assert oe.getType() == OperationErrorType.SERVER; assert oe.getMessage() .equals("SERVER_ERROR out of memory storing object"); success = true; } finally { c.shutdown(); } if (success) { System.out.println(":) Failed as expected."); 
public static void main ( String [ ] args ) throws Exception { MemcachedClient c = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; while ( true ) { for ( int i = 0 ; i < 1000 ; i + + ) { 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { System . out . println ( " *** Established: " + sa + " count= " + reconnectCount ) ; 
public void connectionLost ( SocketAddress sa ) { System . out . println ( " *** Lost connection: " + sa ) ; } 
public boolean isDaemon ( ) { return false ; } 
public void verifySetAndGet ( ) { int iterations = 20 ; for ( int i = 0 ; i < iterations ; i + + ) { mc . set ( " test " + i , 0 , " test " + i ) ; } for ( int i = 0 ; i < iterations ; i + + ) { Object res = mc . get ( " test " + i ) ; 
public void verifySetAndGet2 ( int iterations ) { try { for ( int i = 0 ; i < = iterations ; i + + ) { 
public long hash ( final String k ) { long rv = 0 ; int len = k . length ( ) ; switch ( this ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; } 
public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) md5Digest . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; } 
private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = DefaultHashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . KETAMA_HASH ; } else { throw new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; } 
protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , DefaultHashAlgorithm . NATIVE_HASH ) ; 
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
public void testBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , DefaultHashAlgorithm . FNV1_64_HASH ) ; } 
private void runThisManyNodes ( final int totalNodes ) { final String [ ] stringNodes = generateAddresses ( totalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , DefaultHashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , DefaultHashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; SortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; Verify that EVERY entry in the smaller map has an equivalent mapping in the larger map. boolean failed = false; for (final Long key : smMap.keySet()) { final MemcachedNode largeNode = lgMap.get(key); final MemcachedNode smallNode = smMap.get(key); if (!largeNode.equals(smallNode)) { failed = true; System.out.println("---------------"); System.out.println("Key: " + key); System.out.println("Small: " + smallNode.getSocketAddress()); System.out.println("Large: " + largeNode.getSocketAddress()); } } assertFalse(failed); for (final Map.Entry<Long, MemcachedNode> entry : lgMap.entrySet()) { final Long key = entry.getKey(); final MemcachedNode node = entry.getValue(); if (node.equals(oddManOut)) { final MemcachedNode newNode = smLocator.getNodeForKey(key); if (!smaller.contains(newNode)) { System.out.println("Error - " + key + " -> " + newNode.getSocketAddress()); failed = true; } } } assertFalse(failed); } 
private void assertNativeHash ( String key ) { assertHash ( DefaultHashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; } 
public void testCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testFNV164 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1_64_HASH , me . getKey ( ) , 
public void testFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1A_64_HASH , me . getKey ( ) , 
public void testFNV132 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1_32_HASH , me . getKey ( ) , 
public void testFNV1A32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1A_32_HASH , me . getKey ( ) , 
public void testKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . KETAMA_HASH , me . getKey ( ) , 
public void testCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; assertEquals ( DefaultHashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; } 
protected void setupNodes ( int ) { setupNodes ( DefaultHashAlgorithm . KETAMA_HASH , ) ; } 
public void testFNV1A32 ( ) { HashAlgorithm alg = DefaultHashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; 
public long hash ( final String k ) { long rv = 0 ; int len = k . length ( ) ; switch ( this ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; } 
public static synchronized void registerHashAlgorithm ( String name , HashAlgorithm alg ) { validateName ( name ) ; validateAlgorithm ( alg ) ; REGISTRY . put ( name . toLowerCase ( ) , alg ) ; } 
public static synchronized HashAlgorithm lookupHashAlgorithm ( String name ) { validateName ( name ) ; return REGISTRY . get ( name . toLowerCase ( ) ) ; } 
private static void validateName ( String name ) { if ( name = = null | | " " . equals ( name ) ) { throw new IllegalArgumentException ( " HashAlgorithm name should be " 
private static void validateAlgorithm ( HashAlgorithm alg ) { if ( alg = = null ) { throw new IllegalArgumentException ( " HashAlgorithm instance should be " 
private Config parseEpJSON ( JSONObject jsonObject ) throws JSONException { String algorithm = jsonObject . getString ( " hashAlgorithm " ) ; HashAlgorithm hashAlgorithm = HashAlgorithmRegistry . lookupHashAlgorithm ( algorithm ) ; if ( hashAlgorithm = = null ) { throw new IllegalArgumentException ( " Unhandled hash algorithm type: " + algorithm ) ; } int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { throw new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { throw new ConfigParsingException ( " Number of buckets must be a power of " + " two, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; } 
public void testCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . CRC_HASH , me . getKey ( ) , me . getValue ( ) ) ; 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; 
public ViewFuture asyncQuery ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; } 
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; } 
private ViewResponseReduced parseReducedViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; } 
private String parseField ( String field ) { if ( field ! = null & & field . equals ( " null " ) ) { return null ; 
public Iterator < ViewRow > iterator ( ) { return rows . iterator ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . toString ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . toString ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDocument ( ) + " " ) ; } return s . toString ( ) ; } 
public Set < Entry < String , Object > > entrySet ( ) { Set < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; for ( ViewRow r : rows ) { set . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } return null ; } 
public Set < String > keySet ( ) { Set < String > set = new TreeSet < String > ( ) ; for ( ViewRow r : rows ) { set . add ( r . getId ( ) ) ; } return null ; } 
public Collection < Object > values ( ) { Collection < Object > values = new LinkedList < Object > ( ) ; for ( ViewRow r : rows ) { values . add ( r . getDocument ( ) ) ; } return values ; } 
String getId ( ) ; String getKey ( ) ; String getValue ( ) ; Object getDocument ( ) ; } 
String getKey ( ) ; String getValue ( ) ; Object getDocument ( ) ; } 
public void testReduce ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ; 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) ) ; s . append ( " : " ) ; s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " " ) ; } return s . toString ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " " ) ; } return s . toString ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) ) ; s . append ( " : " ) ; s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " : " ) ; s . append ( r . getDocument ( ) ) ; s . append ( " " ) ; } return s . toString ( ) ; } 
public HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);} 
HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; } 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
public void set ( ViewResponseWithDocs viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { objRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; } 
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new ViewRowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; } 
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; } 
private ViewResponseReduced parseReducedViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; } 
public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void gotData ( ViewResponse response ) { vr = response ; } 
public HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void gotData ( ViewResponse response ) { vr = response ; } 
public HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public ViewResponse query ( View view , Query query ) { try { return asyncQuery ( view , query ) . get ( ) ; 
public ViewResponse queryAndExcludeDocs ( View view , Query query ) { try { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ; 
public ViewResponse queryAndReduce ( View view , Query query ) { try { return asyncQueryAndReduce ( view , query ) . get ( ) ; 
HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);} 
HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);} 
View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);} 
List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);} 
HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; } 
HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; } 
HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; } 
ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; } 
ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; } 
public ViewResponse get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . timeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new ViewRowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; } 
public void set ( ViewResponse viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { objRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; } 
Collection < RowError > getErrors ( ) ; Iterator < ViewRow > iterator ( ) ; Map < String , Object > getMap ( ) ; int size ( ) ; } 
Iterator < ViewRow > iterator ( ) ; Map < String , Object > getMap ( ) ; int size ( ) ; } 
public void testReduce ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponse reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ; 
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroup ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query . setGroup ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroupWithLevel ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query . setGroup ( true , 1 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testViewDocsWithErrors ( ) throws Exception { HttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new NoDocsCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void gotData ( ViewResponse response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } 
public void testViewNoDocsWithErrors ( ) throws Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void testViewReducedWithErrors ( ) throws Exception { HttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewFetcherOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewFetcherOperation . ViewFetcherCallback ( ) { private View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsFetcherOperationImpl ( request , bucketName , designDocumentName , new ViewsFetcherOperation . ViewsFetcherCallback ( ) { private List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewFetcherCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { List < View > views = parseDesignDocumentForViews ( bucketName , designDocName , json ) ; ( ( ViewsFetcherCallback ) callback ) . gotData ( views ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
public HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
protected ViewResponseWithDocs parseResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; } 
protected OperationStatus parseViewForStatus ( String json , int errorcode ) throws ParseException { if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { String error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; if ( base . has ( " reason " ) ) { error + = " Reason: " + base . getString ( " reason " ) ; } return new OperationStatus ( false , error ) ; } else { return new OperationStatus ( true , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ; 
protected ViewResponseNoDocs parseResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; } 
protected ViewResponseReduced parseResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; } 
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponse vr = null ; if ( status . isSuccess ( ) ) { vr = parseResult ( json ) ; } ( ( ViewCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; } 
protected abstract ViewResponse parseResult ( String json ) throws ParseException ; } 
public void testViewDocsWithErrors ( ) throws Exception { HttpOperation op = new DocsOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void testViewNoDocsWithErrors ( ) throws Exception { HttpOperation op = new NoDocsOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }} 
public void testViewReducedWithErrors ( ) throws Exception { HttpOperation op = new ReducedOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } 
public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { if ( query . willReduce ( ) ) { return asyncQueryAndReduce ( view , query ) ; 
private HttpFuture < ViewResponse > asyncQueryAndIncludeDocs ( View view , Query query ) { String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
private HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
private HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; } 
HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);} 
HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);} 
View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);} 
List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);} 
HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; } 
public boolean willReduce ( ) { return ( args . containsKey ( REDUCE ) ) ? ( ( Boolean ) args . get ( REDUCE ) ) . booleanValue ( ) : false ; 
public boolean willIncludeDocs ( ) { return includedocs ; } 
public void testReduce ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( true ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query ) ; ViewResponse reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ; 
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetEndKeyDocID ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroup ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( true ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setGroup ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetGroupWithLevel ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( true ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setGroup ( true , 1 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetInclusiveEnd ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetKey ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetLimit ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRange ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeStart ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetRangeEnd ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetSkip ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStale ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetStartkeyDocID ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testQuerySetUpdateSeq ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; } 
public void testReduceWhenNoneExists ( ) throws Exception { Query query = new Query ( ) ; query . setReduce ( true ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; try { client . asyncQuery ( view , query ) ; } catch ( RuntimeException e ) { return ; Pass, no reduce exists. } assert false : ("No view exists and this query still happened"); } 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public Paginator paginatedQuery ( View view , Query query , int docsPerPage ) { return new Paginator ( this , view , query , 10 ) ; } 
public boolean hasNext ( ) { if ( ! pageItr . hasNext ( ) & & page . size ( ) < docsPerPage ) { return false ; } else if ( ! ( rowsIterated < docsPerPage ) ) { lastRow = pageItr . next ( ) ; query . setStartkeyDocID ( lastRow . getId ( ) ) ; query . setRangeStart ( lastRow . getKey ( ) ) ; getNextPage ( query ) ; } return true ; } 
public ViewRow next ( ) { if ( rowsIterated < = docsPerPage ) { rowsIterated + + ; lastRow = pageItr . next ( ) ; return lastRow ; } return null ; } 
public void remove ( ) { throw new UnsupportedOperationException ( " Remove is unsupported " ) ; } 
public Query copy ( ) { Query query = new Query ( ) ; if ( args . containsKey ( DESCENDING ) ) { query . setDescending ( ( ( Boolean ) args . get ( DESCENDING ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( ENDKEY ) ) { query . setRangeEnd ( ( ( String ) args . get ( ENDKEY ) ) ) ; } if ( args . containsKey ( ENDKEYDOCID ) ) { query . setEndkeyDocID ( ( ( String ) args . get ( ENDKEYDOCID ) ) ) ; } if ( args . containsKey ( GROUP ) ) { query . setGroup ( ( ( Boolean ) args . get ( GROUP ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( GROUPLEVEL ) ) { query . setGroup ( ( ( Boolean ) args . get ( GROUP ) ) . booleanValue ( ) , ( ( Integer ) args . get ( GROUPLEVEL ) ) . intValue ( ) ) ; } if ( args . containsKey ( INCLUSIVEEND ) ) { query . setInclusiveEnd ( ( ( Boolean ) args . get ( INCLUSIVEEND ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( KEY ) ) { query . setEndkeyDocID ( ( ( String ) args . get ( KEY ) ) ) ; } if ( args . containsKey ( LIMIT ) ) { query . setLimit ( ( ( Integer ) args . get ( LIMIT ) ) . intValue ( ) ) ; } if ( args . containsKey ( REDUCE ) ) { query . setReduce ( ( ( Boolean ) args . get ( REDUCE ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( SKIP ) ) { query . setSkip ( ( ( Integer ) args . get ( SKIP ) ) . intValue ( ) ) ; } if ( args . containsKey ( STALE ) ) { query . setStale ( ( ( Stale ) args . get ( STALE ) ) ) ; } if ( args . containsKey ( STARTKEY ) ) { query . setRangeStart ( ( ( String ) args . get ( STARTKEY ) ) ) ; } if ( args . containsKey ( STARTKEYDOCID ) ) { query . setStartkeyDocID ( ( ( String ) args . get ( STARTKEYDOCID ) ) ) ; } if ( args . containsKey ( UPDATESEQ ) ) { query . setUpdateSeq ( ( ( Boolean ) args . get ( UPDATESEQ ) ) . booleanValue ( ) ) ; } setIncludeDocs ( willIncludeDocs ( ) ) ; return query ; } 
public static void before ( ) throws Exception { Create some design documents List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE; String view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_W_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc.type, 1)}\",\"reduce\":\"_sum\" }}}"; c.asyncHttpPut(docUri, view); docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE; view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_WO_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc.type, 1)}\"}}}"; for (Entry<String, Object> item : ITEMS.entrySet()) { assert c.set(item.getKey(), 0, (String) item.getValue()).get().booleanValue(); } c.asyncHttpPut(docUri, view); c.shutdown(); Thread.sleep(15000); } 
private static String generateDoc ( String type , String small , String large ) { return " { \" type \" : \" " + type + " \" " + " , \" small range \" : \" " + small + " \" , " + " \" large range \" : \" " + large + " \" } " ; 
public void testPaginationItemsModPageSizeIsZero ( ) throws Exception { View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; Query query = new Query ( ) ; query . setReduce ( false ) ; Paginator op = client . paginatedQuery ( view , query , 10 ) ; assert client . set ( " key125 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key125 failed " ; assert client . set ( " key126 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key126 failed " ; assert client . set ( " key127 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key127 failed " ; int count = 0 ; while ( op . hasNext ( ) ) { String key = op . next ( ) . getId ( ) ; if ( ! ITEMS . containsKey ( key ) ) { assert false : " Got bad key: " + key + " during pagination " ; } count + + ; } assert count = = ITEMS . size ( ) : " Got " + count + " items, wanted " + ITEMS . size ( ) ; assert client . delete ( " key125 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; assert client . delete ( " key126 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; assert client . delete ( " key127 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; Thread . sleep ( 1000 ) ; } 
public void testPaginationAndDeleteStartKey ( ) throws Exception { View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; Query query = new Query ( ) ; query . setReduce ( false ) ; Paginator op = client . paginatedQuery ( view , query , 10 ) ; int count = 0 ; while ( op . hasNext ( ) ) { op . next ( ) ; if ( count = = 5 ) { assert client . delete ( " key112 " ) . get ( ) . booleanValue ( ) : " Deleteing key key112 failed " ; Thread . sleep ( 1000 ) ; } count + + ; } assert count = = ITEMS . size ( ) - 1 : " Got " + count + " items, wanted " + ( ITEMS . size ( ) - 1 ) ; assert client . set ( " key112 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) 
public String toString ( ) { boolean first = true ; StringBuffer result = new StringBuffer ( ) ; for ( Entry < String , Object > arg : args . entrySet ( ) ) { if ( first ) { result . append ( " ? " ) ; first = false ; } else { result . append ( " & " ) ; } result . append ( getArg ( arg . getKey ( ) , arg . getValue ( ) ) ) ; } return result . toString ( ) ; } 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { top . cancel ( ) ; trv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } treturn rv ; } 
public boolean cancel ( boolean ign ) { tboolean rv = false ; tfor ( Operation op : ops ) { trv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; top . cancel ( ) ; } tfor ( Future < T > v : rvMap . values ( ) ) { tv . cancel ( ign ) ; } tcancelled = true ; tstatus = new OperationStatus ( false , " Cancelled " ) ; treturn rv ; } 
public boolean cancel ( boolean ign ) { tassert op ! = null : " No operation " ; top . cancel ( ) ; } 
tboolean isCancelled ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tboolean hasErrored ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationException getException ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationCallback getCallback ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid cancel ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tOperationState getState ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tByteBuffer getBuffer ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tvoid writing ( ) ; public boolean isTimedOutUnsent ( ) ; } 
tprotected final void transitionState ( OperationState newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; cmd = null; 
public final void writing ( ) { ttransitionState ( OperationState . WRITING ) ; } 
private void redistributeOperations ( Collection < Operation > ops ) { tfor ( Operation op : ops ) { tif ( op . isCancelled ( ) | | op . isTimedOut ( ) ) { 
public final synchronized boolean isCancelled ( ) { treturn cancelled ; } 
public final synchronized void cancel ( ) { tcancelled = true ; twasCancelled ( ) ; tcallback . complete ( ) ; } 
tprotected final synchronized void transitionState ( OperationState newState ) { tgetLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; tstate = newState ; callback.complete(); 
public synchronized void timeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; timedout = true ; callback . complete ( ) ; } 
public synchronized boolean isTimedOut ( ) { return timedout ; } 
public synchronized boolean isTimedOut ( long ttlMillis ) { tlong elapsed = System . nanoTime ( ) ; tlong ttlNanos = ttlMillis * 1000 * 1000 ; tif ( elapsed - creationTime > ttlNanos ) { tassert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; ttimedOutUnsent = true ; ttimedout = true ; tcallback . complete ( ) ; } else { return timedout; } 
protected static String buildAuthHeader ( String username , String password ) throws UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); if (headerResult.endsWith("\r")) { headerResult = headerResult.substring(0, headerResult.length() - 2); } return headerResult; } 
public synchronized void timeOut ( ) { timedout = true ; callback . complete ( ) ; } 
public synchronized boolean isTimedOut ( long ttlMillis ) { tlong elapsed = System . nanoTime ( ) ; tlong ttlNanos = ttlMillis * 1000 * 1000 ; tif ( elapsed - creationTime > ttlNanos ) { ttimedOutUnsent = true ; ttimedout = true ; tcallback . complete ( ) ; } else { return timedout; } 
tprotected byte [ ] serialize ( Object o ) { tif ( o = = null ) { tthrow new NullPointerException ( " Can't serialize null " ) ; } tbyte [ ] rv = null ; tByteArrayOutputStream bos = null ; tObjectOutputStream os = null ; ttry { tbos = new ByteArrayOutputStream ( ) ; tos = new ObjectOutputStream ( bos ) ; tos . writeObject ( o ) ; tos . close ( ) ; tbos . close ( ) ; trv = bos . toByteArray ( ) ; } catch ( IOException e ) { tthrow new IllegalArgumentException ( " Non-serializable object " , e ) ; } finally { tCloseUtil . close ( os ) ; tCloseUtil . close ( bos ) ; } treturn rv ; } 
tprotected Object deserialize ( byte [ ] in ) { tObject rv = null ; tByteArrayInputStream bis = null ; tObjectInputStream is = null ; ttry { tif ( in ! = null ) { tbis = new ByteArrayInputStream ( in ) ; tis = new ObjectInputStream ( bis ) ; trv = is . readObject ( ) ; tis . close ( ) ; tbis . close ( ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , tin = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { tgetLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , tin = = null ? 0 : in . length , e ) ; } finally { tCloseUtil . close ( is ) ; tCloseUtil . close ( bis ) ; } treturn rv ; } 
tprotected byte [ ] decompress ( byte [ ] in ) { tByteArrayOutputStream bos = null ; tif ( in ! = null ) { tByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; tbos = new ByteArrayOutputStream ( ) ; tGZIPInputStream gis = null ; ttry { tgis = new GZIPInputStream ( bis ) ; tbyte [ ] buf = new byte [ 8192 ] ; tint r = - 1 ; twhile ( ( r = gis . read ( buf ) ) > 0 ) { tbos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { tgetLogger ( ) . warn ( " Failed to decompress data " , e ) ; tbos = null ; } finally { tCloseUtil . close ( gis ) ; tCloseUtil . close ( bis ) ; tCloseUtil . close ( bos ) ; } } treturn bos = = null ? null : bos . toByteArray ( ) ; } 
tprotected abstract Collection < ? extends Operation > cloneGet ( tKeyedOperation op ) ; } 
tStoreType getStoreType ( ) ; tbyte [ ] getData ( ) ; } 
tlong getCasValue ( ) ; tbyte [ ] getData ( ) ; } 
tint getFlags ( ) ; tbyte [ ] getData ( ) ; } 
public void addOperation ( CASOperation op ) { tops . add ( op ) ; + keylen + op.getData().length; 
public void initialize ( ) { } 
public void complete ( ) { }} 
public void receivedStatus ( OperationStatus status ) { }} 
public void testCASOperationCloning ( ) { tCASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; tCASOperation op2 = cloneOne ( CASOperation . class , op ) ; tassertKey ( op2 ) ; tassertEquals ( 727582 , op2 . getCasValue ( ) ) ; tassertEquals ( 8174 , op2 . getFlags ( ) ) ; tassertEquals ( 7175 , op2 . getExpiration ( ) ) ; tassertBytes ( op2 . getData ( ) ) ; tassertCallback ( op2 ) ; } 
public String toString ( ) { treturn " Cmd: " + cmd + " Keys: " + StringUtils . join ( keys , " " ) + " Exp: " + exp ; 
public String toString ( ) { treturn " Cmd: " + type + " Key: " + key + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ; 
public String toString ( ) { treturn " Cmd: cas Key: " + key + " Cas Value: " + casValue + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ; 
public String toString ( ) { treturn " Cmd: delete Key: " + key ; } 
public String toString ( ) { treturn " Cmd: flush_all Delay: " + delay ; } 
public String toString ( ) { treturn " Cmd: " + mutator . name ( ) + " Key: " + key + " Amount: " + amount ; } 
public String toString ( ) { treturn super . toString ( ) + " Cas: " + cas + " Data Length: " + data . length ; } 
public String toString ( ) { treturn super . toString ( ) + " Cas: " + cas ; } 
public String toString ( ) { treturn super . toString ( ) + " Delay: " + delay ; } 
public String toString ( ) { treturn super . toString ( ) + " Exp: " + exp ; } 
public String toString ( ) { treturn super . toString ( ) + " Keys: " + StringUtils . join ( getKeys ( ) , " " ) ; } 
public String toString ( ) { treturn super . toString ( ) + " Amount: " + by + " Default: " + def + " Exp: " + exp ; 
public String toString ( ) { treturn " Cmd: " + cmd + " Opaque: " + opaque ; } 
public String toString ( ) { treturn " SASL auth operation " ; } 
tprotected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override tprotected void decodePayload ( byte [ ] pl ) { tgetLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override tprotected void finishedPayload ( byte [ ] pl ) throws IOException { tif ( errorCode = = SASL_CONTINUE ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , tnew String ( pl ) ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { tgetCallback ( ) . receivedStatus ( new OperationStatus ( true , " " ) ) ; ttransitionState ( OperationState . COMPLETE ) ; } else { tsuper . finishedPayload ( pl ) ; } } @Override public String toString ( ) { treturn " SASL base operation " ; } } 
public String toString ( ) { treturn " SASL base operation " ; } 
public String toString ( ) { treturn " SASL mechs operation " ; } 
public String toString ( ) { treturn " SASL steps operation " ; } 
public String toString ( ) { treturn super . toString ( ) + " Key: " + key ; } 
public String toString ( ) { treturn super . toString ( ) + " Cas: " + cas + " Exp: " + exp + " Flags: " + flags + " Data Length: " + data . length ; 
public void readFromBuffer ( ByteBuffer data ) { }} 
public String toString ( ) { treturn " Cmd: tap ack Opcode: " + opcode + " Opaque: " + opaque ; } 
public String toString ( ) { treturn " Cmd: tap dump Flags: backfill,ack " ; } 
public String toString ( ) { treturn " Cmd: tap dump Flags: dump,ack " ; } 
public static String join ( Collection < String > keys , String delimiter ) { tStringBuilder sb = new StringBuilder ( ) ; tfor ( String key : keys ) { tsb . append ( key ) ; tsb . append ( delimiter ) ; } treturn sb . toString ( ) ; } 
public void testConcatentaion ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , null ) ) . toString ( ) ; 
public void testDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testFlush ( ) { ( new FlushOperationImpl ( 0 , null ) ) . toString ( ) ; } 
public void testGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " gat " , 15 , null , " key " ) ) . toString ( ) ; } 
public void testGetl ( ) { ( new GetlOperationImpl ( " key " , 10 , null ) ) . toString ( ) ; } 
public void testGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testGets ( ) { ( new GetsOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , null ) ) . toString ( ) ; } 
public void testOptimizedGet ( ) { ( new OptimizedGetImpl ( new GetOperationImpl ( " key " , null ) ) ) . toString ( ) ; } 
public void testStats ( ) { ( new StatsOperationImpl ( " hash " , null ) ) . toString ( ) ; } 
public void testStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , null ) ) . toString ( ) ; 
public void testVersion ( ) { ( new VersionOperationImpl ( null ) ) . toString ( ) ; } 
public void testConcatenation ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , 0 , null ) ) . toString ( ) ; 
public void testFlush ( ) { ( new FlushOperationImpl ( null ) ) . toString ( ) ; } 
public void testGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " key " , 15 , null ) ) . toString ( ) ; } 
public void testGetl ( ) { ( new GetlOperationImpl ( " key " , 0 , null ) ) . toString ( ) ; } 
public void testMultiGet ( ) { ( new MultiGetOperationImpl ( Collections . singleton ( " key " ) , null ) ) . toString ( ) ; } 
public void testMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , 0 , 15 , null ) ) . toString ( ) ; } 
public void testNoop ( ) { ( new NoopOperationImpl ( null ) ) . toString ( ) ; } 
public void testOptimiedSet ( ) { ( new OptimizedSetImpl ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , 0 , null ) ) ) . toString ( ) ; 
public void testSASLAuth ( ) { ( new SASLAuthOperationImpl ( null , null , null , null , null ) ) . toString ( ) ; } 
public void testSASLMechs ( ) { ( new SASLMechsOperationImpl ( null ) ) . toString ( ) ; } 
public void testSASLStep ( ) { ( new SASLStepOperationImpl ( null , null , null , null , null , null ) ) . toString ( ) ; } 
public void testStats ( ) { ( new StatsOperationImpl ( " dispatcher " , null ) ) . toString ( ) ; } 
public void testStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , 0 , null ) ) . toString ( ) ; 
public void testTapAck ( ) { ( new TapAckOperationImpl ( TapOpcode . MUTATION , 10 , null ) ) . toString ( ) ; } 
public void testTapBackfill ( ) { ( new TapBackfillOperationImpl ( null , 0 , null ) ) . toString ( ) ; } 
public void testTapCustom ( ) { ( new TapCustomOperationImpl ( null , new RequestMessage ( ) , null ) ) . toString ( ) ; } 
public void testTapDump ( ) { ( new TapDumpOperationImpl ( null , null ) ) . toString ( ) ; } 
public void testTouch ( ) { ( new TouchOperationImpl ( " key " , 10 , null ) ) . toString ( ) ; } 
public void testTapVersion ( ) { ( new VersionOperationImpl ( null ) ) . toString ( ) ; } 
public String toString ( ) { treturn " Failure Mode: " + getFailureMode ( ) . name ( ) + " , Hash Algorithm: " + getHashAlg ( ) . name ( ) + " Max Reconnect Delay: " 
public void testDefaultConnectionFactory ( ) { ( new DefaultConnectionFactory ( ) ) . toString ( ) ; ( new DefaultConnectionFactory ( 10 , 1000 ) ) . toString ( ) ; ( new DefaultConnectionFactory ( 100 , 100 , tHashAlgorithm . KETAMA_HASH ) ) . toString ( ) ; 
public void testBinaryConnectionFactory ( ) { ( new BinaryConnectionFactory ( ) ) . toString ( ) ; ( new BinaryConnectionFactory ( 10 , 1000 ) ) . toString ( ) ; ( new BinaryConnectionFactory ( 100 , 1000 , tHashAlgorithm . KETAMA_HASH ) ) . toString ( ) ; 
public void connectionLost ( SocketAddress sa ) { }} 
public String toString ( ) { treturn connFactory . toString ( ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , tIterator < Transcoder < T > > tc_iter ) { tfinal Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; } 
public void receivedStatus ( OperationStatus status ) { trv . setStatus ( status ) ; } 
public void testIPv6Host ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6-localhost " ) ; validLocalhostNames . add ( " 0:0:0:0:0:0:0:1 " ) ; validLocalhostNames . add ( " localhost6.localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; } 
Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; } 
< T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; } 
CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; } 
public void testNumVBuckets ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { assert ( ( MembaseClient ) client ) . getNumVBuckets ( ) = = 1024 ; 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } return rv ; } 
public void connectionLost ( SocketAddress sa ) { Don't care. } @Override public String toString() { return connFactory.toString(); }} 
public String toString ( ) { return connFactory . toString ( ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; } 
public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; } 
public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; This isn't exactly correct, but it's close enough. If we're in a writing state, we *probably* haven't started. return op.getState() == OperationState.WRITE_QUEUED; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); } 
public final synchronized boolean isCancelled ( ) { return cancelled ; } 
public final synchronized void cancel ( ) { cancelled = true ; wasCancelled ( ) ; callback . receivedStatus ( CANCELLED ) ; callback . complete ( ) ; } 
protected final synchronized void transitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; Discard our buffer when we no longer need it. if(state != OperationState.WRITE_QUEUED && state != OperationState.WRITING) { cmd = null; } if (state == OperationState.COMPLETE) { callback.complete(); 
public final void writing ( ) { transitionState ( OperationState . WRITING ) ; } 
protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) ) ) ; transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
public synchronized void timeOut ( ) { timedout = true ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } 
public synchronized boolean isTimedOut ( ) { return timedout ; } 
public synchronized boolean isTimedOut ( long ttlMillis ) { long elapsed = System . nanoTime ( ) ; long ttlNanos = ttlMillis * 1000 * 1000 ; if ( elapsed - creationTime > ttlNanos ) { timedOutUnsent = true ; timedout = true ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } else { timedout would be false, but we cannot allow you to untimeout an operation if (timedout) { throw new IllegalArgumentException("Operation has already timed out;" + " ttl specified would allow it to be valid."); } } return timedout; } 
public String toString ( ) { return " Cmd: cas Key: " + key + " Cas Value: " + casValue + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ; 
tstatic long decodeLong ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 
public void testLongDecode ( ) { tassertEquals ( 4294967296L , tdecodeLong ( new byte [ ] { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 } , 0 ) ) ; tassertEquals ( 1L , tdecodeLong ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } , 0 ) ) ; 
private static byte cmdMap ( ConcatenationType ) { tbyte rv = ( byte ) DUMMY_OPCODE ; tswitch ( ) { tcase append : rv = APPEND ; break ; tcase prepend : rv = PREPEND ; break ; } } 
public void initialize ( ) { tint size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; tfor ( byte [ ] b : bkeys . values ( ) ) { tsize + = b . length ; } } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { finishedPayload(EMPTY_BYTES); 
tprotected void prepareBuffer ( String key , long cas , byte [ ] val , tObject . . . extraHeaders ) { tint extraLen = 0 ; tfor ( Object o : extraHeaders ) { tif ( o instanceof Integer ) { textraLen + = 4 ; } else if ( o instanceof byte [ ] ) { textraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { textraLen + = 8 ; } else { tassert false : " Unhandled extra header type: " + o . getClass ( ) ; } } tfinal byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; tint bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; } 
public void initialize ( ) { } 
private static byte cmdMap ( StoreType ) { tbyte rv = DUMMY_OPCODE ; tswitch ( ) { tcase set : rv = StoreOperationImpl . SETQ ; break ; tcase add : rv = StoreOperationImpl . ADDQ ; break ; tcase replace : rv = StoreOperationImpl . REPLACEQ ; break ; } } 
private static byte cmdMap ( StoreType ) { tbyte rv = DUMMY_OPCODE ; tswitch ( ) { tcase set : rv = SET ; break ; tcase add : rv = ADD ; break ; tcase replace : rv = REPLACE ; break ; } } 
public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { val = new CASValue < T > ( - 1 , null ) ; } rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; } 
public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { val = new CASValue < T > ( - 1 , null ) ; } rv . set ( val , status ) ; } 
public String toString ( ) { return " Cmd: " + cmd + " Keys: " + StringUtils . join ( keys , " " ) + " Exp: " + exp ; 
public Operation tapCustom ( String id , RequestMessage message ) tthrows ConfigurationException , IOException { tfinal TapConnectionProvider conn ; tif ( vBucketAware ) { tconn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { tconn = new TapConnectionProvider ( addrs ) ; } tfinal CountDownLatch latch = new CountDownLatch ( 1 ) ; tfinal Operation op = conn . opFact . tapCustom ( id , message , tnew TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { trqueue . add ( tapMessage ) ; tmessagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { trqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { tlatch . countDown ( ) ; } } ) ; tsynchronized ( omap ) { tomap . put ( op , conn ) ; } tconn . addOp ( op ) ; treturn op ; } 
public static void printMessage ( BaseMessage message , PrintWriter p ) { tint colNum = 0 ; tbyte [ ] mbytes = message . getBytes ( ) . array ( ) ; tp . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; tp . print ( " ---------------------- " ) ; tfor ( int i = 0 ; i < mbytes . length ; i + + ) { tif ( ( i % 4 ) = = 0 ) { tp . printf ( " n%3d| " , colNum ) ; tcolNum + = 4 ; } tint field = mbytes [ i ] ; tif ( field < 0 ) tfield = field + 256 ; tp . printf ( " %5x " , field ) ; } tp . print ( " " ) ; tp . flush ( ) ; } 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) tthrows IOException { tOperation currentOp = qa . getCurrentReadOp ( ) ; getLogger().debug("Read %d bytes", read); 
public void testSimpleGetl ( ) throws Exception { assertNull ( client . get ( " getltest " ) ) ; client . set ( " getltest " , 0 , " value " ) ; ( ( MembaseClient ) client ) . getAndLock ( " getltest " , 3 ) ; Thread . sleep ( 2000 ) ; assert ! client . set ( " getltest " , 1 , " newvalue " ) . get ( ) . booleanValue ( ) : " Key wasn't locked for the right amount of time " ; Thread . sleep ( 2000 ) ; assert client . set ( " getltest " , 1 , " newvalue " ) . get ( ) . booleanValue ( ) : " Key was locked for too long " ; 
tprotected int addKey ( String k ) { tInteger rv = rkeys . get ( k ) ; tif ( rv = = null ) { trv = generateOpaque ( ) ; tkeys . put ( rv , k ) ; tbkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; trkeys . put ( k , rv ) ; tsynchronized ( vbmap ) { tvbmap . put ( k , new Short ( ( short ) 0 ) ) ; } } treturn rv ; } 
public String toString ( ) { tsynchronized ( vbmap ) { treturn super . toString ( ) + " Keys: " + StringUtils . join ( getKeys ( ) , " " ) ; 
public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( String key : keys ) { sb . append ( key ) ; sb . append ( delimiter ) ; } return sb . toString ( ) ; } 
public static boolean isJsonObject ( String s ) { if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | s . equals ( " true " ) | | s . equals ( " false " ) | | s . equals ( " null " ) ) { return true ; } try { new Integer ( s ) ; 
public abstract ByteBuffer getBytes ( ) ; tprotected short decodeShort ( byte [ ] data , int i ) { treturn ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } tprotected int decodeInt ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } tprotected long decodeLong ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } } 
tprotected short decodeShort ( byte [ ] data , int i ) { treturn ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } 
tprotected int decodeInt ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 
tprotected long decodeLong ( byte [ ] data , int i ) { treturn ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 
public void specifyVbuckets ( short [ ] vbucketlist ) { tmessage . setVbucketlist ( vbucketlist ) ; tmessage . setFlags ( TapFlag . LIST_VBUCKETS ) ; } 
public void takeoverVbuckets ( short [ ] vbucketlist ) { tmessage . setVbucketlist ( vbucketlist ) ; tmessage . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; } 
public void testBuildAuthHeaderUTF8 ( ) throws UnsupportedEncodingException { tString result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); } 
private void readPools ( String bucketToFind ) throws ConfigurationException { the intent with this method is to encapsulate all of the walking of URIs and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try { 
protected void setUp ( ) throws Exception { super . setUp ( ) ; tList < URI > baseList = new ArrayList < URI > ( ) ; tbaseList . add ( new URI ( " http:bogus:8091/pools " ) ) ; tbaseList . add ( new URI ( " http:bogustoo:8091/pools " ) ) ; tbaseList . add ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; tbaseList . add ( new URI ( " http:morebogus:8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; } 
private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); } 
public long incr ( String key , long by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , ( long ) by , 0 , - 1 ) ; } 
public long decr ( String key , long by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , ( long ) by , 0 , - 1 ) ; } 
public long incr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; } 
public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , ( long ) by , def , exp ) ; } 
public long decr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; } 
public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , ( long ) by , def , exp ) ; } 
private long mutateWithDefault ( Mutator , String key , long by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; The ascii protocol doesn't support defaults, so I added them manually here. if (rv == -1) { Future<Boolean> f = asyncStore(StoreType.add, key, exp, String.valueOf(def)); try { if (f.get(operationTimeout, TimeUnit.MILLISECONDS)) { rv = def; } else { rv = mutate(t, key, by, 0, exp); assert rv != -1 : "Failed to mutate or init value"; } } catch (InterruptedException e) { throw new RuntimeException("Interrupted waiting for store", e); } catch (ExecutionException e) { throw new RuntimeException("Failed waiting for store", e); } catch (TimeoutException e) { throw new OperationTimeoutException("Timeout waiting to mutate or init" + " value", e); } } return rv; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Long > asyncIncr ( String key , long by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; } 
public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , ( long ) by , 0 , - 1 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , long by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , ( long ) by , 0 , - 1 ) ; } 
public long incr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; } 
public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , ( long ) by , def , 0 ) ; } 
public long decr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; } 
public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , ( long ) by , def , 0 ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Mutator getType ( ) ; int getExpiration ( ) ; } 
long getBy ( ) ; int getExpiration ( ) ; } 
public MutatorOperation mutate ( Mutator m , String key , long by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; } 
public String toString ( ) { return " Cmd: " + mutator . name ( ) + " Key: " + key + " Amount: " + amount ; } 
public MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; } 
public String toString ( ) { return super . toString ( ) + " Amount: " + by + " Default: " + def + " Exp: " + exp ; 
public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();} 
int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; } 
private Config parseJSON ( JSONObject jsonObject ) throws JSONException { the incoming config could be cache or EP object types, JSON envelope picked apart if (!jsonObject.has("vBucketServerMap")) { return parseCacheJSON(jsonObject); } return parseEpJSON(jsonObject); } 
private Config parseEpJSON ( JSONObject jsonObject ) throws JSONException { JSONObject vbMap = jsonObject . getJSONObject ( " vBucketServerMap " ) ; String algorithm = vbMap . getString ( " hashAlgorithm " ) ; HashAlgorithm hashAlgorithm = HashAlgorithmRegistry . lookupHashAlgorithm ( algorithm ) ; if ( hashAlgorithm = = null ) { throw new IllegalArgumentException ( " Unhandled hash algorithm type: " + algorithm ) ; } int replicasCount = vbMap . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { throw new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = vbMap . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { throw new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = vbMap . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { throw new ConfigParsingException ( " Number of buckets must be a power of " + " two, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; List < URL > couchServers = populateCouchServers ( jsonObject . getJSONArray ( " nodes " ) ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets , couchServers ) ; return config ; } 
private List < URL > populateCouchServers ( JSONArray nodes ) throws JSONException { List < URL > nodeNames = new ArrayList < URL > ( ) ; for ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; if ( node . has ( " couchApiBase " ) ) { try { nodeNames . add ( new URL ( node . getString ( " couchApiBase " ) ) ) ; } catch ( MalformedURLException e ) { throw new JSONException ( " Got bad couchApiBase URL from config " ) ; } } } return nodeNames ; } 
public void testAvailableServers ( ) { MembaseClient tracks hostname and ip address of servers need to make sure the available server list is 2 * (num servers) try { Thread.sleep(10); Let the client warm up } catch (InterruptedException e) { fail("Interrupted while client was warming up"); } assert client.getAvailableServers().size() == 2 : "Num servers " + client.getAvailableServers().size(); } 
public void testOverflowingReadQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof Long ) { b = tu . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = tu . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = tu . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = tu . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = tu . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = tu . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = tu . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = this . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = tu . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = tu . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = tu . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = tu . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } 
public void testJsonObject ( ) { String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < SerializingTranscoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , tc . decode ( cd ) ) ; } 
public void testJsonObject ( ) { String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < WhalinTranscoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , tc . decode ( cd ) ) ; } 
public void testJsonObject ( ) { WhalinV1Transcoder transcoder = ( ( WhalinV1Transcoder ) getTranscoder ( ) ) ; String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; transcoder . setCompressionThreshold ( 8 ) ; CachedData cd = transcoder . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < WhalinV1Transcoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , Arrays . copyOfRange ( cd . getData ( ) , 1 , cd . getData ( ) . length ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , transcoder . decode ( cd ) ) ; 
public void testOps ( ) throws Exception { MembaseClient mc = null ; try { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } assert mc . flush ( ) . get ( ) . booleanValue ( ) ; mc . shutdown ( 3 , TimeUnit . SECONDS ) ; } 
public void updateLocator ( List < MemcachedNode > newNodes ) { this . nodes = newNodes . toArray ( new MemcachedNode [ newNodes . size ( ) ] ) ; } 
public void updateLocator ( List < MemcachedNode > nodes ) { setKetamaNodes ( nodes ) ; } 
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = this . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! this . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; } 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read); 
private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op . isCancelled ( ) | | op . isTimedOut ( ) ) { 
public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { addOperation(placeIn, o); 
protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; } 
public void run ( ) { while ( running ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
public void testGetStatsSlabs ( ) throws Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no slabs to check. client.set("slabinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("slabs"); System.out.println("Stats: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); assertTrue(oneStat.containsKey("1:chunk_size")); } 
public void testGetStatsSizes ( ) throws Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no sizes to check. Note the protocol says flushed/expired items may come back in stats sizes and we use flush when testing, so we check that there's at least one. client.set("sizeinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("sizes"); System.out.println("Stats sizes: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String noItemsSmall = oneStat.get("96"); assertTrue(Integer.parseInt(noItemsSmall) >= 1); } 
public void testGetStatsCacheDump ( ) throws Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there won't be anything to dump client.set("dumpinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("cachedump 1 10000"); System.out.println("Stats cachedump: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String val = oneStat.get("dumpinitializer"); assertTrue(val + "doesn't match", val.matches("\\[2 b; \\d+ s\\]")); } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); } 
public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) throws Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , transcoder ) ; T current = null ; If there were a CAS value, check to see if it's compatible. if (casval != null) { T tmp = casval.getValue(); current = tmp; } If we have anything mutate and CAS, else add. if (current != null) { Declaring this impossible since the only way current can be non-null is if casval was set. assert casval != null : "casval was null with a current value"; rv = m.getNewValue(current); There are three possibilities here: 1) It worked and we're done. 2) It collided and we need to reload and try again. 3) It disappeared between our fetch and our cas. We're ignoring #3 because it's *extremely* unlikely and the behavior will be fine in this code -- we'll do another gets and follow it up with either an add or another cas depending on whether it exists the next time. if (client.cas(key, casval.getCas(), initialExp, rv, transcoder) == CASResponse.OK) { done = true; } } else { No value found, try an add. if (initial == null) { done = true; rv = null; } else if (client.add(key, initialExp, initial, transcoder).get()) { done = true; rv = initial; } } } if (!done) { throw new RuntimeException("Couldn't get a CAS in " + max + " attempts"); } return rv; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
public void testSyncGetTimeouts ( ) throws Exception { final String key = " timeoutTestKey " ; final String value = " timeoutTestValue " ; int j = 0 ; boolean set = false ; Do not execute this for CI if (TestConfig.isCITest()) return; do { set = client.set(key, 0, value).get(); j++; } while (!set && j < 10); assert set; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) { 
public void testOverflowingWriteQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) return; r.nextBytes(b); runOverflowTest(b); } 
public void testOverflowingReadQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) return; r.nextBytes(b); client.set("x", 0, b); Collection<Future<Object>> c = new ArrayList<Future<Object>>(); try { for (int i = 0; i < 1000; i++) { c.add(client.asyncGet("x")); } fail("Didn't catch an illegal state exception"); } catch (IllegalStateException e) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); } 
public static boolean isCITest ( ) { return TEST_TYPE . equals ( TYPE_TEST_CI ) ; } 
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
public void testSyncGetTimeouts ( ) throws Exception { final String key = " timeoutTestKey " ; final String value = " timeoutTestValue " ; int j = 0 ; boolean set = false ; Do not execute this for CI if (TestConfig.isCITest()) { return; } do { set = client.set(key, 0, value).get(); j++; } while (!set && j < 10); assert set; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) { 
public void testOverflowingWriteQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) { return; } r.nextBytes(b); runOverflowTest(b); } 
public void testOverflowingReadQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) { return; } r.nextBytes(b); client.set("x", 0, b); Collection<Future<Object>> c = new ArrayList<Future<Object>>(); try { for (int i = 0; i < 1000; i++) { c.add(client.asyncGet("x")); } fail("Didn't catch an illegal state exception"); } catch (IllegalStateException e) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; 
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; } 
protected void tearDown ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ; super . tearDown ( ) ; } 
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; 
public void testDefaults ( ) throws Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; 
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( 
public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }} 
private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; Generate a pseudo-random set of addresses. long now = new Date().getTime(); int first = (int) ((now % 250) + 3); int second = (int) (((now / 250) % 250) + 3); String port = ":" + TestConfig.PORT_NUMBER + " "; int last = (int) ((now % 100) + 3); StringBuffer prefix = new StringBuffer(); prefix.append(first); prefix.append("."); prefix.append(second); prefix.append(".1."); Don't protect the possible range too much, as we are our own client. StringBuffer buf = new StringBuffer(); for (int ix = 0; ix < maxSize - 1; ix++) { buf.append(prefix); buf.append(last + ix); buf.append(port); } results[0] = buf.toString(); buf.append(prefix); buf.append(last + maxSize - 1); buf.append(port); results[1] = buf.toString(); return results; } 
public static void main ( String [ ] args ) throws Exception { Create a client with a queue big enough to hold the 300,000 items we're going to add. MemcachedClient client = new MemcachedClient(new DefaultConnectionFactory(350000, 32768), AddrUtil.getAddresses(TestConfig.IPV4_ADDR + ":" + TestConfig.PORT_NUMBER)); long start = System.currentTimeMillis(); byte[] toStore = new byte[26]; Arrays.fill(toStore, (byte) 'a'); for (int i = 0; i < 300000; i++) { client.set("k" + i, 300, toStore); } long added = System.currentTimeMillis(); System.err.printf("Finished queuing in %sms%n", added - start); client.waitForQueues(Long.MAX_VALUE, TimeUnit.MILLISECONDS); long end = System.currentTimeMillis(); System.err.printf("Completed everything in %sms (%sms to flush)%n", end - start, end - added); Map<String, Object> m = client.getBulk("k1", "k2", "k3", "k4", "k5", "k299999", "k299998", "k299997", "k299996"); assert m.size() == 9 : "Expected 9 results, got " + m; client.shutdown(); } 
private void assertWorking ( ) throws Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " / " + TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER , versions . keySet ( ) . iterator ( ) . next ( ) . toString ( ) ) ; 
public void testVarargConstructor ( ) throws Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , TestConfig . PORT_NUMBER ) ) ; assertWorking ( ) ; } 
public void testArraymodNodeLocatorAccessor ( ) throws Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ; 
public void testKetamaNodeLocatorAccessor ( ) throws Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ; 
protected void setUp ( ) throws Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; } 
public void testSingleOperation ( ) { Operation op = buildOp ( TestConfig . PORT_NUMBER ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " : " 
public void testMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( TestConfig . PORT_NUMBER ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " : " 
Operation addOp ( final String key , final Operation op ) { StringUtils . validateKey ( key ) ; mconn . checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public static void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MemcachedClientIF . MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MemcachedClientIF . MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { throw new IllegalArgumentException ( " Key must contain at least one character. " ) ; } Validate the key for (byte b : keyBytes) { if (b == ' ' || b == '' || b == '\r' || b == 0) { 
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); } 
public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void enqueueOperation ( String key , Operation o ) { StringUtils . validateKey ( key ) ; checkState ( ) ; addOperation ( key , o ) ; } 
protected void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { addOperation(placeIn, o); 
public void testBadOperation ( ) throws Exception { client . mconn . enqueueOperation ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { 
public void complete ( ) { System . err . println ( " Complete. " ) ; } 
public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } 
public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } 
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } 
public void testTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . mconn . enqueueOperation ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; try { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; } 
MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; } 
public abstract ByteBuffer getBytes ( ) ; protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } } 
protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } 
protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 
protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 
public Operation tapCustom ( String id , RequestMessage message ) throws ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; } 
public Operation tapDump ( final String id ) throws IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; } 
protected void addOp ( final Operation op ) { conn . enqueueOperation ( " TStream " , op ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = conn.getName(); conn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { conn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { conn.setName(baseName + " - SHUTTING DOWN (telling client)"); conn.shutdown(); conn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; } 
public String toString ( ) { return " Cmd: tap dump Flags: backfill,ack " ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . DUMP ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; } 
public String toString ( ) { return " Cmd: tap dump Flags: dump,ack " ; } 
public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; } 
public void doDump ( ) { message . setFlags ( TapRequestFlag . DUMP ) ; } 
public void specifyVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . LIST_VBUCKETS ) ; } 
public void supportAck ( ) { message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; } 
public void keysOnly ( ) { message . setFlags ( TapRequestFlag . KEYS_ONLY ) ; } 
public void takeoverVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . TAKEOVER_VBUCKETS ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcIter ) { return asyncGetBulk ( keys . iterator ( ) , tcIter ) ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Transcoder < T > tc ) { return asyncGetBulk ( keyIter , new SingleElementInfiniteIterator < Transcoder < T > > ( tc ) ) ; 
public BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keyIter ) { return asyncGetBulk ( keyIter , transcoder ) ; } 
public < T > Map < String , T > getBulk ( Iterator < String > keyIter , Transcoder < T > tc ) { try { return asyncGetBulk ( keyIter , tc ) . get ( operationTimeout , 
public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) { return getBulk ( keys . iterator ( ) , tc ) ; } 
CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
public UnlockOperation unlock ( String key , long casId , OperationCallback cb ) { return new UnlockOperationImpl ( key , casId , cb ) ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Unlock of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , UNLOCKED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , CMD , key , cas ) ; b . flip ( ) ; setBuffer ( b ) ; } 
public String toString ( ) { return " Cmd: " + CMD + " Key: " + key + " Cas Value: " + cas ; } 
public String toString ( ) { return super . toString ( ) + " Cas: " + cas ; } 
public boolean hasMoreMessages ( ) { if ( ! rqueue . isEmpty ( ) ) { return true ; } else { synchronized ( omap ) { Iterator < TapStream > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { TapStream ts = itr . next ( ) ; if ( ts . isCompleted ( ) | | ts . isCancelled ( ) | | ts . hasErrored ( ) ) { omap . get ( ts ) . shutdown ( ) ; omap . remove ( ts ) ; } } if ( omap . size ( ) > 0 ) { return true ; } } } return false ; } 
public TapStream tapCustom ( final String id , final RequestMessage message ) throws ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; } 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } 
public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } 
public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } 
public TapStream tapDump ( final String id ) throws IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; } 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } 
private void tapAck ( TapConnectionProvider conn , MemcachedNode node , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . tapAck ( opcode , opaque , cb ) ; conn . addTapAckOp ( node , op ) ; } 
public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < TapStream , TapConnectionProvider > me : omap . entrySet ( ) ) { 
public void addTapAckOp ( MemcachedNode node , final Operation op ) { conn . addOperation ( node , op ) ; } 
public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , conn . getLocator ( ) . getAll ( ) ) ; } 
void gotData ( ResponseMessage message ) ; void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; } 
void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; } 
public void cancel ( ) { for ( TapOperation op : ops ) { op . cancel ( ) ; 
public boolean isCancelled ( ) { for ( TapOperation op : ops ) { if ( ! op . isCancelled ( ) ) { return false ; } } return true ; } 
public boolean hasErrored ( ) { for ( TapOperation op : ops ) { if ( ! op . hasErrored ( ) ) { return false ; } } return true ; } 
public void addOp ( TapOperation op ) { ops . add ( op ) ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; } 
public void initialize ( ) { message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; } 
public String toString ( ) { return " Cmd: tap custom " ; } 
public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . DUMP ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . toString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; } 
public abstract ByteBuffer getBytes ( ) ; protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } protected int decodeIntHostOrder ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) | ( data [ i + 1 ] & 0xff ) < < 8 | ( data [ i + 2 ] & 0xff ) < < 16 | ( data [ i + 3 ] & 0xff ) < < 24 ; } protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } } 
protected int decodeIntHostOrder ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) | ( data [ i + 1 ] & 0xff ) < < 8 
public void tearDown ( ) { } @Test public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; } } 
public void testGetEnginePrivate ( ) { long expResult = 0 L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetFlags ( ) { List < TapResponseFlag > result = instance . getFlags ( ) ; short expResultVal = 0 ; for ( TapResponseFlag flag : expectedFlags ) { expResultVal = ( short ) ( expResultVal + flag . getFlags ( ) ) ; } short resultVal = 0 ; for ( TapResponseFlag flag : result ) { resultVal = ( short ) ( resultVal + ( int ) flag . getFlags ( ) ) ; } assertEquals ( expResultVal , resultVal ) ; } 
public void testGetTTL ( ) { int expResult = 0 ; int result = instance . getTTL ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetReserved1 ( ) { int expResult = 0 ; int result = instance . getReserved1 ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetReserved2 ( ) { int expResult = 0 ; int result = instance . getReserved2 ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetReserved3 ( ) { int expResult = 0 ; int result = instance . getReserved3 ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetVBucketState ( ) { int expResult = 0 ; int result = instance . getVBucketState ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetItemFlags ( ) { int expResult = ( int ) 0x0200 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetItemExpiry ( ) { long expResult = 0 L ; long result = instance . getItemExpiry ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetKey ( ) { String expResult = " a " ; String result = instance . getKey ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetValue ( ) { ByteBuffer bb = ByteBuffer . allocate ( 8 ) ; bb . put ( 7 , ( byte ) 42 ) ; byte [ ] expResult = bb . array ( ) ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; } 
public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; } 
public String toString ( ) { return String . format ( " Key: %s, Flags: %d, TTL: %d, Size: %d nValue: %s " , getKey ( ) , getItemFlags ( ) , getTTL ( ) , getValue ( ) . length , deserialize ( ) ) ; 
private Object deserialize ( ) { SerializingTranscoder tc = new SerializingTranscoder ( ) ; CachedData d = new CachedData ( this . getItemFlags ( ) , this . getValue ( ) , CachedData . MAX_SIZE ) ; Object rv = null ; rv = tc . decode ( d ) ; return rv ; } 
public void tearDown ( ) { } @Test public void testToString ( ) { assertNotNull ( instance . toString ( ) ) ; } } 
public void testToString ( ) { assertNotNull ( instance . toString ( ) ) ; } 
public void addOperation ( CASOperation op ) { ops . add ( op ) ; Count the bytes required by this operation. Iterator<String> is = op.getKeys().iterator(); String k = is.next(); int keylen = KeyUtil.getKeyBytes(k).length; byteCount += MIN_RECV_PACKET + StoreOperationImpl.EXTRA_LEN + keylen + op.getData().length; 
public void initialize ( ) { Now create a buffer. ByteBuffer bb = ByteBuffer.allocate(byteCount); for (CASOperation so : ops) { Iterator<String> is = so.getKeys().iterator(); String k = is.next(); byte[] keyBytes = KeyUtil.getKeyBytes(k); assert !is.hasNext(); int myOpaque = generateOpaque(); callbacks.put(myOpaque, so.getCallback()); byte[] data = so.getData(); Custom header bb.put(REQ_MAGIC); bb.put(cmdMap(so.getStoreType())); bb.putShort((short) keyBytes.length); bb.put((byte) StoreOperationImpl.EXTRA_LEN); extralen bb.put((byte) 0); data type bb.putShort(((VBucketAware) so).getVBucket(k)); vbucket bb.putInt(keyBytes.length + data.length + StoreOperationImpl.EXTRA_LEN); bb.putInt(myOpaque); bb.putLong(so.getCasValue()); cas Extras bb.putInt(so.getFlags()); bb.putInt(so.getExpiration()); the actual key bb.put(keyBytes); And the value bb.put(data); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); } 
private static byte cmdMap ( StoreType ) { byte rv ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; default : rv = DUMMY_OPCODE ; } Check fall-through. assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; return rv; } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( responseOpaque = = terminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; super . finishedPayload ( pl ) ; } resetInput ( ) ; } 
protected void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , qa , 
public void tearDown ( ) { } @Test public void testToString ( ) { assertNotNull ( instance . toString ( ) ) ; } } 
public void testGetItemFlags ( ) { int expResult = ( int ) 0x0300 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; } 
public void readFromBuffer ( ByteBuffer b ) throws IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == DUMMY_OPCODE || responseCmd == cmd : "Unexpected response command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = (short) decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES); 
protected void finishedPayload ( byte [ ] pl ) throws IOException { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; ErrorCode ec = ErrorCode . getErrorCode ( errorCode ) ; if ( status = = null ) { handleError ( OperationErrorType . SERVER , new String ( pl ) ) ; 
static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put(cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); } 
public String toString ( ) { return " Cmd: " + cmd + " Opaque: " + opaque ; } 
public Boolean get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( true , " OK " , ErrorCode . SUCCESS ) ; return super . get ( duration , units ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " , ErrorCode . CANCELLED ) ; return rv ; } 
protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) , ErrorCode . EXCEPTION , exception ) ) ; transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
public String toString ( ) { return " Cmd: " + type + " Key: " + key + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ; 
public String toString ( ) { return " Cmd: delete Key: " + key ; } 
public String toString ( ) { return " Cmd: flush_all Delay: " + delay ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( true , line , ErrorCode . SUCCESS ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , line , ErrorCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public String toString ( ) { return " Cmd: version " ; } 
protected void decodePayload ( byte [ ] pl ) { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , String . valueOf ( decodeLong ( pl , 0 ) ) , ec ) ) ; 
protected OperationStatus getStatusForErrorCode ( short errCode , byte [ ] errPl ) throws IOException { ErrorCode ec = ErrorCode . getErrorCode ( errCode ) ; switch ( ec ) { case SUCCESS : 
protected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) throws IOException { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; if ( ec = = ErrorCode . ERR_AUTH_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , ec ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( ec = = ErrorCode . SUCCESS ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , " " , ec ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String toString ( ) { return " SASL base operation " ; } } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; if ( ec = = ErrorCode . ERR_AUTH_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , 
public String toString ( ) { return " SASL base operation " ; } 
protected void decodePayload ( byte [ ] pl ) { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , ec ) ) ; } 
public String toString ( ) { return " SASL mechs operation " ; } 
public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " , ErrorCode . SUCCESS ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback(); 
public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; } 
public boolean cancel ( ) { assert op ! = null : " No operation " ; op . cancel ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } assert op.getState() == OperationState.COMPLETE; return objRef.get(); } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } if (op != null) { assert op.getState() == OperationState.COMPLETE; } return objRef.get(); } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( keyLen > 0 ) { final byte [ ] keyBytes = new byte [ keyLen ] ; final byte [ ] data = new byte [ pl . length - keyLen ] ; System . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; System . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotStat ( new String ( keyBytes , " UTF-8 " ) , new String ( data , " UTF-8 " ) ) ; } else { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; getCallback ( ) . receivedStatus ( status ) ; transitionState ( OperationState . COMPLETE ) ; } resetInput ( ) ; } 
public void testGetEnginePrivate ( ) { long expResult = 4L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetItemFlags ( ) { int expResult = ( int ) 0x0000 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; } 
public void testGetValue ( ) { byte [ ] expResult = new byte [ 0 ] ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; } 
public void testRevID ( ) { byte [ ] result = instance . getRevID ( ) ; assertEquals ( 'a' , result [ 0 ] ) ; assertEquals ( 'b' , result [ 1 ] ) ; assertEquals ( 'c' , result [ 2 ] ) ; assertEquals ( 'd' , result [ 3 ] ) ; } 
public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( 'a' , result [ result . length - 1 ] ) ; } 
public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! keys . isEmpty ( ) ) { Iterator < String > itr = keys . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . toString ( ) ; } 
public void setup ( ) { Empty } public void teardown() { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key1"); keys.add("key1"); assert StringUtils.join(keys, ",").compareTo("key1,key2,key3") == 0; }} 
public void teardown ( ) { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key1"); keys.add("key1"); assert StringUtils.join(keys, ",").compareTo("key1,key2,key3") == 0; }} 
public void testJoin ( ) { Collection < String > keys = new LinkedList < String > ( ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; assert StringUtils . join ( keys , " , " ) . compareTo ( " key1,key2,key3 " ) = = 0 ; } 
public void setup ( ) { Empty } public void teardown() { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key2"); keys.add("key3"); assertEquals("key1,key2,key3", StringUtils.join(keys, ",")); }} 
public void teardown ( ) { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key2"); keys.add("key3"); assertEquals("key1,key2,key3", StringUtils.join(keys, ",")); }} 
public void testJoin ( ) { Collection < String > keys = new LinkedList < String > ( ) ; keys . add ( " key1 " ) ; keys . add ( " key2 " ) ; keys . add ( " key3 " ) ; assertEquals ( " key1,key2,key3 " , StringUtils . join ( keys , " , " ) ) ; } 
public void setvBucketCheckpoints ( Map < Short , Long > vbchkpnts ) { int oldSize = ( vBucketCheckpoints . size ( ) ) * 10 ; int newSize = ( vbchkpnts . size ( ) ) * 10 ; totalbody + = newSize - oldSize ; vBucketCheckpoints = vbchkpnts ; } 
public String toString ( ) { return " Failure Mode: " + getFailureMode ( ) . name ( ) + " , Hash Algorithm: " + ( ( DefaultHashAlgorithm ) getHashAlg ( ) ) . name ( ) + " Max Reconnect Delay: " 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); } 
public void testDefaults ( ) throws Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; 
public void readFromBuffer ( ByteBuffer b ) throws IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == DUMMY_OPCODE || responseCmd == cmd : "Unexpected response command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES); 
protected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , " " ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String toString ( ) { return " SASL base operation " ; } } 
public void gotData ( String key , long cas ) { rv . setCas ( cas ) ; } 
StoreType getStoreType ( ) ; void gotData ( String key , long cas ) ; } } 
int getFlags ( ) ; void gotData ( String key , long cas ) ; } } 
int getExpiration ( ) ; void gotData ( String key , long cas ) ; } } 
byte [ ] getData ( ) ; void gotData ( String key , long cas ) ; } } 
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; } 
public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; } 
public CASOperation cas ( StoreType type , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( type , key , flags , exp , data , casId , cb ) ; } 
private static byte cmdMap ( StoreType ) { byte rv ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : rv = DUMMY_OPCODE ; } Check fall-through. assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; return rv; } 
protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( StoreOperation . Callback ) getCallback ( ) ) . gotData ( key , responseCas ) ; } 
public String toString ( ) { return super . toString ( ) + " Cas: " + cas + " Exp: " + exp + " Flags: " + flags + " Data Length: " + data . length ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; storeCallback = new StoreOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; } 
public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; } 
public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } 
public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } 
protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } 
public void testSetReturnsCAS ( ) throws Exception { OperationFuture < Boolean > setOp = client . set ( " testSetReturnsCAS " , 0 , " testSetReturnsCAS " ) ; setOp . get ( ) ; assertTrue ( setOp . getCas ( ) > 0 ) ; } 
public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , true ) ; } 
public CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , true ) ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; } 
void gotData ( String key , long cas , ObserveResponse or ) ; } } 
public ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback cb ) { throw new UnsupportedOperationException ( " Observe is not supported " + " for ASCII protocol " ) ; 
public ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback cb ) { return new ObserveOperationImpl ( key , casId , index , cb ) ; } 
public void initialize ( ) { prepareBuffer ( " " , 0x0 , EMPTY_BYTES , ( short ) index , ( short ) key . length ( ) , key . getBytes ( ) ) ; 
protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . values ( ) [ keystate ] ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
static int decodeByte ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) ; } 
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put(cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else if (o instanceof Short) { bb.putShort((Short) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); } 
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public static ObserveResponse valueOf ( byte b ) { switch ( b ) { case ( byte ) 0x00 : 
protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . valueOf ( keystate ) ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) { return asyncCAS ( key , casId , 0 , value , tc ) ; } 
public OperationFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , transcoder ) ; } 
public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) { CASResponse casr = null ; try { OperationFuture < CASResponse > casOp = asyncCAS ( key , 
public void testAsyncCASResponse ( ) throws InterruptedException , ExecutionException { String key = " testAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; CASResponse innerCasRes = casRes . get ( ) ; try { casRes . getCas ( ) ; 
public void testAsyncCASResponse ( ) { String key = " testAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; try { CASResponse innerCasRes = casRes . get ( ) ; assertNotNull ( " OperationFuture is missing cas value. " , casRes . getCas ( ) ) ; } catch ( InterruptedException ex ) { fail ( " Interrupted while getting CASResponse " ) ; } catch ( ExecutionException ex ) { fail ( " Execution problem while getting CASResponse " ) ; } assertNotNull ( casRes . getCas ( ) ) ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; } 
public void testAsyncCASResponse ( ) throws InterruptedException , ExecutionException { String key = " testAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; try { casRes . getCas ( ) ; 
public void testAsyncCASResponse ( ) { String key = " testAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; try { casRes . get ( ) ; assertNotNull ( " OperationFuture is missing cas value. " , casRes . getCas ( ) ) ; } catch ( InterruptedException ex ) { fail ( " Interrupted while getting CASResponse " ) ; } catch ( ExecutionException ex ) { fail ( " Execution problem while getting CASResponse " ) ; } assertNotNull ( casRes . getCas ( ) ) ; } 
void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } } 
protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . valueOf ( keystate ) ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , getHandlingNode ( ) , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void gotData ( long cas ) { rv . setCas ( cas ) ; } 
public DeleteOperation delete ( String key , DeleteOperation . Callback cb ) { return new DeleteOperationImpl ( key , cb ) ; } 
public DeleteOperation delete ( String key , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; } 
protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( DeleteOperation . Callback ) getCallback ( ) ) . gotData ( responseCas ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; storeCallback = new StoreOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; deleteCallback = new DeleteOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; } 
public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , deleteCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertDeleteCallback ( op2 ) ; } 
protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } 
public String toString ( ) { return " Cmd: " + Arrays . toString ( msg ) ; } 
public StatsOperation keyStats ( String key , Callback cb ) { throw new UnsupportedOperationException ( " Key stats are not supported " + " for ASCII protocol " ) ; 
public StatsOperation keyStats ( String key , StatsOperation . Callback cb ) { return new KeyStatsOperationImpl ( key , cb ) ; } 
public void initialize ( ) { String keyval = " key " + key + " " + getVBucket ( key ) ; prepareBuffer ( keyval , 0 , EMPTY_BYTES ) ; } 
public final boolean isActive ( ) { return reconnectAttempt . get ( ) = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ; 
public final void reconnecting ( ) { reconnectAttempt . incrementAndGet ( ) ; continuousTimeout . set ( 0 ) ; } 
public final void connected ( ) { reconnectAttempt . set ( 0 ) ; continuousTimeout . set ( 0 ) ; } 
public void testSimpleLoading ( ) throws Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( true ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( throwException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; Load the cache and wait for it to finish. cl.loadData(map).get(); es.shutdown(); es.awaitTermination(1, TimeUnit.SECONDS); assertEquals(1, sl.success.get()); assertEquals(1, sl.exceptions.get()); assertEquals(1, sl.failure.get()); } 
public void errorStoring ( String k , Exception e ) { exceptions . incrementAndGet ( ) ; } 
public void storeResult ( String k , boolean result ) { if ( result ) { success . incrementAndGet ( ) ; 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public void enqueueOperation ( String key , Operation o ) { StringUtils . validateKey ( key , opFact instanceof BinaryOperationFactory ) ; checkState ( ) ; addOperation ( key , o ) ; } 
public static void validateKey ( String key , boolean binary ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MemcachedClientIF . MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MemcachedClientIF . MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { throw new IllegalArgumentException ( " Key must contain at least one character. " ) ; } if ( ! binary ) { Validate the key 
public void testKeyWithSpaces ( ) throws Exception { String key = " key with spaces " ; client . set ( key , 0 , " " ) ; assertNotNull ( " Couldn't get the key with spaces in it. " , client . get ( key ) ) ; } 
public void testKeyWithNewline ( ) throws Exception { String key = " Key " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; } 
public void testKeyWithReturn ( ) throws Exception { String key = " Key r " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; } 
public void testKeyWithASCIINull ( ) throws Exception { String key = " Key 0 " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; } 
public void testGetBulkKeyWSpaces ( ) throws Exception { String key = " Key key2 " ; client . set ( key , 0 , " " ) ; Map < String , Object > bulkReturn = client . getBulk ( key ) ; assertTrue ( bulkReturn . size ( ) > = 1 ) ; } 
public void testKeyWithSpaces ( ) throws Exception { try { client . get ( " key with spaces " ) ; 
public void testKeyLongerThan250 ( ) throws Exception { try { StringBuilder longKey = new StringBuilder ( ) ; 
public void testKeyWithNewline ( ) throws Exception { try { Object val = client . get ( " Key " ) ; 
public void testKeyWithReturn ( ) throws Exception { try { Object val = client . get ( " Key r " ) ; 
public void testKeyWithASCIINull ( ) throws Exception { try { Object val = client . get ( " Key 0 " ) ; 
public void testGetBulkKeyWSpaces ( ) throws Exception { try { Object val = client . getBulk ( " Key key2 " ) ; 
public synchronized boolean isTimedOut ( long ttlMillis ) { long elapsed = System . nanoTime ( ) ; long ttlNanos = ttlMillis * 1000 * 1000 ; if ( elapsed - creationTime > ttlNanos ) { timedOutUnsent = true ; timedout = true ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } else timedout would be false, but we cannot allow you to untimeout an operation. This can happen when the latch timeout is shorter than the default operation timeout. return timedout; } 
private void connected ( MemcachedNode node ) { assert node . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = node . getReconnectCount ( ) ; node . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( node . getSocketAddress ( ) , rt ) ; 
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } 
public void updateLocator ( List < MemcachedNode > nodes ) { allNodes = nodes ; setKetamaNodes ( nodes ) ; } 
public void testAllAfterUpdate ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; } ArrayList < MemcachedNode > toUpdate = new ArrayList < MemcachedNode > ( ) ; Mock mock = mock ( MemcachedNode . class ) ; mock . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 ) ) ) ; toUpdate . add ( ( MemcachedNode ) mock . proxy ( ) ) ; locator . updateLocator ( toUpdate ) ; Collection < MemcachedNode > afterUpdate = locator . getAll ( ) ; assertEquals ( 1 , afterUpdate . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertFalse ( afterUpdate . contains ( nodes [ i ] ) ) ; } assertTrue ( afterUpdate . contains ( ( MemcachedNode ) mock . proxy ( ) ) ) ; } 
public void testBelongsToCluster ( ) throws Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; OperationFactory opfactory = new BinaryOperationFactory ( ) ; MemcachedNode node = new MockMemcachedNode ( new InetSocketAddress ( TestConfig . IPV4_ADDR , TestConfig . PORT_NUMBER ) ) ; MemcachedNode node2 = new MockMemcachedNode ( new InetSocketAddress ( " invalidIpAddr " , TestConfig . PORT_NUMBER ) ) ; List < InetSocketAddress > nodes = new ArrayList < InetSocketAddress > ( ) ; nodes . add ( ( InetSocketAddress ) node . getSocketAddress ( ) ) ; MemcachedConnection conn = new MemcachedConnection ( 100 , factory , nodes , observers , FailureMode . Retry , opfactory ) ; assertTrue ( conn . belongsToCluster ( node ) ) ; assertFalse ( conn . belongsToCluster ( node2 ) ) ; } 
public void testAllAfterUpdate ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; } ArrayList < MemcachedNode > toUpdate = new ArrayList < MemcachedNode > ( ) ; Mock mock = mock ( MemcachedNode . class ) ; mock . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 ) ) ) ; toUpdate . add ( ( MemcachedNode ) mock . proxy ( ) ) ; locator . updateLocator ( toUpdate ) ; Collection < MemcachedNode > afterUpdate = locator . getAll ( ) ; assertEquals ( 1 , afterUpdate . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertFalse ( afterUpdate . contains ( nodes [ i ] ) ) ; } assertTrue ( afterUpdate . contains ( ( MemcachedNode ) mock . proxy ( ) ) ) ; } 
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new CancellationException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); } 
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = this . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! this . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } selector.wakeup(); qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; } 
public void run ( ) { while ( running ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } catch ( ConcurrentModificationException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; } 
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } 
public void complete ( ) { latch . countDown ( ) ; } 
public void trace ( Object message , Throwable exception ) { log ( Level . TRACE , message , exception ) ; } 
public void trace ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { trace ( String . format ( message , args ) , getThrowable ( args ) ) ; 
public void trace ( Object message ) { trace ( message , null ) ; } 
public boolean isTraceEnabled ( ) { return ( false ) ; } 
public boolean isTraceEnabled ( ) { return ( l4jLogger . isTraceEnabled ( ) ) ; } 
public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case TRACE : pLevel = org . apache . log4j . Level . TRACE ; break ; case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : I don't know what this is, so consider it fatal pLevel = org.apache.log4j.Level.FATAL; l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, "Unhandled " + "log level: " + level + " for the following message", null); } l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, message, e); } 
boolean isTraceEnabled ( ) ; void fatal ( String message , Object . . . args ) ; } 
void log ( Level level , Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void log ( Level level , Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void trace ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; } 
void trace ( Object message ) ; void fatal ( String message , Object . . . args ) ; } 
void trace ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; } 
public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ; } 
public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( ) ; } 
public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ; } 
public void log ( Level level , Object message , Throwable e ) { if ( level = = null ) { level = Level . FATAL ; } switch ( level ) { case TRACE : 
public boolean isTraceEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINEST ) ) ; } 
public OperationFuture < Boolean > append ( String key , Object val ) { return append ( 0 , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > append ( String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . append , 0 , key , val , tc ) ; } 
public OperationFuture < Boolean > prepend ( String key , Object val ) { return prepend ( 0 , key , val , transcoder ) ; } 
public < T > OperationFuture < Boolean > prepend ( String key , T val , Transcoder < T > tc ) { return asyncCat ( ConcatenationType . prepend , 0 , key , val , tc ) ; } 
public void testAppendWithoutCAS ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; } 
public void testPrependWithoutCAS ( ) throws Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Touch completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void initialize ( ) { ByteBuffer b = null ; b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + String . valueOf ( exp ) . length ( ) + OVERHEAD ) ; b . put ( ( " touch " + key + " " + exp + " r " ) . getBytes ( ) ) ; b . flip ( ) ; setBuffer ( b ) ; } 
public String toString ( ) { return " Cmd: touch key: " + key + " exp: " + exp ; } 
public String toString ( ) { return super . toString ( ) + " Exp: " + exp ; } 
public void testTouch ( ) throws Exception { assertNull ( client . get ( " touchtest " ) ) ; assertNull ( client . get ( " nonexistent " ) ) ; assertTrue ( client . set ( " touchtest " , 5 , " touchtest " ) . get ( ) ) ; assertTrue ( client . touch ( " touchtest " , 2 ) . get ( ) ) ; assertFalse ( client . touch ( " nonexistent " , 2 ) . get ( ) ) ; } 
public void testConcatentaion ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , null ) ) . toString ( ) ; 
public void testDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testFlush ( ) { ( new FlushOperationImpl ( 0 , null ) ) . toString ( ) ; } 
public void testGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " gat " , 15 , null , " key " ) ) . toString ( ) ; } 
public void testTouch ( ) { ( new TouchOperationImpl ( " key " , 2 , null ) ) . toString ( ) ; } 
public void testGetl ( ) { ( new GetlOperationImpl ( " key " , 10 , null ) ) . toString ( ) ; } 
public void testGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testGets ( ) { ( new GetsOperationImpl ( " key " , null ) ) . toString ( ) ; } 
public void testMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , null ) ) . toString ( ) ; } 
public void testOptimizedGet ( ) { ( new OptimizedGetImpl ( new GetOperationImpl ( " key " , null ) ) ) . toString ( ) ; } 
public void testStats ( ) { ( new StatsOperationImpl ( " hash " , null ) ) . toString ( ) ; } 
public void testStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , null ) ) . toString ( ) ; 
public void testVersion ( ) { ( new VersionOperationImpl ( null ) ) . toString ( ) ; } 
public OperationFuture < Boolean > delete ( String key ) { return delete ( key , ( long ) 0 ) ; } 
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op = null ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
< T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; } 
public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback cb ) { throw new UnsupportedOperationException ( " Delete with CAS is not supported " + " for ASCII protocol " ) ; 
public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , cas , operationCallback ) ; } 
public void testDeleteWithCAS ( ) throws Exception { final String key = " delete.with.cas " ; final long wrongCAS = 1234 ; OperationFuture < Boolean > setFuture = client . set ( key , 0 , " test " ) ; assertTrue ( setFuture . get ( ) ) ; assertFalse ( client . delete ( key , wrongCAS ) . get ( ) ) ; assertTrue ( client . delete ( key , setFuture . getCas ( ) ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; } 
public void gotData ( String key , int flags , byte [ ] data ) { ( ( ReplicaGetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; } 
void gotData ( String key , int flags , byte [ ] data ) ; } int getReplicaIndex ( ) ; } 
public ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) { throw new UnsupportedOperationException ( " Replica get is not supported " + " for ASCII protocol " ) ; 
public ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) { return new ReplicaGetOperationImpl ( key , index , callback ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; ReplicaGetOperation . Callback gcb = ( ReplicaGetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
private String buildTimeoutMessage ( long timeWaited , TimeUnit unit ) { StringBuilder message = new StringBuilder ( ) ; message . append ( MessageFormat . format ( " waited {0} ms. " , unit . convert ( timeWaited , TimeUnit . MILLISECONDS ) ) ) ; message . append ( " Node status: " ) . append ( mconn . connectionsStatus ( ) ) ; return message . toString ( ) ; } 
Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void addOp ( Operation op ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
int getSelectionOps ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean isActive ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
boolean isAuthenticated ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
long lastReadDelta ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
void completedRead ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; } 
public boolean isAuthenticated ( ) { throw new UnsupportedOperationException ( ) ; } 
public long lastReadDelta ( ) { throw new UnsupportedOperationException ( ) ; } 
public void completedRead ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isAuthenticated ( ) { return ( 0 = = authLatch . getCount ( ) ) ; } 
public long lastReadDelta ( ) { return System . currentTimeMillis ( ) - lastReadTimestamp ; } 
public void completedRead ( ) { lastReadTimestamp = System . currentTimeMillis ( ) ; } 
public void testConnectionsStatus ( ) throws Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; MemcachedConnection mcc = new MemcachedConnection ( 10240 , factory , addresses , observers , FailureMode . Retry , new BinaryOperationFactory ( ) ) ; assertNotNull ( mcc . connectionsStatus ( ) ) ; } 
private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { listMechsLatch . await ( 10 , TimeUnit . SECONDS ) ; } catch ( InterruptedException ex ) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); } 
public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; 
public void complete ( ) { listMechsLatch . countDown ( ) ; } 
private Operation buildOperation ( OperationStatus st , OperationCallback cb , final String [ ] supportedMechs ) { if ( st = = null ) { return opFact . saslAuth ( supportedMechs , 
public CASResponse cas ( String key , long casId , int exp , Object value ) { return cas ( key , casId , exp , value , transcoder ) ; } 
public void testCAS ( ) throws Exception { final String key = " castestkey " ; First, make sure it doesn't work for a non-existing value. assertSame("Expected error CASing with no existing value.", CASResponse.NOT_FOUND, client.cas(key, 0x7fffffffffL, "bad value")); OK, stick a value in here. assertTrue(client.add(key, 5, "original value").get()); CASValue<?> getsVal = client.gets(key); assertEquals("original value", getsVal.getValue()); Now try it with an existing value, but wrong CAS id assertSame("Expected error CASing with invalid id", CASResponse.EXISTS, client.cas(key, getsVal.getCas() + 1, "broken value")); Validate the original value is still in tact. assertEquals("original value", getsVal.getValue()); OK, now do a valid update assertSame("Expected successful CAS with correct id (" + getsVal.getCas() + ")", CASResponse.OK, client.cas(key, getsVal.getCas(), "new value")); assertEquals("new value", client.get(key)); Test a CAS replay assertSame("Expected unsuccessful CAS with replayed id", CASResponse.EXISTS, client.cas(key, getsVal.getCas(), "crap value")); assertEquals("new value", client.get(key)); final String key2 = "castestkey2"; assertTrue(client.add(key2, 0, "value").get()); CASValue<Object> casValue = client.gets(key2); assertEquals(CASResponse.OK, client.cas(key2, casValue.getCas(), 3, "new val")); Verify the doc is not there anymore Thread.sleep(5000); assertNull(client.get(key2)); } 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MetricCollector getMetricCollector ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; } 
NodeLocator createLocator ( List < MemcachedNode > nodes ) ; MetricCollector getMetricCollector ( ) ; } 
OperationFactory getOperationFactory ( ) ; MetricCollector getMetricCollector ( ) ; } 
long getOperationTimeout ( ) ; MetricCollector getMetricCollector ( ) ; } 
boolean isDaemon ( ) ; MetricCollector getMetricCollector ( ) ; } 
boolean useNagleAlgorithm ( ) ; MetricCollector getMetricCollector ( ) ; } 
Collection < ConnectionObserver > getInitialObservers ( ) ; MetricCollector getMetricCollector ( ) ; } 
FailureMode getFailureMode ( ) ; MetricCollector getMetricCollector ( ) ; } 
Transcoder < Object > getDefaultTranscoder ( ) ; MetricCollector getMetricCollector ( ) ; } 
boolean shouldOptimize ( ) ; MetricCollector getMetricCollector ( ) ; } 
int getReadBufSize ( ) ; MetricCollector getMetricCollector ( ) ; } 
HashAlgorithm getHashAlg ( ) ; MetricCollector getMetricCollector ( ) ; } 
long getMaxReconnectDelay ( ) ; MetricCollector getMetricCollector ( ) ; } 
AuthDescriptor getAuthDescriptor ( ) ; MetricCollector getMetricCollector ( ) ; } 
int getTimeoutExceptionThreshold ( ) ; MetricCollector getMetricCollector ( ) ; } 
MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; } 
public MetricType enableMetrics ( ) { return metricType = = null ? super . enableMetrics ( ) : metricType ; } 
public MetricType enableMetrics ( ) { String metricType = System . getProperty ( " net.spy.metrics.type " ) ; return metricType = = null ? DEFAULT_METRIC_TYPE : MetricType . valueOf ( metricType . toUpperCase ( ) ) ; 
protected void registerMetrics ( ) { if ( metricType . equals ( MetricType . DEBUG ) | | metricType . equals ( MetricType . PERFORMANCE ) ) { metrics . addHistogram ( OVERALL_AVG_BYTES_READ_METRIC ) ; 
private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); metrics.updateHistogram(OVERALL_AVG_BYTES_READ_METRIC, read); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read); 
public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; } 
public void decrementCounter ( String name ) { decrementCounter ( name , 1 ) ; } 
public void incrementCounter ( String name ) { incrementCounter ( name , 1 ) ; } 
private void initReporter ( ) { String reporterType = System . getProperty ( " net.spy.metrics.reporter.type " , DEFAULT_REPORTER_TYPE ) ; String reporterInterval = System . getProperty ( " net.spy.metrics.reporter.interval " , DEFAULT_REPORTER_INTERVAL ) ; String reporterDir = System . getProperty ( " net.spy.metrics.reporter.outdir " , DEFAULT_REPORTER_OUTDIR ) ; if ( reporterType . equals ( " console " ) ) { final ConsoleReporter reporter = ConsoleReporter . forRegistry ( registry ) 
public void addCounter ( String name ) { if ( ! counters . containsKey ( name ) ) { counters . put ( name , registry . counter ( name ) ) ; 
public void removeCounter ( String name ) { if ( ! counters . containsKey ( name ) ) { registry . remove ( name ) ; 
public void incrementCounter ( String name , int amount ) { if ( counters . containsKey ( name ) ) { counters . get ( name ) . inc ( amount ) ; 
public void decrementCounter ( String name , int amount ) { if ( counters . containsKey ( name ) ) { counters . get ( name ) . dec ( amount ) ; 
public void addMeter ( String name ) { if ( ! meters . containsKey ( name ) ) { meters . put ( name , registry . meter ( name ) ) ; 
public void removeMeter ( String name ) { if ( meters . containsKey ( name ) ) { meters . remove ( name ) ; 
public void markMeter ( String name ) { if ( meters . containsKey ( name ) ) { meters . get ( name ) . mark ( ) ; 
public void addHistogram ( String name ) { if ( ! histograms . containsKey ( name ) ) { histograms . put ( name , registry . histogram ( name ) ) ; 
public void removeHistogram ( String name ) { if ( histograms . containsKey ( name ) ) { histograms . remove ( name ) ; 
public void updateHistogram ( String name , int amount ) { if ( histograms . containsKey ( name ) ) { histograms . get ( name ) . update ( amount ) ; 
void addCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void removeCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void incrementCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void incrementCounter ( String name , int amount ) ; void updateHistogram ( String name , int amount ) ; } 
void decrementCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void decrementCounter ( String name , int amount ) ; void updateHistogram ( String name , int amount ) ; } 
void addMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void removeMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void markMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void addHistogram ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
void removeHistogram ( String name ) ; void updateHistogram ( String name , int amount ) ; } 
public void incrementCounter ( String name , int amount ) { return ; } 
public void decrementCounter ( String name , int amount ) { return ; } 
public void removeHistogram ( String name ) { return ; } 
public void updateHistogram ( String name , int amount ) { return ; } 
boolean isCancelled ( ) ; long getWriteCompleteTimestamp ( ) ; } 
boolean hasErrored ( ) ; long getWriteCompleteTimestamp ( ) ; } 
OperationException getException ( ) ; long getWriteCompleteTimestamp ( ) ; } 
OperationCallback getCallback ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void cancel ( ) ; long getWriteCompleteTimestamp ( ) ; } 
OperationState getState ( ) ; long getWriteCompleteTimestamp ( ) ; } 
ByteBuffer getBuffer ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void writing ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void writeComplete ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void initialize ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void readFromBuffer ( ByteBuffer data ) throws IOException ; long getWriteCompleteTimestamp ( ) ; } 
void handleRead ( ByteBuffer data ) ; long getWriteCompleteTimestamp ( ) ; } 
MemcachedNode getHandlingNode ( ) ; long getWriteCompleteTimestamp ( ) ; } 
void setHandlingNode ( MemcachedNode to ) ; long getWriteCompleteTimestamp ( ) ; } 
void timeOut ( ) ; long getWriteCompleteTimestamp ( ) ; } 
boolean isTimedOut ( ) ; long getWriteCompleteTimestamp ( ) ; } 
boolean isTimedOut ( long ttlMillis ) ; long getWriteCompleteTimestamp ( ) ; } 
boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; } 
public final void writeComplete ( ) { writeCompleteTimestamp = System . nanoTime ( ) ; transitionState ( OperationState . READING ) ; } 
public void isDisabledByDefault ( ) throws Exception { System . clearProperty ( " net.spy.metrics.enable " ) ; System . clearProperty ( " net.spy.metrics.type " ) ; ConnectionFactory cf = new DefaultConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; cf = new BinaryConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; } 
public void canBeEnabledManually ( ) throws Exception { ConnectionFactory cf = new ConnectionFactoryBuilder ( ) . setEnableMetrics ( MetricType . PERFORMANCE ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; System . setProperty ( " net.spy.metrics.enable " , " true " ) ; System . setProperty ( " net.spy.metrics.type " , " performance " ) ; cf = new ConnectionFactoryBuilder ( ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; } 
public void doStuff ( ) throws Exception { DummyMetricCollector collector = new DummyMetricCollector ( ) ; ConnectionFactory cf = new ConnectionFactoryBuilder ( ) . setEnableMetrics ( MetricType . DEBUG ) . setMetricCollector ( collector ) . build ( ) ; MemcachedClient client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . set ( " metrics:test " , 0 , " value " ) . get ( ) ) ; assertNotNull ( client . get ( " metrics:test " ) ) ; HashMap < String , Integer > metrics = collector . getMetrics ( ) ; assertTrue ( metrics . get ( " [MEM] Average Bytes written to OS per write " ) > 0 ) ; assertEquals ( 2 , ( long ) metrics . get ( " [MEM] Response Rate: Success " ) ) ; client . shutdown ( ) ; } 
public void addCounter ( String name ) { metrics . put ( name , 0 ) ; } 
public void removeCounter ( String name ) { metrics . remove ( name ) ; } 
public void incrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; } 
public void incrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; } 
public void decrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) - 1 ) ; } 
public void decrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) - amount ) ; } 
public void addMeter ( String name ) { metrics . put ( name , 0 ) ; } 
public void removeMeter ( String name ) { metrics . remove ( name ) ; } 
public void markMeter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; } 
public void addHistogram ( String name ) { metrics . put ( name , 0 ) ; } 
public void removeHistogram ( String name ) { metrics . remove ( name ) ; } 
public void updateHistogram ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; } 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MetricCollector getMetricCollector ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; } 
ExecutorService getListenerExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch, executorService); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op = null ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout , executorService ) { 
protected ExecutorService executor ( ) { return service ; } 
protected Future < T > addToListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( isDone ( ) ) { notifyListener ( executor ( ) , this , listener ) ; return this ; } synchronized ( this ) { if ( ! isDone ( ) ) { listeners . add ( listener ) ; return this ; } } notifyListener ( executor ( ) , this , listener ) ; return this ; } 
protected void notifyListener ( final ExecutorService executor , final Future < ? > future , final GenericCompletionListener listener ) { executor . submit ( new Runnable ( ) { @Override 
public void run ( ) { Thread . currentThread ( ) . setName ( " FutureNotifyListener " ) ; try { listener . onComplete ( future ) ; 
protected void notifyListeners ( ) { notifyListeners ( this ) ; } 
protected void notifyListeners ( final Future < ? > future ) { for ( GenericCompletionListener < ? extends Future < ? super T > > listener : listeners ) { 
protected Future < T > removeFromListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( isDone ( ) ) { return this ; } synchronized ( this ) { if ( ! isDone ( ) ) { listeners . remove ( listener ) ; } } return this ; } 
boolean isTimeout ( ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; } 
V getSome ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; } 
OperationStatus getStatus ( ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; } 
Future < V > addListener ( BulkGetCompletionListener listener ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; } 
Future < V > removeListener ( BulkGetCompletionListener listener ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " ) ; notifyListeners ( ) ; return rv ; } 
public Future < Map < String , T > > addListener ( BulkGetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
public Future < Map < String , T > > removeListener ( BulkGetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
public boolean cancel ( boolean ign ) { boolean result = rv . cancel ( ign ) ; notifyListeners ( ) ; return result ; } 
public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; notifyListeners ( ) ; } 
public GetFuture < T > addListener ( GetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
public GetFuture < T > removeListener ( GetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
Future < T > addListener ( L listener ) ; Future < T > removeListener ( L listener ) ; } 
public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; } 
public boolean cancel ( ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; } 
public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; notifyListeners ( ) ; } 
public OperationFuture < T > addListener ( OperationCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
public OperationFuture < T > removeListener ( OperationCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; } 
public void testSetWithCallback ( ) throws Exception { OperationFuture < Boolean > setOp = client . set ( " setWithCallback " , 0 , " content " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; setOp . addListener ( new OperationCompletionListener ( ) { @Override public void onComplete ( OperationFuture < ? > f ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( OperationFuture < ? > f ) throws Exception { latch . countDown ( ) ; } 
public void testGetWithCallback ( ) throws Exception { client . set ( " getWithCallback " , 0 , " content " ) . get ( ) ; GetFuture < Object > getOp = client . asyncGet ( " getWithCallback " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; getOp . addListener ( new GetCompletionListener ( ) { @Override public void onComplete ( GetFuture < ? > f ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( GetFuture < ? > f ) throws Exception { latch . countDown ( ) ; } 
public void testGetBulkWithCallback ( ) throws Exception { client . set ( " getBulkWithCallback1 " , 0 , " content " ) . get ( ) ; BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( " getBulkWithCallback1 " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( BulkGetFuture < ? > f ) throws Exception { latch . countDown ( ) ; } 
public boolean cancel ( boolean bln ) { cancelled = true ; notifyListeners ( ) ; return true ; } 
public T get ( ) throws InterruptedException , ExecutionException { try { return get ( 1 , TimeUnit . SECONDS ) ; 
public T get ( long l , TimeUnit tu ) throws InterruptedException , ExecutionException , TimeoutException { return content ; } 
public void set ( T c ) { notifyListeners ( ) ; content = c ; } 
public DummyListenableFuture < T > addListener ( GenericCompletionListener listener ) { super . addToListeners ( listener ) ; return this ; } 
public DummyListenableFuture < T > removeListener ( GenericCompletionListener listener ) { super . removeFromListeners ( listener ) ; return this ; } 
public void verifyOnComplete ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; } } ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( Future future ) throws Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; } 
public void verifyOnCompleteWhenAlreadyDone ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( true , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } 
public void verifyOnCompleteWhenCancelled ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; } } ) ; future . cancel ( true ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( Future future ) throws Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; } 
public void verifyRemoval ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GenericCompletionListener listener = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; future . addListener ( listener ) ; future . removeListener ( listener ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , latch . getCount ( ) ) ; } 
public void verifyMultipleListeners ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; final GenericCompletionListener listener1 = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; final GenericCompletionListener listener2 = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; future . addListener ( listener1 ) ; future . addListener ( listener2 ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } 
public OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , Object value ) { return asyncCAS ( key , casId , exp , value , transcoder ) ; } 
public void testAsyncCASWithExpiration ( ) throws Exception { final String key = " casWithExpiration " ; final String value = " value " ; OperationFuture < Boolean > future = client . set ( key , 0 , value ) ; assertTrue ( future . get ( ) ) ; OperationFuture < CASResponse > casFuture = client . asyncCAS ( key , future . getCas ( ) , 2 , value ) ; assertEquals ( CASResponse . OK , casFuture . get ( ) ) ; Thread . sleep ( 2500 ) ; assertNull ( client . get ( key ) ) ; } 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MetricCollector getMetricCollector ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; } 
ExecutorService getListenerExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; } 
boolean isDefaultExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; } 
public boolean isDefaultExecutorService ( ) { return executorService = = null ; } 
public boolean isDefaultExecutorService ( ) { return true ; } 
public void testOverridingExecutorService ( ) { ConnectionFactory factory = b . build ( ) ; assertTrue ( factory . isDefaultExecutorService ( ) ) ; ExecutorService service = Executors . newFixedThreadPool ( 1 ) ; b . setListenerExecutorService ( service ) ; factory = b . build ( ) ; assertFalse ( factory . isDefaultExecutorService ( ) ) ; assertEquals ( service . hashCode ( ) , factory . getListenerExecutorService ( ) . hashCode ( ) ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; if (connFactory.isDefaultExecutorService()) { try { executorService.shutdown(); } catch (Exception ex) { getLogger().warn("Failed shutting down the ExecutorService: ", ex); } } try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , 
void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getExpiration ( ) ; } 
public void testGetAndTouchOperationCloning ( ) { GetAndTouchOperation . Callback callback = ( GetAndTouchOperation . Callback ) mock ( GetAndTouchOperation . Callback . class ) . proxy ( ) ; GetAndTouchOperation op = ofact . getAndTouch ( TEST_KEY , 0 , callback ) ; GetAndTouchOperation op2 = cloneOne ( GetAndTouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; } 
private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { listMechsLatch . await ( ) ; } catch ( InterruptedException ex ) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); } 
public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; } 
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } 
public void testNotGrowingCallstack ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( 1 ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus status ) { } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } 
public void receivedStatus ( OperationStatus status ) { } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; } } 
public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; } } 
protected void registerMetrics ( ) { if ( metricType . equals ( MetricType . DEBUG ) | | metricType . equals ( MetricType . PERFORMANCE ) ) { 
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = this . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! this . connectionFactory . useNagleAlgorithm ( ) ) ; try { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; } 
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { getLogger ( ) . debug ( " No selectors ready, interrupted: " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . debug ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; if ( sk . readyOps ( ) ! = 0 ) { getLogger ( ) . debug ( " %s has a ready op, handling IO " , sk ) ; handleIO ( sk ) ; } else { lostConnection ( ( MemcachedNode ) sk . attachment ( ) ) ; } } assert emptySelects < EXCESSIVE_EMPTY : " Too many empty selects " ; } } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } redistributeOperations ( retryOps ) ; retryOps . clear ( ) ; handleShutdownQueue ( ) ; } 
private void handleShutdownQueue ( ) throws IOException { for ( MemcachedNode qa : nodesToShutdown ) { if ( ! addedQueue . contains ( qa ) ) { 
private void checkPotentiallyTimedOutConnection ( ) { boolean stillCheckingTimeouts = true ; while ( stillCheckingTimeouts ) { try { 
public boolean addObserver ( final ConnectionObserver obs ) { return connObservers . add ( obs ) ; } 
public boolean removeObserver ( final ConnectionObserver obs ) { return connObservers . remove ( obs ) ; } 
private void connected ( final MemcachedNode node ) { assert node . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = node . getReconnectCount ( ) ; node . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( node . getSocketAddress ( ) , rt ) ; 
private void lostConnection ( final MemcachedNode node ) { queueReconnect ( node ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionLost ( node . getSocketAddress ( ) ) ; 
private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; try { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { if ( sk . isValid ( ) & & sk . isReadable ( ) ) { handleReads ( node ) ; } if ( sk . isValid ( ) & & sk . isWritable ( ) ) { handleWrites ( node ) ; } } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; } 
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } 
private void handleWrites ( final MemcachedNode node ) throws IOException { node . fillWriteBuffer ( shouldOptimize ) ; boolean canWriteMore = node . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = node . writeSome ( ) ; 
private void handleReads ( final MemcachedNode node ) throws IOException { Operation currentOp = node . getCurrentReadOp ( ) ; if ( currentOp instanceof TapAckOperationImpl ) { node . removeCurrentReadOp ( ) ; return ; } ByteBuffer rbuf = node . getRbuf ( ) ; final SocketChannel channel = node . getChannel ( ) ; int read = channel . read ( rbuf ) ; metrics . updateHistogram ( OVERALL_AVG_BYTES_READ_METRIC , read ) ; if ( read < 0 ) { currentOp = handleReadsWhenChannelEndOfStream ( currentOp , node , rbuf ) ; } while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ; 
private Operation handleReadsWhenChannelEndOfStream ( final Operation currentOp , final MemcachedNode node , final ByteBuffer rbuf ) throws IOException { if ( currentOp instanceof TapOperation ) { currentOp . getCallback ( ) . complete ( ) ; 
private void cancelOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { op . cancel ( ) ; 
private void redistributeOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op . isCancelled ( ) | | op . isTimedOut ( ) ) { 
private void potentiallyCloseLeakingChannel ( final SocketChannel ch , final MemcachedNode node ) { if ( ch ! = null & & ! ch . isConnected ( ) & & ! ch . isConnectionPending ( ) ) { try { 
public void enqueueOperation ( final String key , final Operation o ) { checkState ( ) ; StringUtils . validateKey ( key , opFact instanceof BinaryOperationFactory ) ; addOperation ( key , o ) ; } 
protected void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Iterator < MemcachedNode > i = locator . getSequence ( key ) ; while ( placeIn = = null & & i . hasNext ( ) ) { MemcachedNode = i . next ( ) ; if ( . isActive ( ) ) { placeIn = ; } } if ( placeIn = = null ) { placeIn = primary ; this . getLogger ( ) . warn ( " Could not redistribute to another node, " + " retrying primary node for %s. " , key ) ; } } assert o . isCancelled ( ) | | placeIn ! = null : " No node found for key " + key ; if ( placeIn ! = null ) { addOperation ( placeIn , o ) ; 
public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { addOperation ( me . getKey ( ) , me . getValue ( ) ) ; 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; } 
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , final Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; } 
public static void opTimedOut ( final Operation op ) { MemcachedConnection . setTimeout ( op , true ) ; } 
public static void opSucceeded ( final Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; } 
private void logRunException ( final Exception e ) { if ( shutDown ) { getLogger ( ) . debug ( " Exception occurred during shutdown " , e ) ; 
public void readFromBuffer ( final ByteBuffer buffer ) throws IOException { if ( headerOffset < MIN_RECV_PACKET ) { readHeaderFromBuffer ( buffer ) ; if ( headerOffset = = MIN_RECV_PACKET ) { parseHeaderFromBuffer ( ) ; } } if ( headerOffset > = MIN_RECV_PACKET & & payload = = null ) { finishedPayload ( EMPTY_BYTES ) ; 
private void readHeaderFromBuffer ( final ByteBuffer buffer ) { int toRead = MIN_RECV_PACKET - headerOffset ; int available = buffer . remaining ( ) ; toRead = Math . min ( toRead , available ) ; getLogger ( ) . debug ( " Reading %d header bytes " , toRead ) ; buffer . get ( header , headerOffset , toRead ) ; headerOffset + = toRead ; } 
private void parseHeaderFromBuffer ( ) { int magic = header [ 0 ] ; assert magic = = RES_MAGIC : " Invalid magic: " + magic ; responseCmd = header [ 1 ] ; assert cmd = = DUMMY_OPCODE | | responseCmd = = cmd : " Unexpected response command value " ; keyLen = decodeShort ( header , 2 ) ; errorCode = decodeShort ( header , 6 ) ; int bytesToRead = decodeInt ( header , 8 ) ; payload = new byte [ bytesToRead ] ; responseOpaque = decodeInt ( header , 12 ) ; responseCas = decodeLong ( header , 16 ) ; assert opaqueIsValid ( ) : " Opaque is not valid " ; } 
private void readPayloadFromBuffer ( final ByteBuffer buffer ) throws IOException { int toRead = payload . length - payloadOffset ; int available = buffer . remaining ( ) ; toRead = Math . min ( toRead , available ) ; getLogger ( ) . debug ( " Reading %d payload bytes " , toRead ) ; buffer . get ( payload , payloadOffset , toRead ) ; payloadOffset + = toRead ; if ( payloadOffset = = payload . length ) { finishedPayload ( payload ) ; 
protected void prepareBuffer ( final String key , final long cas , final byte [ ] val , final Object . . . extraHeaders ) { int extraLen = 0 ; int extraHeadersLength = extraHeaders . length ; if ( extraHeadersLength > 0 ) { extraLen = calculateExtraLength ( extraHeaders ) ; } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; ByteBuffer bb = ByteBuffer . allocate ( bufSize + extraLen ) ; assert bb . order ( ) = = ByteOrder . BIG_ENDIAN ; bb . put ( REQ_MAGIC ) ; bb . put ( cmd ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) extraLen ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbucket ) ; bb . putInt ( keyBytes . length + val . length + extraLen ) ; bb . putInt ( opaque ) ; bb . putLong ( cas ) ; if ( extraHeadersLength > 0 ) { addExtraHeaders ( bb , extraHeaders ) ; } bb . put ( keyBytes ) ; bb . put ( val ) ; bb . flip ( ) ; setBuffer ( bb ) ; } 
private void addExtraHeaders ( final ByteBuffer bb , final Object . . . extraHeaders ) { for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { 
private int calculateExtraLength ( final Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } return extraLen ; } 
public void initialize ( ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; prepareBuffer ( " " , 0x0 , EMPTY_BYTES , ( short ) index , ( short ) keyBytes . length , keyBytes ) ; 
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } handleOperationalTasks ( ) ; } 
private void handleOperationalTasks ( ) throws IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } redistributeOperations ( retryOps ) ; retryOps . clear ( ) ; handleShutdownQueue ( ) ; } 
private void handleEmptySelects ( ) { getLogger ( ) . debug ( " No selectors ready, interrupted: " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { 
private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; try { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { handleReadsAndWrites ( sk , node ) ; } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; } 
private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) throws IOException { if ( sk . isValid ( ) ) { if ( sk . isReadable ( ) ) { 
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) { CASResponse casr ; try { OperationFuture < CASResponse > casOp = asyncCAS ( key , 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > tcIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch, executorService); GetOperation.Callback cb = new GetOperation.Callback() { @Override @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } @Override public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } @Override public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) { @Override 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) { @Override 
private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } @Override public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + ']'); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Boolean > delete ( String key ) { return delete ( key , 0 L ) ; } 
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { @Override public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout , executorService ) { 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } 
public Operation newOp ( MemcachedNode , final CountDownLatch latch ) { return opFact . saslMechs ( new OperationCallback ( ) { @Override 
public boolean waitForQueues ( long timeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { @Override public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, mconn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here 
public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { @Override 
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } 
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } 
public < T > OperationFuture < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . touch ( key , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } 
public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; } 
public void set ( Boolean o , OperationStatus s ) { super . set ( o , s ) ; notifyListeners ( ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } notifyListeners ( ) ; return rv ; } 
public void signalComplete ( ) { notifyListeners ( ) ; } 
public void testGetBulkWithCallback ( ) throws Exception { final int items = 1000 ; List < String > keysList = new ArrayList < String > ( items ) ; for ( int i = 0 ; i < items ; i + + ) { assertTrue ( client . set ( " getBulkWithCallback " + i , 0 , " content " ) . get ( ) ) ; keysList . add ( " getBulkWithCallback " + i ) ; } BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( keysList ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; latch . countDown ( ) ; } 
public boolean shutdown ( long timeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; if (connFactory.isDefaultExecutorService()) { try { executorService.shutdown(); } catch (Exception ex) { getLogger().warn("Failed shutting down the ExecutorService: ", ex); } } try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); terminate all pending Auth Threads authMonitor.interruptAllPendingAuth(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; } 
public synchronized void interruptAllPendingAuth ( ) { for ( AuthThread toStop : nodeMap . values ( ) ) { if ( toStop . isAlive ( ) ) { 
private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( true ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); } 
protected void handleRetryInformation ( final byte [ ] retryMessage ) { getLogger ( ) . debug ( " Got RETRY message: " + new String ( retryMessage ) + " , but not handled. " ) ; 
boolean isCancelled ( ) ; byte [ ] getErrorMsg ( ) ; } 
boolean hasErrored ( ) ; byte [ ] getErrorMsg ( ) ; } 
OperationException getException ( ) ; byte [ ] getErrorMsg ( ) ; } 
OperationCallback getCallback ( ) ; byte [ ] getErrorMsg ( ) ; } 
void cancel ( ) ; byte [ ] getErrorMsg ( ) ; } 
OperationState getState ( ) ; byte [ ] getErrorMsg ( ) ; } 
ByteBuffer getBuffer ( ) ; byte [ ] getErrorMsg ( ) ; } 
void writing ( ) ; byte [ ] getErrorMsg ( ) ; } 
void writeComplete ( ) ; byte [ ] getErrorMsg ( ) ; } 
void initialize ( ) ; byte [ ] getErrorMsg ( ) ; } 
void readFromBuffer ( ByteBuffer data ) throws IOException ; byte [ ] getErrorMsg ( ) ; } 
void handleRead ( ByteBuffer data ) ; byte [ ] getErrorMsg ( ) ; } 
MemcachedNode getHandlingNode ( ) ; byte [ ] getErrorMsg ( ) ; } 
void setHandlingNode ( MemcachedNode to ) ; byte [ ] getErrorMsg ( ) ; } 
void timeOut ( ) ; byte [ ] getErrorMsg ( ) ; } 
boolean isTimedOut ( ) ; byte [ ] getErrorMsg ( ) ; } 
boolean isTimedOut ( long ttlMillis ) ; byte [ ] getErrorMsg ( ) ; } 
boolean isTimedOutUnsent ( ) ; byte [ ] getErrorMsg ( ) ; } 
long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; } 
protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) throws IOException { errorMsg = new byte [ errPl . length ] ; errorMsg = errPl . clone ( ) ; switch ( errCode ) { case SUCCESS : 
public Thread newThread ( Runnable r ) { return new Thread ( r , " FutureNotifyListener " ) ; } 
public void run ( ) { try { listener . onComplete ( future ) ; 
protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( true ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); } 
protected synchronized void notifyListeners ( final Future < ? > future ) { for ( GenericCompletionListener < ? extends Future < ? super T > > listener : listeners ) { 
void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getReplicaIndex ( ) ; } 
public ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) { throw new UnsupportedOperationException ( " Replica gets is not supported " + " for ASCII protocol " ) ; 
public ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) { return new ReplicaGetsOperationImpl ( key , index , callback ) ; } 
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; Callback gcb = ( Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; } 
public Boolean get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( true , " OK " , StatusCode . SUCCESS ) ; return super . get ( duration , units ) ; } 
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " , StatusCode . CANCELLED ) ; notifyListeners ( ) ; return rv ; } 
public static StatusCode fromBinaryCode ( int code ) { switch ( code ) { case 0x00 : 
public static StatusCode fromAsciiLine ( String line ) { if ( line . equals ( " STORED " ) | | line . equals ( " DELETED " ) ) { return SUCCESS ; 
protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) , StatusCode . ERR_INTERNAL ) ) ; transitionState ( OperationState . COMPLETE ) ; throw exception ; } 
public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( true , line , StatusCode . SUCCESS ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; } 
public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , line . substring ( " VERSION " . length ( ) ) , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } 
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , String . valueOf ( decodeLong ( pl , 0 ) ) , StatusCode . SUCCESS ) ) ; 
protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) throws IOException { errorMsg = new byte [ errPl . length ] ; errorMsg = errPl . clone ( ) ; StatusCode statusCode = StatusCode . fromBinaryCode ( errCode ) ; switch ( errCode ) { case SUCCESS : 
protected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , " " , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String toString ( ) { return " SASL base operation " ; } } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , 
protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , StatusCode . SUCCESS ) ) ; 
public void testAddGetSetStatusCodes ( ) throws Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_NOT_STORED , add . getStatus ( ) . getStatusCode ( ) ) ; } 
public void testAddGetSetStatusCodes ( ) throws Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_EXISTS , add . getStatus ( ) . getStatusCode ( ) ) ; } 
public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " , StatusCode . SUCCESS ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback(); 
public void testMutateWithDefaultAndExp ( ) throws Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; OperationStatus status = client . asyncGet ( " mtest " ) . getStatus ( ) ; assertFalse ( status . isSuccess ( ) ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , status . getStatusCode ( ) ) ; } 
public void testAsyncIncrement ( ) throws Exception { String k = " async-incr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; } 
public void testAsyncIncrementNonExistent ( ) throws Exception { String k = " async-incr-non-existent " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrement ( ) throws Exception { String k = " async-decr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrementNonExistent ( ) throws Exception { String k = " async-decr-non-existent " ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; } 
public void testAppend ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; } 
public void testPrepend ( ) throws Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; } 
public void testGetBulkWithCallback ( ) throws Exception { final int items = 1000 ; List < String > keysList = new ArrayList < String > ( items ) ; for ( int i = 0 ; i < items ; i + + ) { assertTrue ( client . set ( " getBulkWithCallback " + i , 0 , " content " ) . get ( ) ) ; keysList . add ( " getBulkWithCallback " + i ) ; } BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( keysList ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; } 
public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; latch . countDown ( ) ; } 
public static String join ( final Collection < String > chunks , final String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! chunks . isEmpty ( ) ) { Iterator < String > itr = chunks . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . toString ( ) ; } 
public static boolean isJsonObject ( final String s ) { if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " true " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalMatcher . reset ( s ) . matches ( ) ) { return true ; } return false ; } 
public static void validateKey ( final String key , final boolean binary ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int keyLength = keyBytes . length ; if ( keyLength > MAX_KEY_LENGTH ) { throw KEY_TOO_LONG_EXCEPTION ; } if ( keyLength = = 0 ) { throw KEY_EMPTY_EXCEPTION ; } if ( ! binary ) { for ( byte b : keyBytes ) { 
public void setup ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < MemcachedClientIF . MAX_KEY_LENGTH + 1 ; i + + ) { builder . append ( " k " ) ; } tooLongKey = builder . toString ( ) ; } 
public void shouldJoinChunk ( ) { List < String > chunks = Arrays . asList ( " chunk1 " ) ; String delimiter = " , " ; String expected = " chunk1 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; } 
public void shouldJoinChunks ( ) { List < String > chunks = Arrays . asList ( " chunk1 " , " chunk2 " , " chunk3 " ) ; String delimiter = " , " ; String expected = " chunk1,chunk2,chunk3 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; } 
public void shouldReturnEmptyStringWithNoChunks ( ) { String result = StringUtils . join ( Collections . < String > emptyList ( ) , " , " ) ; assertEquals ( " " , result ) ; } 
public void shouldValidateJSONObject ( ) { assertTrue ( StringUtils . isJsonObject ( " { \" a \" :true} " ) ) ; assertTrue ( StringUtils . isJsonObject ( " [0, 1, 2] " ) ) ; assertTrue ( StringUtils . isJsonObject ( " true " ) ) ; assertTrue ( StringUtils . isJsonObject ( " false " ) ) ; assertTrue ( StringUtils . isJsonObject ( " null " ) ) ; assertTrue ( StringUtils . isJsonObject ( " 1 " ) ) ; assertTrue ( StringUtils . isJsonObject ( " -1 " ) ) ; } 
public void shouldValidateNonJSONObject ( ) { assertFalse ( StringUtils . isJsonObject ( " foobar " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 0.5 " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 1,244.0 " ) ) ; } 
public void shouldValidateAsciiKey ( ) { StringUtils . validateKey ( " mykey1234 " , false ) ; assertTrue ( true ) ; } 
public void shouldFailValidationWithAsciiSpace ( ) { StringUtils . validateKey ( " key baz " , false ) ; } 
public void shouldFailValidationWithAsciiNewline ( ) { StringUtils . validateKey ( " keybaz " , false ) ; } 
public void shouldFailValidationWithAsciiReturn ( ) { StringUtils . validateKey ( " keybaz r " , false ) ; } 
public void shouldFailValidationWithAsciiNull ( ) { StringUtils . validateKey ( " keybaz 0 " , false ) ; } 
public void shouldFailValidationWithAsciiTooLong ( ) { StringUtils . validateKey ( tooLongKey , false ) ; } 
public void shouldFailValidationWithBinaryTooLong ( ) { StringUtils . validateKey ( tooLongKey , true ) ; } 
public void shouldFailValidationWithAsciiEmpty ( ) { StringUtils . validateKey ( " " , false ) ; } 
public void shouldFailValidationWithBinaryEmpty ( ) { StringUtils . validateKey ( " " , true ) ; } 
public void shouldValidateBinaryKey ( ) { StringUtils . validateKey ( " mykey1234 " , true ) ; StringUtils . validateKey ( " key baz " , true ) ; StringUtils . validateKey ( " keybaz " , true ) ; StringUtils . validateKey ( " keybaz r " , true ) ; StringUtils . validateKey ( " keybaz 0 " , true ) ; } 
public void complete ( ) { if ( pendingChunks . decrementAndGet ( ) < = 0 ) { latch . countDown ( ) ; 
protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; synchronized ( vbmap ) { vbmap . put ( k , new Short ( ( short ) 0 ) ) ; } } return rv ; } 
public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(size); for (Map.Entry<Integer, byte[]> me : bkeys.entrySet()) { final byte[] keyBytes = me.getValue(); final String key = keys.get(me.getKey()); Custom header bb.put(REQ_MAGIC); bb.put(CMD_GETQ); bb.putShort((short) keyBytes.length); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort(vbmap.get(key).shortValue()); vbucket bb.putInt(keyBytes.length); bb.putInt(me.getKey()); bb.putLong(0); cas the actual key bb.put(keyBytes); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); } 
protected void finishedPayload ( byte [ ] pl ) throws IOException { getStatusForErrorCode ( errorCode , pl ) ; if ( responseOpaque = = terminalOpaque ) { if ( retryKeys . size ( ) > 0 ) { transitionState ( OperationState . RETRY ) ; OperationStatus retryStatus = new OperationStatus ( true , Integer . toString ( retryKeys . size ( ) ) , StatusCode . ERR_NOT_MY_VBUCKET ) ; getCallback ( ) . receivedStatus ( retryStatus ) ; getCallback ( ) . complete ( ) ; } else { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } } else if ( errorCode = = ERR_NOT_MY_VBUCKET ) { retryKeys . add ( keys . get ( responseOpaque ) ) ; } else if ( errorCode ! = SUCCESS ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; } 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; long getAuthWaitTime ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; long getAuthWaitTime ( ) ; } 
ExecutorService getListenerExecutorService ( ) ; long getAuthWaitTime ( ) ; } 
boolean isDefaultExecutorService ( ) ; long getAuthWaitTime ( ) ; } 
NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getAuthWaitTime ( ) ; } 
OperationFactory getOperationFactory ( ) ; long getAuthWaitTime ( ) ; } 
long getOperationTimeout ( ) ; long getAuthWaitTime ( ) ; } 
boolean isDaemon ( ) ; long getAuthWaitTime ( ) ; } 
boolean useNagleAlgorithm ( ) ; long getAuthWaitTime ( ) ; } 
Collection < ConnectionObserver > getInitialObservers ( ) ; long getAuthWaitTime ( ) ; } 
FailureMode getFailureMode ( ) ; long getAuthWaitTime ( ) ; } 
Transcoder < Object > getDefaultTranscoder ( ) ; long getAuthWaitTime ( ) ; } 
boolean shouldOptimize ( ) ; long getAuthWaitTime ( ) ; } 
int getReadBufSize ( ) ; long getAuthWaitTime ( ) ; } 
HashAlgorithm getHashAlg ( ) ; long getAuthWaitTime ( ) ; } 
long getMaxReconnectDelay ( ) ; long getAuthWaitTime ( ) ; } 
AuthDescriptor getAuthDescriptor ( ) ; long getAuthWaitTime ( ) ; } 
int getTimeoutExceptionThreshold ( ) ; long getAuthWaitTime ( ) ; } 
MetricType enableMetrics ( ) ; long getAuthWaitTime ( ) ; } 
MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; } 
public final void addOp ( Operation op ) { try { if ( ! authLatch . await ( authWaitTime , TimeUnit . MILLISECONDS ) ) { 
public void testDefaults ( ) throws Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; assertEquals ( f . getAuthWaitTime ( ) , DefaultConnectionFactory . DEFAULT_AUTH_WAIT_TIME ) ; 
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor) .setAuthWaitTime(3000) .build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); assertEquals(f.getAuthWaitTime(), 3000); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( 
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; qa . setConnection ( this ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! connectionFactory . useNagleAlgorithm ( ) ) ; try { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; } 
public void redistributeOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { redistributeOperation ( op ) ; 
Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void addOp ( Operation op ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
int getSelectionOps ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
boolean isActive ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
boolean isAuthenticated ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
long lastReadDelta ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void completedRead ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void reconnecting ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void connected ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
int getReconnectCount ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void setChannel ( SocketChannel to ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
SocketChannel getChannel ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void setSk ( SelectionKey to ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
SelectionKey getSk ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
int getBytesRemainingToWrite ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
int writeSome ( ) throws IOException ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void fixupOps ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void authComplete ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; } 
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { if ( ! ( opFact instanceof BinaryOperationFactory ) & & ( def ! = 0 | | exp ! = - 1 ) ) { throw new UnsupportedOperationException ( " Default value or expiration " + " time are not supported on the async mutate methods. Use either the " + " binary protocol or the sync variant. " ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; } 
public OperationFuture < Long > asyncIncr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; } 
public OperationFuture < Long > asyncIncr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; } 
public OperationFuture < Long > asyncDecr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; } 
public OperationFuture < Long > asyncDecr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; } 
public OperationFuture < Long > asyncIncr ( String key , long by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; } 
public OperationFuture < Long > asyncIncr ( String key , int by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , long by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; } 
public OperationFuture < Long > asyncDecr ( String key , int by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; } 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
public void testAsyncIncrementWithDefault ( ) throws Exception { String k = " async-incr-with-default " ; try { client . asyncIncr ( k , 1 , 5 ) ; 
public void testAsyncDecrementWithDefault ( ) throws Exception { String k = " async-decr-with-default " ; try { client . asyncDecr ( k , 1 , 5 ) ; 
public void testAsyncIncrementWithDefault ( ) throws Exception { String k = " async-incr-with-default " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 5 , ( long ) f . get ( ) ) ; f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; } 
public void testAsyncDecrementWithDefault ( ) throws Exception { String k = " async-decr-with-default " ; OperationFuture < Long > f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 10 , ( long ) f . get ( ) ) ; f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; } 
public void retryOperation ( Operation op ) { retryOps . add ( op ) ; } 
private void handleOperationalTasks ( ) throws IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } if ( ! retryOps . isEmpty ( ) ) { redistributeOperations ( new ArrayList < Operation > ( retryOps ) ) ; retryOps . clear ( ) ; } handleShutdownQueue ( ) ; } 
boolean isCancelled ( ) ; void setCloneCount ( int count ) ; } 
boolean hasErrored ( ) ; void setCloneCount ( int count ) ; } 
OperationException getException ( ) ; void setCloneCount ( int count ) ; } 
OperationCallback getCallback ( ) ; void setCloneCount ( int count ) ; } 
void cancel ( ) ; void setCloneCount ( int count ) ; } 
OperationState getState ( ) ; void setCloneCount ( int count ) ; } 
ByteBuffer getBuffer ( ) ; void setCloneCount ( int count ) ; } 
void writing ( ) ; void setCloneCount ( int count ) ; } 
void writeComplete ( ) ; void setCloneCount ( int count ) ; } 
void initialize ( ) ; void setCloneCount ( int count ) ; } 
void readFromBuffer ( ByteBuffer data ) throws IOException ; void setCloneCount ( int count ) ; } 
void handleRead ( ByteBuffer data ) ; void setCloneCount ( int count ) ; } 
MemcachedNode getHandlingNode ( ) ; void setCloneCount ( int count ) ; } 
void setHandlingNode ( MemcachedNode to ) ; void setCloneCount ( int count ) ; } 
void timeOut ( ) ; void setCloneCount ( int count ) ; } 
boolean isTimedOut ( ) ; void setCloneCount ( int count ) ; } 
boolean isTimedOut ( long ttlMillis ) ; void setCloneCount ( int count ) ; } 
boolean isTimedOutUnsent ( ) ; void setCloneCount ( int count ) ; } 
long getWriteCompleteTimestamp ( ) ; void setCloneCount ( int count ) ; } 
byte [ ] getErrorMsg ( ) ; void setCloneCount ( int count ) ; } 
void addClone ( Operation op ) ; void setCloneCount ( int count ) ; } 
int getCloneCount ( ) ; void setCloneCount ( int count ) ; } 
public final synchronized void cancel ( ) { cancelled = true ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . cancel ( ) ; } } wasCancelled ( ) ; callback . receivedStatus ( CANCELLED ) ; callback . complete ( ) ; } 
public synchronized void timeOut ( ) { timedout = true ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . timeOut ( ) ; } } callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } 
public void addClone ( Operation op ) { clones . add ( op ) ; } 
protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } else { getLogger ( ) . warn ( " Received non-success response for SASL mechs: " + status ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; try { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( true ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { getLogger().warn("Interrupted in Auth while waiting for SASL mechs."); we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { return null; } return supported.split(MECH_SEPARATOR); } 
public void testEmptyGetBulk ( ) throws Exception { Map < String , Object > bulk = client . getBulk ( Collections . < String > emptyList ( ) ) ; assertTrue ( bulk . isEmpty ( ) ) ; } 
public static boolean isJsonObject ( final String s ) { if ( s = = null | | s . isEmpty ( ) ) { return false ; } if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " true " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalMatcher . reset ( s ) . matches ( ) ) { return true ; } return false ; } 
public void shouldWorkWithEmptyOrNullStrings ( ) { assertFalse ( StringUtils . isJsonObject ( " " ) ) ; assertFalse ( StringUtils . isJsonObject ( null ) ) ; assertFalse ( StringUtils . isJsonObject ( " r " ) ) ; assertFalse ( StringUtils . isJsonObject ( " " ) ) ; assertFalse ( StringUtils . isJsonObject ( " " ) ) ; } 
protected Future < T > addToListeners ( final GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can't be null. " ) ; } synchronized ( this ) { listeners . add ( listener ) ; } if ( isDone ( ) ) { notifyListeners ( ) ; } return this ; } 
protected void notifyListeners ( final Future < ? > future ) { final List < GenericCompletionListener < ? extends Future < T > > > copy = new ArrayList < GenericCompletionListener < ? extends Future < T > > > ( ) ; synchronized ( this ) { copy . addAll ( listeners ) ; listeners = new ArrayList < GenericCompletionListener < ? extends Future < T > > > ( ) ; } for ( GenericCompletionListener < ? extends Future < ? super T > > listener : copy ) { 
protected Future < T > removeFromListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( ! isDone ( ) ) { synchronized ( this ) { listeners . remove ( listener ) ; } } return this ; } 
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set<SelectionKey> selectedKeys = selector.selectedKeys(); if (selector.selectedKeys().isEmpty() && !shutDown) { handleEmptySelects(); } else { getLogger().debug("Selected %d, selected %d keys", selected, selector.selectedKeys().size()); emptySelects = 0; Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while(iterator.hasNext()) { SelectionKey sk = iterator.next(); handleIO(sk); iterator.remove(); } } handleOperationalTasks(); } 
long getCasValue ( ) ; void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } } 
int getIndex ( ) ; void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } } 
public long lastReadDelta ( ) { return TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - lastReadTimestamp ) ; } 
public void completedRead ( ) { lastReadTimestamp = System . nanoTime ( ) ; } 
public static boolean isJsonObject ( final String s ) { if ( s = = null | | s . isEmpty ( ) ) { return false ; } if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " true " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalPattern . matcher ( s ) . matches ( ) ) { return true ; } return false ; } 
private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; try { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . debug ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { handleReadsAndWrites ( sk , node ) ; } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; } 
public void handleIO ( ) throws IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set<SelectionKey> selectedKeys = selector.selectedKeys(); if (selector.selectedKeys().isEmpty() && !shutDown) { handleEmptySelects(); } else { getLogger().debug("Selected %d, selected %d keys", selected, selector.selectedKeys().size()); emptySelects = 0; Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while(iterator.hasNext()) { SelectionKey sk = iterator.next(); handleIO(sk); iterator.remove(); } } handleOperationalTasks(); } 
public void shutdown ( ) throws IOException { shutDown = true ; try { Selector s = selector . wakeup ( ) ; 
public void handleIO ( ) throws IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 1000 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; if ( shutDown ) { return ; } else if ( selected = = 0 & & addedQueue . isEmpty ( ) ) { handleWokenUpSelector ( ) ; } else if ( selector . selectedKeys ( ) . isEmpty ( ) ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selector . selectedKeys ( ) . size ( ) ) ; emptySelects = 0 ; Iterator < SelectionKey > iterator = selector . selectedKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { SelectionKey sk = iterator . next ( ) ; handleIO ( sk ) ; iterator . remove ( ) ; } } handleOperationalTasks ( ) ; } 
public void shouldWakeUpOnIdle ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 3 ) ; MemcachedConnection connection = new InstrumentedConnection ( latch , 1024 , new BinaryConnectionFactory ( ) , Arrays . asList ( new InetSocketAddress ( 11210 ) ) , Collections . < ConnectionObserver > emptyList ( ) , FailureMode . Redistribute , new BinaryOperationFactory ( ) ) ; assertTrue ( latch . await ( 5 , TimeUnit . SECONDS ) ) ; } 
protected void handleWokenUpSelector ( ) { latch . countDown ( ) ; } 
public void shouldWakeUpOnIdle ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 3 ) ; MemcachedConnection connection = new InstrumentedConnection ( latch , 1024 , new BinaryConnectionFactory ( ) , Arrays . asList ( new InetSocketAddress ( 11211 ) ) , Collections . < ConnectionObserver > emptyList ( ) , FailureMode . Redistribute , new BinaryOperationFactory ( ) ) ; assertTrue ( latch . await ( 5 , TimeUnit . SECONDS ) ) ; } 
public void complete ( ) { if ( remaining . decrementAndGet ( ) = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ; 
protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) throws IOException { if ( errCode = = SUCCESS ) { return STATUS_OK ; 
private void handleOperationalTasks ( ) throws IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } if ( ! retryOps . isEmpty ( ) ) { ArrayList < Operation > operations = new ArrayList < Operation > ( retryOps ) ; retryOps . clear ( ) ; redistributeOperations ( operations ) ; } handleShutdownQueue ( ) ; } 
protected void addOperation ( final MemcachedNode node , final Operation o ) { if ( ! node . isAuthenticated ( ) ) { retryOperation ( o ) ; return ; } o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; } 
public Object getObject ( ) throws Exception { return client ; } 
public void afterPropertiesSet ( ) throws Exception { client = new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; 
public void destroy ( ) throws Exception { if ( shutdownTimeoutSeconds > 0 ) { client . shutdown ( shutdownTimeoutSeconds , TimeUnit . SECONDS ) ; 
public final void initialize ( ) { Figure out the length of the request int size = 6; Enough for gets\r Collection<byte[]> keyBytes = KeyUtil.getKeyBytes(keys); for (byte[] k : keyBytes) { size += k.length; size++; } size += afterKeyBytesSize(); ByteBuffer b = ByteBuffer.allocate(size); b.put(cmd.getBytes()); for (byte[] k : keyBytes) { b.put((byte) ' '); b.put(k); } afterKeyBytes(b); b.put(RN_BYTES); b.flip(); setBuffer(b); } 
protected int afterKeyBytesSize ( ) { if ( expBytes = = null ) { return 0 ; } return expBytes . length + 1 ; } 
protected void afterKeyBytes ( final ByteBuffer b ) { if ( expBytes ! = null ) { b . put ( ( byte ) ' ' ) ; 
void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getExpiration ( ) ; } 
public void testGetObject ( ) throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( true ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( true ) ; final Transcoder < Object > transcoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( transcoder ) ; factory . afterPropertiesSet ( ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " transcoder " , transcoder , memcachedClient . getTranscoder ( ) ) ; 
public TouchOperation touch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; } 
public void testTouchOperationCloning ( ) { OperationCallback callback = ( OperationCallback ) mock ( OperationCallback . class ) . proxy ( ) ; TouchOperation op = ofact . touch ( TEST_KEY , 0 , callback ) ; TouchOperation op2 = cloneOne ( TouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) , getKetamaNodeKeyFormat ( ) , getWeights ( ) ) ; 
private List < Long > ketamaNodePositionsAtIteration ( MemcachedNode node , int iteration ) { List < Long > positions = new ArrayList < Long > ( ) ; byte [ ] digest = DefaultHashAlgorithm . computeMd5 ( config . getKeyForNode ( node , iteration ) ) ; for ( int h = 0 ; h < 4 ; h + + ) { Long k = ( ( long ) ( digest [ 3 + h * 4 ] & 0xFF ) < < 24 ) | ( ( long ) ( digest [ 2 + h * 4 ] & 0xFF ) < < 16 ) | ( ( long ) ( digest [ 1 + h * 4 ] & 0xFF ) < < 8 ) | ( digest [ h * 4 ] & 0xFF ) ; positions . add ( k ) ; } return positions ; } 
public void testCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; } 
public void testDefaultProperties ( ) { KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . KETAMA_HASH ) ; assertTrue ( connectionFactory . getWeights ( ) . isEmpty ( ) ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; } 
public void testSettingProperties ( ) { Map < InetSocketAddress , Integer > weights = new HashMap < InetSocketAddress , Integer > ( ) ; weights . put ( new InetSocketAddress ( " localhost " , 11211 ) , 8 ) ; KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( 1 , 1 , 1 , DefaultHashAlgorithm . FNV1_32_HASH , KetamaNodeKeyFormatter . Format . LIBMEMCACHED , weights ) ; assertEquals ( connectionFactory . getWeights ( ) , weights ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . FNV1_32_HASH ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; } 
public void setUp ( ) throws Exception { ip = InetAddress . getByAddress ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; noHostnameNode = new MockMemcachedNode ( new InetSocketAddress ( ip , 11211 ) ) ; } 
public void testSpymemcachedFormatIsDefault ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( ) ; assertEquals ( formatter . getFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; } 
public void testSpymemcachedFormat ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; assertEquals ( " localhost/127.0.0.1:11211-1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1.2.3.4:11211-1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost/127.0.0.1:11212-1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; } 
public void testLibmemcachedFormat ( ) throws Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; assertEquals ( " localhost-1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1.2.3.4-1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost:11212-1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; } 
public void testLibKetamaWeightedCompatLibmemcached ( ) { String [ ] servers = { " 127.0.0.1:11211 " , " 127.0.0.1:11212 " } ; List < MemcachedNode > nodes = Arrays . asList ( mockNodes ( servers ) ) ; Map < InetSocketAddress , Integer > weights = new HashMap < InetSocketAddress , Integer > ( ) ; weights . put ( ( InetSocketAddress ) nodes . get ( 0 ) . getSocketAddress ( ) , 8 ) ; weights . put ( ( InetSocketAddress ) nodes . get ( 1 ) . getSocketAddress ( ) , 8 ) ; locator = new KetamaNodeLocator ( nodes , DefaultHashAlgorithm . KETAMA_HASH , KetamaNodeKeyFormatter . Format . LIBMEMCACHED , weights ) ; String [ ] [ ] exp = { { " key1 " , " localhost/127.0.0.1:11212 " } , { " key2 " , " localhost/127.0.0.1:11211 " } , { " key3 " , " localhost/127.0.0.1:11212 " } , { " key4 " , " localhost/127.0.0.1:11212 " } } ; for ( String [ ] s : exp ) { String k = s [ 0 ] ; 
CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; } 
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; OperationFuture < Boolean > setResult = client . set ( " bigassthing " , 60 , data , st ) ; assertFalse ( setResult . get ( ) ) ; assertEquals ( StatusCode . ERR_2BIG , setResult . getStatus ( ) . getStatusCode ( ) ) ; client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; } 
private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) throws IOException { if ( sk . isValid ( ) & & sk . isReadable ( ) ) { handleReads ( node ) ; } if ( sk . isValid ( ) & & sk . isWritable ( ) ) { handleWrites ( node ) ; 
public void handleIO ( ) throws IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = wakeupDelay ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; if ( shutDown ) { return ; } else if ( selected = = 0 & & addedQueue . isEmpty ( ) ) { handleWokenUpSelector ( ) ; } else if ( selector . selectedKeys ( ) . isEmpty ( ) ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selector . selectedKeys ( ) . size ( ) ) ; emptySelects = 0 ; Iterator < SelectionKey > iterator = selector . selectedKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { SelectionKey sk = iterator . next ( ) ; handleIO ( sk ) ; iterator . remove ( ) ; } } handleOperationalTasks ( ) ; } 
public void retryOperation ( Operation op ) { if ( retryQueueSize > = 0 & & retryOps . size ( ) > = retryQueueSize ) { if ( ! op . isCancelled ( ) ) { op . cancel ( ) ; } } retryOps . add ( op ) ; } 
private void handleEmptySelects ( ) { getLogger ( ) . debug ( " No selectors ready, interrupted: %b " , Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { 
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; long getAuthWaitTime ( ) ; } 
MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createReadOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getAuthWaitTime ( ) ; } 
long getOpQueueMaxBlockTime ( ) ; long getAuthWaitTime ( ) ; } 
ExecutorService getListenerExecutorService ( ) ; long getAuthWaitTime ( ) ; } 
boolean isDefaultExecutorService ( ) ; long getAuthWaitTime ( ) ; } 
NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getAuthWaitTime ( ) ; } 
OperationFactory getOperationFactory ( ) ; long getAuthWaitTime ( ) ; } 
long getOperationTimeout ( ) ; long getAuthWaitTime ( ) ; } 
boolean isDaemon ( ) ; long getAuthWaitTime ( ) ; } 
boolean useNagleAlgorithm ( ) ; long getAuthWaitTime ( ) ; } 
boolean getKeepAlive ( ) ; long getAuthWaitTime ( ) ; } 
protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; qa . setConnection ( this ) ; int ops = 0 ; Socket socket = ch . socket ( ) ; socket . setTcpNoDelay ( ! connectionFactory . useNagleAlgorithm ( ) ) ; socket . setKeepAlive ( connectionFactory . getKeepAlive ( ) ) ; try { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; } 
public void testDefaults ( ) throws Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertFalse ( f . getKeepAlive ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; assertEquals ( f . getAuthWaitTime ( ) , DefaultConnectionFactory . DEFAULT_AUTH_WAIT_TIME ) ; 
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor) .setAuthWaitTime(3000) .setKeepAlive(true) .build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertTrue(f.getKeepAlive()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); assertEquals(f.getAuthWaitTime(), 3000); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( 
