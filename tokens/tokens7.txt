static public Log makeNewLogInstance ( String name ) { Log log = null ; String logclassname = System . getProperty ( " httpclient.log " , " org.apache.commons.httpclient.log.NoOpLog " ) ; try { Class logclass = Class . forName ( logclassname ) ; Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; Constructor ctor = logclass . getConstructor ( argtypes ) ; Object [ ] args = new Object [ 1 ] ; args [ 0 ] = name ; log = ( Log ) ( ctor . newInstance ( args ) ) ; } catch ( Exception e ) { log = null ; } if ( null = = log ) { if ( _log4jIsAvailable ) { return new Log4JCategoryLog ( name ) ; } else { log = new NoOpLog ( name ) ; } } return log ; } 
public void debug ( Object message ) ; public void debug ( Object message , Throwable ) ; public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void debug ( Object message , Throwable ) ; public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; } 
public final void debug ( Object message , Throwable ) { _category . debug ( message , ) ; } 
public final void info ( Object message , Throwable ) { _category . info ( message , ) ; } 
public final void warn ( Object message , Throwable ) { _category . warn ( message , ) ; } 
public final void error ( Object message , Throwable ) { _category . error ( message , ) ; } 
public final void fatal ( Object message , Throwable ) { _category . fatal ( message , ) ; } 
public final boolean isDebugEnabled ( ) { return _category . isDebugEnabled ( ) ; } 
public final boolean isInfoEnabled ( ) { return _category . isInfoEnabled ( ) ; } 
public final boolean isEnabledFor ( Priority p ) { return _category . isEnabledFor ( p ) ; } 
public void debug ( Object message ) { } public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public void fatal ( Object message , Throwable ) { } public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } } 
public final boolean isDebugEnabled ( ) { return false ; } public final boolean isInfoEnabled ( ) { return false ; } 
public void debug ( Object message ) ; public void debug ( Object message , Throwable ) ; public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void debug ( Object message , Throwable ) ; public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void info ( Object message ) ; public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void info ( Object message , Throwable ) ; public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void warn ( Object message , Throwable ) ; public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void error ( Object message ) ; public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void fatal ( Object message , Throwable ) ; public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public boolean isDebugEnabled ( ) ; public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public boolean isInfoEnabled ( ) ; public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public void setLevel ( int level ) ; public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
public int getLevel ( ) ; public static final int OFF = Integer . MAX_VALUE ; } 
static public void setLogImplementation ( String classname ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException , ClassNotFoundException { Class logclass = Class . forName ( classname ) ; Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; _logimplctor = logclass . getConstructor ( argtypes ) ; } 
static public void setLogImplementation ( Class logclass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; _logimplctor = logclass . getConstructor ( argtypes ) ; } 
static public Log makeNewLogInstance ( String name ) { Log log = null ; try { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = name ; log = ( Log ) ( _logimplctor . newInstance ( args ) ) ; } catch ( InstantiationException e ) { log = null ; } catch ( IllegalAccessException e ) { log = null ; } catch ( IllegalArgumentException e ) { log = null ; } catch ( InvocationTargetException e ) { log = null ; } catch ( NullPointerException e ) { log = null ; } if ( null = = log ) { if ( _log4jIsAvailable ) { return new Log4JCategoryLog ( name ) ; } else { log = new NoOpLog ( name ) ; } } return log ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; Add independent test suites suite.addTest(TestLogLevels.suite()); return suite; } 
public static void main ( String args [ ] ) { String [ ] testCaseName = { TestAll . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
protected void debugImpl ( Object message ) { setMessage ( message ) ; } 
protected void debugImpl ( Object message , Throwable ) { debugImpl ( message ) ; } 
protected void infoImpl ( Object message , Throwable ) { infoImpl ( message ) ; } 
protected void warnImpl ( Object message , Throwable ) { warnImpl ( message ) ; } 
protected void errorImpl ( Object message ) { setMessage ( message ) ; } 
protected void errorImpl ( Object message , Throwable ) { errorImpl ( message ) ; } 
protected void fatalImpl ( Object message ) { setMessage ( message ) ; } 
protected void fatalImpl ( Object message , Throwable ) { fatalImpl ( message ) ; } 
public static Test suite ( ) { return new TestSuite ( TestLogLevels . class ) ; } 
public void testAbstractLogLevelCheck ( ) { TestLog log = new TestLog ( ) ; test OFF log level log.setLevel(Log.OFF); log.setMessage(null); log.debug("DEBUG"); assertNull( "Log level checking failed (DEBUG/OFF)", log.getMessage()); log.setMessage(null); log.info("INFO"); assertNull( "Log level checking failed (INFO/OFF)", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertNull( "Log level checking failed (ERROR/OFF)", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertNull( "Log level checking failed (FATAL/OFF)", log.getMessage()); test ALL log level log.setLevel(Log.ALL); log.setMessage(null); log.debug("DEBUG"); assertEquals( "Log level checking failed (DEBUG/ALL)", "DEBUG", log.getMessage()); log.setMessage(null); log.info("INFO"); assertEquals( "Log level checking failed (INFO/ALL)", "INFO", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertEquals( "Log level checking failed (ERROR/ALL)", "ERROR", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertEquals( "Log level checking failed (FATAL/ALL)", "FATAL", log.getMessage()); test DEBUG log level log.setLevel(Log.DEBUG); log.setMessage(null); log.debug("DEBUG"); assertEquals( "Log level checking failed (DEBUG/DEBUG)", "DEBUG", log.getMessage()); log.setMessage(null); log.info("INFO"); assertEquals( "Log level checking failed (INFO/DEBUG)", "INFO", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertEquals( "Log level checking failed (ERROR/DEBUG)", "ERROR", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertEquals( "Log level checking failed (FATAL/DEBUG)", "FATAL", log.getMessage()); test INFO log level log.setLevel(Log.INFO); log.setMessage(null); log.debug("DEBUG"); assertNull( "Log level checking failed (DEBUG/INFO)", log.getMessage()); log.setMessage(null); log.info("INFO"); assertEquals( "Log level checking failed (INFO/INFO)", "INFO", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertEquals( "Log level checking failed (ERROR/INFO)", "ERROR", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertEquals( "Log level checking failed (FATAL/INFO)", "FATAL", log.getMessage()); test ERROR log level log.setLevel(Log.ERROR); log.setMessage(null); log.debug("DEBUG"); assertNull( "Log level checking failed (DEBUG/ERROR)", log.getMessage()); log.setMessage(null); log.info("INFO"); assertNull( "Log level checking failed (INFO/ERROR)", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertEquals( "Log level checking failed (ERROR/ERROR)", "ERROR", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertEquals( "Log level checking failed (FATAL/ERROR)", "FATAL", log.getMessage()); test FATAL log level log.setLevel(Log.FATAL); log.setMessage(null); log.debug("DEBUG"); assertNull( "Log level checking failed (DEBUG/FATAL)", log.getMessage()); log.setMessage(null); log.info("INFO"); assertNull( "Log level checking failed (INFO/FATAL)", log.getMessage()); log.setMessage(null); log.error("ERROR"); assertNull( "Log level checking failed (ERROR/FATAL)", log.getMessage()); log.setMessage(null); log.fatal("FATAL"); assertEquals( "Log level checking failed (FATAL/FATAL)", 
public final boolean isDebugEnabled ( ) { if ( isLevelEnabled ( Log . DEBUG ) ) { return isDebugEnabledImpl ( ) ; } return false ; } 
public final boolean isInfoEnabled ( ) { if ( isLevelEnabled ( Log . INFO ) ) { return isInfoEnabledImpl ( ) ; } return false ; } 
public final void debug ( Object message ) { if ( isLevelEnabled ( Log . DEBUG ) ) { debugImpl ( message ) ; 
public final void debug ( Object message , Throwable ) { if ( isLevelEnabled ( Log . DEBUG ) ) { debugImpl ( message , ) ; 
public final void info ( Object message ) { if ( isLevelEnabled ( Log . INFO ) ) { infoImpl ( message ) ; 
public final void info ( Object message , Throwable ) { if ( isLevelEnabled ( Log . INFO ) ) { infoImpl ( message , ) ; 
public final void warn ( Object message ) { if ( isLevelEnabled ( Log . WARN ) ) { warnImpl ( message ) ; 
public final void warn ( Object message , Throwable ) { if ( isLevelEnabled ( Log . WARN ) ) { warnImpl ( message , ) ; 
public final void error ( Object message ) { if ( isLevelEnabled ( Log . ERROR ) ) { errorImpl ( message ) ; 
public final void error ( Object message , Throwable ) { if ( isLevelEnabled ( Log . ERROR ) ) { errorImpl ( message , ) ; 
public final void fatal ( Object message ) { if ( isLevelEnabled ( Log . FATAL ) ) { fatalImpl ( message ) ; 
public final void fatal ( Object message , Throwable ) { if ( isLevelEnabled ( Log . FATAL ) ) { fatalImpl ( message , ) ; 
protected abstract void debugImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void debugImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void infoImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void infoImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void warnImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void warnImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void errorImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void errorImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void fatalImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void fatalImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected boolean isLevelEnabled ( int logLevel ) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public void setLevel ( int level ) ; public void fatal(Object message, Throwable t);} 
public int getLevel ( ) ; --------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
protected final void debugImpl ( Object message ) { _category . debug ( message ) ; } 
protected final void debugImpl ( Object message , Throwable ) { _category . debug ( message , ) ; } 
protected final void infoImpl ( Object message ) { _category . info ( message ) ; } 
protected final void infoImpl ( Object message , Throwable ) { _category . info ( message , ) ; } 
protected final void warnImpl ( Object message ) { _category . warn ( message ) ; } 
protected final void warnImpl ( Object message , Throwable ) { _category . warn ( message , ) ; } 
protected final void errorImpl ( Object message ) { _category . error ( message ) ; } 
protected final void errorImpl ( Object message , Throwable ) { _category . error ( message , ) ; } 
protected final void fatalImpl ( Object message ) { _category . fatal ( message ) ; } 
protected final void fatalImpl ( Object message , Throwable ) { _category . fatal ( message , ) ; } 
protected final boolean isDebugEnabledImpl ( ) { return _category . isDebugEnabled ( ) ; } 
protected final boolean isInfoEnabledImpl ( ) { return _category . isInfoEnabled ( ) ; } 
public void debug ( Object message ) { logger . log ( Level . FINEST , message . toString ( ) ) ; 
public void debug ( Object message , Throwable exception ) { logger . log ( Level . FINEST , message . toString ( ) , exception ) ; 
public void error ( Object message ) { logger . log ( Level . SEVERE , message . toString ( ) ) ; 
public void error ( Object message , Throwable exception ) { logger . log ( Level . SEVERE , message . toString ( ) , exception ) ; 
public void fatal ( Object message ) { logger . log ( Level . SEVERE , message . toString ( ) ) ; 
public void fatal ( Object message , Throwable exception ) { logger . log ( Level . SEVERE , message . toString ( ) , exception ) ; 
public void info ( Object message ) { logger . log ( Level . INFO , message . toString ( ) ) ; 
public void info ( Object message , Throwable exception ) { logger . log ( Level . INFO , message . toString ( ) , exception ) ; 
public boolean isDebugEnabled ( ) { return ( logger . isLoggable ( Level . FINEST ) ) ; 
public boolean isInfoEnabled ( ) { return ( logger . isLoggable ( Level . INFO ) ) ; 
public void warn ( Object message ) { logger . log ( Level . WARNING , message . toString ( ) ) ; 
public void warn ( Object message , Throwable exception ) { logger . log ( Level . WARNING , message . toString ( ) , exception ) ; 
static public void setLogImplementation ( String classname ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { Class logclass = Class . forName ( classname ) ; 
static public Log makeNewLogInstance ( String name ) { Log log = null ; try { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = name ; log = ( Log ) ( _logimplctor . newInstance ( args ) ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; 
protected final void debugImpl ( Object message ) { if ( message ! = null ) { logger . debug ( message . toString ( ) ) ; 
protected final void debugImpl ( Object message , Throwable ) { if ( message ! = null ) { logger . debug ( message . toString ( ) , ) ; 
protected final void infoImpl ( Object message ) { if ( message ! = null ) { logger . info ( message . toString ( ) ) ; 
protected final void infoImpl ( Object message , Throwable ) { if ( message ! = null ) { logger . info ( message . toString ( ) , ) ; 
protected final void warnImpl ( Object message ) { if ( message ! = null ) { logger . warn ( message . toString ( ) ) ; 
protected final void warnImpl ( Object message , Throwable ) { if ( message ! = null ) { logger . warn ( message . toString ( ) , ) ; 
protected final void errorImpl ( Object message ) { if ( message ! = null ) { logger . error ( message . toString ( ) ) ; 
protected final void errorImpl ( Object message , Throwable ) { if ( message ! = null ) { logger . error ( message . toString ( ) , ) ; 
protected final void fatalImpl ( Object message ) { if ( message ! = null ) { logger . fatalError ( message . toString ( ) ) ; 
protected final void fatalImpl ( Object message , Throwable ) { if ( message ! = null ) { logger . fatalError ( message . toString ( ) , ) ; 
protected boolean isInfoEnabledImpl ( ) { return logger . isInfoEnabled ( ) ; } 
protected boolean isDebugEnabledImpl ( ) { return logger . isDebugEnabled ( ) ; } 
public final boolean isErrorEnabled ( ) { if ( isLevelEnabled ( Log . ERROR ) ) { return isErrorEnabledImpl ( ) ; } return false ; } 
public final boolean isFatalEnabled ( ) { if ( isLevelEnabled ( Log . FATAL ) ) { return isFatalEnabledImpl ( ) ; } return false ; } 
public final boolean isWarnEnabled ( ) { if ( isLevelEnabled ( Log . WARN ) ) { return isWarnEnabledImpl ( ) ; } return false ; } 
protected abstract void debugImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void debugImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void infoImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void infoImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void warnImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void warnImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void errorImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void errorImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void fatalImpl ( Object message ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected abstract void fatalImpl ( Object message , Throwable ) ; protected boolean isLevelEnabled(int logLevel) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); }} 
protected boolean isLevelEnabled ( int logLevel ) { log level are numerically ordered so can use simple numeric comparison return (logLevel >= currentLogLevel); } 
public boolean isErrorEnabled ( ) { return ( logger . isLoggable ( Level . SEVERE ) ) ; 
public boolean isFatalEnabled ( ) { return ( logger . isLoggable ( Level . SEVERE ) ) ; 
public boolean isWarnEnabled ( ) { return ( logger . isLoggable ( Level . WARNING ) ) ; 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) { category . debug ( message , ) ; } 
public void info ( Object message , Throwable ) { category . info ( message , ) ; } 
public void warn ( Object message , Throwable ) { category . warn ( message , ) ; } 
public void error ( Object message , Throwable ) { category . error ( message , ) ; } 
public void fatal ( Object message , Throwable ) { category . fatal ( message , ) ; } 
public boolean isErrorEnabled ( ) { return category . isEnabledFor ( Priority . ERROR ) ; } 
public boolean isFatalEnabled ( ) { return category . isEnabledFor ( Priority . FATAL ) ; } 
public boolean isWarnEnabled ( ) { return category . isEnabledFor ( Priority . WARN ) ; } 
public void debug ( Object message ) { if ( message ! = null ) { logger . debug ( message . toString ( ) ) ; 
public void debug ( Object message , Throwable ) { if ( message ! = null ) { logger . debug ( message . toString ( ) , ) ; 
public void info ( Object message ) { if ( message ! = null ) { logger . info ( message . toString ( ) ) ; 
public void info ( Object message , Throwable ) { if ( message ! = null ) { logger . info ( message . toString ( ) , ) ; 
public void warn ( Object message ) { if ( message ! = null ) { logger . warn ( message . toString ( ) ) ; 
public void warn ( Object message , Throwable ) { if ( message ! = null ) { logger . warn ( message . toString ( ) , ) ; 
public void error ( Object message ) { if ( message ! = null ) { logger . error ( message . toString ( ) ) ; 
public void error ( Object message , Throwable ) { if ( message ! = null ) { logger . error ( message . toString ( ) , ) ; 
public void fatal ( Object message ) { if ( message ! = null ) { logger . fatalError ( message . toString ( ) ) ; 
public void fatal ( Object message , Throwable ) { if ( message ! = null ) { logger . fatalError ( message . toString ( ) , ) ; 
public boolean isFatalEnabled ( ) { return logger . isFatalErrorEnabled ( ) ; } 
public void debug ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
static public void setLogImplementation ( Class logclass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; logImplctor = logclass . getConstructor ( argtypes ) ; } 
static public Log makeNewLogInstance ( String name ) { Log log = null ; try { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = name ; log = ( Log ) ( logImplctor . newInstance ( args ) ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; don't have any tests anymore suite.addTest(TestLogLevels.suite()); return suite; } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) { logger . log ( Level . FINE , message . toString ( ) ) ; 
public void debug ( Object message , Throwable exception ) { logger . log ( Level . FINE , message . toString ( ) , exception ) ; 
public boolean isDebugEnabled ( ) { return ( logger . isLoggable ( Level . FINE ) ) ; 
public boolean isTraceEnabled ( ) { return ( logger . isLoggable ( Level . FINEST ) ) ; 
public void trace ( Object message ) { logger . log ( Level . FINEST , message . toString ( ) ) ; 
public void trace ( Object message , Throwable exception ) { logger . log ( Level . FINEST , message . toString ( ) , exception ) ; 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) { category . debug ( message , ) ; } 
public void trace ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
static public void setLogImplementation ( String classname ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { Class logclass = Class . forName ( classname ) ; 
static public void setLogImplementation ( Class logclass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; logImplctor = logclass . getConstructor ( argtypes ) ; } 
static public Log makeNewLogInstance ( String name ) { Log log = null ; try { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = name ; log = ( Log ) ( logImplctor . newInstance ( args ) ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; 
public abstract Object getAttribute ( String name ) ; private static LogFactory newInstance(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; private static LogFactory newInstance(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; private static LogFactory newInstance(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; private static LogFactory newInstance(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; --------------------------------------------------------- Static Methods private static LogFactory newInstance(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public static LogFactory newFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader classLoader = findClassLoader(); First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { return (newInstance(factoryClass, classLoader)); } } catch (SecurityException e) { ; } Second, try a properties file try { InputStream stream = classLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { LogFactory instance = newInstance(factoryClass, classLoader); Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); instance.setAttribute(name, value); } return (instance); } } } catch (IOException e) { } catch (SecurityException e) { } Third, try the fallback implementation class return (newInstance(FACTORY_DEFAULT, classLoader)); 
protected static ClassLoader findClassLoader ( ) throws LogConfigurationException { Are we running on a JDK 1.2 or later system? Method method = null; try { method = Thread.class.getMethod("getContextClassLoader", null); } catch (NoSuchMethodException e) { Assume we are running on JDK 1.1 return (LogFactory.class.getClassLoader()); } Get the thread context class loader (if there is one) ClassLoader classLoader = null; try { classLoader = (ClassLoader) method.invoke(Thread.currentThread(), null); if (classLoader == null) { classLoader = LogFactory.class.getClassLoader(); } } catch (IllegalAccessException e) { throw new LogConfigurationException ("Unexpected IllegalAccessException", e); } catch (InvocationTargetException e) { throw new LogConfigurationException ("Unexpected InvocationTargetException", e); } Return the selected class loader return (classLoader); 
private static LogFactory newInstance ( String factoryClass , ClassLoader classLoader ) throws LogConfigurationException { try { Class clazz = null ; 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance ! = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return ( instance ) ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return (logConstructor); } Identify the Log implementation class we will be using String logClassName = null; try { logClassName = System.getProperty(LOG_PROPERTY); if (logClassName == null) { @deprecated logClassName = System.getProperty(LOG_PROPERTY_OLD); } if ((logClassName == null) && isLog4JAvailable()) { logClassName = "org.apache.commons.logging.impl.Log4JCategoryLog"; } if ((logClassName == null) && isJdk14Available()) { logClassName = "org.apache.commons.logging.impl.Jdk14Logger"; } if (logClassName == null) { logClassName = "org.apache.commons.logging.impl.NoOpLog"; } } catch (SecurityException e) { } Attempt to load the Log implementation class Class logClass = null; try { logClass = findClassLoader().loadClass(logClassName); if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
protected boolean isJdk14Available ( ) { try { findClassLoader ( ) . loadClass ( " java.util.logging.Logger " ) ; 
protected boolean isLog4JAvailable ( ) { try { findClassLoader ( ) . loadClass ( " org.apache.log4j.Category " ) ; 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance = null ; try { Object params [ ] = new Object [ 1 ] ; 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader classLoader = findClassLoader(); Return any previously registered factory for this class loader LogFactory factory = (LogFactory) factories.get(classLoader); if (factory != null) { return (factory); } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, classLoader); } } catch (SecurityException e) { ; } Second, try a properties file if (factory == null) { try { InputStream stream = classLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, classLoader); Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } } catch (IOException e) { } catch (SecurityException e) { } } Third, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, classLoader); } Cache and return the new factory instance factories.put(classLoader, factory); return (factory); 
public static Log getLog ( Class clazz ) throws LogConfigurationException { return ( getFactory ( ) . getInstance ( clazz ) ) ; 
public static Log getLog ( String name ) throws LogConfigurationException { return ( getFactory ( ) . getInstance ( name ) ) ; 
public static void releaseAll ( ) { synchronized ( factories ) { Enumeration elements = factories . elements ( ) ; 
protected static LogFactory newFactory ( String factoryClass , ClassLoader classLoader ) throws LogConfigurationException { try { Class clazz = null ; 
public Log getInstance ( Class clazz ) throws LogConfigurationException { return ( getInstance ( clazz . getName ( ) ) ) ; 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader classLoader = findClassLoader(); Return any previously registered factory for this class loader LogFactory factory = (LogFactory) factories.get(classLoader); if (factory != null) { return (factory); } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, classLoader); } } catch (SecurityException e) { ; } Second, try a properties file if (factory == null) { try { InputStream stream = classLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, classLoader); Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } catch (IOException e) { } catch (SecurityException e) { } } Third, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, classLoader); } Cache and return the new factory instance factories.put(classLoader, factory); return (factory); 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return ( instance ) ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return (logConstructor); } Identify the Log implementation class we will be using String logClassName = null; try { logClassName = (String) getAttribute(LOG_PROPERTY); if (logClassName == null) { @deprecated logClassName = (String) getAttribute(LOG_PROPERTY_OLD); } if (logClassName == null) { logClassName = System.getProperty(LOG_PROPERTY); } if (logClassName == null) { @deprecated logClassName = System.getProperty(LOG_PROPERTY_OLD); } if ((logClassName == null) && isLog4JAvailable()) { logClassName = "org.apache.commons.logging.impl.Log4JCategoryLog"; } if ((logClassName == null) && isJdk14Available()) { logClassName = "org.apache.commons.logging.impl.Jdk14Logger"; } if (logClassName == null) { logClassName = LOG_DEFAULT; } } catch (SecurityException e) { } Attempt to load the Log implementation class Class logClass = null; try { logClass = findClassLoader().loadClass(logClassName); if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { clazz = classLoader.loadClass(factoryClass); } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader classLoader = findClassLoader(); Return any previously registered factory for this class loader LogFactory factory = (LogFactory) factories.get(classLoader); if (factory != null) { return (factory); } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, classLoader); } } catch (SecurityException e) { ; } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if( factory==null ) { try { InputStream is=null; if (classLoader == null) { is=ClassLoader.getSystemResourceAsStream( SERVICE_ID ); } else { is=classLoader.getResourceAsStream( SERVICE_ID ); } if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, classLoader ); } } } catch( Exception ex ) { ; } } Properties props=null; Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) try { InputStream stream = classLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if( factory==null ) { if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, classLoader); } } the properties will be set at the end. } catch (IOException e) { } catch (SecurityException e) { } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, classLoader); } if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } Cache and return the new factory instance factories.put(classLoader, factory); return (factory); 
public Log getInstance ( Class clazz ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( clazz ) ; if ( instance ! = null ) return instance ; instance = new Log4JCategoryLog ( Category . getInstance ( clazz ) ) ; instances . put ( clazz , instance ) ; return instance ; } 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance ! = null ) return instance ; instance = new Log4JCategoryLog ( Category . getInstance ( name ) ) ; instances . put ( name , instance ) ; return instance ; } 
public Log getInstance ( Class clazz ) throws LogConfigurationException { if ( proxyFactory ! = null ) return proxyFactory . getInstance ( clazz ) ; return ( getInstance ( clazz . getName ( ) ) ) ; 
public Log getInstance ( String name ) throws LogConfigurationException { if ( proxyFactory ! = null ) return proxyFactory . getInstance ( name ) ; Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return ( instance ) ; 
public void release ( ) { if ( proxyFactory ! = null ) proxyFactory . release ( ) ; instances . clear ( ) ; 
public void removeAttribute ( String name ) { if ( proxyFactory ! = null ) proxyFactory . removeAttribute ( name ) ; attributes . remove ( name ) ; } 
protected void guessConfig ( ) { if ( isLog4JAvailable ( ) ) { try { 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); throw new LogConfigurationException(e); } }} 
protected static LogFactory newFactory ( String factoryClass , ClassLoader classLoader ) throws LogConfigurationException { try { Class clazz = null ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return (logConstructor); } Identify the Log implementation class we will be using String logClassName = null; try { logClassName = (String) getAttribute(LOG_PROPERTY); if (logClassName == null) { @deprecated logClassName = (String) getAttribute(LOG_PROPERTY_OLD); } if (logClassName == null) { logClassName = System.getProperty(LOG_PROPERTY); } if (logClassName == null) { @deprecated logClassName = System.getProperty(LOG_PROPERTY_OLD); } if ((logClassName == null) && isLog4JAvailable()) { logClassName = "org.apache.commons.logging.impl.Log4JCategoryLog"; } if ((logClassName == null) && isJdk14Available()) { logClassName = "org.apache.commons.logging.impl.Jdk14Logger"; } if (logClassName == null) { logClassName = LOG_DEFAULT; } } catch (SecurityException e) { } Attempt to load the Log implementation class Class logClass = null; try { logClass = loadClass(logClassName); if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
static Class loadClass ( String name ) throws ClassNotFoundException { ClassLoader threadCL = findClassLoader ( ) ; try { return threadCL . loadClass ( name ) ; 
protected boolean isJdk14Available ( ) { try { loadClass ( " java.util.logging.Logger " ) ; 
protected boolean isLog4JAvailable ( ) { try { loadClass ( " org.apache.log4j.Category " ) ; 
public void trace ( Object message ) { category . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void trace ( Object message , Throwable ) { category . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void debug ( Object message ) { category . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void debug ( Object message , Throwable ) { category . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void info ( Object message ) { category . log ( FQCN , Priority . INFO , message , null ) ; } 
public void info ( Object message , Throwable ) { category . log ( FQCN , Priority . INFO , message , ) ; } 
public void warn ( Object message ) { category . log ( FQCN , Priority . WARN , message , null ) ; } 
public void warn ( Object message , Throwable ) { category . log ( FQCN , Priority . WARN , message , ) ; } 
public void error ( Object message ) { category . log ( FQCN , Priority . ERROR , message , null ) ; } 
public void error ( Object message , Throwable ) { category . log ( FQCN , Priority . ERROR , message , ) ; } 
public void fatal ( Object message ) { category . log ( FQCN , Priority . FATAL , message , null ) ; } 
public void fatal ( Object message , Throwable ) { category . log ( FQCN , Priority . FATAL , message , ) ; } 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return (logConstructor); } Identify the Log implementation class we will be using String logClassName = null; if (logClassName == null) { logClassName = (String) getAttribute(LOG_PROPERTY); } if (logClassName == null) { @deprecated logClassName = (String) getAttribute(LOG_PROPERTY_OLD); } if (logClassName == null) { try { logClassName = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { ; } } if (logClassName == null) { @deprecated try { logClassName = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { ; } } if ((logClassName == null) && isLog4JAvailable()) { logClassName = "org.apache.commons.logging.impl.Log4JCategoryLog"; } if ((logClassName == null) && isJdk14Available()) { logClassName = "org.apache.commons.logging.impl.Jdk14Logger"; } if (logClassName == null) { logClassName = LOG_DEFAULT; } Attempt to load the Log implementation class Class logClass = null; try { logClass = loadClass(logClassName); if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
public abstract Object getAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract String [ ] getAttributeNames ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void release ( ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void removeAttribute ( String name ) ; protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public abstract void setAttribute ( String name , Object value ) ; ------------------------------------------------------- Static Variables protected static LogFactory newFactory(String factoryClass, ClassLoader classLoader) throws LogConfigurationException { try { Class clazz = null; if (classLoader == null) { clazz = Class.forName(factoryClass); } else { try { first the thread class loader clazz = classLoader.loadClass(factoryClass); } catch( ClassNotFoundException ex ) { if this failed ( i.e. no implementation is found in the webapp itself ) try the caller's loader clazz = Class.forName( factoryClass ); } } return ((LogFactory) clazz.newInstance()); } catch (Exception e) { throw new LogConfigurationException(e); } }} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader classLoader = findClassLoader(); Return any previously registered factory for this class loader LogFactory factory = (LogFactory) factories.get(classLoader); if (factory != null) { return (factory); } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, classLoader); } } catch (SecurityException e) { ; } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if( factory==null ) { try { InputStream is=null; if (classLoader == null) { is=ClassLoader.getSystemResourceAsStream( SERVICE_ID ); } else { is=classLoader.getResourceAsStream( SERVICE_ID ); } if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, classLoader ); } } } catch( Exception ex ) { ; } } Properties props=null; Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) try { InputStream stream = classLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if( factory==null ) { if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, classLoader); } } the properties will be set at the end. } catch (IOException e) { } catch (SecurityException e) { } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } Cache and return the new factory instance factories.put(classLoader, factory); return (factory); 
private void log ( Level level , String msg , Throwable ex ) { Hack (?) to get the stack trace. Throwable dummyException=new Throwable(); StackTraceElement locations[]=dummyException.getStackTrace(); Caller will be the third element String cname="unknown"; String method="unknown"; if( locations!=null && locations.length >2 ) { StackTraceElement caller=locations[2]; cname=caller.getClassName(); method=caller.getMethodName(); } if( ex==null ) { logger.logp( level, cname, method, msg ); 
public void debug ( Object message ) { log ( Level . FINE , message . toString ( ) , null ) ; 
public void debug ( Object message , Throwable exception ) { log ( Level . FINE , message . toString ( ) , exception ) ; 
public void error ( Object message ) { log ( Level . SEVERE , message . toString ( ) , null ) ; 
public void error ( Object message , Throwable exception ) { log ( Level . SEVERE , message . toString ( ) , exception ) ; 
public void fatal ( Object message ) { log ( Level . SEVERE , message . toString ( ) , null ) ; 
public void fatal ( Object message , Throwable exception ) { log ( Level . SEVERE , message . toString ( ) , exception ) ; 
public void info ( Object message ) { log ( Level . INFO , message . toString ( ) , null ) ; 
public void info ( Object message , Throwable exception ) { log ( Level . INFO , message . toString ( ) , exception ) ; 
public void trace ( Object message ) { log ( Level . FINEST , message . toString ( ) , null ) ; 
public void trace ( Object message , Throwable exception ) { log ( Level . FINEST , message . toString ( ) , exception ) ; 
public void warn ( Object message ) { log ( Level . WARNING , message . toString ( ) , null ) ; 
public void warn ( Object message , Throwable exception ) { log ( Level . WARNING , message . toString ( ) , exception ) ; 
private void initialize ( ) { Category root = Category . getRoot ( ) ; Enumeration appenders = root . getAllAppenders ( ) ; if ( appenders = = null | | ! appenders . hasMoreElements ( ) ) { No config, set some defaults ( consistent with commons-logging patterns ). ConsoleAppender app=new ConsoleAppender(new PatternLayout( LAYOUT ), ConsoleAppender.SYSTEM_ERR ); root.addAppender( app ); root.setPriority( Priority.INFO ); } initialized=true; } 
private void initialize ( ) { Category root = Category . getRoot ( ) ; Enumeration appenders = root . getAllAppenders ( ) ; if ( appenders = = null | | ! appenders . hasMoreElements ( ) ) { No config, set some defaults ( consistent with commons-logging patterns ). ConsoleAppender app=new ConsoleAppender(new PatternLayout( LAYOUT ), ConsoleAppender.SYSTEM_ERR ); app.setName("stderr"); root.addAppender( app ); root.setPriority( Priority.INFO ); } initialized=true; } 
private void initialize ( ) { Category root = Category . getRoot ( ) ; Enumeration appenders = root . getAllAppenders ( ) ; if ( appenders = = null | | ! appenders . hasMoreElements ( ) ) { No config, set some defaults ( consistent with commons-logging patterns ). ConsoleAppender app=new ConsoleAppender(new PatternLayout( LAYOUT ), ConsoleAppender.SYSTEM_ERR ); app.setName("commons-logging"); root.addAppender( app ); root.setPriority( Priority.INFO ); } initialized=true; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( SERVICE_ID ) : contextClassLoader.getResourceAsStream( SERVICE_ID )); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Properties props=null; Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) try { InputStream stream = contextClassLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if( factory==null ) { if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, contextClassLoader); } } the properties will be set at the end. } catch (IOException e) { } catch (SecurityException e) { } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } return factory; } 
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { if ( classLoader ! = null & & factory ! = null ) factories . put ( classLoader , factory ) ; 
protected static LogFactory newFactory ( String factoryClass , ClassLoader classLoader ) throws LogConfigurationException { try { if ( classLoader = = null ) 
static Class loadClass ( String name ) throws ClassNotFoundException { ClassLoader threadCL = getContextClassLoader ( ) ; try { return threadCL . loadClass ( name ) ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return (logConstructor); } Identify the Log implementation class we will be using String logClassName = null; if (logClassName == null) { logClassName = (String) getAttribute(LOG_PROPERTY); } if (logClassName == null) { @deprecated logClassName = (String) getAttribute(LOG_PROPERTY_OLD); } if (logClassName == null) { try { logClassName = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { ; } } if (logClassName == null) { @deprecated try { logClassName = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { ; } } if ((logClassName == null) && isLog4JAvailable()) { logClassName = "org.apache.commons.logging.impl.Log4JCategoryLog"; } if ((logClassName == null) && isJdk14Available()) { logClassName = "org.apache.commons.logging.impl.Jdk14Logger"; } if (logClassName == null) { logClassName = LOG_DEFAULT; } Attempt to load the Log implementation class Class logClass = null; try { logClass = loadClass(logClassName); if (logClass == null) { throw new LogConfigurationException ("No suitable Log implementation for " + logClassName); } if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
static Class loadClass ( String name ) throws ClassNotFoundException { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { try { return threadCL . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name ) ; } } return null ; } 
protected void guessConfig ( ) { if ( isLog4JAvailable ( ) ) { proxyFactory = null ; 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) { log ( Level . FINE , String . valueOf ( message ) , null ) ; } 
public void debug ( Object message , Throwable exception ) { log ( Level . FINE , String . valueOf ( message ) , exception ) ; } 
public void error ( Object message ) { log ( Level . SEVERE , String . valueOf ( message ) , null ) ; } 
public void error ( Object message , Throwable exception ) { log ( Level . SEVERE , String . valueOf ( message ) , exception ) ; } 
public void fatal ( Object message ) { log ( Level . SEVERE , String . valueOf ( message ) , null ) ; } 
public void fatal ( Object message , Throwable exception ) { log ( Level . SEVERE , String . valueOf ( message ) , exception ) ; } 
public void info ( Object message ) { log ( Level . INFO , String . valueOf ( message ) , null ) ; } 
public void info ( Object message , Throwable exception ) { log ( Level . INFO , String . valueOf ( message ) , exception ) ; } 
public boolean isDebugEnabled ( ) { return ( logger . isLoggable ( Level . FINE ) ) ; } 
public boolean isErrorEnabled ( ) { return ( logger . isLoggable ( Level . SEVERE ) ) ; } 
public boolean isFatalEnabled ( ) { return ( logger . isLoggable ( Level . SEVERE ) ) ; } 
public boolean isInfoEnabled ( ) { return ( logger . isLoggable ( Level . INFO ) ) ; } 
public boolean isTraceEnabled ( ) { return ( logger . isLoggable ( Level . FINEST ) ) ; } 
public boolean isWarnEnabled ( ) { return ( logger . isLoggable ( Level . WARNING ) ) ; } 
public void trace ( Object message ) { log ( Level . FINEST , String . valueOf ( message ) , null ) ; } 
public void trace ( Object message , Throwable exception ) { log ( Level . FINEST , String . valueOf ( message ) , exception ) ; } 
public void warn ( Object message ) { log ( Level . WARNING , String . valueOf ( message ) , null ) ; } 
public void warn ( Object message , Throwable exception ) { log ( Level . WARNING , String . valueOf ( message ) , exception ) ; } 
public void debug ( Object message ) { if ( message ! = null ) { logger . debug ( String . valueOf ( message ) ) ; 
public void debug ( Object message , Throwable ) { if ( message ! = null ) { logger . debug ( String . valueOf ( message ) , ) ; 
public void info ( Object message ) { if ( message ! = null ) { logger . info ( String . valueOf ( message ) ) ; 
public void info ( Object message , Throwable ) { if ( message ! = null ) { logger . info ( String . valueOf ( message ) , ) ; 
public void warn ( Object message ) { if ( message ! = null ) { logger . warn ( String . valueOf ( message ) ) ; 
public void warn ( Object message , Throwable ) { if ( message ! = null ) { logger . warn ( String . valueOf ( message ) , ) ; 
public void error ( Object message ) { if ( message ! = null ) { logger . error ( String . valueOf ( message ) ) ; 
public void error ( Object message , Throwable ) { if ( message ! = null ) { logger . error ( String . valueOf ( message ) , ) ; 
public void fatal ( Object message ) { if ( message ! = null ) { logger . fatalError ( String . valueOf ( message ) ) ; 
public void fatal ( Object message , Throwable ) { if ( message ! = null ) { logger . fatalError ( String . valueOf ( message ) , ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( SERVICE_ID ) : contextClassLoader.getResourceAsStream( SERVICE_ID )); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Properties props=null; Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) try { InputStream stream = contextClassLoader.getResourceAsStream(FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if( factory==null ) { if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, contextClassLoader); } } the properties will be set at the end. } catch (IOException e) { } catch (SecurityException e) { } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); } if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } return factory; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return getContextClassLoader(); } }); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( SERVICE_ID ) : contextClassLoader.getResourceAsStream( SERVICE_ID )); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Properties props=null; Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) try { InputStream stream = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( FACTORY_PROPERTIES ) : contextClassLoader.getResourceAsStream( FACTORY_PROPERTIES )); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); String factoryClass = props.getProperty(FACTORY_PROPERTY); if( factory==null ) { if (factoryClass == null) { factoryClass = FACTORY_DEFAULT; } factory = newFactory(factoryClass, contextClassLoader); } } the properties will be set at the end. } catch (IOException e) { } catch (SecurityException e) { } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); } if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } return factory; } 
public Object run ( ) { return getContextClassLoader ( ) ; } 
private static Class loadClass ( final String name ) throws ClassNotFoundException { Object result = AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { try { return threadCL . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { ignore } } try { return Class.forName( name ); } catch (ClassNotFoundException e) { return e; } } }); if (result instanceof Class) return (Class)result; throw (ClassNotFoundException)result; } 
public Object run ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { try { return threadCL . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { ignore } } try { return Class.forName( name ); 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; todo suite.addTest(TestLogLevels.suite()); return suite; } 
public static void main ( String args [ ] ) { String [ ] testCaseName = { AbstractLogTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; } } 
public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; 
public static void main ( String [ ] args ) { String [ ] testCaseName = { NoOpLogTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( NoOpLogTest . class ) ; return suite ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { SimpleLogTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( SimpleLogTest . class ) ; return suite ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SimpleLogTest . suite ( ) ) ; suite . addTest ( NoOpLogTest . suite ( ) ) ; return suite ; } 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( " debug statement " ) ; tlog . debug ( " debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( " error statement " ) ; tlog . error ( " error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( " fatal statement " ) ; tlog . fatal ( " fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( " info statement " ) ; tlog . info ( " info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( " trace statement " ) ; tlog . trace ( " trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( " warn statement " ) ; tlog . warn ( " warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( " debug statement " ) ; tlog . debug ( " debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( " error statement " ) ; tlog . error ( " error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( " fatal statement " ) ; tlog . fatal ( " fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( " info statement " ) ; tlog . info ( " info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( " trace statement " ) ; tlog . trace ( " trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( " warn statement " ) ; tlog . warn ( " warn statement w/ null exception " , new RuntimeException ( ) ) ; 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . debug ( " debug statement " ) ; tlog . debug ( " debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . error ( " error statement " ) ; tlog . error ( " error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . fatal ( " fatal statement " ) ; tlog . fatal ( " fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . info ( " info statement " ) ; tlog . info ( " info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . trace ( " trace statement " ) ; tlog . trace ( " trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; tlog . warn ( " warn statement " ) ; tlog . warn ( " warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . debug ( " debug statement " ) ; tlog . debug ( " debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . error ( " error statement " ) ; tlog . error ( " error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . fatal ( " fatal statement " ) ; tlog . fatal ( " fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . info ( " info statement " ) ; tlog . info ( " info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . trace ( " trace statement " ) ; tlog . trace ( " trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; tlog . warn ( " warn statement " ) ; tlog . warn ( " warn statement w/ null exception " , new RuntimeException ( ) ) ; 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; tlog . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; tlog . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; tlog . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; tlog . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; tlog . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; tlog . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; tlog . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { tLog log = this . getLogObject ( ) ; tassertNotNull ( log ) ; tlog . debug ( null ) ; tlog . debug ( null , null ) ; tlog . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; tlog . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; tlog . error ( null ) ; tlog . error ( null , null ) ; tlog . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; tlog . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; tlog . fatal ( null ) ; tlog . fatal ( null , null ) ; tlog . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; tlog . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; tlog . info ( null ) ; tlog . info ( null , null ) ; tlog . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; tlog . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; tlog . trace ( null ) ; tlog . trace ( null , null ) ; tlog . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; tlog . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; tlog . warn ( null ) ; tlog . warn ( null , null ) ; tlog . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; tlog . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { LogTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( LogTest . class ) ; return suite ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SimpleLogTest . suite ( ) ) ; suite . addTest ( NoOpLogTest . suite ( ) ) ; suite . addTest ( LogTest . suite ( ) ) ; return suite ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return getContextClassLoader(); } }); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; Load properties file.. will be used one way or another in the end. Properties props=null; try { InputStream stream = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( FACTORY_PROPERTIES ) : contextClassLoader.getResourceAsStream( FACTORY_PROPERTIES )); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { } catch (SecurityException e) { } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = (contextClassLoader == null ? ClassLoader.getSystemResourceAsStream( SERVICE_ID ) : contextClassLoader.getResourceAsStream( SERVICE_ID )); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null && props != null) { String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static LogFactory newFactory ( String factoryClass , ClassLoader classLoader ) throws LogConfigurationException { try { if ( classLoader ! = null ) { 
public Log getInstance ( Class clazz ) throws LogConfigurationException { if ( proxyFactory ! = null ) return proxyFactory . getInstance ( clazz ) ; return getInstance ( clazz . getName ( ) ) ; } 
public Log getInstance ( String name ) throws LogConfigurationException { if ( proxyFactory ! = null ) return proxyFactory . getInstance ( name ) ; Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return instance ; } 
public void release ( ) { if ( proxyFactory ! = null ) proxyFactory . release ( ) ; instances . clear ( ) ; } 
public void removeAttribute ( String name ) { if ( proxyFactory ! = null ) proxyFactory . removeAttribute ( name ) ; attributes . remove ( name ) ; } 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return logConstructor; } String logClassName = getLogClassName(); Attempt to load the Log implementation class Class logClass = null; try { logClass = loadClass(logClassName); if (logClass == null) { throw new LogConfigurationException ("No suitable Log implementation for " + logClassName); } if (!Log.class.isAssignableFrom(logClass)) { throw new LogConfigurationException ("Class " + logClassName + " does not implement Log"); } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance = null ; try { Object params [ ] = new Object [ 1 ] ; 
public Log getInstance ( Class clazz ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( clazz ) ; if ( instance ! = null ) return instance ; instance = new Log4JLogger ( Logger . getLogger ( clazz ) ) ; instances . put ( clazz , instance ) ; return instance ; } 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance ! = null ) return instance ; instance = new Log4JLogger ( Logger . getLogger ( name ) ) ; instances . put ( name , instance ) ; return instance ; } 
protected boolean isLog4JAvailable ( ) { try { loadClass ( " org.apache.log4j.Logger " ) ; 
private void initialize ( ) { Logger root = Logger . getRootLogger ( ) ; Enumeration appenders = root . getAllAppenders ( ) ; if ( appenders = = null | | ! appenders . hasMoreElements ( ) ) { No config, set some defaults ( consistent with commons-logging patterns ). ConsoleAppender app=new ConsoleAppender(new PatternLayout( LAYOUT ), ConsoleAppender.SYSTEM_ERR ); app.setName("commons-logging"); root.addAppender( app ); root.setPriority( Priority.INFO ); } initialized=true; } 
public void trace ( Object message ) { logger . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void trace ( Object message , Throwable ) { logger . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void debug ( Object message ) { logger . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void debug ( Object message , Throwable ) { logger . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void info ( Object message ) { logger . log ( FQCN , Priority . INFO , message , null ) ; } 
public void info ( Object message , Throwable ) { logger . log ( FQCN , Priority . INFO , message , ) ; } 
public void warn ( Object message ) { logger . log ( FQCN , Priority . WARN , message , null ) ; } 
public void warn ( Object message , Throwable ) { logger . log ( FQCN , Priority . WARN , message , ) ; } 
public void error ( Object message ) { logger . log ( FQCN , Priority . ERROR , message , null ) ; } 
public void error ( Object message , Throwable ) { logger . log ( FQCN , Priority . ERROR , message , ) ; } 
public void fatal ( Object message ) { logger . log ( FQCN , Priority . FATAL , message , null ) ; } 
public void fatal ( Object message , Throwable ) { logger . log ( FQCN , Priority . FATAL , message , ) ; } 
public boolean isErrorEnabled ( ) { return logger . isEnabledFor ( Priority . ERROR ) ; } 
public boolean isFatalEnabled ( ) { return logger . isEnabledFor ( Priority . FATAL ) ; } 
public boolean isWarnEnabled ( ) { return logger . isEnabledFor ( Priority . WARN ) ; } 
protected void log ( int type , Object message , Throwable ) { if( showShortName) { if( prefix==null ) { cut all but the last component of the name for both styles prefix = logName.substring( logName.lastIndexOf(".") +1) + " - "; prefix = prefix.substring( prefix.lastIndexOf("/") +1) + "-"; } buf.append( prefix ); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } append the message buf.append(String.valueOf(message)); append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } print to System.err System.err.println(buf.toString()); } 
public final void debug ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , null ) ; 
public final void debug ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , ) ; 
public final void trace ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , null ) ; 
public final void trace ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , ) ; 
public final void info ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , null ) ; 
public final void info ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , ) ; 
public final void warn ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , null ) ; 
public final void warn ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , ) ; 
public final void error ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , null ) ; 
public final void error ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , ) ; 
public final void fatal ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , null ) ; 
public final void fatal ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , ) ; 
public final boolean isDebugEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ; } 
public final boolean isErrorEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ; } 
public final boolean isFatalEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ; } 
public final boolean isInfoEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ; } 
public final boolean isTraceEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ; } 
public final boolean isWarnEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return getContextClassLoader(); } }); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; Load properties file.. will be used one way or another in the end. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { } catch (SecurityException e) { } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar with the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null && props != null) { String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static InputStream getResourceAsStream ( final ClassLoader loader , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
public Object run ( ) { if ( loader ! = null ) { return loader . getResourceAsStream ( name ) ; 
public Object run ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { return threadCL . getResourceAsStream ( name ) ; 
public Object run ( ) { try { if ( classLoader ! = null ) { 
public static void release ( ClassLoader classLoader ) { synchronized ( factories ) { LogFactory factory = ( LogFactory ) factories . get ( classLoader ) ; 
protected boolean isJdk14Available ( ) { try { loadClass ( " java.sql.Savepoint " ) ; 
private Class def ( String name ) throws ClassNotFoundException { Class result = ( Class ) classes . get ( name ) ; if ( result ! = null ) { return result ; } try { 
public Class loadClass ( String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exeptions to simlify handling in test for(int i = 0; i < LOG_PCKG.length; i++ ){ if( name.startsWith( LOG_PCKG[i] ) && name.indexOf("Exception") == -1 ){ return def(name); } } return super.loadClass(name); } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try{ execute(cls); fail("SystemClassLoader"); }catch( LogConfigurationException ok ){ } cls = reload(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); try{ execute(cls); 
private Class reload ( ) throws Exception { Class testObjCls = null ; AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( ClassNotFoundException cnfe ) { throw cnfe ; } catch ( Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertTrue ( " app isolated " , testObjCls . getClassLoader ( ) = = appLoader ) ; return testObjCls ; 
private void execute ( Class cls ) throws Exception { cls . newInstance ( ) ; 
public static void main ( String [ ] args ) { String [ ] testCaseName = { LoadTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( LoadTest . class ) ; return suite ; } 
public void setUp ( ) throws Exception { setUpManager ( " org/apache/commons/logging/jdk14/CustomConfig.properties " ) ; setUpLogger ( " TestLogger " ) ; setUpHandlers ( ) ; setUpFactory ( ) ; setUpLog ( " TestLogger " ) ; } 
public static Test suite ( ) { return ( new TestSuite ( CustomConfigTestCase . class ) ) ; } 
public void tearDown ( ) { super . tearDown ( ) ; handlers = null ; logger = null ; manager = null ; } 
public void testPlainMessages ( ) throws Exception { logPlainMessages ( ) ; Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertEquals ( " LogRecord class " , this . getClass ( ) . getName ( ) , record . getSourceClassName ( ) ) ; assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } assertTrue ( ! records . hasNext ( ) ) ; handler . flush ( ) ; 
public void testPristineHandlers ( ) { assertNotNull ( handlers ) ; assertEquals ( 1 , handlers . length ) ; assertTrue ( handlers [ 0 ] instanceof TestHandler ) ; assertNotNull ( handler ) ; 
public void testPristineLog ( ) { super . testPristineLog ( ) ; Assert which logging levels have been enabled assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
public void testPristineLogger ( ) { assertNotNull ( " Logger exists " , logger ) ; assertEquals ( " Logger name " , " TestLogger " , logger . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(logger.isLoggable(Level.SEVERE)); assertTrue(logger.isLoggable(Level.WARNING)); assertTrue(logger.isLoggable(Level.INFO)); assertTrue(logger.isLoggable(Level.CONFIG)); assertTrue(logger.isLoggable(Level.FINE)); assertTrue(!logger.isLoggable(Level.FINER)); assertTrue(!logger.isLoggable(Level.FINEST)); 
protected void logPlainMessages ( ) { log . trace ( " trace " ) ; Should not actually get logged log.debug("debug"); log.info("info"); log.warn("warn"); log.error("error"); } 
protected void setUpLogger ( String name ) throws Exception { logger = Logger . getLogger ( name ) ; } 
protected void setUpManager ( String config ) throws Exception { manager = LogManager . getLogManager ( ) ; InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( config ) ; manager . readConfiguration ( is ) ; is . close ( ) ; } 
public void setUp ( ) throws Exception { setUpFactory ( ) ; setUpLog ( " TestLogger " ) ; } 
public static Test suite ( ) { return ( new TestSuite ( DefaultConfigTestCase . class ) ) ; } 
public void tearDown ( ) { log = null ; if ( factory ! = null ) { factory . releaseAll ( ) ; 
public void testPristineLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Jdk14Logger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? log.isDebugEnabled(); log.isErrorEnabled(); log.isFatalEnabled(); log.isInfoEnabled(); log.isTraceEnabled(); log.isWarnEnabled(); 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; 
protected void setUpFactory ( ) throws Exception { factory = LogFactory . getFactory ( ) ; } 
protected void setUpLog ( String name ) throws Exception { log = factory . getLog ( name ) ; } 
public void close ( ) { } public void flush ( ) { records . clear ( ) ; } public void publish ( LogRecord record ) { records . add ( record ) ; } } 
public void testExceptionMessages ( ) throws Exception { logExceptionMessages ( ) ; checkLogRecords ( true ) ; 
public void testPlainMessages ( ) throws Exception { logPlainMessages ( ) ; checkLogRecords ( false ) ; 
protected void checkLogRecords ( boolean thrown ) { Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertEquals ( " LogRecord class " , this . getClass ( ) . getName ( ) , record . getSourceClassName ( ) ) ; if ( thrown ) { assertEquals ( " LogRecord method " , " logExceptionMessages " , record . getSourceMethodName ( ) ) ; } else { assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } if ( thrown ) { assertNotNull ( " LogRecord thrown " , record . getThrown ( ) ) ; assertTrue ( " LogRecord thrown type " , record . getThrown ( ) instanceof IndexOutOfBoundsException ) ; } else { assertNull ( " LogRecord thrown " , record . getThrown ( ) ) ; } } assertTrue ( ! records . hasNext ( ) ) ; handler . flush ( ) ; } 
protected void logExceptionMessages ( ) { Throwable = new IndexOutOfBoundsException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); } 
public void testPristineLog ( ) { super . testPristineLog ( ) ; Assert which logging levels have been enabled assertTrue(log.isFatalEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
protected void logExceptionMessages ( ) { Throwable = new IndexOutOfBoundsException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
protected void logPlainMessages ( ) { log . trace ( " trace " ) ; Should not actually get logged log.debug("debug"); log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); } 
public void setUp ( ) throws Exception { setUpAppender ( " org/apache/commons/logging/log4j/CustomConfig.properties " ) ; setUpLogger ( " TestLogger " ) ; setUpFactory ( ) ; setUpLog ( " TestLogger " ) ; } 
public void tearDown ( ) { super . tearDown ( ) ; Logger . getRootLogger ( ) . removeAppender ( appender ) ; appender = null ; logger = null ; } 
public void testExceptionMessages ( ) throws Exception { logExceptionMessages ( ) ; checkLoggingEvents ( true ) ; 
public void testPlainMessages ( ) throws Exception { logPlainMessages ( ) ; checkLoggingEvents ( false ) ; 
public void testPristineAppender ( ) { assertNotNull ( " Appender exists " , appender ) ; 
public void testPristineLog ( ) { super . testPristineLog ( ) ; Assert which logging levels have been enabled assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
public void testPristineLogger ( ) { assertNotNull ( " Logger exists " , logger ) ; assertEquals ( " Logger level " , Level . INFO , logger . getEffectiveLevel ( ) ) ; assertEquals ( " Logger name " , " TestLogger " , logger . getName ( ) ) ; 
protected void checkLoggingEvents ( boolean thrown ) { Iterator events = appender . events ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( events . hasNext ( ) ) ; LoggingEvent event = ( LoggingEvent ) events . next ( ) ; assertEquals ( " LoggingEvent level " , testLevels [ i ] , event . getLevel ( ) ) ; assertEquals ( " LoggingEvent message " , testMessages [ i ] , event . getMessage ( ) ) ; if ( thrown ) { assertNotNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) . getThrowable ( ) ) ; assertTrue ( " LoggingEvent thrown type " , event . getThrowableInformation ( ) . getThrowable ( ) instanceof IndexOutOfBoundsException ) ; } else { assertNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) ) ; } } assertTrue ( ! events . hasNext ( ) ) ; appender . flush ( ) ; } 
protected void logExceptionMessages ( ) { Throwable = new IndexOutOfBoundsException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
protected void logPlainMessages ( ) { log . trace ( " trace " ) ; Should not actually get logged log.debug("debug"); Should not actually get logged log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); } 
protected void setUpAppender ( String config ) throws Exception { Properties props = new Properties ( ) ; InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( config ) ; props . load ( is ) ; is . close ( ) ; PropertyConfigurator . configure ( props ) ; Enumeration appenders = Logger . getRootLogger ( ) . getAllAppenders ( ) ; appender = ( TestAppender ) appenders . nextElement ( ) ; } 
public void testPristineLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Log4JLogger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? log.isDebugEnabled(); log.isErrorEnabled(); log.isFatalEnabled(); log.isInfoEnabled(); log.isTraceEnabled(); log.isWarnEnabled(); 
public void close ( ) { } public boolean requiresLayout ( ) { return ( false ) ; } } 
private void log ( Level level , String msg , Throwable ex ) { if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
protected void checkLoggingEvents ( boolean thrown ) { Iterator events = appender . events ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( " Logged event " + i + " exists " , events . hasNext ( ) ) ; LoggingEvent event = ( LoggingEvent ) events . next ( ) ; assertEquals ( " LoggingEvent level " , testLevels [ i ] , event . getLevel ( ) ) ; assertEquals ( " LoggingEvent message " , testMessages [ i ] , event . getMessage ( ) ) ; if ( thrown ) { assertNotNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) . getThrowable ( ) ) ; assertTrue ( " LoggingEvent thrown type " , event . getThrowableInformation ( ) . getThrowable ( ) instanceof IndexOutOfBoundsException ) ; } else { assertNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) ) ; } } assertTrue ( ! events . hasNext ( ) ) ; appender . flush ( ) ; } 
public Log getInstance ( Class clazz ) throws LogConfigurationException { return ( getInstance ( clazz . getName ( ) ) ) ; 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return ( instance ) ; 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance = null ; try { Object params [ ] = new Object [ 1 ] ; 
public Object run ( ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
public void debug ( Object o , Throwable ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( o . toString ( ) , ) ; } 
public void debug ( Object o ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( o . toString ( ) ) ; } 
public void error ( Object o , Throwable ) { if ( this . logger . isErrorEnabled ( ) ) this . logger . error ( o . toString ( ) , ) ; } 
public void error ( Object o ) { if ( this . logger . isErrorEnabled ( ) ) this . logger . error ( o . toString ( ) ) ; } 
public void fatal ( Object o , Throwable ) { if ( this . logger . isFatalErrorEnabled ( ) ) this . logger . fatalError ( o . toString ( ) , ) ; } 
public void fatal ( Object o ) { if ( this . logger . isFatalErrorEnabled ( ) ) this . logger . fatalError ( o . toString ( ) ) ; } 
public void info ( Object o , Throwable ) { if ( this . logger . isInfoEnabled ( ) ) this . logger . info ( o . toString ( ) , ) ; } 
public void info ( Object o ) { if ( this . logger . isInfoEnabled ( ) ) this . logger . info ( o . toString ( ) ) ; } 
public boolean isDebugEnabled ( ) { return this . logger . isDebugEnabled ( ) ; } 
public boolean isErrorEnabled ( ) { return this . logger . isErrorEnabled ( ) ; } 
public boolean isFatalEnabled ( ) { return this . logger . isFatalErrorEnabled ( ) ; } 
public boolean isInfoEnabled ( ) { return this . logger . isInfoEnabled ( ) ; } 
public boolean isTraceEnabled ( ) { return this . logger . isDebugEnabled ( ) ; } 
public boolean isWarnEnabled ( ) { return this . logger . isWarnEnabled ( ) ; } 
public void trace ( Object o , Throwable ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( o . toString ( ) , ) ; } 
public void trace ( Object o ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( o . toString ( ) ) ; } 
public void warn ( Object o , Throwable ) { if ( this . logger . isWarnEnabled ( ) ) this . logger . warn ( o . toString ( ) , ) ; } 
public void warn ( Object o ) { if ( this . logger . isWarnEnabled ( ) ) this . logger . warn ( o . toString ( ) ) ; } 
public void debug ( Object o , Throwable ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( String . valueOf ( o ) , ) ; } 
public void debug ( Object o ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( String . valueOf ( o ) ) ; } 
public void error ( Object o , Throwable ) { if ( this . logger . isErrorEnabled ( ) ) this . logger . error ( String . valueOf ( o ) , ) ; } 
public void error ( Object o ) { if ( this . logger . isErrorEnabled ( ) ) this . logger . error ( String . valueOf ( o ) ) ; } 
public void fatal ( Object o , Throwable ) { if ( this . logger . isFatalErrorEnabled ( ) ) this . logger . fatalError ( String . valueOf ( o ) , ) ; } 
public void fatal ( Object o ) { if ( this . logger . isFatalErrorEnabled ( ) ) this . logger . fatalError ( String . valueOf ( o ) ) ; } 
public void info ( Object o , Throwable ) { if ( this . logger . isInfoEnabled ( ) ) this . logger . info ( String . valueOf ( o ) , ) ; } 
public void info ( Object o ) { if ( this . logger . isInfoEnabled ( ) ) this . logger . info ( String . valueOf ( o ) ) ; } 
public void trace ( Object o , Throwable ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( String . valueOf ( o ) , ) ; } 
public void trace ( Object o ) { if ( this . logger . isDebugEnabled ( ) ) this . logger . debug ( String . valueOf ( o ) ) ; } 
public void warn ( Object o , Throwable ) { if ( this . logger . isWarnEnabled ( ) ) this . logger . warn ( String . valueOf ( o ) , ) ; } 
public void warn ( Object o ) { if ( this . logger . isWarnEnabled ( ) ) this . logger . warn ( String . valueOf ( o ) ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { AvalonLoggerTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( AvalonLoggerTest . class ) ; return suite ; } 
public void tearDown ( ) { log = null ; factory = null ; LogFactory . releaseAll ( ) ; } 
protected void setUpLog ( String name ) throws Exception { log = LogFactory . getLog ( name ) ; } 
public void setUp ( ) throws Exception { expected = new ArrayList ( ) ; setUpFactory ( ) ; setUpLog ( " DecoratedLogger " ) ; } 
public void testExceptionMessages ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logExceptionMessages ( ) ; checkExpected ( ) ; 
public void testPlainMessages ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logPlainMessages ( ) ; checkExpected ( ) ; 
public void testSerializable ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logPlainMessages ( ) ; super . testSerializable ( ) ; logExceptionMessages ( ) ; checkExpected ( ) ; 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_DEBUG, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertTrue(!((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkExpected ( ) { List acts = ( ( DecoratedSimpleLog ) log ) . getCache ( ) ; Iterator exps = expected . iterator ( ) ; int = 0 ; while ( exps . hasNext ( ) ) { LogRecord exp = ( LogRecord ) exps . next ( ) ; 
protected void logExceptionMessages ( ) { Generate log records Throwable t = new IndexOutOfBoundsException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", t)); 
protected void logPlainMessages ( ) { Generate log records log.trace("trace"); Should not actually get logged log.debug("debug"); log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", null)); 
protected void log ( int type , Object message , Throwable ) { super . log ( type , message , ) ; cache . add ( new LogRecord ( type , message , ) ) ; 
public void testPristineDecorated ( ) { setUpDecorated ( " DecoratedLogger " ) ; checkDecorated ( ) ; 
public void testSerializable ( ) throws Exception { Serialize and deserialize the instance ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); Check the characteristics of the resulting object checkStandard(); 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(!log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertTrue(!((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkStandard ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.SimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(!log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); 
public void debug ( Object o , Throwable ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( o ) , ) ; } 
public void debug ( Object o ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( o ) ) ; } 
public void error ( Object o , Throwable ) { if ( getLogger ( ) . isErrorEnabled ( ) ) getLogger ( ) . error ( String . valueOf ( o ) , ) ; } 
public void error ( Object o ) { if ( getLogger ( ) . isErrorEnabled ( ) ) getLogger ( ) . error ( String . valueOf ( o ) ) ; } 
public void fatal ( Object o , Throwable ) { if ( getLogger ( ) . isFatalErrorEnabled ( ) ) getLogger ( ) . fatalError ( String . valueOf ( o ) , ) ; } 
public void fatal ( Object o ) { if ( getLogger ( ) . isFatalErrorEnabled ( ) ) getLogger ( ) . fatalError ( String . valueOf ( o ) ) ; } 
public void info ( Object o , Throwable ) { if ( getLogger ( ) . isInfoEnabled ( ) ) getLogger ( ) . info ( String . valueOf ( o ) , ) ; } 
public void info ( Object o ) { if ( getLogger ( ) . isInfoEnabled ( ) ) getLogger ( ) . info ( String . valueOf ( o ) ) ; } 
public boolean isDebugEnabled ( ) { return getLogger ( ) . isDebugEnabled ( ) ; } 
public boolean isErrorEnabled ( ) { return getLogger ( ) . isErrorEnabled ( ) ; } 
public boolean isFatalEnabled ( ) { return getLogger ( ) . isFatalErrorEnabled ( ) ; } 
public boolean isInfoEnabled ( ) { return getLogger ( ) . isInfoEnabled ( ) ; } 
public boolean isTraceEnabled ( ) { return getLogger ( ) . isDebugEnabled ( ) ; } 
public boolean isWarnEnabled ( ) { return getLogger ( ) . isWarnEnabled ( ) ; } 
public void trace ( Object o , Throwable ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( o ) , ) ; } 
public void trace ( Object o ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( o ) ) ; } 
public void warn ( Object o , Throwable ) { if ( getLogger ( ) . isWarnEnabled ( ) ) getLogger ( ) . warn ( String . valueOf ( o ) , ) ; } 
public void warn ( Object o ) { if ( getLogger ( ) . isWarnEnabled ( ) ) getLogger ( ) . warn ( String . valueOf ( o ) ) ; } 
private void log ( Level level , String msg , Throwable ex ) { Logger logger = getLogger ( ) ; if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
public boolean isDebugEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . FINE ) ) ; } 
public boolean isErrorEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . SEVERE ) ) ; } 
public boolean isFatalEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . SEVERE ) ) ; } 
public boolean isInfoEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . INFO ) ) ; } 
public boolean isTraceEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . FINEST ) ) ; } 
public boolean isWarnEnabled ( ) { return ( getLogger ( ) . isLoggable ( Level . WARNING ) ) ; } 
public void trace ( Object message ) { getLogger ( ) . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void trace ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void debug ( Object message ) { getLogger ( ) . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public void debug ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . DEBUG , message , ) ; } 
public void info ( Object message ) { getLogger ( ) . log ( FQCN , Priority . INFO , message , null ) ; } 
public void info ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . INFO , message , ) ; } 
public void warn ( Object message ) { getLogger ( ) . log ( FQCN , Priority . WARN , message , null ) ; } 
public void warn ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . WARN , message , ) ; } 
public void error ( Object message ) { getLogger ( ) . log ( FQCN , Priority . ERROR , message , null ) ; } 
public void error ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . ERROR , message , ) ; } 
public void fatal ( Object message ) { getLogger ( ) . log ( FQCN , Priority . FATAL , message , null ) ; } 
public void fatal ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Priority . FATAL , message , ) ; } 
public boolean isErrorEnabled ( ) { return getLogger ( ) . isEnabledFor ( Priority . ERROR ) ; } 
public boolean isFatalEnabled ( ) { return getLogger ( ) . isEnabledFor ( Priority . FATAL ) ; } 
public boolean isWarnEnabled ( ) { return getLogger ( ) . isEnabledFor ( Priority . WARN ) ; } 
public void debug ( Object message ) { if ( message ! = null ) { getLogger ( ) . debug ( String . valueOf ( message ) ) ; 
public void debug ( Object message , Throwable ) { if ( message ! = null ) { getLogger ( ) . debug ( String . valueOf ( message ) , ) ; 
public void info ( Object message ) { if ( message ! = null ) { getLogger ( ) . info ( String . valueOf ( message ) ) ; 
public void info ( Object message , Throwable ) { if ( message ! = null ) { getLogger ( ) . info ( String . valueOf ( message ) , ) ; 
public void warn ( Object message ) { if ( message ! = null ) { getLogger ( ) . warn ( String . valueOf ( message ) ) ; 
public void warn ( Object message , Throwable ) { if ( message ! = null ) { getLogger ( ) . warn ( String . valueOf ( message ) , ) ; 
public void error ( Object message ) { if ( message ! = null ) { getLogger ( ) . error ( String . valueOf ( message ) ) ; 
public void error ( Object message , Throwable ) { if ( message ! = null ) { getLogger ( ) . error ( String . valueOf ( message ) , ) ; 
public void fatal ( Object message ) { if ( message ! = null ) { getLogger ( ) . fatalError ( String . valueOf ( message ) ) ; 
public void fatal ( Object message , Throwable ) { if ( message ! = null ) { getLogger ( ) . fatalError ( String . valueOf ( message ) , ) ; 
public void testSerializable ( ) throws Exception { super . testSerializable ( ) ; testExceptionMessages ( ) ; 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Jdk14Logger " , log . getClass ( ) . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(log.isFatalEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
public void testSerializable ( ) throws Exception { Serialize and deserialize the instance ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); Check the characteristics of the resulting object checkLog(); 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Jdk14Logger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? log.isDebugEnabled(); log.isErrorEnabled(); log.isFatalEnabled(); log.isInfoEnabled(); log.isTraceEnabled(); log.isWarnEnabled(); 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Log4JLogger " , log . getClass ( ) . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Log4JLogger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? log.isDebugEnabled(); log.isErrorEnabled(); log.isFatalEnabled(); log.isInfoEnabled(); log.isTraceEnabled(); log.isWarnEnabled(); 
protected boolean isJdk13LumberjackAvailable ( ) { try { loadClass ( " java.util.logging.Logger " ) ; 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return getContextClassLoader(); } }); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; Load properties file. Will be used one way or another in the end. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { } catch (SecurityException e) { } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar to the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null && props != null) { String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public Object run ( ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
protected void log ( int type , Object message , Throwable ) { if( showShortName) { if( prefix==null ) { cut all but the last component of the name for both styles prefix = logName.substring( logName.lastIndexOf(".") +1) + " - "; prefix = prefix.substring( prefix.lastIndexOf("/") +1) + "-"; } buf.append( prefix ); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to System.err System.err.println(buf.toString()); } 
protected void log ( int type , Object message , Throwable ) { if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles shortLogName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = shortLogName.substring(shortLogName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to System.err System.err.println(buf.toString()); } 
protected void log ( int type , Object message , Throwable ) { if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles shortLogName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = shortLogName.substring(shortLogName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); 
protected void write ( StringBuffer buffer ) { System . err . println ( buffer . toString ( ) ) ; 
public void testIsEnabledClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class ) ; executeIsEnabledTest ( log ) ; } 
public void testIsEnabledNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class . getName ( ) ) ; executeIsEnabledTest ( log ) ; } 
public void testMessageWithoutExceptionClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithoutExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class . getName ( ) ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void executeMessageWithoutExceptionTest ( Log log ) { try { 
public void testMessageWithExceptionClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class ) ; executeMessageWithExceptionTest ( log ) ; } 
public void testMessageWithExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTest . class . getName ( ) ) ; executeMessageWithExceptionTest ( log ) ; } 
protected void checkLoggingEvents ( boolean thrown ) { Iterator events = appender . events ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( " Logged event " + i + " exists " , events . hasNext ( ) ) ; LoggingEvent event = ( LoggingEvent ) events . next ( ) ; assertEquals ( " LoggingEvent level " , testLevels [ i ] , event . getLevel ( ) ) ; assertEquals ( " LoggingEvent message " , testMessages [ i ] , event . getMessage ( ) ) ; if ( thrown ) { assertNotNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) . getThrowableStrRep ( ) ) ; assertTrue ( " LoggingEvent thrown type " , event . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] . indexOf ( " IndexOutOfBoundsException " ) > 0 ) ; } else { assertNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) ) ; } } assertTrue ( ! events . hasNext ( ) ) ; appender . flush ( ) ; } 
public void trace ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . DEBUG , message , null ) ; 
public void trace ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . DEBUG , message , ) ; 
public void debug ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . DEBUG , message , null ) ; 
public void debug ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . DEBUG , message , ) ; 
public void info ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . INFO , message , null ) ; 
public void info ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . INFO , message , ) ; 
public void warn ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . WARN , message , null ) ; 
public void warn ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . WARN , message , ) ; 
public void error ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . ERROR , message , null ) ; 
public void error ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . ERROR , message , ) ; 
public void fatal ( Object message ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . FATAL , message , null ) ; 
public void fatal ( Object message , Throwable ) { if ( is12 ) { getLogger ( ) . log ( FQCN , ( Priority ) Level . FATAL , message , ) ; 
public boolean isErrorEnabled ( ) { if ( is12 ) { return getLogger ( ) . isEnabledFor ( ( Priority ) Level . ERROR ) ; 
public boolean isFatalEnabled ( ) { if ( is12 ) { return getLogger ( ) . isEnabledFor ( ( Priority ) Level . FATAL ) ; 
public boolean isWarnEnabled ( ) { if ( is12 ) { return getLogger ( ) . isEnabledFor ( ( Priority ) Level . WARN ) ; 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_DEBUG, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("yyyy/MM/dd HH:mm:ss:SSS zzz", ((DecoratedSimpleLog) log).getDateTimeFormat()); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertTrue(!((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(!log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("yyyy/MM/dd HH:mm:ss:SSS zzz", ((DecoratedSimpleLog) log).getDateTimeFormat()); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertTrue(!((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_DEBUG, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? checkDecoratedDateTime(); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); checkShowDateTime(); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkShowDateTime ( ) { assertTrue ( ! ( ( DecoratedSimpleLog ) log ) . getShowDateTime ( ) ) ; } 
protected void checkDecoratedDateTime ( ) { assertEquals ( " yyyy/MM/dd HH:mm:ss:SSS zzz " , ( ( DecoratedSimpleLog ) log ) . getDateTimeFormat ( ) ) ; 
public static Test suite ( ) { return ( new TestSuite ( DateTimeCustomConfigTestCase . class ) ) ; } 
protected void checkDecoratedDateTime ( ) { assertEquals ( " Expected date format to be set " , " dd.mm.yyyy " , ( ( DecoratedSimpleLog ) log ) . getDateTimeFormat ( ) ) ; try the formatter Date now = new Date(); DateFormat formatter = ((DecoratedSimpleLog) log).getDateTimeFormatter(); SimpleDateFormat sampleFormatter = new SimpleDateFormat("dd.mm.yyyy"); assertEquals("Date should be formatters to pattern dd.mm.yyyy", sampleFormatter.format(now), formatter.format(now)); } 
protected void checkShowDateTime ( ) { assertTrue ( ( ( DecoratedSimpleLog ) log ) . getShowDateTime ( ) ) ; } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
protected boolean isLog4JAvailable ( ) { try { loadClass ( " org.apache.commons.logging.impl.Log4JLogger " ) . getClassLoader ( ) 
protected static ClassLoader getContextClassLoader ( ) throws LogConfigurationException { return LogFactory . getContextClassLoader ( ) ; } 
protected void log ( int type , Object message , Throwable ) { if ( isLevelEnabled ( type ) ) { Entry entry = new Entry ( logName , type , message , ) ; 
public final void debug ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_DEBUG ) ) { log ( MemoryLog . LOG_LEVEL_DEBUG , message , null ) ; 
public final void debug ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_DEBUG ) ) { log ( MemoryLog . LOG_LEVEL_DEBUG , message , ) ; 
public final void trace ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_TRACE ) ) { log ( MemoryLog . LOG_LEVEL_TRACE , message , null ) ; 
public final void trace ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_TRACE ) ) { log ( MemoryLog . LOG_LEVEL_TRACE , message , ) ; 
public final void info ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_INFO ) ) { log ( MemoryLog . LOG_LEVEL_INFO , message , null ) ; 
public final void info ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_INFO ) ) { log ( MemoryLog . LOG_LEVEL_INFO , message , ) ; 
public final void warn ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_WARN ) ) { log ( MemoryLog . LOG_LEVEL_WARN , message , null ) ; 
public final void warn ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_WARN ) ) { log ( MemoryLog . LOG_LEVEL_WARN , message , ) ; 
public final void error ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_ERROR ) ) { log ( MemoryLog . LOG_LEVEL_ERROR , message , null ) ; 
public final void error ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_ERROR ) ) { log ( MemoryLog . LOG_LEVEL_ERROR , message , ) ; 
public final void fatal ( Object message ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_FATAL ) ) { log ( MemoryLog . LOG_LEVEL_FATAL , message , null ) ; 
public final void fatal ( Object message , Throwable ) { if ( isLevelEnabled ( MemoryLog . LOG_LEVEL_FATAL ) ) { log ( MemoryLog . LOG_LEVEL_FATAL , message , ) ; 
public final boolean isDebugEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_DEBUG ) ; } 
public final boolean isErrorEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_ERROR ) ; } 
public final boolean isFatalEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_FATAL ) ; } 
public final boolean isInfoEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_INFO ) ; } 
public final boolean isTraceEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_TRACE ) ; } 
public final boolean isWarnEnabled ( ) { return isLevelEnabled ( MemoryLog . LOG_LEVEL_WARN ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MemoryLogTest . suite ( ) ) ; return suite ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; MemoryLog . reset ( ) ; } 
public final void testGetLogEntries ( ) { MemoryLog log = ( MemoryLog ) getLogObject ( ) ; log . setLevel ( MemoryLog . LOG_LEVEL_DEBUG ) ; log . trace ( " trace " ) ; log . debug ( " debug " ) ; log . info ( " info " ) ; log . warn ( " warn " ) ; log . error ( " error " , new RuntimeException ( " error " ) ) ; log . fatal ( " fatal " , new RuntimeException ( " fatal " ) ) ; List list = MemoryLog . getLogEntries ( ) ; assertEquals ( 5 , list . size ( ) ) ; assertEquals ( " debug " , ( ( MemoryLog . Entry ) list . get ( 0 ) ) . getMessage ( ) ) ; assertEquals ( " info " , ( ( MemoryLog . Entry ) list . get ( 1 ) ) . getMessage ( ) ) ; assertEquals ( " warn " , ( ( MemoryLog . Entry ) list . get ( 2 ) ) . getMessage ( ) ) ; assertEquals ( " error " , ( ( MemoryLog . Entry ) list . get ( 3 ) ) . getMessage ( ) ) ; assertEquals ( " error " , ( ( MemoryLog . Entry ) list . get ( 3 ) ) . getThrowable ( ) . getMessage ( ) ) ; assertEquals ( " fatal " , ( ( MemoryLog . Entry ) list . get ( 4 ) ) . getMessage ( ) ) ; assertEquals ( " fatal " , ( ( MemoryLog . Entry ) list . get ( 4 ) ) . getThrowable ( ) . getMessage ( ) ) ; MemoryLog . reset ( ) ; assertEquals ( 0 , MemoryLog . getLogEntries ( ) . size ( ) ) ; } 
public static void main ( String [ ] args ) { junit . textui . TestRunner . run ( MemoryLogTest . suite ( ) ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( MemoryLogTest . class ) ; return suite ; } 
public void testLogFactoryType ( ) { assertTrue ( LogFactory . factories instanceof WeakHashtable ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MemoryLogTest . suite ( ) ) ; suite . addTestSuite ( WeakHashtableTest . class ) ; suite . addTestSuite ( LogFactoryTest . class ) ; return suite ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; weakHashtable = new WeakHashtable ( ) ; keyOne = new Long ( 1 ) ; keyTwo = new Long ( 2 ) ; keyThree = new Long ( 3 ) ; valueOne = new Long ( 100 ) ; valueTwo = new Long ( 200 ) ; valueThree = new Long ( 300 ) ; weakHashtable . put ( keyOne , valueOne ) ; weakHashtable . put ( keyTwo , valueTwo ) ; weakHashtable . put ( keyThree , valueThree ) ; } 
public void testContains ( ) throws Exception { assertFalse ( weakHashtable . contains ( new Long ( 1 ) ) ) ; assertFalse ( weakHashtable . contains ( new Long ( 2 ) ) ) ; assertFalse ( weakHashtable . contains ( new Long ( 3 ) ) ) ; assertTrue ( weakHashtable . contains ( new Long ( 100 ) ) ) ; assertTrue ( weakHashtable . contains ( new Long ( 200 ) ) ) ; assertTrue ( weakHashtable . contains ( new Long ( 300 ) ) ) ; assertFalse ( weakHashtable . contains ( new Long ( 400 ) ) ) ; } 
public void testContainsKey ( ) throws Exception { assertTrue ( weakHashtable . containsKey ( new Long ( 1 ) ) ) ; assertTrue ( weakHashtable . containsKey ( new Long ( 2 ) ) ) ; assertTrue ( weakHashtable . containsKey ( new Long ( 3 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 100 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 200 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 300 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 400 ) ) ) ; } 
public void testContainsValue ( ) throws Exception { assertFalse ( weakHashtable . containsValue ( new Long ( 1 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 2 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 3 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 100 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 200 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 300 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 400 ) ) ) ; } 
public void testElements ( ) throws Exception { ArrayList elements = new ArrayList ( ) ; for ( Enumeration e = weakHashtable . elements ( ) ; e . hasMoreElements ( ) ; ) { elements . add ( e . nextElement ( ) ) ; } assertEquals ( 3 , elements . size ( ) ) ; assertTrue ( elements . contains ( valueOne ) ) ; assertTrue ( elements . contains ( valueTwo ) ) ; assertTrue ( elements . contains ( valueThree ) ) ; } 
public void testEntrySet ( ) throws Exception { Set entrySet = weakHashtable . entrySet ( ) ; for ( Iterator it = entrySet . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; 
public void testGet ( ) throws Exception { assertEquals ( valueOne , weakHashtable . get ( keyOne ) ) ; assertEquals ( valueTwo , weakHashtable . get ( keyTwo ) ) ; assertEquals ( valueThree , weakHashtable . get ( keyThree ) ) ; assertNull ( weakHashtable . get ( new Long ( 50 ) ) ) ; } 
public void testKeys ( ) throws Exception { ArrayList keys = new ArrayList ( ) ; for ( Enumeration e = weakHashtable . keys ( ) ; e . hasMoreElements ( ) ; ) { keys . add ( e . nextElement ( ) ) ; } assertEquals ( 3 , keys . size ( ) ) ; assertTrue ( keys . contains ( keyOne ) ) ; assertTrue ( keys . contains ( keyTwo ) ) ; assertTrue ( keys . contains ( keyThree ) ) ; } 
public void testKeySet ( ) throws Exception { Set keySet = weakHashtable . keySet ( ) ; assertEquals ( 3 , keySet . size ( ) ) ; assertTrue ( keySet . contains ( keyOne ) ) ; assertTrue ( keySet . contains ( keyTwo ) ) ; assertTrue ( keySet . contains ( keyThree ) ) ; } 
public void testPut ( ) throws Exception { Long anotherKey = new Long ( 2004 ) ; weakHashtable . put ( anotherKey , new Long ( 1066 ) ) ; assertEquals ( new Long ( 1066 ) , weakHashtable . get ( anotherKey ) ) ; } 
public void testPutAll ( ) throws Exception { Map newValues = new HashMap ( ) ; Long newKey = new Long ( 1066 ) ; Long newValue = new Long ( 1415 ) ; newValues . put ( newKey , newValue ) ; Long anotherNewKey = new Long ( 1645 ) ; Long anotherNewValue = new Long ( 1815 ) ; newValues . put ( anotherNewKey , anotherNewValue ) ; weakHashtable . putAll ( newValues ) ; assertEquals ( 5 , weakHashtable . size ( ) ) ; assertEquals ( newValue , weakHashtable . get ( newKey ) ) ; assertEquals ( anotherNewValue , weakHashtable . get ( anotherNewKey ) ) ; } 
public void testRemove ( ) throws Exception { weakHashtable . remove ( keyOne ) ; assertEquals ( 2 , weakHashtable . size ( ) ) ; assertNull ( weakHashtable . get ( keyOne ) ) ; } 
public void testValues ( ) throws Exception { Collection values = weakHashtable . values ( ) ; assertEquals ( 3 , values . size ( ) ) ; assertTrue ( values . contains ( valueOne ) ) ; assertTrue ( values . contains ( valueTwo ) ) ; assertTrue ( values . contains ( valueThree ) ) ; } 
public void testRelease ( ) throws Exception { lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; if ( storeImplementationClass = = null ) { storeImplementationClass = " org.apache.commons.logging.impl.WeakHashtable " ; } try { Class implementationClass = Class . forName ( storeImplementationClass ) ; result = ( Hashtable ) implementationClass . newInstance ( ) ; } catch ( Exception e ) { ignore System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } if (result == null) { result = new Hashtable(); } return result; } 
public Object put ( Object key , Object value ) { lastKey = key ; lastValue = value ; return super . put ( key , value ) ; } 
public void testType ( ) { assertTrue ( LogFactory . factories instanceof AltHashtable ) ; } 
public void testPutCalled ( ) throws Exception { AltHashtable . lastKey = null ; AltHashtable . lastValue = null ; ClassLoader classLoader = new ClassLoader ( ) { } ; Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { LogFactory . getLog ( AltHashtableTest . class ) ; } } ) ; thread . setContextClassLoader ( classLoader ) ; thread . start ( ) ; thread . join ( ) ; assertEquals ( classLoader , AltHashtable . lastKey ) ; assertNotNull ( AltHashtable . lastValue ) ; } 
public void run ( ) { LogFactory . getLog ( AltHashtableTest . class ) ; } 
public void testType ( ) { assertTrue ( LogFactory . factories instanceof Hashtable ) ; } 
public void testPutCalled ( ) throws Exception { Log log = LogFactory . getLog ( BadHashtablePropertyTest . class ) ; } 
public void testPut ( ) throws Exception { Long anotherKey = new Long ( 2004 ) ; weakHashtable . put ( anotherKey , new Long ( 1066 ) ) ; assertEquals ( new Long ( 1066 ) , weakHashtable . get ( anotherKey ) ) ; Test compliance with the hashtable API re nulls Exception caught = null; try { weakHashtable.put(null, new Object()); } catch (Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null key", caught); caught = null; try { weakHashtable.put(new Object(), null); } catch (Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null value", caught); } 
public void testRelease ( ) throws Exception { lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } else { create garbage: byte[] b = new byte[bytz]; bytz = bytz * 2; } } Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public void testHoldFactories ( ) { Get a factory and create a WeakReference to it that we can check to see if the factory has been removed from LogFactory.properties LogFactory factory = LogFactory.getFactory(); WeakReference weakFactory = new WeakReference(factory); Remove any hard reference to the factory factory = null; Run the gc, confirming that the original factory is not dropped from the map even though there are no other references to it int iterations = 0; int bytz = 2; while(iterations++ < MAX_GC_ITERATIONS) { System.gc(); 
public void testReleaseFactories ( ) { Create a temporary classloader ClassLoader childLoader = new ClassLoader() {}; Thread.currentThread().setContextClassLoader(childLoader); Get a factory using the child loader. LogFactory factory = LogFactory.getFactory(); Hold a WeakReference to the factory. When this reference is cleared we know the factory has been cleared from LogFactory.factories as well WeakReference weakFactory = new WeakReference(factory); Get a WeakReference to the child loader so we know when it has been gc'ed WeakReference weakLoader = new WeakReference(childLoader); Remove any hard reference to the childLoader and the factory Thread.currentThread().setContextClassLoader(origLoader); childLoader = null; factory = null; Run the gc, confirming that the original childLoader is dropped from the map int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before childLoader released."); } if(weakLoader.get() == null) { break; } else { create garbage: byte[] b; try { b = new byte[bytz]; bytz = bytz * 2; } catch (OutOfMemoryError oom) { Doing this is probably a no-no, but it seems to work ;-) b = null; System.gc(); fail("OutOfMemory before childLoader released."); } } } Confirm that the original factory is removed from the map within the maximum allowed number of calls to put() + the maximum number of subsequent gc iterations iterations = 0; while(true) { System.gc(); 
protected void setUp ( ) throws Exception { Preserve the original classloader and factory implementation class so we can restore them when we are done origLoader = Thread.currentThread().getContextClassLoader(); origFactoryProperty = System.getProperty(LogFactory.FACTORY_PROPERTY); Ensure we use LogFactoryImpl as our factory System.setProperty(LogFactory.FACTORY_PROPERTY, LogFactoryImpl.class.getName()); super.setUp(); } 
protected void tearDown ( ) throws Exception { Set the classloader back to whatever it originally was Thread.currentThread().setContextClassLoader(origLoader); Set the factory implementation class back to whatever it originally was if (origFactoryProperty != null) { System.setProperty(LogFactory.FACTORY_PROPERTY, origFactoryProperty); } else { System.getProperties().remove(LogFactory.FACTORY_PROPERTY); } super.tearDown(); } 
public void testRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; ReferenceQueue testQueue = new ReferenceQueue ( ) ; WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } else { create garbage: byte[] b = new byte[bytz]; bytz = bytz * 2; } } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public void testHoldFactories ( ) throws Exception { 1) Basic test Get a weak reference to the factory using the classloader. When this reference is cleared we know the factory has been cleared from LogFactory.factories as well WeakReference weakFactory = loadFactoryFromContextClassLoader(); Run the gc, confirming that the factory is not dropped from the map even though there are no other references to it checkRelease(weakFactory, true); 2) Test using an isolated classloader a la a web app Create a classloader that isolates commons-logging ClassLoader childLoader = new IsolatedClassLoader(origLoader); Thread.currentThread().setContextClassLoader(childLoader); weakFactory = loadFactoryFromContextClassLoader(); Thread.currentThread().setContextClassLoader(origLoader); At this point we still have a reference to childLoader, so the factory should not be cleared checkRelease(weakFactory, true); } 
public void testReleaseClassLoader ( ) throws Exception { 1) Test of a child classloader that follows the Java2 delegation model (e.g. an EJB module classloader) Create a classloader that delegates to its parent ClassLoader childLoader = new ClassLoader() {}; Get a weak reference to the factory using the classloader. When this reference is cleared we know the factory has been cleared from LogFactory.factories as well Thread.currentThread().setContextClassLoader(childLoader); loadFactoryFromContextClassLoader(); Thread.currentThread().setContextClassLoader(origLoader); Get a WeakReference to the child loader so we know when it has been gc'ed WeakReference weakLoader = new WeakReference(childLoader); Remove any hard reference to the childLoader or the factory creator childLoader = null; Run the gc, confirming that childLoader is dropped from the map checkRelease(weakLoader, false); 2) Test using an isolated classloader a la a web app childLoader = new IsolatedClassLoader(origLoader); Thread.currentThread().setContextClassLoader(childLoader); loadFactoryFromContextClassLoader(); Thread.currentThread().setContextClassLoader(origLoader); weakLoader = new WeakReference(childLoader); childLoader = null; somewhat equivalent to undeploying a webapp checkRelease(weakLoader, false); 
private void checkRelease ( WeakReference reference , boolean failOnRelease ) { int iterations = 0 ; int bytz = 2 ; while ( true ) { System . gc ( ) ; 
private static WeakReference loadFactoryFromContextClassLoader ( ) throws Exception { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Class clazz = loader . loadClass ( SubDeploymentClass . class . getName ( ) ) ; IFactoryCreator creator = ( IFactoryCreator ) clazz . newInstance ( ) ; return creator . getWeakFactory ( ) ; } 
protected synchronized Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { if ( name ! = null & & name . startsWith ( " org.apache.commons.logging " ) & & " org.apache.commons.logging.IFactoryCreator " . equals ( name ) = = false ) { 
protected Class findClass ( String name ) throws ClassNotFoundException { if ( name ! = null & & name . startsWith ( " org.apache.commons.logging " ) & & " org.apache.commons.logging.IFactoryCreator " . equals ( name ) = = false ) { 
public boolean containsKey ( Object key ) { purge should not be required Referenced referenced = new Referenced(key); return super.containsKey(referenced); } 
public Enumeration elements ( ) { purge ( ) ; return super . elements ( ) ; } 
public Set entrySet ( ) { purge ( ) ; Set referencedEntries = super . entrySet ( ) ; Set unreferencedEntries = new HashSet ( ) ; for ( Iterator it = referencedEntries . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; Referenced referencedKey = ( Referenced ) entry . getKey ( ) ; Object key = referencedKey . getValue ( ) ; Object value = entry . getValue ( ) ; if ( key ! = null ) { Entry dereferencedEntry = new Entry ( key , value ) ; unreferencedEntries . add ( dereferencedEntry ) ; } } return unreferencedEntries ; } 
public Object get ( Object key ) { for performance reasons, no purge Referenced referenceKey = new Referenced(key); return super.get(referenceKey); } 
public Enumeration keys ( ) { purge ( ) ; final Enumeration enumer = super . keys ( ) ; return new Enumeration ( ) { public boolean hasMoreElements ( ) { 
public boolean hasMoreElements ( ) { return enumer . hasMoreElements ( ) ; } 
public Object nextElement ( ) { Referenced nextReference = ( Referenced ) enumer . nextElement ( ) ; return nextReference . getValue ( ) ; } 
public Set keySet ( ) { purge ( ) ; Set referencedKeys = super . keySet ( ) ; Set unreferencedKeys = new HashSet ( ) ; for ( Iterator it = referencedKeys . iterator ( ) ; it . hasNext ( ) ; ) { Referenced referenceKey = ( Referenced ) it . next ( ) ; Object keyValue = referenceKey . getValue ( ) ; if ( keyValue ! = null ) { unreferencedKeys . add ( keyValue ) ; } } return unreferencedKeys ; } 
public Object put ( Object key , Object value ) { check for nulls, ensuring symantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if ((changeCount % PARTIAL_PURGE_COUNT) == 0) { purgeOne(); } Object result = null; Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public void putAll ( Map ) { if ( ! = null ) { Set entrySet = . entrySet ( ) ; 
public Collection values ( ) { purge ( ) ; return super . values ( ) ; } 
public Object remove ( Object key ) { for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if ((changeCount % PARTIAL_PURGE_COUNT) == 0) { purgeOne(); } return super.remove(new Referenced(key)); } 
public String toString ( ) { purge ( ) ; return super . toString ( ) ; } 
protected void rehash ( ) { purge here to save the effort of rehashing dead entries purge(); super.rehash(); } 
private void purgeOne ( ) { synchronized ( queue ) { WeakKey key = ( WeakKey ) queue . poll ( ) ; 
public boolean equals ( Object o ) { boolean result = false ; if ( o ! = null & & o instanceof Map . Entry ) { Map . Entry entry = ( Map . Entry ) o ; result = ( getKey ( ) = = null ? entry . getKey ( ) = = null : getKey ( ) . equals ( entry . getKey ( ) ) ) & & ( getValue ( ) = = null ? entry . getValue ( ) = = null : getValue ( ) . equals ( entry . getValue ( ) ) ) ; } return result ; } 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Referenced ) { Referenced otherKey = ( Referenced ) o ; Object thisKeyValue = getValue ( ) ; Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = ( otherKeyValue = = null ) ; Since our hashcode was calculated from the original non-null referant, the above check breaks the hashcode/equals contract, as two cleared Referenced objects could test equal but have different hashcodes. We can reduce (not eliminate) the chance of this happening by comparing hashcodes. if (result == true) { result = (this.hashCode() == otherKey.hashCode()); } In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; if ( storeImplementationClass = = null ) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME ; } try { Class implementationClass = Class . forName ( storeImplementationClass ) ; result = ( Hashtable ) implementationClass . newInstance ( ) ; } catch ( Exception e ) { } } if (result == null) { result = new Hashtable(); } return result; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; if ( storeImplementationClass = = null ) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME ; } try { Class implementationClass = Class . forName ( storeImplementationClass ) ; result = ( Hashtable ) implementationClass . newInstance ( ) ; } catch ( Throwable ) { } } if (result == null) { result = new Hashtable(); } return result; } 
public void runJCL ( ) { try { SomeObject someObject = new SomeObject ( ) ; 
public void runStatic ( ) { try { SomeObject someObject = new SomeObject ( ) ; 
public void logToJCL ( ) { LogFactory . getLog ( " a log " ) . info ( " A message " ) ; } 
public void logToStaticLog4J ( ) { StaticLog4JLogger . info ( " A message " ) ; } 
protected synchronized Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { very basic implementation Class result = findLoadedClass(name); if (result == null) { try { result = findClass(name); if (resolve) { resolveClass(result); } } catch (ClassNotFoundException e) { result = super.loadClass(name, resolve); } } return result; } 
public void testCase17 ( ) { int parentUrls = JCL_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 17 " , parentUrls , childUrls , false , true ) ; } 
public void testCase18 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 18 " , parentUrls , childUrls , false , true ) ; } 
public void testCase19 ( ) { int parentUrls = JCL_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 19 " , parentUrls , childUrls , true , true ) ; } 
public void testCase20 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 20 " , parentUrls , childUrls , true , true ) ; } 
public void testCase21 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 21 " , parentUrls , childUrls , false , true ) ; } 
public void testCase22 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 22 " , parentUrls , childUrls , false , true ) ; } 
public void testCase23 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 23 " , parentUrls , childUrls , true , true ) ; } 
public void testCase24 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 24 " , parentUrls , childUrls , true , true ) ; } 
public void testCase25 ( ) { int parentUrls = API_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 25 " , parentUrls , childUrls , false , true ) ; } 
public void testCase26 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 26 " , parentUrls , childUrls , false , true ) ; } 
public void testCase27 ( ) { int parentUrls = API_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 27 " , parentUrls , childUrls , true , true ) ; } 
public void testCase28 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 28 " , parentUrls , childUrls , true , true ) ; } 
public void testCase29 ( ) { int parentUrls = API_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 29 " , parentUrls , childUrls , false , true ) ; } 
public void testCase30 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 30 " , parentUrls , childUrls , false , true ) ; } 
public void testCase31 ( ) { int parentUrls = API_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 31 " , parentUrls , childUrls , true , true ) ; } 
public void testCase32 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 32 " , parentUrls , childUrls , true , true ) ; } 
public static void main ( String [ ] args ) { ChildFirstRunner runner ; try { runner = new ChildFirstRunner ( ) ; 
public void run ( String caseName , int parentJars , int childJars , boolean setContextClassloader , boolean childFirst ) { System . out . println ( " " ) ; System . out . println ( " ***************************** " ) ; System . out . println ( " " ) ; System . out . println ( " Running case " + caseName + " ... " ) ; System . out . println ( " " ) ; URL [ ] parentUrls = urlsForJars ( parentJars , " Parent Classloader: " ) ; URL [ ] childUrls = urlsForJars ( childJars , " Child Classloader: " ) ; System . out . println ( " Child context classloader: " + setContextClassloader ) ; System . out . println ( " Child first: " + childFirst ) ; System . out . println ( " " ) ; run ( " org.apache.commons.logging.proofofconcept.caller.JCLDemonstrator " , parentUrls , childUrls , setContextClassloader , childFirst ) ; System . out . println ( " ***************************** " ) ; } 
private URL [ ] urlsForJars ( int jars , String humanLoaderName ) { List urls = new ArrayList ( ) ; ; if ( ( LOG4J_JAR & jars ) > 0 ) { urls . add ( log4jUrl ) ; } if ( ( STATIC_JAR & jars ) > 0 ) { urls . add ( staticUrl ) ; } if ( ( JCL_JAR & jars ) > 0 ) { urls . add ( jclUrl ) ; } if ( ( API_JAR & jars ) > 0 ) { urls . add ( apiUrl ) ; } if ( ( CALLER_JAR & jars ) > 0 ) { urls . add ( callerUrl ) ; } System . out . println ( humanLoaderName + " " + urls ) ; URL [ ] results = ( URL [ ] ) urls . toArray ( EMPTY_URLS ) ; return results ; } 
public void run ( String testName , URL [ ] parentClassloaderUrls , URL [ ] childClassloaderUrls , boolean setContextClassloader , boolean childFirst ) { URLClassLoader parent = new URLClassLoader ( parentClassloaderUrls ) ; URLClassLoader child = null ; if ( childFirst ) { child = new ChildFirstClassLoader ( childClassloaderUrls , parent ) ; } else { child = new URLClassLoader ( childClassloaderUrls , parent ) ; } if ( setContextClassloader ) { Thread . currentThread ( ) . setContextClassLoader ( child ) ; } logDefiningLoaders ( child , parent ) ; try { 
private void logDefiningLoaders ( ClassLoader child , ClassLoader parent ) { System . out . println ( " " ) ; logDefiningLoaders ( child , parent , " org.apache.commons.logging.LogFactory " , " JCL " ) ; logDefiningLoaders ( child , parent , " org.apache.log4j.Logger " , " Log4j " ) ; logDefiningLoaders ( child , parent , " org.apache.commons.logging.proofofconcept.staticlogger.StaticLog4JLogger " , " Static Logger " ) ; logDefiningLoaders ( child , parent , " org.apache.commons.logging.proofofconcept.caller.SomeObject " , " Caller " ) ; System . out . println ( " " ) ; } 
private void logDefiningLoaders ( ClassLoader child , ClassLoader parent , String className , String humanName ) { try { Class clazz = child . loadClass ( className ) ; 
public void testCase1 ( ) { int parentUrls = JCL_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 1 " , parentUrls , childUrls , false , false ) ; } 
public void testCase2 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 2 " , parentUrls , childUrls , false , false ) ; } 
public void testCase3 ( ) { int parentUrls = JCL_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 3 " , parentUrls , childUrls , true , false ) ; } 
public void testCase4 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 4 " , parentUrls , childUrls , true , false ) ; } 
public void testCase5 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 5 " , parentUrls , childUrls , false , false ) ; } 
public void testCase6 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 6 " , parentUrls , childUrls , false , false ) ; } 
public void testCase7 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 7 " , parentUrls , childUrls , true , false ) ; } 
public void testCase8 ( ) { int parentUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 8 " , parentUrls , childUrls , true , false ) ; } 
public void testCase9 ( ) { int parentUrls = API_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 9 " , parentUrls , childUrls , false , false ) ; } 
public void testCase10 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 10 " , parentUrls , childUrls , false , false ) ; } 
public void testCase11 ( ) { int parentUrls = API_JAR + STATIC_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 11 " , parentUrls , childUrls , true , false ) ; } 
public void testCase12 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 12 " , parentUrls , childUrls , true , false ) ; } 
public void testCase13 ( ) { int parentUrls = API_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 13 " , parentUrls , childUrls , false , false ) ; } 
public void testCase14 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 14 " , parentUrls , childUrls , false , false ) ; } 
public void testCase15 ( ) { int parentUrls = API_JAR + STATIC_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; run ( " 15 " , parentUrls , childUrls , true , false ) ; } 
public void testCase16 ( ) { int parentUrls = API_JAR + STATIC_JAR + CALLER_JAR + LOG4J_JAR ; int childUrls = JCL_JAR + STATIC_JAR + LOG4J_JAR ; run ( " 16 " , parentUrls , childUrls , true , false ) ; } 
public static void main ( String [ ] args ) { ParentFirstRunner runner ; try { runner = new ParentFirstRunner ( ) ; 
public static void info ( String message ) { could have got the logger at the start Logger.getLogger("Whatever").info(message); } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return getContextClassLoader(); } }); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; Load properties file. Will be used one way or another in the end. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { } catch (SecurityException e) { } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar to the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null && props != null) { String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } Fourth, try the fallback implementation class if (factory == null) { factory = newFactory(FACTORY_DEFAULT, LogFactory.class.getClassLoader()); } if (factory != null) { cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static void release ( ClassLoader classLoader ) { synchronized ( factories ) { if ( classLoader = = null ) { 
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { Ideally we would assert(factory != null) here. However reporting errors from within a logging implementation is a little tricky! if (factory != null) { if (classLoader == null) { 
public static void main ( String [ ] args ) { String [ ] testCaseName = { NullClassLoaderTest . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( NullClassLoaderTest . class ) ; return suite ; } 
public void testSameLogObject ( ) throws Exception { ClassLoader oldContextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { emulate an app (not a webapp) running code loaded via the 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SimpleLogTest . suite ( ) ) ; suite . addTest ( NoOpLogTest . suite ( ) ) ; suite . addTest ( LogTest . suite ( ) ) ; suite . addTest ( NullClassLoaderTest . suite ( ) ) ; return suite ; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader ) throws LogConfigurationException { Object result = AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return createFactory ( factoryClass , classLoader ) ; } } ) ; if ( result instanceof LogConfigurationException ) throw ( LogConfigurationException ) result ; return ( LogFactory ) result ; } 
public Object run ( ) { return createFactory ( factoryClass , classLoader ) ; } 
protected static Object createFactory ( String factoryClass , ClassLoader classLoader ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) return factory; Load properties file. Will be used one way or another in the end. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { } catch (SecurityException e) { } First, try the system property try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } catch (SecurityException e) { ; ignore } Second, try to find a service by using the JDK1.3 jar discovery mechanism. This will allow users to plug a logger by just placing it in the lib/ directory of the webapp ( or in CLASSPATH or equivalent ). This is similar to the second step, except that it uses the (standard?) jdk1.3 location in the jar. if (factory == null) { try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { factory= newFactory( factoryClassName, contextClassLoader ); } } } catch( Exception ex ) { ; } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null && props != null) { String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader); } } Fourth, try the fallback implementation class if (factory == null) { ClassLoader logFactoryClassLoader = getClassLoader(LogFactory.class); factory = newFactory(FACTORY_DEFAULT, logFactoryClassLoader); } if (factory != null) { cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static ClassLoader getContextClassLoader ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
public Object run ( ) { return directGetContextClassLoader ( ) ; } 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return logConstructor; } String logClassName = getLogClassName(); Attempt to load the Log implementation class Class logClass = null; Class logInterface = null; try { ClassLoader cl = this.getClass().getClassLoader(); handle the case if getClassLoader() returns null It may mean this class was loaded from the bootstrap classloader logInterface = (cl == null) ? loadClass(LOG_INTERFACE) : cl.loadClass(LOG_INTERFACE); logClass = loadClass(logClassName); if (logClass == null) { throw new LogConfigurationException ("No suitable Log implementation for " + logClassName); } if (!logInterface.isAssignableFrom(logClass)) { LogConfigurationException ex = reportInvalidLogAdapter(logInterface, logClass); throw ex; } } catch (Throwable t) { throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
public void run ( String testName , URL [ ] parentClassloaderUrls , URL [ ] childClassloaderUrls , boolean setContextClassloader , boolean childFirst ) { URLClassLoader parent = new URLClassLoader ( parentClassloaderUrls ) ; URLClassLoader child = null ; if ( childFirst ) { child = new ChildFirstClassLoader ( childClassloaderUrls , parent ) ; } else { child = new URLClassLoader ( childClassloaderUrls , parent ) ; } if ( setContextClassloader ) { Thread . currentThread ( ) . setContextClassLoader ( child ) ; } else { ClassLoader system = ClassLoader . getSystemClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( system ) ; } logDefiningLoaders ( child , parent ) ; try { 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; if ( storeImplementationClass = = null ) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME ; } try { Class implementationClass = Class . forName ( storeImplementationClass ) ; result = ( Hashtable ) implementationClass . newInstance ( ) ; } catch ( Throwable ) { } } if (result == null) { result = new Hashtable(); } return result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { ; ignore } catch (SecurityException e) { ; ignore } First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory( factoryClassName, contextClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: we don't try to load the LogFactory implementation via the context classloader here because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static void release ( ClassLoader classLoader ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; synchronized ( factories ) { if ( classLoader = = null ) { 
public static void releaseAll ( ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; synchronized ( factories ) { Enumeration elements = factories . elements ( ) ; 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Object result = AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return createFactory ( factoryClass , classLoader ) ; } } ) ; if ( result instanceof LogConfigurationException ) { LogConfigurationException ex = ( LogConfigurationException ) result ; logDiagnostic ( " An error occurred while loading the factory class: " + ex . getMessage ( ) ) ; throw ex ; } logDiagnostic ( " Created object " + objectId ( result ) + " to manage classloader " + objectId ( contextClassLoader ) ) ; return ( LogFactory ) result ; } 
private static void initDiagnostics ( ) { String dest ; ttry { dest = System . getProperty ( DIAGNOSTICS_DEST_PROPERTY ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form LogFactory@12345: Class clazz = LogFactory.class; String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = String.valueOf(System.identityHashCode(classLoader)); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = clazz.getName() + "@" + classLoaderName + ": "; 
protected static boolean isDiagnosticsEnabled ( ) { return diagnosticsStream ! = null ; } 
private static final void logDiagnostic ( String msg ) { if ( diagnosticsStream ! = null ) { diagnosticsStream . print ( diagnosticPrefix ) ; 
protected static final void logRawDiagnostic ( String msg ) { if ( diagnosticsStream ! = null ) { diagnosticsStream . println ( msg ) ; 
private static void logClassLoaderTree ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; ClassLoader systemClassLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "Security forbids determining the classloader for " + className); return; } logDiagnostic( "Class " + className + " was loaded via classloader " + objectId(classLoader)); try { systemClassLoader = ClassLoader.getSystemClassLoader(); } catch(SecurityException ex) { logDiagnostic( "Security forbids determining the system classloader."); return; } if (classLoader != null) { StringBuffer buf = new StringBuffer("ClassLoader tree:"); 
public static String objectId ( Object o ) { if ( o = = null ) { return " null " ; 
public void release ( ) { logDiagnostic ( " Releasing all known loggers " ) ; instances . clear ( ) ; } 
protected static boolean isDiagnosticsEnabled ( ) { return LogFactory . isDiagnosticsEnabled ( ) ; } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); diagnosticPrefix = clazz.getName() + "@" + classLoader.toString() + ":"; } 
protected void logDiagnostic ( String msg ) { if ( isDiagnosticsEnabled ( ) ) { logRawDiagnostic ( diagnosticPrefix + msg ) ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor != null) { return logConstructor; } String logClassName = getLogClassName(); Attempt to load the Log implementation class Question: why is the loginterface being loaded dynamically? Isn't the code below exactly the same as this? Class logInterface = Log.class; Class logClass = null; Class logInterface = null; try { ClassLoader cl = getClassLoader(this.getClass()); if (cl == null) { we are probably in Java 1.1, but may also be running in some sort of embedded system.. logInterface = loadClass(LOG_INTERFACE); } else { normal situation logInterface = cl.loadClass(LOG_INTERFACE); } logClass = loadClass(logClassName); if (logClass == null) { logDiagnostic( "Unable to find any class named [" + logClassName + "]" + " in either the context classloader" + " or the classloader that loaded this class."); throw new LogConfigurationException ("No suitable Log implementation for " + logClassName); } if (!logInterface.isAssignableFrom(logClass)) { oops, we need to cast this logClass we have loaded into a Log object in order to return it. But we won't be able to. See method reportInvalidLogAdapter for more information. LogConfigurationException ex = reportInvalidLogAdapter(logInterface, logClass); throw ex; } } catch (Throwable t) { logDiagnostic( "An unexpected problem occurred while loading the" + " log adapter class: " + t.getMessage()); throw new LogConfigurationException(t); } Identify the <code>setLogFactory</code> method (if there is one) try { logMethod = logClass.getMethod("setLogFactory", logMethodSignature); } catch (Throwable t) { logMethod = null; } Identify the corresponding constructor to be used try { logConstructor = logClass.getConstructor(logConstructorSignature); 
protected boolean isJdk13LumberjackAvailable ( ) { note: the algorithm here is different from isLog4JAvailable. I think isLog4JAvailable is correct....see bugzilla#31597 logDiagnostic("Checking for Jdk13Lumberjack."); try { loadClass("java.util.logging.Logger"); 
protected boolean isJdk14Available ( ) { note: the algorithm here is different from isLog4JAvailable. I think isLog4JAvailable is correct.... logDiagnostic("Checking for Jdk14."); try { loadClass("java.util.logging.Logger"); 
protected boolean isLog4JAvailable ( ) { logDiagnostic ( " Checking for Log4J " ) ; try { Class adapterClass = loadClass ( " org.apache.commons.logging.impl.Log4JLogger " ) ; 
protected Constructor getLogConstructor ( ) throws LogConfigurationException { Return the previously identified Constructor (if any) if (logConstructor == null) { discoverLogImplementation(getClass().getName()); } return logConstructor; } 
private static Class loadClass ( final String name ) throws ClassNotFoundException { Object result = AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { try { return threadCL . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { ignore } } try { return Class.forName( name ); } catch (ClassNotFoundException e) { return e; } } }); if (result instanceof Class) return (Class)result; throw (ClassNotFoundException)result; } 
protected boolean isJdk13LumberjackAvailable ( ) { logDiagnostic ( " Checking for Jdk13Lumberjack. " ) ; try { createLogFromClass ( " org.apache.commons.logging.impl.Jdk13LumberjackLogger " , 
protected boolean isJdk14Available ( ) { logDiagnostic ( " Checking for Jdk14. " ) ; try { createLogFromClass ( " org.apache.commons.logging.impl.Jdk14Logger " , 
protected boolean isLog4JAvailable ( ) { logDiagnostic ( " Checking for Log4J " ) ; try { createLogFromClass ( " org.apache.commons.logging.impl.Log4JLogger " , 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance = null ; try { if ( logConstructor = = null ) { 
private Log discoverLogImplementation ( String logCategory ) { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { try { note: createLogFromClass never returns null.. result = createLogFromClass(specifiedLogClassName, logCategory, true); return result; } catch (LogConfigurationException ex) { this type of exception means we've already output diagnostics about this issue, etc.; just pass it on throw ex; } catch (Throwable t) { log problem, and throw a LogConfigurationException wrapping the Throwable handleFlawedDiscovery(specifiedLogClassName, null, t); handleFlawedDiscovery should have thrown an LCE, but in case it didn't we'll throw one. Inability to instantiate a user specified class is a fatal error throw new LogConfigurationException("Unable to instantiate " + specifiedLogClassName, t); } this if-statement never exits! } No user specified log; try to discover what's on the classpath Try Log4j try { result = createLogFromClass("org.apache.commons.logging.impl.Log4JLogger", logCategory, true); } catch (LogConfigurationException lce) { LCE means we had a flawed discovery and already output diagnostics; just pass it on throw (LogConfigurationException) lce; } catch (Throwable t) { Other throwables just mean couldn't load the adapter or log4j; continue with discovery } if (result == null) { Try JDK 1.4 Logging try { result = createLogFromClass("org.apache.commons.logging.impl.Jdk14Logger", logCategory, true); } catch (LogConfigurationException lce) { LCE means we had a flawed discovery and already output diagnostics; just pass it on throw (LogConfigurationException) lce; } catch (Throwable t) { Other throwables just mean couldn't load the adapter or j.u.l; continue with discovery } } if (result == null) { Try Lumberjack try { result = createLogFromClass("org.apache.commons.logging.impl.Jdk13LumberjackLogger", logCategory, true); } catch (LogConfigurationException lce) { LCE means we had a flawed discovery and already output diagnostics; just pass it on throw (LogConfigurationException) lce; } catch (Throwable t) { Other throwables just mean couldn't load the adapter or j.u.l; continue with discovery } } if (result == null) { Try SimpleLog try { result = createLogFromClass("org.apache.commons.logging.impl.SimpleLog", logCategory, true); } catch (LogConfigurationException lce) { LCE means we had a flawed discovery and already output diagnostics; just pass it up throw (LogConfigurationException) lce; } catch (Throwable t) { Other throwables just mean couldn't load the adapter } } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private String findUserSpecifiedLogClassName ( ) { logDiagnostic ( " Trying to get log class from attribute " + LOG_PROPERTY ) ; String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated logDiagnostic("Trying to get log class from attribute " + LOG_PROPERTY_OLD); specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { logDiagnostic("Trying to get log class from system property " + LOG_PROPERTY); try { specifiedClass = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { ; } } if (specifiedClass == null) { @deprecated logDiagnostic("Trying to get log class from system property " + LOG_PROPERTY_OLD); try { specifiedClass = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { ; } } return specifiedClass; 
private Log createLogFromClass ( String logAdapterClass , String logCategory , boolean affectState ) throws Throwable { logDiagnostic ( " Attempting to instantiate " + logAdapterClass ) ; Class logClass = loadClass ( logAdapterClass ) ; Object [ ] params = { logCategory } ; Log result = null ; Constructor constructor = null ; try { constructor = logClass . getConstructor ( logConstructorSignature ) ; result = ( Log ) constructor . newInstance ( params ) ; } catch ( NoClassDefFoundError e ) { We were able to load the adapter but its underlying logger library could not be found. This is normal and not a "flawed discovery", so just throw the error on logDiagnostic("Unable to load logging library used by " + logAdapterClass); throw e; } catch (Throwable t) { ExceptionInInitializerError NoSuchMethodException InvocationTargetException ClassCastException All mean the adapter and underlying logger library were found but there was a problem creating an instance. This is a "flawed discovery" handleFlawedDiscovery(logAdapterClass, logClass, t); handleFlawedDiscovery should have thrown an LCE, but in case it didn't we'll throw one throw new LogConfigurationException(t); } if (affectState) { We've succeeded, so set instance fields this.logClassName = logClass.getName(); this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClass + " does not declare method " + "setLogFactory(LogFactory)"); } } return result; 
private void handleFlawedDiscovery ( String logClassName , Class adapterClass , Throwable discoveryFlaw ) { Output diagnostics For ClassCastException use the more complex diagnostic that analyzes the classloader hierarchy if ( discoveryFlaw instanceof ClassCastException && adapterClass != null) { reportInvalidAdapter returns a LogConfigurationException that wraps the ClassCastException; replace variable 'discoveryFlaw' with that so we can rethrow the LCE discoveryFlaw = reportInvalidLogAdapter(adapterClass, discoveryFlaw); } else { logDiagnostic("Could not instantiate Log " + logClassName + " -- " + discoveryFlaw.getLocalizedMessage()); } if (discoveryFlaw instanceof LogConfigurationException) { throw (LogConfigurationException) discoveryFlaw; 
protected boolean isJdk13LumberjackAvailable ( ) { return isLogLibraryAvailable ( " Jdk13Lumberjack " , 
protected boolean isJdk14Available ( ) { return isLogLibraryAvailable ( " Jdk14 " , 
protected boolean isLog4JAvailable ( ) { return isLogLibraryAvailable ( " Log4J " , 
private boolean isLogLibraryAvailable ( String name , String classname ) { logDiagnostic ( " Checking for " + name + " . " ) ; try { Log log = createLogFromClass ( 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { note: createLogFromClass never returns null.. result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class " + specifiedLogClassName + " cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath Try Log4j result = createLogFromClass("org.apache.commons.logging.impl.Log4JLogger", logCategory, true); if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.Jdk14Logger", logCategory, true); } if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.Jdk13LumberjackLogger", logCategory, true); } if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.SimpleLog", logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClass , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClass ) ; Class logClass = null ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; try { logClass = loadClass ( logAdapterClass ) ; constructor = logClass . getConstructor ( logConstructorSignature ) ; logAdapter = ( Log ) constructor . newInstance ( params ) ; } catch ( NoClassDefFoundError e ) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClass + " is not available: " + msg.trim()); return null; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClass + " is not available: " + msg.trim()); return null; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClass, logClass, t); return null; } if (affectState) { We've succeeded, so set instance fields this.logClassName = logClass.getName(); this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClass + " does not declare method " + "setLogFactory(LogFactory)"); } } return logAdapter; } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader" cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. JCL 1.0.4 and earlier will fail with this setup. Later versions of JCL should fail to load Log4J, but then fall back to jdk14 logging. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the classloader of this class, ie the parent classloader of the UserClass that will make the logging call. Actually, as the system classloader is expected to load this class, this test is identical to the preceding one. cls = reload(); Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); execute(cls); } 
private Class reload ( ) throws Exception { Class testObjCls = null ; AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( ClassNotFoundException cnfe ) { throw cnfe ; } catch ( Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertTrue ( " app isolated " , testObjCls . getClassLoader ( ) = = appLoader ) ; return testObjCls ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SimpleLogTest . suite ( ) ) ; suite . addTest ( NoOpLogTest . suite ( ) ) ; suite . addTest ( LogTest . suite ( ) ) ; suite . addTest ( NullClassLoaderTest . suite ( ) ) ; suite . addTest ( LoadTest . suite ( ) ) ; return suite ; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Class logAdapterClass = null ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; try { logAdapterClass = loadClass ( logAdapterClassName ) ; constructor = logAdapterClass . getConstructor ( logConstructorSignature ) ; logAdapter = ( Log ) constructor . newInstance ( params ) ; } catch ( NoClassDefFoundError e ) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClassName + " is not available: " + msg.trim()); return null; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClassName + " is not available: " + msg.trim()); return null; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, logAdapterClass, t); return null; } if (affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClassName + " does not declare method " + "setLogFactory(LogFactory)"); } } return logAdapter; } 
private void handleFlawedDiscovery ( String logAdapterClassName , Class logAdapterClass , Throwable discoveryFlaw ) { Output diagnostics For ClassCastException use the more complex diagnostic that analyzes the classloader hierarchy if (discoveryFlaw instanceof ClassCastException && logAdapterClass != null) { reportInvalidAdapter returns a LogConfigurationException that wraps the ClassCastException; replace variable 'discoveryFlaw' with that so we can rethrow the LCE discoveryFlaw = reportInvalidLogAdapter(logAdapterClass, discoveryFlaw); } else { logDiagnostic("Could not instantiate Log " + logAdapterClassName + " -- " + discoveryFlaw.getLocalizedMessage()); } if (discoveryFlaw instanceof LogConfigurationException) { throw (LogConfigurationException) discoveryFlaw; 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Class logAdapterClass = null ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; try { logAdapterClass = loadClass ( logAdapterClassName ) ; constructor = logAdapterClass . getConstructor ( logConstructorSignature ) ; logAdapter = ( Log ) constructor . newInstance ( params ) ; } catch ( ClassNotFoundException e ) { We were unable to find the log adapter String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available: " + msg.trim()); return null; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClassName + " is not available: " + msg.trim()); return null; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The logging library used by " + logAdapterClassName + " is not available: " + msg.trim()); return null; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, logAdapterClass, t); return null; } if (affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClassName + " does not declare method " + "setLogFactory(LogFactory)"); } } return logAdapter; } 
private void initConfiguration ( ) { allowFlawedContext = getBooleanConfiguration ( ALLOW_FLAWED_CONTEXT_PROPERTY , true ) ; allowFlawedDiscovery = getBooleanConfiguration ( ALLOW_FLAWED_DISCOVERY_PROPERTY , true ) ; allowFlawedHierarchy = getBooleanConfiguration ( ALLOW_FLAWED_HIERARCHY_PROPERTY , true ) ; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { note: createLogFromClass never returns null.. result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class " + specifiedLogClassName + " cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath Try Log4j result = createLogFromClass("org.apache.commons.logging.impl.Log4JLogger", logCategory, true); if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.Jdk14Logger", logCategory, true); } if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.Jdk13LumberjackLogger", logCategory, true); } if (result == null) { result = createLogFromClass("org.apache.commons.logging.impl.SimpleLog", logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { try { Class c = Class . forName ( logAdapterClassName , true , currentCL ) ; constructor = c . getConstructor ( logConstructorSignature ) ; Object o = constructor . newInstance ( params ) ; Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClassName + " does not declare method " + "setLogFactory(LogFactory)"); } } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader contextClassLoader = getContextClassLoader ( ) ; ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { throw new LogConfigurationException ( " Bad classloader hierarchy; LogFactoryImpl was loaded via " + " a classloader that is not related to the current context " + " classloader. " ) ; } if ( baseClassLoader ! = contextClassLoader ) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { logDiagnostic ( " Could not instantiate Log " + logAdapterClassName + " -- " + discoveryFlaw . getLocalizedMessage ( ) ) ; if ( ! allowFlawedDiscovery ) { throw new LogConfigurationException ( discoveryFlaw ) ; 
private void setAllowFlawedContext ( Class c , String state ) throws Exception { Class [ ] params = { String . class } ; java . lang . reflect . Method m = c . getDeclaredMethod ( " setAllowFlawedContext " , params ) ; m . invoke ( null , new Object [ ] { state } ) ; } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch(LogConfigurationException ex) { expected; the boot classloader doesn't *have* JCL available } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
public void tearDown ( ) { restore original state so a test can't stuff up later tests. Thread.currentThread().setContextClassLoader(origContextClassLoader); } 
public void testSameLogObject ( ) throws Exception { unfortunately, there just isn't any way to emulate JCL being accessable via the null classloader in "standard" systems, so we can't include this test in our standard unit tests. }} 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { try { Class c = Class . forName ( logAdapterClassName , true , currentCL ) ; constructor = c . getConstructor ( logConstructorSignature ) ; Object o = constructor . newInstance ( params ) ; Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic(logAdapterClassName + " does not declare method " + "setLogFactory(LogFactory)"); } } return logAdapter; } 
public void contextDestroyed ( ServletContextEvent sce ) { LogFactory . release ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } 
public void contextInitialized ( ServletContextEvent sce ) { do nothing }} 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { note: createLogFromClass never returns null.. result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class " + specifiedLogClassName + " cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { try { Class c = Class . forName ( logAdapterClassName , true , currentCL ) ; constructor = c . getConstructor ( logConstructorSignature ) ; Object o = constructor . newInstance ( params ) ; Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info:" + logAdapterClassName + " from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter " + logAdapterClassName + " from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader contextClassLoader = getContextClassLoader ( ) ; ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { logDiagnostic( "Warning: the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { note: createLogFromClass never returns null.. result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class " + specifiedLogClassName + " cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
public void trace ( Object message ) { getLogger ( ) . log ( FQCN , traceLevel , message , null ) ; } 
public void trace ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , traceLevel , message , ) ; } 
public void debug ( Object message ) { getLogger ( ) . log ( FQCN , Priority . DEBUG , message , null ) ; } 
public boolean isTraceEnabled ( ) { return getLogger ( ) . isEnabledFor ( traceLevel ) ; } 
public void trace ( Object message ) { getLogger ( ) . log ( FQCN , Level . TRACE , message , null ) ; } 
public void trace ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . TRACE , message , ) ; } 
public void debug ( Object message ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , null ) ; } 
public void debug ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , ) ; } 
public void info ( Object message ) { getLogger ( ) . log ( FQCN , Level . INFO , message , null ) ; } 
public void info ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . INFO , message , ) ; } 
public void warn ( Object message ) { getLogger ( ) . log ( FQCN , Level . WARN , message , null ) ; } 
public void warn ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . WARN , message , ) ; } 
public void error ( Object message ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , null ) ; } 
public void error ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , ) ; } 
public void fatal ( Object message ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , null ) ; } 
public void fatal ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , ) ; } 
public boolean isErrorEnabled ( ) { return getLogger ( ) . isEnabledFor ( Level . ERROR ) ; } 
public boolean isFatalEnabled ( ) { return getLogger ( ) . isEnabledFor ( Level . FATAL ) ; } 
public boolean isTraceEnabled ( ) { return getLogger ( ) . isTraceEnabled ( ) ; } 
public boolean isWarnEnabled ( ) { return getLogger ( ) . isEnabledFor ( Level . WARN ) ; } 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Log4J12Logger " , log . getClass ( ) . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(!log.isDebugEnabled()); assertTrue(!log.isTraceEnabled()); 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Log4J12Logger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? log.isDebugEnabled(); log.isErrorEnabled(); log.isFatalEnabled(); log.isInfoEnabled(); log.isTraceEnabled(); log.isWarnEnabled(); 
public void useSystemLoader ( String prefix ) { useExplicitLoader ( prefix , ClassLoader . getSystemClassLoader ( ) ) ; 
public void useExplicitLoader ( String prefix , ClassLoader loader ) { if ( lookasides = = null ) { lookasides = new HashMap ( ) ; } lookasides . put ( prefix , loader ) ; } 
public void addLogicalLib ( String [ ] logicalLibs ) { for ( int i = 0 ; i < logicalLibs . length ; + + i ) { addLogicalLib ( logicalLibs [ i ] ) ; 
public void addLogicalLib ( String logicalLib ) { String filename = System . getProperty ( logicalLib ) ; if ( filename = = null ) { throw new UnknownError ( " Logical lib [ " + logicalLib + " ] is not defined " + " as a System property. " ) ; } try { URL url = new File ( filename ) . toURL ( ) ; 
protected Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for(Iterator i = lookasides.entrySet().iterator(); i.hasNext(); ) { Map.Entry entry = (Map.Entry) i.next(); String prefix = (String) entry.getKey(); if (name.startsWith(prefix) == true) { ClassLoader loader = (ClassLoader) entry.getValue(); Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); 
public Enumeration getResources ( String name ) throws IOException { if ( parentFirst ) { return super . getResources ( name ) ; 
public void runTest ( Test test , TestResult result ) { ClassLoader origContext = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( contextLoader ) ; 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. parent.useSystemLoader("org.apache.commons.logging.jdk14.TestHandler"); parent.addLogicalLib("commons-logging-api"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. parent.useSystemLoader("org.apache.commons.logging.jdk14.TestHandler"); parent.addLogicalLib("commons-logging"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { return new TestSuite ( CustomConfigTestCase . class ) ; } 
protected void checkLogRecords ( boolean thrown ) { Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertTrue ( " LogRecord class " , record . getSourceClassName ( ) . startsWith ( " org.apache.commons.logging.jdk14.CustomConfig " ) ) ; if ( thrown ) { assertEquals ( " LogRecord method " , " logExceptionMessages " , record . getSourceMethodName ( ) ) ; } else { assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } if ( thrown ) { assertNotNull ( " LogRecord thrown " , record . getThrown ( ) ) ; assertTrue ( " LogRecord thrown type " , record . getThrown ( ) instanceof IndexOutOfBoundsException ) ; } else { assertNull ( " LogRecord thrown " , record . getThrown ( ) ) ; } } assertTrue ( ! records . hasNext ( ) ) ; handler . flush ( ) ; } 
public static Test suite ( ) throws Exception { return ( new TestSuite ( DefaultConfigTestCase . class ) ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging-api " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( CustomConfigAPITestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( CustomConfigFullTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( CustomConfigTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public void testExceptionMessages ( ) throws Exception { logExceptionMessages ( ) ; checkLoggingEvents ( true ) ; 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( DefaultConfigTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); make the junit classes from the system classpath visible, though, as junit won't be able to call this class at all without this.. parent.useSystemLoader("junit."); make the commons-logging-api.jar classes visible via the parent parent.addLogicalLib("commons-logging-api"); create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader Class testClass = child.loadClass(PathableTestCase.class.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl non-api classes should not be visible try { Class log4jClass = contextLoader.loadClass( "org.apache.commons.logging.impl.Log4J12Logger"); fail("Class Log4J12Logger is unexpectedly available"); } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public static Test suite ( ) throws Exception { make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); make the junit classes from the system classpath visible, though, as junit won't be able to call this class at all without this.. parent.useSystemLoader("junit."); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader Class testClass = child.loadClass(PathableTestCase.class.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4J12Logger"); assertSame("Log4J12Logger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4J12Logger.class"); assertNotNull("Unable to locate Log4J12Logger.class resource", resource); assertTrue("Incorrect source for Log4J12Logger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4J12Logger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4J12Logger.class resources found", 2, urls.length); assertTrue("Incorrect source for Log4J12Logger class", urls[0].toString().indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4J12Logger class", urls[1].toString().indexOf("/commons-logging-adapters-1.") > 0); 
private static URL [ ] toURLArray ( Enumeration e ) { ArrayList l = new ArrayList ( ) ; while ( e . hasMoreElements ( ) ) { URL u = ( URL ) e . nextElement ( ) ; l . add ( u ) ; } URL [ ] tmp = new URL [ l . size ( ) ] ; return ( URL [ ] ) l . toArray ( tmp ) ; } 
public void testResourceAsStream ( ) throws Exception { java . io . InputStream is ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResourceAsStream where no instances exist is = childLoader.getResourceAsStream("nosuchfile"); assertNull("Invalid resource returned non-null stream", is); getResourceAsStream where resource does exist is = childLoader.getResourceAsStream("org/apache/commons/logging/Log.class"); assertNotNull("Null returned for valid resource", is); is.close(); 
private static void checkAndSetContext ( ) { ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( " ContextLoader is of unexpected type " , contextLoader . getClass ( ) . getName ( ) , PathableClassLoader . class . getName ( ) ) ; URL [ ] noUrls = new URL [ 0 ] ; Thread . currentThread ( ) . setContextClassLoader ( new URLClassLoader ( noUrls ) ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = ParentFirstTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public static Test suite ( ) throws Exception { Class thisClass = ChildFirstTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); parent.setParentFirst(false); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); Make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); Create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); Obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); Create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); context.setParentFirst(false); reload this class via the child classloader Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4J12Logger"); assertSame("Log4J12Logger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4J12Logger.class"); assertNotNull("Unable to locate Log4J12Logger.class resource", resource); assertTrue("Incorrect source for Log4J12Logger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4J12Logger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4J12Logger.class resources found", 2, urls.length); assertTrue("Incorrect source for Log4J12Logger class", urls[0].toString().indexOf("/commons-logging-adapters-1.") > 0); assertTrue("Incorrect source for Log4J12Logger class", urls[1].toString().indexOf("/commons-logging-1.") > 0); 
public static void main ( String [ ] args ) { String [ ] testCaseName = { AvalonLoggerTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( AvalonLoggerTestCase . class ) ; return suite ; } 
public void testPutCalled ( ) throws Exception { AltHashtable . lastKey = null ; AltHashtable . lastValue = null ; ClassLoader classLoader = new ClassLoader ( ) { } ; Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { LogFactory . getLog ( AltHashtableTestCase . class ) ; } } ) ; thread . setContextClassLoader ( classLoader ) ; thread . start ( ) ; thread . join ( ) ; assertEquals ( classLoader , AltHashtable . lastKey ) ; assertNotNull ( AltHashtable . lastValue ) ; } 
public void run ( ) { LogFactory . getLog ( AltHashtableTestCase . class ) ; } 
public void runTest ( Test test , TestResult result ) { ClassLoader origContext = Thread . currentThread ( ) . getContextClassLoader ( ) ; Properties oldSysProps = ( Properties ) System . getProperties ( ) . clone ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( contextLoader ) ; 
public static Test suite ( ) throws Exception { Class thisClass = GeneralTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , thisClassLoader ) ; loader . addLogicalLib ( " testclasses " ) ; reload this class via the child classloader Class testClass = loader.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, loader); } 
private static void checkAndSetProperties ( ) { String prop = System . getProperty ( " no.such.property " ) ; assertNull ( " no.such.property is unexpectedly defined " , prop ) ; System . setProperty ( " no.such.property " , " dummy value " ) ; prop = System . getProperty ( " no.such.property " ) ; assertNotNull ( " no.such.property is unexpectedly undefined " , prop ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = AltHashtableTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , thisClassLoader ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testType ( ) { Here, the reference to the LogFactory class should cause the class to be loaded and initialised. It will see the property set and use the AltHashtable class. If other tests in this class have already been run within the same classloader then LogFactory will already have been initialised, but that doesn't change the effectiveness of this test. assertTrue(LogFactory.factories instanceof AltHashtable); } 
public void testPutCalled ( ) throws Exception { AltHashtable . lastKey = null ; AltHashtable . lastValue = null ; LogFactory . getLog ( AltHashtableTestCase . class ) ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( contextLoader , AltHashtable . lastKey ) ; assertNotNull ( AltHashtable . lastValue ) ; } 
public void testPutCalled ( ) throws Exception { Log log = LogFactory . getLog ( BadHashtablePropertyTestCase . class ) ; } 
public void setUp ( ) throws Exception { LogFactory . releaseAll ( ) ; setUpFactory ( ) ; setUpLog ( " TestLogger " ) ; } 
public void setUp ( ) throws Exception { LogFactory . releaseAll ( ) ; setProperties ( ) ; expected = new ArrayList ( ) ; setUpFactory ( ) ; setUpLog ( " DecoratedLogger " ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = CustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = DateTimeCustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = DefaultConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void setUp ( ) throws Exception { LogFactory . releaseAll ( ) ; setProperties ( ) ; setUpFactory ( ) ; setUpLog ( " TestLogger " ) ; } 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behaviour - even though it's not the desired behaviour. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4J12Logger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4J12Logger.class resources found", 2, urls.length); assertTrue("Incorrect source for Log4J12Logger class", urls[0].toString().indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4J12Logger class", urls[1].toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behaviour - even though it's not the desired behaviour. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4J12Logger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4J12Logger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4J12Logger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4J12Logger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4J12Logger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4J12Logger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4J12Logger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4J12Logger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public void testIsEnabledClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeIsEnabledTest ( log ) ; } 
public void testIsEnabledNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeIsEnabledTest ( log ) ; } 
public void testMessageWithoutExceptionClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithoutExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithExceptionClassLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithExceptionTest ( log ) ; } 
public void testMessageWithExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithExceptionTest ( log ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { LoadTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { NoOpLogTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { NullClassLoaderTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { SimpleLogTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { LogTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public void testAppender ( ) throws Exception { setUpTestAppender ( ) ; TestAppender testAppender = getTestAppender ( ) ; assertNotNull ( " Appender exists " , testAppender ) ; } 
public void testCreateFactory ( ) { LogFactory factory = LogFactory . getFactory ( ) ; assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void testCreateLog ( ) throws Exception { setUpTestAppender ( ) ; Log log = LogFactory . getLog ( " test-category " ) ; check that it is of the expected type, that we can access the underlying real logger and that the logger level has been set as expected after the call to setUpTestAppender. Log4J12Logger log4j12 = (Log4J12Logger) log; Logger logger = log4j12.getLogger(); assertEquals("Logger name", "test-category", logger.getName()); assertEquals("Logger level", Level.INFO, logger.getEffectiveLevel()); } 
public void testPlainMessages ( ) throws Exception { setUpTestAppender ( ) ; Log log = LogFactory . getLog ( " test-category " ) ; logPlainMessages ( log ) ; checkLoggingEvents ( false ) ; } 
public void testExceptionMessages ( ) throws Exception { setUpTestAppender ( ) ; Log log = LogFactory . getLog ( " test-category " ) ; logExceptionMessages ( log ) ; checkLoggingEvents ( true ) ; } 
public void testSerializable ( ) throws Exception { Log log = LogFactory . getLog ( " test-category " ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( log ) ; oos . close ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; ObjectInputStream ois = new ObjectInputStream ( bais ) ; Log newLog = ( Log ) ois . readObject ( ) ; ois . close ( ) ; Check the characteristics of the resulting object logExceptionMessages(newLog); checkLoggingEvents(true); } 
private void setUpTestAppender ( ) throws Exception { Properties props = new Properties ( ) ; props . put ( " log4j.rootLogger " , " INFO, A1 " ) ; props . put ( " log4j.appender.A1 " , " org.apache.commons.logging.log4j.TestAppender " ) ; PropertyConfigurator . configure ( props ) ; } 
private void checkLoggingEvents ( boolean thrown ) { TestAppender appender = getTestAppender ( ) ; Iterator events = appender . events ( ) ; for ( int i = 0 ; i < TEST_MESSAGES . length ; i + + ) { assertTrue ( " Logged event " + i + " exists " , events . hasNext ( ) ) ; LoggingEvent event = ( LoggingEvent ) events . next ( ) ; assertEquals ( " LoggingEvent level " , TEST_LEVELS [ i ] , event . getLevel ( ) ) ; assertEquals ( " LoggingEvent message " , TEST_MESSAGES [ i ] , event . getMessage ( ) ) ; if ( thrown ) { assertNotNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) . getThrowableStrRep ( ) ) ; assertTrue ( " LoggingEvent thrown type " , event . getThrowableInformation ( ) . getThrowableStrRep ( ) [ 0 ] . indexOf ( " IndexOutOfBoundsException " ) > 0 ) ; } else { assertNull ( " LoggingEvent thrown " , event . getThrowableInformation ( ) ) ; } } assertTrue ( ! events . hasNext ( ) ) ; appender . flush ( ) ; } 
private void logPlainMessages ( Log log ) { log . trace ( " trace " ) ; Should not actually get logged log.debug("debug"); Should not actually get logged log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); } 
private void logExceptionMessages ( Log log ) { Throwable = new IndexOutOfBoundsException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
public static Test suite ( ) throws Exception { Class thisClass = ApiClasspathStandardTestCase . class ; PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging-api " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = AppClasspathStandardTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " log4j12 " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = ChildClasspathStandardTestCase . class ; PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = ParentClasspathStandardTestCase . class ; PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , child ) ; } 
public void forwardMessages ( List logEvents ) ; } ------------------------------------------------------------------- JUnit Infrastructure Methods ------------------------------------------------------------------- private void logExceptionMessages(Log log) { Throwable t = new IndexOutOfBoundsException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
protected abstract String getTestHelperClassName ( ) ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(Log log) { Throwable t = new IndexOutOfBoundsException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
public void testPlainMessages ( ) throws Exception { List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; Log log = LogFactory . getLog ( " test-category " ) ; logPlainMessages ( log ) ; checkLoggingEvents ( logEvents , false ) ; } 
public void testExceptionMessages ( ) throws Exception { List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; Log log = LogFactory . getLog ( " test-category " ) ; logExceptionMessages ( log ) ; checkLoggingEvents ( logEvents , true ) ; } 
public void testSerializable ( ) throws Exception { List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; Log log = LogFactory . getLog ( " test-category " ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( log ) ; oos . close ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; ObjectInputStream ois = new ObjectInputStream ( bais ) ; Log newLog = ( Log ) ois . readObject ( ) ; ois . close ( ) ; Check the characteristics of the resulting object logExceptionMessages(newLog); checkLoggingEvents(logEvents, true); } 
private void setUpTestAppender ( List logEvents ) throws Exception { String testHelperClassName = getTestHelperClassName ( ) ; Class clazz = this . getClass ( ) . getClassLoader ( ) . loadClass ( testHelperClassName ) ; TestHelper testHelper = ( TestHelper ) clazz . newInstance ( ) ; testHelper . forwardMessages ( logEvents ) ; } 
private void checkLoggingEvents ( List logEvents , boolean thrown ) { LogEvent ev ; assertEquals ( " Unexpected number of log events " , 4 , logEvents . size ( ) ) ; ev = ( LogEvent ) logEvents . get ( 0 ) ; assertEquals ( " Info message expected " , " info " , ev . msg ) ; assertEquals ( " Info level expected " , " INFO " , ev . level ) ; assertEquals ( " Exception data incorrect " , ( ev . throwable ! = null ) , thrown ) ; ev = ( LogEvent ) logEvents . get ( 1 ) ; assertEquals ( " Warn message expected " , " warn " , ev . msg ) ; assertEquals ( " Warn level expected " , " WARN " , ev . level ) ; assertEquals ( " Exception data incorrect " , ( ev . throwable ! = null ) , thrown ) ; ev = ( LogEvent ) logEvents . get ( 2 ) ; assertEquals ( " Error message expected " , " error " , ev . msg ) ; assertEquals ( " Error level expected " , " ERROR " , ev . level ) ; assertEquals ( " Exception data incorrect " , ( ev . throwable ! = null ) , thrown ) ; ev = ( LogEvent ) logEvents . get ( 3 ) ; assertEquals ( " Fatal message expected " , " fatal " , ev . msg ) ; assertEquals ( " Fatal level expected " , " FATAL " , ev . level ) ; assertEquals ( " Exception data incorrect " , ( ev . throwable ! = null ) , thrown ) ; } 
protected void append ( LoggingEvent event ) { StandardTests . LogEvent lev = new StandardTests . LogEvent ( ) ; lev . level = event . getLevel ( ) . toString ( ) ; if ( event . getMessage ( ) = = null ) lev . msg = null ; else lev . msg = event . getMessage ( ) . toString ( ) ; if ( event . getThrowableInformation ( ) = = null ) lev . throwable = null ; else lev . throwable = event . getThrowableInformation ( ) . getThrowable ( ) ; events . add ( lev ) ; } 
public void forwardMessages ( List logEvents ) { tTestAppender appender = new TestAppender ( logEvents ) ; Logger rootLogger = Logger . getRootLogger ( ) ; rootLogger . removeAllAppenders ( ) ; rootLogger . addAppender ( appender ) ; rootLogger . setLevel ( Level . INFO ) ; } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(Log log) { Throwable t = new IndexOutOfBoundsException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging-api " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " log4j12 " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props=null; try { InputStream stream = getResourceAsStream(contextClassLoader, FACTORY_PROPERTIES); if (stream != null) { props = new Properties(); props.load(stream); stream.close(); } } catch (IOException e) { ; ignore } catch (SecurityException e) { ; ignore } First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory( factoryClassName, contextClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: we don't try to load the LogFactory implementation via the context classloader here because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public void addURL ( URL url ) { System . err . println ( " adding URL [ " + url + " ] " ) ; super . addURL ( url ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory( factoryClassName, contextClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, contextClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static Enumeration getResources ( final ClassLoader loader , final String name ) { PrivilegedAction action = new PrivilegedAction ( ) { public Object run ( ) { try { if ( loader ! = null ) { return loader . getResources ( name ) ; } else { return ClassLoader . getSystemResources ( name ) ; } } catch ( IOException e ) { logDiagnostic ( " Exception while trying to find configuration file " + name + " : " + e . getMessage ( ) ) ; return null ; } } } ; Object result = AccessController . doPrivileged ( action ) ; return ( Enumeration ) result ; } 
public Object run ( ) { try { if ( loader ! = null ) { 
public Object run ( ) { try { InputStream stream = url . openStream ( ) ; if ( stream ! = null ) { Properties props = new Properties ( ) ; props . load ( stream ) ; stream . close ( ) ; return props ; } } catch ( IOException e ) { logDiagnostic ( " Unable to read URL " + url ) ; } return null ; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { props = newProps ; } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; if ( newPriorityStr ! = null ) { double newPriority = Double . valueOf ( newPriorityStr ) . doubleValue ( ) ; if ( newPriority > priority ) { props = newProps ; priority = newPriority ; } } } } } } catch ( SecurityException e ) { logDiagnostic ( " SecurityException thrown " ) ; } return props ; } 
public static Test suite ( ) throws Exception { Class thisClass = PriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useSystemLoader("junit."); containerLoader.addLogicalLib("commons-logging"); URL pri10URL = new URL(baseUrl, "priority10/"); containerLoader.addURL(pri10URL); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.setParentFirst(true); webappLoader.addLogicalLib("testclasses"); URL noPriorityURL = new URL(baseUrl, "nopriority/"); webappLoader.addURL(noPriorityURL); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri20aURL = new URL(baseUrl, "priority20a/"); webappLoader.addURL(pri20aURL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; String id = ( String ) instance . getAttribute ( " configId " ) ; assertEquals ( " Correct config file loaded " , " priority20 " , id ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { if (Boolean.valueOf(useTCCLStr) == Boolean.FALSE) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass( "org.apache.commons.logging.tccl.custom.MyLogFactoryImpl"); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass( 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_FACTORY_IMPL); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_FACTORY_IMPL); 
public void testTcclLoading ( ) throws Exception { try { LogFactory instance = LogFactory . getFactory ( ) ; 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class " + specifiedLogClassName + " cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { try { Class c = Class . forName ( logAdapterClassName , true , currentCL ) ; constructor = c . getConstructor ( logConstructorSignature ) ; Object o = constructor . newInstance ( params ) ; Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info:" + logAdapterClassName + " from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter " + logAdapterClassName + " from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( useTCCL = = false ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoader ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { logDiagnostic( "Warning: the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
public boolean isDebugEnabled ( ) { return false ; } public boolean isErrorEnabled ( ) { return false ; } 
public boolean isErrorEnabled ( ) { return false ; } public boolean isFatalEnabled ( ) { return false ; } 
public boolean isFatalEnabled ( ) { return false ; } public boolean isInfoEnabled ( ) { return false ; } 
public boolean isInfoEnabled ( ) { return false ; } public boolean isTraceEnabled ( ) { return false ; } 
public boolean isTraceEnabled ( ) { return false ; } public boolean isWarnEnabled ( ) { return false ; } 
public void trace ( Object message ) { } public void trace ( Object message , Throwable ) { } public void debug ( Object message ) { } public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void trace ( Object message , Throwable ) { } public void debug ( Object message ) { } public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void debug ( Object message ) { } public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void debug ( Object message , Throwable ) { } public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void info ( Object message ) { } public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void info ( Object message , Throwable ) { } public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void warn ( Object message ) { } public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void warn ( Object message , Throwable ) { } public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void error ( Object message ) { } public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void error ( Object message , Throwable ) { } public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public void fatal ( Object message ) { } public void fatal ( Object message , Throwable ) { } } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLog parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); } catch(ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; try { Log log = instance . getLog ( " test " ) ; 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); } catch(ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; Log log = instance . getLog ( " test " ) ; assertEquals ( " Correct Log loaded " , 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useSystemLoader("junit."); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void contextDestroyed ( ServletContextEvent sce ) { ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessable via this loader, but is accessable via some ancestor then that class will be returned. try { Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(IllegalAccessException ex) { This is not expected; every ancestor class should be accessable System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behaviour - even though it's not the desired behaviour. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public void debug ( Object message , Throwable ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( message ) , ) ; } 
public void debug ( Object message ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( message ) ) ; } 
public void error ( Object message , Throwable ) { if ( getLogger ( ) . isErrorEnabled ( ) ) getLogger ( ) . error ( String . valueOf ( message ) , ) ; } 
public void error ( Object message ) { if ( getLogger ( ) . isErrorEnabled ( ) ) getLogger ( ) . error ( String . valueOf ( message ) ) ; } 
public void fatal ( Object message , Throwable ) { if ( getLogger ( ) . isFatalErrorEnabled ( ) ) getLogger ( ) . fatalError ( String . valueOf ( message ) , ) ; } 
public void fatal ( Object message ) { if ( getLogger ( ) . isFatalErrorEnabled ( ) ) getLogger ( ) . fatalError ( String . valueOf ( message ) ) ; } 
public void info ( Object message , Throwable ) { if ( getLogger ( ) . isInfoEnabled ( ) ) getLogger ( ) . info ( String . valueOf ( message ) , ) ; } 
public void info ( Object message ) { if ( getLogger ( ) . isInfoEnabled ( ) ) getLogger ( ) . info ( String . valueOf ( message ) ) ; } 
public void trace ( Object message , Throwable ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( message ) , ) ; } 
public void trace ( Object message ) { if ( getLogger ( ) . isDebugEnabled ( ) ) getLogger ( ) . debug ( String . valueOf ( message ) ) ; } 
public void warn ( Object message , Throwable ) { if ( getLogger ( ) . isWarnEnabled ( ) ) getLogger ( ) . warn ( String . valueOf ( message ) , ) ; } 
public void warn ( Object message ) { if ( getLogger ( ) . isWarnEnabled ( ) ) getLogger ( ) . warn ( String . valueOf ( message ) ) ; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader ) { return newFactory ( factoryClass , classLoader , null ) ; } 
public void contextDestroyed ( ServletContextEvent sce ) { ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialised/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessable via this loader, but is accessable via some ancestor then that class will be returned. try { Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(IllegalAccessException ex) { This is not expected; every ancestor class should be accessable System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public static Test suite ( ) throws Exception { LogFactory in parent LogFactory in child (loads test) LogFactory in tccl Having the test loaded via a loader above the tccl emulates the situation where a web.xml file specifies ServletContextCleaner as a listener, and that class is deployed via a shared classloader. PathableClassLoader parent = new PathableClassLoader(null); parent.useSystemLoader("junit."); parent.addLogicalLib("commons-logging"); parent.addLogicalLib("servletapi"); PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); child.addLogicalLib("commons-logging"); child.addLogicalLib("testclasses"); PathableClassLoader tccl = new PathableClassLoader(child); tccl.setParentFirst(false); tccl.addLogicalLib("commons-logging"); Class testClass = child.loadClass(BasicServletTestCase.class.getName()); return new PathableTestSuite(testClass, tccl); } 
public void testBasics ( ) { ServletContextCleaner scc = new ServletContextCleaner ( ) ; scc . contextDestroyed ( null ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { throw new LogConfigurationException( "User-specified log class '" + specifiedLogClassName + "' cannot be found or is not useable."); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private static void logClassLoaderTree ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " Extension directories: " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " Application classpath: " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; ClassLoader systemClassLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "Security forbids determining the classloader for " + className); return; } logDiagnostic( "Class " + className + " was loaded via classloader " + objectId(classLoader)); try { systemClassLoader = ClassLoader.getSystemClassLoader(); } catch(SecurityException ex) { logDiagnostic( "Security forbids determining the system classloader."); return; } if (classLoader != null) { StringBuffer buf = new StringBuffer("ClassLoader tree:"); 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load " + logAdapterClassName + " from classloader " + objectId(currentCL)); try { Class c = Class.forName(logAdapterClassName, true, currentCL); constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info:" + logAdapterClassName + " from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter " + logAdapterClassName + " from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; This variable is used to ensure that the system classloader is tried only once when getParent is null. boolean systemClassloaderTried = false; for(;;) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load " + logAdapterClassName + " from classloader " + objectId(currentCL)); try { Class c = Class.forName(logAdapterClassName, true, currentCL); constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (ClassNotFoundException e) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader final ClassLoader parentCL = currentCL.getParent(); getParent may return null to indicate that the parent is the 'bootstrap classloader'. This term is difficult. A reasonable way to interpret this is as the system classloader which is provided as a base for delegating classloaders. Note that this functionality cannot be easily tested since it depends upon an optional behaviour of the basic java libraries. The Sun libraries do not behave in this fashion. It may be possible to create a test that uses a customized boot classpath containing a special implementation but this approach would need to wait until an open source Java implementation exists. So sadly, this code path is not unit tested. if (parentCL == null) { if (systemClassloaderTried == true) { logDiagnostic("Parent classloader is NULL. But System ClassLoader has already been tried."); break; } try system classloader try { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); if (systemClassLoader == null) { logDiagnostic("System classloader is NULL. Cannot find parent of classloader " + objectId(currentCL)); break; } else if (systemClassLoader.equals(currentCL)) { the system classloader has already been tried and failed logDiagnostic("System classloader tried and failed."); break; } else { the parent is null indicating that the parent is the boot classloader so retry with system classloader currentCL = systemClassLoader; avoid infinite loops by trying the system loader only the first time a classloader systemClassloaderTried = true; logDiagnostic("Parent classloader is NULL. Trying System ClassLoader."); } } catch (Throwable t) { getSystemClassLoader is allowed to fail in many strange ways: so need to catch everything including errors logDiagnostic("Failed to get system classloader: '" + t.getMessage() + "'. Cannot find parent of classloader " + objectId(currentCL)); break; } } else { currentCL = parentCL; } } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info:" + logAdapterClassName + " from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter " + logAdapterClassName + " from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate " + logAdapterClassName ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; This variable is used to ensure that the system classloader is tried only once when getParent is null. boolean systemClassloaderTried = false; for(;;) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load " + logAdapterClassName + " from classloader " + objectId(currentCL)); try { Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter " + logAdapterClassName + " is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader final ClassLoader parentCL = currentCL.getParent(); getParent may return null to indicate that the parent is the 'bootstrap classloader'. This term is difficult. A reasonable way to interpret this is as the system classloader which is provided as a base for delegating classloaders. Note that this functionality cannot be easily tested since it depends upon an optional behaviour of the basic java libraries. The Sun libraries do not behave in this fashion. It may be possible to create a test that uses a customized boot classpath containing a special implementation but this approach would need to wait until an open source Java implementation exists. So sadly, this code path is not unit tested. if (parentCL == null) { if (systemClassloaderTried == true) { logDiagnostic("Parent classloader is NULL. But System ClassLoader has already been tried."); break; } try system classloader try { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); if (systemClassLoader == null) { logDiagnostic("System classloader is NULL. Cannot find parent of classloader " + objectId(currentCL)); break; } else if (systemClassLoader.equals(currentCL)) { the system classloader has already been tried and failed logDiagnostic("System classloader tried and failed."); break; } else { the parent is null indicating that the parent is the boot classloader so retry with system classloader currentCL = systemClassLoader; avoid infinite loops by trying the system loader only the first time a classloader systemClassloaderTried = true; logDiagnostic("Parent classloader is NULL. Trying System ClassLoader."); } } catch (Throwable t) { getSystemClassLoader is allowed to fail in many strange ways: so need to catch everything including errors logDiagnostic("Failed to get system classloader: '" + t.getMessage() + "'. Cannot find parent of classloader " + objectId(currentCL)); break; } } else { currentCL = parentCL; } } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in " + logAdapterClassName); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info:" + logAdapterClassName + " from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter " + logAdapterClassName + " from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
public static Test suite ( ) throws Exception { PathableClassLoader contextClassLoader = new PathableClassLoader ( null ) ; contextClassLoader . useSystemLoader ( " junit. " ) ; PathableTestSuite suite = new PathableTestSuite ( BadTCCLTestCase . class , contextClassLoader ) ; return suite ; } 
public void testGetLog ( ) { Log log = LogFactory . getLog ( BadTCCLTestCase . class ) ; log . debug ( " Hello, Mum " ) ; } 
public static Test suite ( ) throws Exception { ; PathableTestSuite suite = new PathableTestSuite ( NullTCCLTestCase . class , null ) ; return suite ; } 
public void testGetLog ( ) { Log log = LogFactory . getLog ( NullTCCLTestCase . class ) ; log . debug ( " Hello, Mum " ) ; } 
private static Enumeration getResources ( final ClassLoader loader , final String name ) { PrivilegedAction action = new PrivilegedAction ( ) { public Object run ( ) { try { if ( loader ! = null ) { return loader . getResources ( name ) ; } else { return ClassLoader . getSystemResources ( name ) ; } } catch ( IOException e ) { logDiagnostic ( " Exception while trying to find configuration file " + name + " : " + e . getMessage ( ) ) ; return null ; } catch ( NoSuchMethodError e ) { we must be running on a 1.1 JVM which doesn't support ClassLoader.getSystemResources; just return null in this case. return null; } } }; Object result = AccessController.doPrivileged(action); return (Enumeration) result; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can if (specifiedLogClassName != null) { final String trimmedName = specifiedLogClassName.trim(); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_SIMPLE_LOGGER); } throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { this formular (first four letters of the name excluding package) gives a reason guess if (candidate.regionMatches(true, 0, name, 0, 38)) { messageBuffer.append(" Did you mean '"); 
private static void logClassLoaderTree ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " [ENV] Extension directories: " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " [ENV] Application classpath: " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " [ENV] Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; ClassLoader systemClassLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); try { systemClassLoader = ClassLoader.getSystemClassLoader(); } catch(SecurityException ex) { logDiagnostic( "[ENV] Security forbids determining the system classloader."); return; } if (classLoader != null) { StringBuffer buf = new StringBuffer("[ENV] ClassLoader tree:"); 
private static void initDiagnostics ( ) { String dest ; ttry { dest = System . getProperty ( DIAGNOSTICS_DEST_PROPERTY ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory --> classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory -> " + classLoaderName + "] "; } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl -> " + classLoaderName + "] "; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; This variable is used to ensure that the system classloader is tried only once when getParent is null. boolean systemClassloaderTried = false; for(;;) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader final ClassLoader parentCL = currentCL.getParent(); getParent may return null to indicate that the parent is the 'bootstrap classloader'. This term is difficult. A reasonable way to interpret this is as the system classloader which is provided as a base for delegating classloaders. Note that this functionality cannot be easily tested since it depends upon an optional behaviour of the basic java libraries. The Sun libraries do not behave in this fashion. It may be possible to create a test that uses a customized boot classpath containing a special implementation but this approach would need to wait until an open source Java implementation exists. So sadly, this code path is not unit tested. if (parentCL == null) { if (systemClassloaderTried == true) { logDiagnostic("Parent classloader is NULL. But System ClassLoader has already been tried."); break; } try system classloader try { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); if (systemClassLoader == null) { logDiagnostic("System classloader is NULL. Cannot find parent of classloader " + objectId(currentCL)); break; } else if (systemClassLoader.equals(currentCL)) { the system classloader has already been tried and failed logDiagnostic("System classloader tried and failed."); break; } else { the parent is null indicating that the parent is the boot classloader so retry with system classloader currentCL = systemClassLoader; avoid infinite loops by trying the system loader only the first time a classloader systemClassloaderTried = true; logDiagnostic("Parent classloader is NULL. Trying System ClassLoader."); } } catch (Throwable t) { getSystemClassLoader is allowed to fail in many strange ways: so need to catch everything including errors logDiagnostic("Failed to get system classloader: '" + t.getMessage() + "'. Cannot find parent of classloader " + objectId(currentCL)); break; } } else { currentCL = parentCL; } } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "info: '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getLocalizedMessage ( ) ) ; if ( ! allowFlawedDiscovery ) { throw new LogConfigurationException ( discoveryFlaw ) ; 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " [ENV] Extension directories: " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " [ENV] Application classpath: " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " [ENV] Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; ClassLoader systemClassLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); try { systemClassLoader = ClassLoader.getSystemClassLoader(); } catch(SecurityException ex) { logDiagnostic( "[ENV] Security forbids determining the system classloader."); return; } if (classLoader != null) { StringBuffer buf = new StringBuffer("[ENV] ClassLoader tree:"); 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; This variable is used to ensure that the system classloader is tried only once when getParent is null. boolean systemClassloaderTried = false; for(;;) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader final ClassLoader parentCL = currentCL.getParent(); getParent may return null to indicate that the parent is the 'bootstrap classloader'. This term is difficult. A reasonable way to interpret this is as the system classloader which is provided as a base for delegating classloaders. Note that this functionality cannot be easily tested since it depends upon an optional behaviour of the basic java libraries. The Sun libraries do not behave in this fashion. It may be possible to create a test that uses a customized boot classpath containing a special implementation but this approach would need to wait until an open source Java implementation exists. So sadly, this code path is not unit tested. if (parentCL == null) { if (systemClassloaderTried == true) { logDiagnostic("Parent classloader is NULL. But System ClassLoader has already been tried."); break; } try system classloader try { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); if (systemClassLoader == null) { logDiagnostic("System classloader is NULL. Cannot find parent of classloader " + objectId(currentCL)); break; } else if (systemClassLoader.equals(currentCL)) { the system classloader has already been tried and failed logDiagnostic("System classloader tried and failed."); break; } else { the parent is null indicating that the parent is the boot classloader so retry with system classloader currentCL = systemClassLoader; avoid infinite loops by trying the system loader only the first time a classloader systemClassloaderTried = true; logDiagnostic("Parent classloader is NULL. Trying System ClassLoader."); } } catch (Throwable t) { getSystemClassLoader is allowed to fail in many strange ways: so need to catch everything including errors logDiagnostic("Failed to get system classloader: '" + t.getMessage() + "'. Cannot find parent of classloader " + objectId(currentCL)); break; } } else { currentCL = parentCL; } } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " [ENV] Extension directories: " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " [ENV] Application classpath: " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " [ENV] Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; ClassLoader systemClassLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); if (classLoader != null) { final String classLoaderString = classLoader.toString(); logDiagnostic("[ENV] " + objectId(classLoader) + " == '" + classLoaderString + "'"); } try { systemClassLoader = ClassLoader.getSystemClassLoader(); } catch(SecurityException ex) { logDiagnostic( "[ENV] Security forbids determining the system classloader."); return; } if (classLoader != null) { StringBuffer buf = new StringBuffer("[ENV] ClassLoader tree:"); 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use.."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClass + " as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use.."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "Creating an instance of LogFactory class " + factoryClassName + " as specified by file " + SERVICE_ID + " which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations.."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "Looking for a properties file of name " + FACTORY_PROPERTIES + " to define the LogFactory subclass to use.."); if (props != null) { logDiagnostic( "Properties file found. Looking for property " + FACTORY_PROPERTY + " to define the LogFactory subclass to use.."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "Loading the default LogFactory implementation " + FACTORY_DEFAULT + " via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " [ENV] Extension directories: " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " [ENV] Application classpath: " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " [ENV] Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] ", classLoader); } 
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "[LOOKUP] Looking for a properties file of name '" + FACTORY_PROPERTIES + "' to define the LogFactory subclass to use..."); if (props != null) { logDiagnostic( "[LOOKUP] Properties file found. Looking for property '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { logDiagnostic( "[LOOKUP] Looking for a properties file of name '" + FACTORY_PROPERTIES + "' to define the LogFactory subclass to use..."); if (props != null) { logDiagnostic( "[LOOKUP] Properties file found. Looking for property '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static void initDiagnostics ( ) { String dest ; ttry { dest = System . getProperty ( DIAGNOSTICS_DEST_PROPERTY ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory --> classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory -> " + classLoaderName + "] "; } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl@" + System.identityHashCode(this) + " -> " + classLoaderName + "] "; } 
private String findUserSpecifiedLogClassName ( ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); try { specifiedClass = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { ; } } if (specifiedClass == null) { @deprecated logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); try { specifiedClass = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { ; } } return specifiedClass; 
private String findUserSpecifiedLogClassName ( ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); try { specifiedClass = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } if (specifiedClass == null) { @deprecated logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); try { specifiedClass = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } return specifiedClass; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a properties file of name '" + FACTORY_PROPERTIES + "' to define the LogFactory subclass to use..."); } if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file found. Looking for property '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static void release ( ClassLoader classLoader ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; } synchronized ( factories ) { if ( classLoader = = null ) { 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; } synchronized ( factories ) { Enumeration elements = factories . elements ( ) ; 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Object result = AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return createFactory ( factoryClass , classLoader ) ; } } ) ; if ( result instanceof LogConfigurationException ) { LogConfigurationException ex = ( LogConfigurationException ) result ; if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " An error occurred while loading the factory class: " + ex . getMessage ( ) ) ; } throw ex ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Created object " + objectId ( result ) + " to manage classloader " + objectId ( contextClassLoader ) ) ; } return ( LogFactory ) result ; } 
private static Enumeration getResources ( final ClassLoader loader , final String name ) { PrivilegedAction action = new PrivilegedAction ( ) { public Object run ( ) { try { if ( loader ! = null ) { return loader . getResources ( name ) ; } else { return ClassLoader . getSystemResources ( name ) ; } } catch ( IOException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Exception while trying to find configuration file " + name + " : " + e . getMessage ( ) ) ; } return null ; } catch ( NoSuchMethodError e ) { we must be running on a 1.1 JVM which doesn't support ClassLoader.getSystemResources; just return null in this case. return null; } } }; Object result = AccessController.doPrivileged(action); return (Enumeration) result; } 
public Object run ( ) { try { InputStream stream = url . openStream ( ) ; if ( stream ! = null ) { Properties props = new Properties ( ) ; props . load ( stream ) ; stream . close ( ) ; return props ; } } catch ( IOException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Unable to read URL " + url ) ; } } return null ; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { props = newProps ; } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; if ( newPriorityStr ! = null ) { double newPriority = Double . valueOf ( newPriorityStr ) . doubleValue ( ) ; if ( newPriority > priority ) { props = newProps ; priority = newPriority ; } } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown " ) ; } } return props ; } 
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
private boolean isLogLibraryAvailable ( String name , String classname ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Checking for " + name + " . " ) ; } try { Log log = createLogFromClass ( 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to discover a Log implementation. " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can if (specifiedLogClassName != null) { final String trimmedName = specifiedLogClassName.trim(); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_SIMPLE_LOGGER); } throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } return specifiedClass; 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; This variable is used to ensure that the system classloader is tried only once when getParent is null. boolean systemClassloaderTried = false; for(;;) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader final ClassLoader parentCL = currentCL.getParent(); getParent may return null to indicate that the parent is the 'bootstrap classloader'. This term is difficult. A reasonable way to interpret this is as the system classloader which is provided as a base for delegating classloaders. Note that this functionality cannot be easily tested since it depends upon an optional behaviour of the basic java libraries. The Sun libraries do not behave in this fashion. It may be possible to create a test that uses a customized boot classpath containing a special implementation but this approach would need to wait until an open source Java implementation exists. So sadly, this code path is not unit tested. if (parentCL == null) { if (systemClassloaderTried == true) { logDiagnostic("Parent classloader is NULL. But System ClassLoader has already been tried."); break; } try system classloader try { final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); if (systemClassLoader == null) { logDiagnostic("System classloader is NULL. Cannot find parent of classloader " + objectId(currentCL)); break; } else if (systemClassLoader.equals(currentCL)) { the system classloader has already been tried and failed logDiagnostic("System classloader tried and failed."); break; } else { the parent is null indicating that the parent is the boot classloader so retry with system classloader currentCL = systemClassLoader; avoid infinite loops by trying the system loader only the first time a classloader systemClassloaderTried = true; logDiagnostic("Parent classloader is NULL. Trying System ClassLoader."); } } catch (Throwable t) { getSystemClassLoader is allowed to fail in many strange ways: so need to catch everything including errors logDiagnostic("Failed to get system classloader: '" + t.getMessage() + "'. Cannot find parent of classloader " + objectId(currentCL)); break; } } else { currentCL = parentCL; } } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( useTCCL = = false ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoader ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getLocalizedMessage ( ) ) ; } if ( ! allowFlawedDiscovery ) { throw new LogConfigurationException ( discoveryFlaw ) ; 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to discover a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can if (specifiedLogClassName != null) { final String trimmedName = specifiedLogClassName.trim(); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, trimmedName, LOGGING_IMPL_SIMPLE_LOGGER); } throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( useTCCL = = false ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoader ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private boolean isLogLibraryAvailable ( String name , String classname ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Checking for ' " + name + " '. " ) ; } try { Log log = createLogFromClass ( 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getClass ( ) . getName ( ) + " : " + discoveryFlaw . getLocalizedMessage ( ) ) ; } if ( ! allowFlawedDiscovery ) { throw new LogConfigurationException ( discoveryFlaw ) ; 
public static Test suite ( ) throws Exception { Class thisClass = StandardTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useSystemLoader ( " junit. " ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; loader . addLogicalLib ( " logkit " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void setUp ( ) throws Exception { LogFactory . releaseAll ( ) ; System . setProperty ( " org.apache.commons.logging.Log " , " org.apache.commons.logging.impl.LogKitLogger " ) ; factory = LogFactory . getFactory ( ) ; log = LogFactory . getLog ( " TestLogger " ) ; } 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void testSerializable ( ) throws Exception { checkStandard ( ) ; Serialize and deserialize the instance ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); checkStandard(); } 
protected void checkStandard ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.LogKitLogger " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? Note that by default *everything* is enabled for LogKit assertTrue(log.isTraceEnabled()); assertTrue(log.isDebugEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); } 
public void setUp ( ) throws Exception { LogFactory . releaseAll ( ) ; System . setProperty ( " org.apache.commons.logging.Log " , 
public void testSerializable ( ) throws Exception { Log log = LogFactory . getLog ( this . getClass ( ) . getName ( ) ) ; checkLog ( log ) ; Serialize and deserialize the instance ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); checkLog(log); } 
private void checkLog ( Log log ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.NoOpLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? Note that *everything* is permanently disabled for NoOpLog assertFalse(log.isTraceEnabled()); assertFalse(log.isDebugEnabled()); assertFalse(log.isInfoEnabled()); assertFalse(log.isWarnEnabled()); assertFalse(log.isErrorEnabled()); assertFalse(log.isFatalEnabled()); } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl@" + System.identityHashCode(this) + " from " + classLoaderName + "] "; } 
private static void initDiagnostics ( ) { String dest ; ttry { dest = System . getProperty ( DIAGNOSTICS_DEST_PROPERTY ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { logDiagnostic ( " [ENV] Extension directories (java.ext.dir): " + System . getProperty ( " java.ext.dir " ) ) ; logDiagnostic ( " [ENV] Application classpath (java.class.path): " + System . getProperty ( " java.class.path " ) ) ; } catch ( SecurityException ex ) { logDiagnostic ( " [ENV] Security setting prevent interrogation of system classpaths. " ) ; } String className = clazz . getName ( ) ; ClassLoader classLoader ; try { classLoader = getClassLoader ( clazz ) ; } catch ( SecurityException ex ) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } catch(Exception e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a properties file of name '" + FACTORY_PROPERTIES + "' to define the LogFactory subclass to use..."); } if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file found. Looking for property '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. Object result = AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return createFactory(factoryClass, classLoader); } }); if (result instanceof LogConfigurationException) { LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic( "An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic( "Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try a properties file. If the properties file exists, it'll be read and the properties used. IMHO ( costin ) System property and JDK1.3 jar service should be enough for detecting the class name. The properties should be used to set the attributes ( which may be specific to the webapp, even if a default logger is set at JVM level by a system property ) if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a properties file of name '" + FACTORY_PROPERTIES + "' to define the LogFactory subclass to use..."); } if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file found. Looking for property '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static boolean implementsLogFactory ( Class logFactoryClass ) { tboolean implementsLogFactory = false ; tif ( logFactoryClass ! = null ) { ttry { ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; if ( implementsLogFactory ) { tlogDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { tlogDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " does not implement LogFactory. " ) ; } } } catch ( SecurityException e ) { } 
public static Test suite ( ) throws Exception { Class thisClass = PriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useSystemLoader("junit."); containerLoader.addLogicalLib("commons-logging"); URL pri10URL = new URL(baseUrl, "priority10/"); containerLoader.addURL(pri10URL); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.setParentFirst(false); webappLoader.addLogicalLib("testclasses"); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; String id = ( String ) instance . getAttribute ( " configId " ) ; assertEquals ( " Correct config file loaded " , " priority20 " , id ) ; fail ( " deliberate failure " ) ; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { props = newProps ; String priorityStr = props . getProperty ( PRIORITY_KEY ) ; priority = 0.0 ; if ( priorityStr ! = null ) { priority = Double . parseDouble ( priorityStr ) ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] First properties file found at ' " + url + " ' " ) ; } } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; double newPriority = 0.0 ; if ( newPriorityStr ! = null ) { newPriority = Double . parseDouble ( newPriorityStr ) ; } if ( newPriority > priority ) { props = newProps ; priority = newPriority ; if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] New properties file found at ' " + url + " ' " + " has higher priority than earlier file. " ) ; } } else { logDiagnostic ( " [LOOKUP] New properties file found at ' " + url + " ' " + " has less priority than earlier file -- ignoring. " ) ; } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown " ) ; } } return props ; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; URL propsUrl = null ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { propsUrl = url ; props = newProps ; String priorityStr = props . getProperty ( PRIORITY_KEY ) ; priority = 0.0 ; if ( priorityStr ! = null ) { priority = Double . parseDouble ( priorityStr ) ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file found at ' " + url + " ' " + " with priority " + priority ) ; } } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; double newPriority = 0.0 ; if ( newPriorityStr ! = null ) { newPriority = Double . parseDouble ( newPriorityStr ) ; } if ( newPriority > priority ) { if ( isDiagnosticsEnabled ( ) ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " overrides file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } propsUrl = url ; props = newProps ; priority = newPriority ; } else { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " does not override file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown " ) ; } } return props ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); what about handling an exception from newFactory?? } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; URL propsUrl = null ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { propsUrl = url ; props = newProps ; String priorityStr = props . getProperty ( PRIORITY_KEY ) ; priority = 0.0 ; if ( priorityStr ! = null ) { priority = Double . parseDouble ( priorityStr ) ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file found at ' " + url + " ' " + " with priority " + priority ) ; } } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; double newPriority = 0.0 ; if ( newPriorityStr ! = null ) { newPriority = Double . parseDouble ( newPriorityStr ) ; } if ( newPriority > priority ) { if ( isDiagnosticsEnabled ( ) ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " overrides file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } propsUrl = url ; props = newProps ; priority = newPriority ; } else { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " does not override file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown while trying to find/read config files. " ) ; } } if ( isDiagnosticsEnabled ( ) ) { if ( props = = null ) { logDiagnostic ( " [LOOKUP] No properties file of name ' " + FACTORY_PROPERTIES + " ' found. " ) ; } else { logDiagnostic ( " [LOOKUP] Properties file of name ' " + FACTORY_PROPERTIES + " ' found at ' " + propsUrl + '"' ) ; } } return props ; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; " using the standard supported logging implementations..."); } for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { show exactly where we are loading this class from. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } hack { String l4jCategory = "org.apache.log4j.Category"; String l4jResource = l4jCategory.replace('.', '/') + ".class"; URL l4jUrl = currentCL.getResource(l4jResource); if (l4jUrl == null) { logDiagnostic("log4j not found:" + l4jResource); } else { logDiagnostic("log4j found:" + l4jUrl); } } Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " has been selected for use."); } return logAdapter; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; URL propsUrl = null ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { propsUrl = url ; props = newProps ; String priorityStr = props . getProperty ( PRIORITY_KEY ) ; priority = 0.0 ; if ( priorityStr ! = null ) { priority = Double . parseDouble ( priorityStr ) ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file found at ' " + url + " ' " + " with priority " + priority ) ; } } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; double newPriority = 0.0 ; if ( newPriorityStr ! = null ) { newPriority = Double . parseDouble ( newPriorityStr ) ; } if ( newPriority > priority ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " overrides file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } propsUrl = url ; props = newProps ; priority = newPriority ; } else { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " does not override file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown while trying to find/read config files. " ) ; } } if ( isDiagnosticsEnabled ( ) ) { if ( props = = null ) { logDiagnostic ( " [LOOKUP] No properties file of name ' " + FACTORY_PROPERTIES + " ' found. " ) ; } else { logDiagnostic ( " [LOOKUP] Properties file of name ' " + FACTORY_PROPERTIES + " ' found at ' " + propsUrl + '"' ) ; } } return props ; } 
public Enumeration getResourcesInOrder ( String name ) throws IOException { if ( parentFirst ) { return super . getResources ( name ) ; 
public static Test suite ( ) throws Exception { Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useSystemLoader("junit."); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useSystemLoader("junit."); containerLoader.addLogicalLib("commons-logging"); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; " using the standard supported logging implementations..."); } for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { Don't suggest a name that is exactly the same as the one the user tried... return; } If the user provides a name that is in the right package, and gets the first 4 characters of the adapter class right (ignoring case), then suggest the candidate adapter class name. if (name.regionMatches(true, 0, candidate, 0, PKG_LEN + 4)) { messageBuffer.append(" Did you mean '"); 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = System.getProperty(LOG_PROPERTY); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = System.getProperty(LOG_PROPERTY_OLD); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a classname so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { Don't suggest a name that is exactly the same as the one the user tried... return; } If the user provides a name that is in the right package, and gets the first 5 characters of the adapter class right (ignoring case), then suggest the candidate adapter class name. if (name.regionMatches(true, 0, candidate, 0, PKG_LEN + 5)) { messageBuffer.append(" Did you mean '"); 
private ArrayList toList ( Enumeration en ) { ArrayList results = new ArrayList ( ) ; if ( en ! = null ) { while ( en . hasMoreElements ( ) ) { Object element = en . nextElement ( ) ; results . add ( element ) ; } } return results ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; if ( storeImplementationClass = = null ) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME ; } try { Class implementationClass = Class . forName ( storeImplementationClass ) ; result = ( Hashtable ) implementationClass . newInstance ( ) ; } catch ( Throwable ) { ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoader(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = System.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static boolean implementsLogFactory ( Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " does not implement LogFactory. " ) ; } } } catch ( SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the classloaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by classloader which loaded the " + "custom LogFactory implementation. Is the custom factory in the right classloader?"); } } return implementsLogFactory; } 
private static final Properties getConfigurationFile ( ClassLoader classLoader , String fileName ) { Properties props = null ; double priority = 0.0 ; URL propsUrl = null ; try { Enumeration urls = getResources ( classLoader , fileName ) ; if ( urls = = null ) { return null ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; Properties newProps = getProperties ( url ) ; if ( newProps ! = null ) { if ( props = = null ) { propsUrl = url ; props = newProps ; String priorityStr = props . getProperty ( PRIORITY_KEY ) ; priority = 0.0 ; if ( priorityStr ! = null ) { priority = Double . parseDouble ( priorityStr ) ; } if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file found at ' " + url + " ' " + " with priority " + priority ) ; } } else { String newPriorityStr = newProps . getProperty ( PRIORITY_KEY ) ; double newPriority = 0.0 ; if ( newPriorityStr ! = null ) { newPriority = Double . parseDouble ( newPriorityStr ) ; } if ( newPriority > priority ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " overrides file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } propsUrl = url ; props = newProps ; priority = newPriority ; } else { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " [LOOKUP] Properties file at ' " + url + " ' " + " with priority " + newPriority + " does not override file at ' " + propsUrl + " ' " + " with priority " + priority ) ; } } } } } } catch ( SecurityException e ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " SecurityException thrown while trying to find/read config files. " ) ; } } if ( isDiagnosticsEnabled ( ) ) { if ( props = = null ) { logDiagnostic ( " [LOOKUP] No properties file of name ' " + fileName + " ' found. " ) ; } else { logDiagnostic ( " [LOOKUP] Properties file of name ' " + fileName + " ' found at ' " + propsUrl + '"' ) ; } } return props ; } 
public Object put ( Object key , Object value ) { check for nulls, ensuring symantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if ((changeCount % PARTIAL_PURGE_COUNT) == 0) { purgeOne(); } Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is system. this will of course throw an exception if not found. Class junitTest = contextLoader.loadClass("junit.framework.Test"); assertSame("Junit not loaded via systemloader", systemLoader, junitTest.getClassLoader()); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); assertNotNull(clazz); silence warnings about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; try { Log log = instance . getInstance ( " test " ) ; 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); assertNotNull(clazz); silence warnings about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; Log log = instance . getInstance ( " test " ) ; assertEquals ( " Correct Log loaded " , 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_FACTORY_IMPL); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_FACTORY_IMPL); 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass( "org.apache.commons.logging.tccl.custom.MyLogFactoryImpl"); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass( 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void tearDown ( ) { Restore, so other tests don't get stuffed up if a test sets a custom security manager. System.setSecurityManager(oldSecMgr); } 
public void testSimple ( ) { SecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityTestCaseAllowed " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void testAllAllowed ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; mySecurityManager . addPermission ( new AllPermission ( ) ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityTestCaseForbidden " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void testAllForbidden ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = System . getProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY ) ; } catch ( SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (Throwable t) { ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
private static void initClass ( ) { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). thisClassLoader = getClassLoader(LogFactory.class); initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); 
public Object run ( ) { initClass ( ) ; return null ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (Throwable t) { ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + e.getMessage().trim() + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + ex.getMessage().trim() + "]. Trying alternative implementations..."); } ; ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static ClassLoader getContextClassLoader ( ) throws LogConfigurationException { return directGetContextClassLoader ( ) ; } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
private static String getSystemProperty ( final String key , final String def ) throws SecurityException { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
public Object run ( ) { return System . getProperty ( key , def ) ; } 
private static void initDiagnostics ( ) { String dest ; ttry { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch(SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch(SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic( "[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
public Object run ( ) { return LogFactory . directGetContextClassLoader ( ) ; } 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY_OLD, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a classname so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( useTCCL = = false ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityAllowedTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useSystemLoader ( " junit. " ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityForbiddenTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public Object run ( ) { return cl . getParent ( ) ; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c = null; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = "" + secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = "" + e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public static Test suite ( ) throws Exception { Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public static Test suite ( ) throws Exception { Class thisClass = PriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); URL pri10URL = new URL(baseUrl, "priority10/"); containerLoader.addURL(pri10URL); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.setParentFirst(true); webappLoader.addLogicalLib("testclasses"); URL noPriorityURL = new URL(baseUrl, "nopriority/"); webappLoader.addURL(noPriorityURL); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri20aURL = new URL(baseUrl, "priority20a/"); webappLoader.addURL(pri20aURL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. parent.useSystemLoader("org.apache.commons.logging.jdk14.TestHandler"); parent.addLogicalLib("commons-logging-api"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. parent.useSystemLoader("org.apache.commons.logging.jdk14.TestHandler"); parent.addLogicalLib("commons-logging"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging-api " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " log4j12 " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = StandardTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; loader . addLogicalLib ( " logkit " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityAllowedTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityForbiddenTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public static Test suite ( ) throws Exception { LogFactory in parent LogFactory in child (loads test) LogFactory in tccl Having the test loaded via a loader above the tccl emulates the situation where a web.xml file specifies ServletContextCleaner as a listener, and that class is deployed via a shared classloader. PathableClassLoader parent = new PathableClassLoader(null); parent.useExplicitLoader("junit.", Test.class.getClassLoader()); parent.addLogicalLib("commons-logging"); parent.addLogicalLib("servletapi"); PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); child.addLogicalLib("commons-logging"); child.addLogicalLib("testclasses"); PathableClassLoader tccl = new PathableClassLoader(child); tccl.setParentFirst(false); tccl.addLogicalLib("commons-logging"); Class testClass = child.loadClass(BasicServletTestCase.class.getName()); return new PathableTestSuite(testClass, tccl); } 
public static Test suite ( ) throws Exception { Class thisClass = CustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = DateTimeCustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = DefaultConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader contextClassLoader = new PathableClassLoader ( null ) ; contextClassLoader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; PathableTestSuite suite = new PathableTestSuite ( BadTCCLTestCase . class , contextClassLoader ) ; return suite ; } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLog parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void addLogicalLib ( String logicalLib ) { first, check the system properties String filename = System.getProperty(logicalLib); if (filename != null) { try { URL libUrl = new File(filename).toURL(); addURL(libUrl); return; } catch(java.net.MalformedURLException e) { throw new UnknownError( "Invalid file [" + filename + "] for logical lib [" + logicalLib + "]"); } } now check the classpath for a similar-named lib URL libUrl = libFromClasspath(logicalLib); if (libUrl != null) { addURL(libUrl); return; } lib not found throw new UnknownError( "Logical lib [" + logicalLib + "] is not defined" 
private URL libFromClasspath ( String logicalLib ) { ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } URLClassLoader ucl = ( URLClassLoader ) cl ; URL [ ] path = ucl . getURLs ( ) ; for ( int i = 0 ; i < path . length ; + + i ) { URL u = path [ i ] ; extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } if (filename.startsWith(logicalLib)) { System.out.println("found lib " + logicalLib + " at url " + u); return u; } else { System.out.println("lib " + logicalLib + " does not match [" + filename + "] at url " + u); } } return null; 
public static Test suite ( ) throws Exception { LogFactory in parent LogFactory in child (loads test) LogFactory in tccl Having the test loaded via a loader above the tccl emulates the situation where a web.xml file specifies ServletContextCleaner as a listener, and that class is deployed via a shared classloader. PathableClassLoader parent = new PathableClassLoader(null); parent.useExplicitLoader("junit.", Test.class.getClassLoader()); parent.addLogicalLib("commons-logging"); parent.addLogicalLib("servlet-api"); PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); child.addLogicalLib("commons-logging"); child.addLogicalLib("testclasses"); PathableClassLoader tccl = new PathableClassLoader(child); tccl.setParentFirst(false); tccl.addLogicalLib("commons-logging"); Class testClass = child.loadClass(BasicServletTestCase.class.getName()); return new PathableTestSuite(testClass, tccl); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. Class junitTest = contextLoader.loadClass("junit.framework.Test"); Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public static Test suite ( ) throws Exception { Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put JCL in the container path, the testcase in a webapp path, and both config files into the webapp path too. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader lfClassLoader = instance . getClass ( ) . getClassLoader ( ) ; ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; context classloader should be thisClassLoader assertEquals(thisClassLoader, contextClassLoader); lfClassLoader should be parent of this classloader assertEquals(lfClassLoader, thisClassLoader.getParent()); assertEquals(PathableClassLoader.class.getName(), lfClassLoader.getClass().getName()); String id = (String) instance.getAttribute("configId"); assertEquals("Correct config file loaded", "priority20", id ); } 
private URL libFromClasspath ( String logicalLib ) { ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } URLClassLoader ucl = ( URLClassLoader ) cl ; URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( int i = 0 ; i < path . length ; + + i ) { URL u = path [ i ] ; extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } if (filename.startsWith(logicalLib)) { ok, this is a candidate if (filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } } return shortestMatch; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging-api"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
protected static byte [ ] readClass ( String name , ClassLoader srcCL ) throws Exception { String resName = name . replace ( '.' , '/' ) + " .class " ; System . err . println ( " Trying to load resource [ " + resName + " ] " ) ; InputStream is = srcCL . getResourceAsStream ( resName ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; System . err . println ( " Reading resource [ " + resName + " ] " ) ; byte [ ] buf = new byte [ 1000 ] ; for ( ; ; ) { int read = is . read ( buf ) ; if ( read < = 0 ) { break ; } baos . write ( buf , 0 , read ) ; } is . close ( ) ; return baos . toByteArray ( ) ; } 
protected static void loadTestHandler ( String className , ClassLoader targetCL ) { try { targetCL . loadClass ( className ) ; fail("Class already in target classloader"); return; } catch(ClassNotFoundException ex) { ok, go ahead and load it } try { ClassLoader srcCL = CustomConfigAPITestCase.class.getClassLoader(); 
public static Test suite ( ) throws Exception { PathableClassLoader cl = new PathableClassLoader ( null ) ; cl . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); cl.useExplicitLoader(HANDLER_NAME, scl); cl.addLogicalLib("commons-logging"); cl.addLogicalLib("testclasses"); Class testClass = cl.loadClass(CustomConfigTestCase.class.getName()); return new PathableTestSuite(testClass, cl); } 
public static Test suite ( ) throws Exception { PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( DefaultConfigTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. Class junitTest = contextLoader.loadClass("junit.framework.Test"); Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
protected void log ( int type , Object message , Throwable ) { if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles shortLogName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = shortLogName.substring(shortLogName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can if (specifiedLogClassName != null) { informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); } throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getClass ( ) . getName ( ) + " : " + discoveryFlaw . getLocalizedMessage ( ) ) ; if ( discoveryFlaw instanceof InvocationTargetException ) { that if possible. InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; Throwable cause2 = eiie.getException(); if (cause2 != null) { logDiagnostic("... ExceptionInInitializerError: " + cause2.getClass().getName() + ": " + cause2.getLocalizedMessage()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
protected void logExceptionMessages ( ) { Throwable = new DummyException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(Log log) { Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
private void logExceptionMessages ( Log log ) { Throwable = new DummyException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
protected void logExceptionMessages ( ) { Generate log records Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", t)); 
protected void checkLogRecords ( boolean thrown ) { Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertTrue ( " LogRecord class " , record . getSourceClassName ( ) . startsWith ( " org.apache.commons.logging.jdk14.CustomConfig " ) ) ; if ( thrown ) { assertEquals ( " LogRecord method " , " logExceptionMessages " , record . getSourceMethodName ( ) ) ; } else { assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } if ( thrown ) { assertNotNull ( " LogRecord thrown " , record . getThrown ( ) ) ; assertTrue ( " LogRecord thrown type " , record . getThrown ( ) instanceof DummyException ) ; } else { assertNull ( " LogRecord thrown " , record . getThrown ( ) ) ; } } assertTrue ( ! records . hasNext ( ) ) ; handler . flush ( ) ; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader ) { return newFactory ( factoryClass , classLoader , null ) ; } 
private static void initDiagnostics ( ) { String dest ; try { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return ; } } catch ( SecurityException ex ) { We must be running in some very secure environment. We just have to assume output is not wanted.. return; } if (dest.equals("STDOUT")) { diagnosticsStream = System.out; } else if (dest.equals("STDERR")) { diagnosticsStream = System.err; } else { try { open the file in append mode FileOutputStream fos = new FileOutputStream(dest, true); diagnosticsStream = new PrintStream(fos); } catch(IOException ex) { We should report this to the user - but how? return; } } In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { ClassLoader classLoader = thisClassLoader; if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , Throwable discoveryFlaw ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getClass ( ) . getName ( ) + " : " + discoveryFlaw . getLocalizedMessage ( ) ) ; if ( discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; Throwable cause2 = eiie.getException(); if (cause2 != null) { logDiagnostic("... ExceptionInInitializerError: " + cause2.getClass().getName() + ": " + cause2.getLocalizedMessage()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
protected void log ( int type , Object message , Throwable ) { Use a string buffer for better performance StringBuffer buf = new StringBuffer(); Append date-time if so configured if(showDateTime) { Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles shortLogName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = shortLogName.substring(shortLogName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { SimpleLogTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
public static void main ( String [ ] args ) { String [ ] testCaseName = { AvalonLoggerTestCase . class . getName ( ) } ; junit . textui . TestRunner . main ( testCaseName ) ; } 
private static String trim ( String src ) { tif ( src = = null ) { treturn null ; } treturn src . trim ( ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ; ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ; ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public void tearDown ( ) { LogFactory . releaseAll ( ) ; System . getProperties ( ) . remove ( " org.apache.commons.logging.Log " ) ; } 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behaviour of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. URLConnection connection = url.openConnection(); connection.setDefaultUseCaches(false); stream = connection.getInputStream(); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch(IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch(Throwable t) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behaviour of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. URLConnection connection = url.openConnection(); connection.setUseCaches(false); stream = connection.getInputStream(); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch(IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch(Throwable t) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
public void run ( ) { for ( int i = 0 ; i < RUN_LOOPS ; i + + ) { hashtable . put ( " key " + " : " + ( i % 10 ) , Boolean . TRUE ) ; 
public void testLOGGING_119 ( ) throws Exception { Thread [ ] = new Thread [ THREAD_COUNT ] ; for ( int j = 1 ; j < = OUTER_LOOP ; j + + ) { hashtable = new WeakHashtable ( ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatability. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static Test suite ( ) throws Exception { PathableTestSuite suite = new PathableTestSuite ( NullTCCLTestCase . class , null ) ; return suite ; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; (i<classesToDiscover.length) && (result == null); ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
public void testPutCalled ( ) throws Exception { LogFactory . getLog ( BadHashtablePropertyTestCase . class ) ; } 
public static void release ( ClassLoader classLoader ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { if (classLoader == null) { 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { Enumeration elements = factories.elements(); 
static public void setLogImplementation ( String classname ) throws LinkageError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { Class logclass = Class . forName ( classname ) ; 
static public Log makeNewLogInstance ( String name ) { Log log ; try { Object [ ] args = { name } ; log = ( Log ) ( logImplctor . newInstance ( args ) ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance ; try { if ( logConstructor = = null ) { 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if ((logAdapter != null) && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( ! useTCCL ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , USED? Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; Throwable cause2 = eiie.getException(); if (cause2 != null) { logDiagnostic("... ExceptionInInitializerError: " + cause2.getClass().getName() + ": " + cause2.getLocalizedMessage()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Referenced ) { Referenced otherKey = ( Referenced ) o ; Object thisKeyValue = getValue ( ) ; Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = ( otherKeyValue = = null ) ; Since our hashcode was calculated from the original non-null referant, the above check breaks the hashcode/equals contract, as two cleared Referenced objects could test equal but have different hashcodes. We can reduce (not eliminate) the chance of this happening by comparing hashcodes. result = result && (this.hashCode() == otherKey.hashCode()); In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
protected void log ( int type , Object message , Throwable ) { Use a string buffer for better performance StringBuffer buf = new StringBuffer(); Append date-time if so configured if(showDateTime) { Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); 
private static PrintStream initDiagnostics ( ) { String dest ; try { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return null ; } } catch ( SecurityException ex ) { We must be running in some very secure environment. We just have to assume output is not wanted.. return null; } if (dest.equals("STDOUT")) { return System.out; 
public void run ( ) { for ( int i = 0 ; i < RUN_LOOPS ; i + + ) { hashtable . put ( " key " + " : " + ( i % 10 ) , Boolean . TRUE ) ; 
public static Log getLog ( Class clazz ) throws LogConfigurationException { return getFactory ( ) . getInstance ( clazz ) ; 
public static Log getLog ( String name ) throws LogConfigurationException { return getFactory ( ) . getInstance ( name ) ; 
static public Log makeNewLogInstance ( String name ) { Log log ; try { Object [ ] args = { name } ; log = ( Log ) logImplctor . newInstance ( args ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; 
public boolean isDebugEnabled ( ) { return getLogger ( ) . isLoggable ( Level . FINE ) ; } 
public boolean isErrorEnabled ( ) { return getLogger ( ) . isLoggable ( Level . SEVERE ) ; } 
public boolean isFatalEnabled ( ) { return getLogger ( ) . isLoggable ( Level . SEVERE ) ; } 
public boolean isInfoEnabled ( ) { return getLogger ( ) . isLoggable ( Level . INFO ) ; } 
public boolean isTraceEnabled ( ) { return getLogger ( ) . isLoggable ( Level . FINEST ) ; } 
public boolean isWarnEnabled ( ) { return getLogger ( ) . isLoggable ( Level . WARNING ) ; } 
public Log getInstance ( Class clazz ) throws LogConfigurationException { return getInstance ( clazz . getName ( ) ) ; 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return instance ; 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapter != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
protected boolean isLevelEnabled ( int logLevel ) { log level are numerically ordered so can use simple numeric comparison return logLevel >= currentLogLevel; } 
public Object put ( Object key , Object value ) { check for nulls, ensuring symantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public Object remove ( Object key ) { for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } return super.remove(new Referenced(key)); } 
public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Referenced ) { Referenced otherKey = ( Referenced ) o ; Object thisKeyValue = getValue ( ) ; Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = otherKeyValue = = null ; Since our hashcode was calculated from the original non-null referant, the above check breaks the hashcode/equals contract, as two cleared Referenced objects could test equal but have different hashcodes. We can reduce (not eliminate) the chance of this happening by comparing hashcodes. result = result && this.hashCode() == otherKey.hashCode(); In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
public void run ( ) { for ( int i = 0 ; i < RUN_LOOPS ; i + + ) { hashtable . put ( " key " + " : " + i % 10 , Boolean . TRUE ) ; 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(Log log) { Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
private void checkLoggingEvents ( List logEvents , boolean thrown ) { LogEvent ev ; assertEquals ( " Unexpected number of log events " , 4 , logEvents . size ( ) ) ; ev = ( LogEvent ) logEvents . get ( 0 ) ; assertEquals ( " Info message expected " , " info " , ev . msg ) ; assertEquals ( " Info level expected " , " INFO " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 1 ) ; assertEquals ( " Warn message expected " , " warn " , ev . msg ) ; assertEquals ( " Warn level expected " , " WARN " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 2 ) ; assertEquals ( " Error message expected " , " error " , ev . msg ) ; assertEquals ( " Error level expected " , " ERROR " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 3 ) ; assertEquals ( " Fatal message expected " , " fatal " , ev . msg ) ; assertEquals ( " Fatal level expected " , " FATAL " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; } 
public void close ( ) { } public boolean requiresLayout ( ) { return false ; } } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public void contextDestroyed ( ServletContextEvent sce ) { ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialised/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public Object put ( Object key , Object value ) { check for nulls, ensuring semantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context" + " classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { Enumeration elements = factories.elements(); 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. Object result = AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return createFactory(factoryClass, classLoader); } }); if (result instanceof LogConfigurationException) { LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic( "An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic( "Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
protected static Object createFactory ( String factoryClass , ClassLoader classLoader ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
private static String getSystemProperty ( final String key , final String def ) throws SecurityException { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
private void log ( Level level , String msg , Throwable ex ) { Logger logger = getLogger ( ) ; if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
public Log getInstance ( Class clazz ) throws LogConfigurationException { return getInstance ( clazz . getName ( ) ) ; } 
public Log getInstance ( String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return instance ; } 
protected Log newInstance ( String name ) throws LogConfigurationException { Log instance ; try { if ( logConstructor = = null ) { 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY_OLD, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a classname so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic( "Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic( "The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapter != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic( "[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic( "Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public void trace ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( Object message , Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
protected void log ( int type , Object message , Throwable ) { Use a string buffer for better performance StringBuffer buf = new StringBuffer(); Append date-time if so configured if(showDateTime) { Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if( showShortName) { if( shortLogName==null ) { Cut all but the last component of the name for both styles String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); java.io.StringWriter sw= new java.io.StringWriter(1024); java.io.PrintWriter pw= new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
protected void write ( StringBuffer buffer ) { System . err . println ( buffer . toString ( ) ) ; } 
public final void debug ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , null ) ; 
public final void debug ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , ) ; 
public final void trace ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , null ) ; 
public final void trace ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , ) ; 
public final void info ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , null ) ; 
public final void info ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , ) ; 
public final void warn ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , null ) ; 
public final void warn ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , ) ; 
public final void error ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , null ) ; 
public final void error ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , ) ; 
public final void fatal ( Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , null ) ; 
public final void fatal ( Object message , Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , ) ; 
public final boolean isDebugEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ; } 
public final boolean isErrorEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ; } 
public final boolean isFatalEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ; } 
public final boolean isInfoEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ; } 
public final boolean isTraceEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ; } 
public final boolean isWarnEnabled ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (Throwable t) { ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
private static String trim ( String src ) { if ( src = = null ) { return null ; } return src . trim ( ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if( props!=null ) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. Object result = AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return createFactory(factoryClass, classLoader); } }); if (result instanceof LogConfigurationException) { LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic("An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic("Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch(SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch(SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic( "[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic("[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch(SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl@" + System.identityHashCode(this) + " from " + classLoaderName + "] "; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behaviour). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { Don't suggest a name that is exactly the same as the one the user tried... return; } If the user provides a name that is in the right package, and gets the first 5 characters of the adapter class right (ignoring case), then suggest the candidate adapter class name. if (name.regionMatches(true, 0, candidate, 0, PKG_LEN + 5)) { messageBuffer.append(" Did you mean '"); 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY_OLD, null); } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a classname so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapter != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( ! useTCCL ) { return thisClassLoader ; } ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic("[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException("Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , USED? Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; Throwable cause2 = eiie.getException(); if (cause2 != null) { logDiagnostic("... ExceptionInInitializerError: " + cause2.getClass().getName() + ": " + cause2.getLocalizedMessage()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
public void contextDestroyed ( ServletContextEvent sce ) { ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialised/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public Object put ( Object key , Object value ) { check for nulls, ensuring semantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public Object remove ( Object key ) { for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } return super.remove(new Referenced(key)); } 
private void purgeOne ( ) { synchronized ( queue ) { WeakKey key = ( WeakKey ) queue . poll ( ) ; 
public boolean equals ( Object o ) { boolean result = false ; if ( o ! = null & & o instanceof Map . Entry ) { Map . Entry entry = ( Map . Entry ) o ; result = ( getKey ( ) = = null ? entry . getKey ( ) = = null : getKey ( ) . equals ( entry . getKey ( ) ) ) & & ( getValue ( ) = = null ? entry . getValue ( ) = = null : getValue ( ) . equals ( entry . getValue ( ) ) ) ; } return result ; } 
public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Referenced ) { Referenced otherKey = ( Referenced ) o ; Object thisKeyValue = getValue ( ) ; Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = otherKeyValue = = null ; Since our hashcode was calculated from the original non-null referant, the above check breaks the hashcode/equals contract, as two cleared Referenced objects could test equal but have different hashcodes. We can reduce (not eliminate) the chance of this happening by comparing hashcodes. result = result && this.hashCode() == otherKey.hashCode(); In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } 
public void testPutCalled ( ) throws Exception { AltHashtable . lastKey = null ; AltHashtable . lastValue = null ; LogFactory . getLog ( AltHashtableTestCase . class ) ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( contextLoader , AltHashtable . lastKey ) ; assertNotNull ( AltHashtable . lastValue ) ; } 
public void testIsEnabledNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeIsEnabledTest ( log ) ; } 
public void testMessageWithoutExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithExceptionNamedLog ( ) { Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithExceptionTest ( log ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put JCL in the container path, the testcase in a webapp path, and both config files into the webapp path too. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader lfClassLoader = instance . getClass ( ) . getClassLoader ( ) ; ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; context classloader should be thisClassLoader assertEquals(thisClassLoader, contextClassLoader); lfClassLoader should be parent of this classloader assertEquals(lfClassLoader, thisClassLoader.getParent()); assertEquals(PathableClassLoader.class.getName(), lfClassLoader.getClass().getName()); String id = (String) instance.getAttribute("configId"); assertEquals("Correct config file loaded", "priority20", id ); } 
public static Test suite ( ) throws Exception { Class thisClass = PriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); URL pri10URL = new URL(baseUrl, "priority10/"); containerLoader.addURL(pri10URL); PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.setParentFirst(true); webappLoader.addLogicalLib("testclasses"); URL noPriorityURL = new URL(baseUrl, "nopriority/"); webappLoader.addURL(noPriorityURL); URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); URL pri20aURL = new URL(baseUrl, "priority20a/"); webappLoader.addURL(pri20aURL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; weakHashtable = new WeakHashtable ( ) ; keyOne = new Long ( 1 ) ; keyTwo = new Long ( 2 ) ; keyThree = new Long ( 3 ) ; valueOne = new Long ( 100 ) ; valueTwo = new Long ( 200 ) ; valueThree = new Long ( 300 ) ; weakHashtable . put ( keyOne , valueOne ) ; weakHashtable . put ( keyTwo , valueTwo ) ; weakHashtable . put ( keyThree , valueThree ) ; } 
public void testContainsKey ( ) throws Exception { assertTrue ( weakHashtable . containsKey ( new Long ( 1 ) ) ) ; assertTrue ( weakHashtable . containsKey ( new Long ( 2 ) ) ) ; assertTrue ( weakHashtable . containsKey ( new Long ( 3 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 100 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 200 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 300 ) ) ) ; assertFalse ( weakHashtable . containsKey ( new Long ( 400 ) ) ) ; } 
public void testContainsValue ( ) throws Exception { assertFalse ( weakHashtable . containsValue ( new Long ( 1 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 2 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 3 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 100 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 200 ) ) ) ; assertTrue ( weakHashtable . containsValue ( new Long ( 300 ) ) ) ; assertFalse ( weakHashtable . containsValue ( new Long ( 400 ) ) ) ; } 
public void testKeys ( ) throws Exception { ArrayList keys = new ArrayList ( ) ; for ( Enumeration e = weakHashtable . keys ( ) ; e . hasMoreElements ( ) ; ) { keys . add ( e . nextElement ( ) ) ; } assertEquals ( 3 , keys . size ( ) ) ; assertTrue ( keys . contains ( keyOne ) ) ; assertTrue ( keys . contains ( keyTwo ) ) ; assertTrue ( keys . contains ( keyThree ) ) ; } 
public void testPut ( ) throws Exception { Long anotherKey = new Long ( 2004 ) ; weakHashtable . put ( anotherKey , new Long ( 1066 ) ) ; assertEquals ( new Long ( 1066 ) , weakHashtable . get ( anotherKey ) ) ; Test compliance with the hashtable API re nulls Exception caught = null; try { weakHashtable.put(null, new Object()); } catch (Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null key", caught); caught = null; try { weakHashtable.put(new Object(), null); } catch (Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null value", caught); } 
public void testPutAll ( ) throws Exception { Map newValues = new HashMap ( ) ; Long newKey = new Long ( 1066 ) ; Long newValue = new Long ( 1415 ) ; newValues . put ( newKey , newValue ) ; Long anotherNewKey = new Long ( 1645 ) ; Long anotherNewValue = new Long ( 1815 ) ; newValues . put ( anotherNewKey , anotherNewValue ) ; weakHashtable . putAll ( newValues ) ; assertEquals ( 5 , weakHashtable . size ( ) ) ; assertEquals ( newValue , weakHashtable . get ( newKey ) ) ; assertEquals ( anotherNewValue , weakHashtable . get ( anotherNewKey ) ) ; } 
public void testRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; ReferenceQueue testQueue = new ReferenceQueue ( ) ; WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } else { create garbage: byte[] b = new byte[bytz]; bytz = bytz * 2; } } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging-api"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging"); PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { PathableClassLoader cl = new PathableClassLoader ( null ) ; cl . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); cl.useExplicitLoader(HANDLER_NAME, scl); cl.addLogicalLib("commons-logging"); cl.addLogicalLib("testclasses"); Class testClass = cl.loadClass(CustomConfigTestCase.class.getName()); return new PathableTestSuite(testClass, cl); } 
public static Test suite ( ) throws Exception { PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( DefaultConfigTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(Log log) { Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
private void checkLoggingEvents ( List logEvents , boolean thrown ) { LogEvent ev ; assertEquals ( " Unexpected number of log events " , 4 , logEvents . size ( ) ) ; ev = ( LogEvent ) logEvents . get ( 0 ) ; assertEquals ( " Info message expected " , " info " , ev . msg ) ; assertEquals ( " Info level expected " , " INFO " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 1 ) ; assertEquals ( " Warn message expected " , " warn " , ev . msg ) ; assertEquals ( " Warn level expected " , " WARN " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 2 ) ; assertEquals ( " Error message expected " , " error " , ev . msg ) ; assertEquals ( " Error level expected " , " ERROR " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 3 ) ; assertEquals ( " Fatal message expected " , " fatal " , ev . msg ) ; assertEquals ( " Fatal level expected " , " FATAL " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " log4j12 " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = ChildFirstTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); parent.setParentFirst(false); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); Make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); Create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); Obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); Create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); context.setParentFirst(false); reload this class via the child classloader Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. Class junitTest = contextLoader.loadClass("junit.framework.Test"); Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behaviour - even though it's not the desired behaviour. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no guarantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public void testResourceAsStream ( ) throws Exception { java . io . InputStream is ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResourceAsStream where no instances exist is = childLoader.getResourceAsStream("nosuchfile"); assertNull("Invalid resource returned non-null stream", is); getResourceAsStream where resource does exist is = childLoader.getResourceAsStream("org/apache/commons/logging/Log.class"); assertNotNull("Null returned for valid resource", is); is.close(); 
public static Test suite ( ) throws Exception { Class thisClass = GeneralTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , thisClassLoader ) ; loader . addLogicalLib ( " testclasses " ) ; reload this class via the child classloader Class testClass = loader.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, loader); } 
private static void checkAndSetContext ( ) { ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( " ContextLoader is of unexpected type " , contextLoader . getClass ( ) . getName ( ) , PathableClassLoader . class . getName ( ) ) ; URL [ ] noUrls = new URL [ 0 ] ; Thread . currentThread ( ) . setContextClassLoader ( new URLClassLoader ( noUrls ) ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = ParentFirstTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public static Test suite ( ) throws Exception { Class thisClass = DateTimeCustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
protected void checkDecoratedDateTime ( ) { assertEquals ( " Expected date format to be set " , " dd.mm.yyyy " , ( ( DecoratedSimpleLog ) log ) . getDateTimeFormat ( ) ) ; try the formatter Date now = new Date(); DateFormat formatter = ((DecoratedSimpleLog) log).getDateTimeFormatter(); SimpleDateFormat sampleFormatter = new SimpleDateFormat("dd.mm.yyyy"); assertEquals("Date should be formatters to pattern dd.mm.yyyy", sampleFormatter.format(now), formatter.format(now)); 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public boolean equals ( Object o ) { boolean result = false ; if ( o ! = null & & o instanceof Map . Entry ) { Map . Entry entry = ( Map . Entry ) o ; result = ( getKey ( ) = = null ? entry . getKey ( ) = = null : getKey ( ) . equals ( entry . getKey ( ) ) ) & & ( getValue ( ) = = null ? entry . getValue ( ) = = null : getValue ( ) . equals ( entry . getValue ( ) ) ) ; } return result ; } 
public int hashCode ( ) { return ( getKey ( ) = = null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) = = null ? 0 : getValue ( ) . hashCode ( ) ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch(RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch( Exception ex ) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static Log getLog ( Class clazz ) throws LogConfigurationException { return getFactory ( ) . getInstance ( clazz ) ; } 
public static Log getLog ( String name ) throws LogConfigurationException { return getFactory ( ) . getInstance ( name ) ; } 
public static void release ( ClassLoader classLoader ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { if (classLoader == null) { 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { final Enumeration elements = factories.elements(); 
protected static ClassLoader getContextClassLoader ( ) throws LogConfigurationException { return directGetContextClassLoader ( ) ; } 
private static void cacheFactory ( ClassLoader classLoader , LogFactory factory ) { Ideally we would assert(factory != null) here. However reporting errors from within a logging implementation is a little tricky! if (factory != null) { if (classLoader == null) { 
private static boolean implementsLogFactory ( Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " does not implement LogFactory. " ) ; } } } catch ( SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the classloaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by classloader which loaded " + "the custom LogFactory implementation. Is the custom factory in the right classloader?"); } } return implementsLogFactory; } 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch(SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch(SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic("[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic("[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { final StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
static public void setLogImplementation ( String classname ) throws LinkageError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { Class logclass = Class . forName ( classname ) ; 
static public void setLogImplementation ( Class logclass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; logImplctor = logclass . getConstructor ( argtypes ) ; } 
static public Log makeNewLogInstance ( String name ) { Log log ; try { Object [ ] args = { name } ; log = ( Log ) logImplctor . newInstance ( args ) ; } catch ( Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; } 
protected void log ( int type , Object message , Throwable ) { Use a string buffer for better performance final StringBuffer buf = new StringBuffer(); Append date-time if so configured if(showDateTime) { final Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if(showShortName) { if(shortLogName == null) { Cut all but the last component of the name for both styles final String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); final java.io.StringWriter sw = new java.io.StringWriter(1024); final java.io.PrintWriter pw = new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch(LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch(Throwable t) { handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (Throwable t) { ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behaviour of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. URLConnection connection = url.openConnection(); connection.setUseCaches(false); stream = connection.getInputStream(); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch (IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch (Throwable t) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
private static PrintStream initDiagnostics ( ) { String dest ; try { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return null ; } } catch ( SecurityException ex ) { We must be running in some very secure environment. We just have to assume output is not wanted.. return null; } if (dest.equals("STDOUT")) { return System.out; 
private static void logClassLoaderEnvironment ( Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch (SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch (SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic("[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic("[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
private static void logHierarchy ( String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { final StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
public synchronized Object put ( Object key , Object value ) { check for nulls, ensuring semantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public synchronized Object remove ( Object key ) { for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } return super.remove(new Referenced(key)); } 
private void purge ( ) { final List toRemove = new ArrayList ( ) ; synchronized ( queue ) { WeakKey key ; while ( ( key = ( WeakKey ) queue . poll ( ) ) ! = null ) { toRemove . add ( key . getReferenced ( ) ) ; } } LOGGING-119: do the actual removal of the keys outside the sync block to prevent deadlock scenarios as purge() may be called from non-synchronized methods too final int size = toRemove.size(); for (int i = 0; i < size; i++) { super.remove(toRemove.get(i)); 
protected void log ( Level level , String msg , Throwable ex ) { Logger logger = getLogger ( ) ; if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
public void setUp ( ) throws Exception { setUpManager ( " org/apache/commons/logging/jdk14/CustomConfig.properties " ) ; setUpLogger ( this . getClass ( ) . getName ( ) ) ; setUpHandlers ( ) ; setUpFactory ( ) ; setUpLog ( this . getClass ( ) . getName ( ) ) ; } 
public void testPristineLogger ( ) { assertNotNull ( " Logger exists " , logger ) ; assertEquals ( " Logger name " , this . getClass ( ) . getName ( ) , logger . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(logger.isLoggable(Level.SEVERE)); assertTrue(logger.isLoggable(Level.WARNING)); assertTrue(logger.isLoggable(Level.INFO)); assertTrue(logger.isLoggable(Level.CONFIG)); assertTrue(logger.isLoggable(Level.FINE)); assertTrue(!logger.isLoggable(Level.FINER)); assertTrue(!logger.isLoggable(Level.FINEST)); 
private void handleFlawedDiscovery ( String logAdapterClassName , ClassLoader classLoader , USED? Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; Throwable cause2 = eiie.getException(); if (cause2 != null) { final StringWriter sw = new StringWriter(); cause2.printStackTrace(new PrintWriter(sw, true)); logDiagnostic("... ExceptionInInitializerError: " + sw.toString()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
public void trace ( Object message ) { getLogger ( ) . log ( FQCN , traceLevel , message , null ) ; } 
public void trace ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , traceLevel , message , ) ; } 
public void debug ( Object message ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , null ) ; } 
public void debug ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , ) ; } 
public void info ( Object message ) { getLogger ( ) . log ( FQCN , Level . INFO , message , null ) ; } 
public void info ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . INFO , message , ) ; } 
public void warn ( Object message ) { getLogger ( ) . log ( FQCN , Level . WARN , message , null ) ; } 
public void warn ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . WARN , message , ) ; } 
public void error ( Object message ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , null ) ; } 
public void error ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , ) ; } 
public void fatal ( Object message ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , null ) ; } 
public void fatal ( Object message , Throwable ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , ) ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
protected static void handleThrowable ( Throwable ) { if ( instanceof ThreadDeath ) { throw ( ThreadDeath ) ; } if ( instanceof VirtualMachineError ) { throw ( VirtualMachineError ) ; 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behaviour of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. URLConnection connection = url.openConnection(); connection.setUseCaches(false); stream = connection.getInputStream(); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch (IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch (IOException e) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. Class clazz = this.getClass(); ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch (SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl@" + System.identityHashCode(this) + " from " + classLoaderName + "] "; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behaviour indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; ReferenceQueue testQueue = new ReferenceQueue ( ) ; WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } else { create garbage: byte[] b = new byte[bytz]; bytz = bytz * 2; } } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public void testAllForbidden ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
public void debug ( Object message ) ; public void warn(Object message, Throwable t);} 
public void debug ( Object message , Throwable ) ; public void warn(Object message, Throwable t);} 
public void error ( Object message ) ; public void warn(Object message, Throwable t);} 
public void error ( Object message , Throwable ) ; public void warn(Object message, Throwable t);} 
public void fatal ( Object message ) ; public void warn(Object message, Throwable t);} 
public void fatal ( Object message , Throwable ) ; -------------------------------------------------------- Logging Methods public void warn(Object message, Throwable t);} 
public void info ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isDebugEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isErrorEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isFatalEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isInfoEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isTraceEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isWarnEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public void trace ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void warn(Object message, Throwable t);} 
public void debug ( Object message , Throwable ) ; public void warn(Object message, Throwable t);} 
public void error ( Object message ) ; public void warn(Object message, Throwable t);} 
public void error ( Object message , Throwable ) ; public void warn(Object message, Throwable t);} 
public void fatal ( Object message ) ; public void warn(Object message, Throwable t);} 
public void fatal ( Object message , Throwable ) ; -------------------------------------------------------- Logging Methods public void warn(Object message, Throwable t);} 
public void info ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isDebugEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isErrorEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isFatalEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isInfoEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isTraceEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public boolean isWarnEnabled ( ) ; public void warn ( Object message , Throwable ) ; } 
public void trace ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
public void fatal ( Object message , Throwable ) ; public void warn ( Object message , Throwable ) ; } 
public void testContextClassLoader ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { load a dummy class with another classloader 
private Object loadClass ( String name , ClassLoader classLoader ) { try { Class clazz = classLoader . loadClass ( name ) ; Object obj = clazz . newInstance ( ) ; return obj ; } catch ( Exception e ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; e . printStackTrace ( pw ) ; fail ( " Unexpected exception: " + e . getMessage ( ) + " : " + sw . toString ( ) ) ; } return null ; } 
public void debug ( Object message ) ; public void warn ( Object message , Throwable ) ; } 
protected static ClassLoader directGetContextClassLoader ( ) throws LogConfigurationException { ClassLoader classLoader = null ; try { classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { ignore } Return the selected class loader return classLoader; } 
void debug ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void debug ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void error ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void error ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void fatal ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void fatal ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void info ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void info ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
boolean isDebugEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isErrorEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isFatalEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isInfoEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isTraceEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isWarnEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
void trace ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void trace ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void warn ( Object message ) ; void warn ( Object message , Throwable ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (RuntimeException e) { This is not consistent with the behaviour when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behavior of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. URLConnection connection = url.openConnection(); connection.setUseCaches(false); stream = connection.getInputStream(); if (stream != null) { Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch (IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch (IOException e) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
private Log discoverLogImplementation ( String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behavior). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private Log createLogFromClass ( String logAdapterClassName , String logCategory , boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behavior - even though it's not the desired behavior. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no guarantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
private Class def ( String name ) throws ClassNotFoundException { Class result = ( Class ) classes . get ( name ) ; if ( result ! = null ) { return result ; } try { 
public Class loadClass ( String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exeptions to simlify handling in test for(int i = 0; i < LOG_PCKG.length; i++ ){ if( name.startsWith( LOG_PCKG[i] ) && name.indexOf("Exception") == -1 ){ return def(name); } } return super.loadClass(name); } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch(LogConfigurationException ex) { expected; the boot classloader doesn't *have* JCL available } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
private Class reload ( ) throws Exception { Class testObjCls = null ; AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( ClassNotFoundException cnfe ) { throw cnfe ; } catch ( Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertTrue ( " app isolated " , testObjCls . getClassLoader ( ) = = appLoader ) ; return testObjCls ; 
public void useSystemLoader ( String prefix ) { useExplicitLoader ( prefix , ClassLoader . getSystemClassLoader ( ) ) ; 
private URL libFromClasspath ( String logicalLib ) { ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } URLClassLoader ucl = ( URLClassLoader ) cl ; URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( int i = 0 ; i < path . length ; + + i ) { URL u = path [ i ] ; extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } if (filename.startsWith(logicalLib)) { ok, this is a candidate if (filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } } return shortestMatch; } 
protected Class loadClass ( String name , boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for(Iterator i = lookasides.entrySet().iterator(); i.hasNext(); ) { Map.Entry entry = (Map.Entry) i.next(); String prefix = (String) entry.getKey(); if (name.startsWith(prefix) == true) { ClassLoader loader = (ClassLoader) entry.getValue(); Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); 
public static Test suite ( ) throws Exception { Class thisClass = ParentFirstTestCase . class ; ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath PathableClassLoader parent = new PathableClassLoader(null); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. Class junitTest = contextLoader.loadClass("junit.framework.Test"); Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(ClassNotFoundException ex) { ok } String class classloader is null Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader childLoader = contextLoader.getParent(); ClassLoader parentLoader = childLoader.getParent(); ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public static Test suite ( ) throws Exception { Class thisClass = CustomConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = DefaultConfigTestCase . class ; PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLog parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); assertNotNull(clazz); silence warnings about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; try { Log log = instance . getInstance ( " test " ) ; 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; Log log = instance . getInstance ( " test " ) ; assertEquals ( " Correct Log loaded " , 
public static Test suite ( ) throws Exception { Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass(MY_LOG_FACTORY_IMPL); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass(MY_LOG_FACTORY_IMPL); 
public static Test suite ( ) throws Exception { Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. PathableClassLoader emptyLoader = new PathableClassLoader(null); PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { Class clazz = thisClassLoader.loadClass( "org.apache.commons.logging.tccl.custom.MyLogFactoryImpl"); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { Class clazz = tcclLoader.loadClass( 
public void testTcclLoading ( ) throws Exception { LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , 
public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Map . Entry ) { Map . Entry entry = ( Map . Entry ) o ; result = ( getKey ( ) = = null ? entry . getKey ( ) = = null : getKey ( ) . equals ( entry . getKey ( ) ) ) & & ( getValue ( ) = = null ? entry . getValue ( ) = = null : getValue ( ) . equals ( entry . getValue ( ) ) ) ; } return result ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
private static String trim ( final String src ) { if ( src = = null ) { return null ; } return src . trim ( ) ; } 
protected static void handleThrowable ( final Throwable ) { if ( instanceof ThreadDeath ) { throw ( ThreadDeath ) ; } if ( instanceof VirtualMachineError ) { throw ( VirtualMachineError ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static Log getLog ( final Class clazz ) throws LogConfigurationException { return getFactory ( ) . getInstance ( clazz ) ; } 
public static Log getLog ( final String name ) throws LogConfigurationException { return getFactory ( ) . getInstance ( name ) ; } 
public static void release ( final ClassLoader classLoader ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; } factories is not final and could be replaced in this block. final Hashtable factories = LogFactory.factories; synchronized (factories) { if (classLoader == null) { 
protected static ClassLoader directGetContextClassLoader ( ) throws LogConfigurationException { ClassLoader classLoader = null ; try { classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( final SecurityException ex ) { ignore } Return the selected class loader return classLoader; } 
private static void cacheFactory ( final ClassLoader classLoader , final LogFactory factory ) { Ideally we would assert(factory != null) here. However reporting errors from within a logging implementation is a little tricky! if (factory != null) { if (classLoader == null) { 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. final Object result = AccessController.doPrivileged( new PrivilegedAction() { public Object run() { return createFactory(factoryClass, classLoader); } }); if (result instanceof LogConfigurationException) { final LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic("An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic("Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
protected static Object createFactory ( final String factoryClass , final ClassLoader classLoader ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
private static boolean implementsLogFactory ( final Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { final ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; final Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " does not implement LogFactory. " ) ; } } } catch ( final SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (final LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError thrown whilst trying to determine whether " + "the compatibility was caused by a classloader conflict: " + e.getMessage()); } catch (final ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the classloaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by classloader which loaded " + "the custom LogFactory implementation. Is the custom factory in the right classloader?"); } } return implementsLogFactory; } 
public Object run ( ) { InputStream stream = null ; try { We must ensure that useCaches is set to false, as the default behavior of java is to cache file handles, and this "locks" files, preventing hot-redeploy on windows. final URLConnection connection = url.openConnection(); connection.setUseCaches(false); stream = connection.getInputStream(); if (stream != null) { final Properties props = new Properties(); props.load(stream); stream.close(); stream = null; return props; } } catch (final IOException e) { if (isDiagnosticsEnabled()) { logDiagnostic("Unable to read URL " + url); } } finally { if (stream != null) { try { stream.close(); } catch (final IOException e) { ignore exception; this should not happen if (isDiagnosticsEnabled()) { logDiagnostic("Unable to close stream for URL " + url); } } } } return null; } 
private static PrintStream initDiagnostics ( ) { String dest ; try { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return null ; } } catch ( final SecurityException ex ) { We must be running in some very secure environment. We just have to assume output is not wanted.. return null; } if (dest.equals("STDOUT")) { return System.out; 
private static final void logDiagnostic ( final String msg ) { if ( diagnosticsStream ! = null ) { diagnosticsStream . print ( diagnosticPrefix ) ; 
protected static final void logRawDiagnostic ( final String msg ) { if ( diagnosticsStream ! = null ) { diagnosticsStream . println ( msg ) ; 
private static void logClassLoaderEnvironment ( final Class clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch (final SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } final String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch (final SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic("[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic("[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
private static void logHierarchy ( final String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( final SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { final StringBuffer buf = new StringBuffer ( prefix + " ClassLoader tree: " ) ; 
public static String objectId ( final Object o ) { if ( o = = null ) { return " null " ; 
static public void setLogImplementation ( final String classname ) throws LinkageError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { final Class logclass = Class . forName ( classname ) ; 
static public void setLogImplementation ( final Class logclass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { final Class [ ] argtypes = new Class [ 1 ] ; argtypes [ 0 ] = " " . getClass ( ) ; logImplctor = logclass . getConstructor ( argtypes ) ; } 
static public Log makeNewLogInstance ( final String name ) { Log log ; try { final Object [ ] args = { name } ; log = ( Log ) logImplctor . newInstance ( args ) ; } catch ( final Throwable ) { log = null ; } if ( null = = log ) { log = new NoOpLog ( name ) ; } return log ; } 
public void debug ( final Object message ) { log ( Level . FINE , String . valueOf ( message ) , null ) ; } 
public void debug ( final Object message , final Throwable exception ) { log ( Level . FINE , String . valueOf ( message ) , exception ) ; } 
public void error ( final Object message ) { log ( Level . SEVERE , String . valueOf ( message ) , null ) ; } 
public void error ( final Object message , final Throwable exception ) { log ( Level . SEVERE , String . valueOf ( message ) , exception ) ; } 
public void fatal ( final Object message ) { log ( Level . SEVERE , String . valueOf ( message ) , null ) ; } 
public void fatal ( final Object message , final Throwable exception ) { log ( Level . SEVERE , String . valueOf ( message ) , exception ) ; } 
public void info ( final Object message ) { log ( Level . INFO , String . valueOf ( message ) , null ) ; } 
public void info ( final Object message , final Throwable exception ) { log ( Level . INFO , String . valueOf ( message ) , exception ) ; } 
public void trace ( final Object message ) { log ( Level . FINEST , String . valueOf ( message ) , null ) ; } 
public void trace ( final Object message , final Throwable exception ) { log ( Level . FINEST , String . valueOf ( message ) , exception ) ; } 
public void warn ( final Object message ) { log ( Level . WARNING , String . valueOf ( message ) , null ) ; } 
public void warn ( final Object message , final Throwable exception ) { log ( Level . WARNING , String . valueOf ( message ) , exception ) ; } 
protected void log ( final Level level , final String msg , final Throwable ex ) { final Logger logger = getLogger ( ) ; if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
public void trace ( final Object message ) { getLogger ( ) . log ( FQCN , traceLevel , message , null ) ; } 
public void trace ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , traceLevel , message , ) ; } 
public void debug ( final Object message ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , null ) ; } 
public void debug ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , Level . DEBUG , message , ) ; } 
public void info ( final Object message ) { getLogger ( ) . log ( FQCN , Level . INFO , message , null ) ; } 
public void info ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , Level . INFO , message , ) ; } 
public void warn ( final Object message ) { getLogger ( ) . log ( FQCN , Level . WARN , message , null ) ; } 
public void warn ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , Level . WARN , message , ) ; } 
public void error ( final Object message ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , null ) ; } 
public void error ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , Level . ERROR , message , ) ; } 
public void fatal ( final Object message ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , null ) ; } 
public void fatal ( final Object message , final Throwable ) { getLogger ( ) . log ( FQCN , Level . FATAL , message , ) ; } 
public Log getInstance ( final Class clazz ) throws LogConfigurationException { return getInstance ( clazz . getName ( ) ) ; } 
public Log getInstance ( final String name ) throws LogConfigurationException { Log instance = ( Log ) instances . get ( name ) ; if ( instance = = null ) { instance = newInstance ( name ) ; instances . put ( name , instance ) ; } return instance ; } 
public void removeAttribute ( final String name ) { attributes . remove ( name ) ; } 
private void initDiagnostics ( ) { It would be nice to include an identifier of the context classloader that this LogFactoryImpl object is responsible for. However that isn't possible as that information isn't available. It is possible to figure this out by looking at the logging from LogFactory to see the context & impl ids from when this object was instantiated, in order to link the impl id output as this object's prefix back to the context it is intended to manage. Note that this prefix should be kept consistent with that in LogFactory. final Class clazz = this.getClass(); final ClassLoader classLoader = getClassLoader(clazz); String classLoaderName; try { if (classLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(classLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactoryImpl@" + System.identityHashCode(this) + " from " + classLoaderName + "] "; } 
protected void logDiagnostic ( final String msg ) { if ( isDiagnosticsEnabled ( ) ) { logRawDiagnostic ( diagnosticPrefix + msg ) ; 
protected Log newInstance ( final String name ) throws LogConfigurationException { Log instance ; try { if ( logConstructor = = null ) { 
private boolean isLogLibraryAvailable ( final String name , final String classname ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Checking for ' " + name + " '. " ) ; } try { final Log log = createLogFromClass ( 
private Log discoverLogImplementation ( final String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use final String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { final StringBuffer messageBuffer = new StringBuffer("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behavior). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY, null); } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY_OLD, null); } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a classname so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the <code>setLogFactory</code> method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { final ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( ! useTCCL ) { return thisClassLoader ; } final ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; final ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic("[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } else { throw new LogConfigurationException("Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (allowFlawedContext) { if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } else { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } } return baseClassLoader; } 
private void handleFlawedDiscovery ( final String logAdapterClassName , final ClassLoader classLoader , USED? final Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. final InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; final Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { final ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; final Throwable cause2 = eiie.getException(); if (cause2 != null) { final StringWriter sw = new StringWriter(); cause2.printStackTrace(new PrintWriter(sw, true)); logDiagnostic("... ExceptionInInitializerError: " + sw.toString()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
public void trace ( final Object message , final Throwable ) { debug ( message , ) ; } 
public void debug ( final Object message ) { if ( message ! = null ) { getLogger ( ) . debug ( String . valueOf ( message ) ) ; 
public void debug ( final Object message , final Throwable ) { if ( message ! = null ) { getLogger ( ) . debug ( String . valueOf ( message ) , ) ; 
public void info ( final Object message ) { if ( message ! = null ) { getLogger ( ) . info ( String . valueOf ( message ) ) ; 
public void info ( final Object message , final Throwable ) { if ( message ! = null ) { getLogger ( ) . info ( String . valueOf ( message ) , ) ; 
public void warn ( final Object message ) { if ( message ! = null ) { getLogger ( ) . warn ( String . valueOf ( message ) ) ; 
public void warn ( final Object message , final Throwable ) { if ( message ! = null ) { getLogger ( ) . warn ( String . valueOf ( message ) , ) ; 
public void error ( final Object message ) { if ( message ! = null ) { getLogger ( ) . error ( String . valueOf ( message ) ) ; 
public void error ( final Object message , final Throwable ) { if ( message ! = null ) { getLogger ( ) . error ( String . valueOf ( message ) , ) ; 
public void fatal ( final Object message ) { if ( message ! = null ) { getLogger ( ) . fatalError ( String . valueOf ( message ) ) ; 
public void fatal ( final Object message , final Throwable ) { if ( message ! = null ) { getLogger ( ) . fatalError ( String . valueOf ( message ) , ) ; 
public void trace ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message , final Throwable ) { } public final boolean isWarnEnabled ( ) { return false ; } } 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialised/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { final Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(final ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void contextInitialized ( final ServletContextEvent sce ) { do nothing }} 
protected void log ( final int type , final Object message , final Throwable ) { Use a string buffer for better performance final StringBuffer buf = new StringBuffer(); Append date-time if so configured if(showDateTime) { final Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if(showShortName) { if(shortLogName == null) { Cut all but the last component of the name for both styles final String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); final java.io.StringWriter sw = new java.io.StringWriter(1024); final java.io.PrintWriter pw = new java.io.PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
protected void write ( final StringBuffer buffer ) { System . err . println ( buffer . toString ( ) ) ; } 
protected boolean isLevelEnabled ( final int logLevel ) { log level are numerically ordered so can use simple numeric comparison return logLevel >= currentLogLevel; } 
public final void debug ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , null ) ; 
public final void debug ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_DEBUG ) ) { log ( SimpleLog . LOG_LEVEL_DEBUG , message , ) ; 
public final void trace ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , null ) ; 
public final void trace ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_TRACE ) ) { log ( SimpleLog . LOG_LEVEL_TRACE , message , ) ; 
public final void info ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , null ) ; 
public final void info ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , message , ) ; 
public final void warn ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , null ) ; 
public final void warn ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , message , ) ; 
public final void error ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , null ) ; 
public final void error ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , message , ) ; 
public final void fatal ( final Object message ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , null ) ; 
public final void fatal ( final Object message , final Throwable ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , message , ) ; 
public Object run ( ) { final ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { return threadCL . getResourceAsStream ( name ) ; 
public boolean containsKey ( final Object key ) { purge should not be required final Referenced referenced = new Referenced(key); return super.containsKey(referenced); } 
public Set entrySet ( ) { purge ( ) ; final Set referencedEntries = super . entrySet ( ) ; final Set unreferencedEntries = new HashSet ( ) ; for ( final Iterator it = referencedEntries . iterator ( ) ; it . hasNext ( ) ; ) { final Map . Entry entry = ( Map . Entry ) it . next ( ) ; final Referenced referencedKey = ( Referenced ) entry . getKey ( ) ; final Object key = referencedKey . getValue ( ) ; final Object value = entry . getValue ( ) ; if ( key ! = null ) { final Entry dereferencedEntry = new Entry ( key , value ) ; unreferencedEntries . add ( dereferencedEntry ) ; } } return unreferencedEntries ; } 
public Object get ( final Object key ) { for performance reasons, no purge final Referenced referenceKey = new Referenced(key); return super.get(referenceKey); } 
public Object nextElement ( ) { final Referenced nextReference = ( Referenced ) enumer . nextElement ( ) ; return nextReference . getValue ( ) ; } 
public Set keySet ( ) { purge ( ) ; final Set referencedKeys = super . keySet ( ) ; final Set unreferencedKeys = new HashSet ( ) ; for ( final Iterator it = referencedKeys . iterator ( ) ; it . hasNext ( ) ; ) { final Referenced referenceKey = ( Referenced ) it . next ( ) ; final Object keyValue = referenceKey . getValue ( ) ; if ( keyValue ! = null ) { unreferencedKeys . add ( keyValue ) ; } } return unreferencedKeys ; } 
public synchronized Object put ( final Object key , final Object value ) { check for nulls, ensuring semantics match superclass if (key == null) { throw new NullPointerException("Null keys are not allowed"); } if (value == null) { throw new NullPointerException("Null values are not allowed"); } for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } final Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public void putAll ( final Map ) { if ( ! = null ) { final Set entrySet = . entrySet ( ) ; 
public synchronized Object remove ( final Object key ) { for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } return super.remove(new Referenced(key)); } 
private void purgeOne ( ) { synchronized ( queue ) { final WeakKey key = ( WeakKey ) queue . poll ( ) ; 
public boolean equals ( final Object o ) { boolean result = false ; if ( o instanceof Map . Entry ) { final Map . Entry entry = ( Map . Entry ) o ; result = ( getKey ( ) = = null ? entry . getKey ( ) = = null : getKey ( ) . equals ( entry . getKey ( ) ) ) & & ( getValue ( ) = = null ? entry . getValue ( ) = = null : getValue ( ) . equals ( entry . getValue ( ) ) ) ; } return result ; } 
public boolean equals ( final Object o ) { boolean result = false ; if ( o instanceof Referenced ) { final Referenced otherKey = ( Referenced ) o ; final Object thisKeyValue = getValue ( ) ; final Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = otherKeyValue = = null ; Since our hashcode was calculated from the original non-null referant, the above check breaks the hashcode/equals contract, as two cleared Referenced objects could test equal but have different hashcodes. We can reduce (not eliminate) the chance of this happening by comparing hashcodes. result = result && this.hashCode() == otherKey.hashCode(); In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { final Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { final Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } 
public Object put ( final Object key , final Object value ) { lastKey = key ; lastValue = value ; return super . put ( key , value ) ; } 
public static Test suite ( ) throws Exception { final Class thisClass = AltHashtableTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , thisClassLoader ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testPutCalled ( ) throws Exception { AltHashtable . lastKey = null ; AltHashtable . lastValue = null ; LogFactory . getLog ( AltHashtableTestCase . class ) ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( contextLoader , AltHashtable . lastKey ) ; assertNotNull ( AltHashtable . lastValue ) ; } 
public void testIsEnabledClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeIsEnabledTest ( log ) ; } 
public void testIsEnabledNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeIsEnabledTest ( log ) ; } 
public void testMessageWithoutExceptionClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithoutExceptionNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void executeMessageWithoutExceptionTest ( final Log log ) { try { 
public void testMessageWithExceptionClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithExceptionTest ( log ) ; } 
public void testMessageWithExceptionNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithExceptionTest ( log ) ; } 
public void executeMessageWithExceptionTest ( final Log log ) { try { 
private Class def ( final String name ) throws ClassNotFoundException { Class result = ( Class ) classes . get ( name ) ; if ( result ! = null ) { return result ; } try { 
public Class loadClass ( final String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exeptions to simlify handling in test for(int i = 0; i < LOG_PCKG.length; i++ ){ if( name.startsWith( LOG_PCKG[i] ) && name.indexOf("Exception") == -1 ){ return def(name); } } return super.loadClass(name); } 
private void setAllowFlawedContext ( final Class c , final String state ) throws Exception { final Class [ ] params = { String . class } ; final java . lang . reflect . Method m = c . getDeclaredMethod ( " setAllowFlawedContext " , params ) ; m . invoke ( null , new Object [ ] { state } ) ; } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch(final LogConfigurationException ex) { expected; the boot classloader doesn't *have* JCL available } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
private Class reload ( ) throws Exception { Class testObjCls = null ; final AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( final ClassNotFoundException cnfe ) { throw cnfe ; } catch ( final Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertTrue ( " app isolated " , testObjCls . getClassLoader ( ) = = appLoader ) ; return testObjCls ; 
private void execute ( final Class cls ) throws Exception { cls . newInstance ( ) ; 
public void useSystemLoader ( final String prefix ) { useExplicitLoader ( prefix , ClassLoader . getSystemClassLoader ( ) ) ; 
public void useExplicitLoader ( final String prefix , final ClassLoader loader ) { if ( lookasides = = null ) { lookasides = new HashMap ( ) ; } lookasides . put ( prefix , loader ) ; } 
public void addLogicalLib ( final String [ ] logicalLibs ) { for ( int i = 0 ; i < logicalLibs . length ; + + i ) { addLogicalLib ( logicalLibs [ i ] ) ; 
public void addLogicalLib ( final String logicalLib ) { first, check the system properties final String filename = System.getProperty(logicalLib); if (filename != null) { try { final URL libUrl = new File(filename).toURL(); addURL(libUrl); return; } catch(final java.net.MalformedURLException e) { throw new UnknownError( "Invalid file [" + filename + "] for logical lib [" + logicalLib + "]"); } } now check the classpath for a similar-named lib final URL libUrl = libFromClasspath(logicalLib); if (libUrl != null) { addURL(libUrl); return; } lib not found throw new UnknownError( "Logical lib [" + logicalLib + "] is not defined" 
private URL libFromClasspath ( final String logicalLib ) { final ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } final URLClassLoader ucl = ( URLClassLoader ) cl ; final URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( int i = 0 ; i < path . length ; + + i ) { final URL u = path [ i ] ; extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } final int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } if (filename.startsWith(logicalLib)) { ok, this is a candidate if (filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } } return shortestMatch; } 
protected Class loadClass ( final String name , final boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for(final Iterator i = lookasides.entrySet().iterator(); i.hasNext(); ) { final Map.Entry entry = (Map.Entry) i.next(); final String prefix = (String) entry.getKey(); if (name.startsWith(prefix) == true) { final ClassLoader loader = (ClassLoader) entry.getValue(); final Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); 
public Enumeration getResourcesInOrder ( final String name ) throws IOException { if ( parentFirst ) { return super . getResources ( name ) ; 
private ArrayList toList ( final Enumeration en ) { final ArrayList results = new ArrayList ( ) ; if ( en ! = null ) { while ( en . hasMoreElements ( ) ) { final Object element = en . nextElement ( ) ; results . add ( element ) ; } } return results ; } 
public void runTest ( final Test test , final TestResult result ) { final ClassLoader origContext = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Properties oldSysProps = ( Properties ) System . getProperties ( ) . clone ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( contextLoader ) ; 
public static Test suite ( ) { final TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( AvalonLoggerTestCase . class ) ; return suite ; } 
public static Test suite ( ) throws Exception { final Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put JCL in the container path, the testcase in a webapp path, and both config files into the webapp path too. final PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); final PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); final URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); final URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. final Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { final LogFactory instance = LogFactory . getFactory ( ) ; final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader lfClassLoader = instance . getClass ( ) . getClassLoader ( ) ; final ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; context classloader should be thisClassLoader assertEquals(thisClassLoader, contextClassLoader); lfClassLoader should be parent of this classloader assertEquals(lfClassLoader, thisClassLoader.getParent()); assertEquals(PathableClassLoader.class.getName(), lfClassLoader.getClass().getName()); final String id = (String) instance.getAttribute("configId"); assertEquals("Correct config file loaded", "priority20", id ); } 
public static Test suite ( ) throws Exception { final Class thisClass = PriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put a config file of priority=10 in the container path, and ones of both "no priority" and priority=20 in the webapp path. A second properties file with priority=20 is also added, so we can check that the first one in the classpath is used. final PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); final URL pri10URL = new URL(baseUrl, "priority10/"); containerLoader.addURL(pri10URL); final PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.setParentFirst(true); webappLoader.addLogicalLib("testclasses"); final URL noPriorityURL = new URL(baseUrl, "nopriority/"); webappLoader.addURL(noPriorityURL); final URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); final URL pri20aURL = new URL(baseUrl, "priority20a/"); webappLoader.addURL(pri20aURL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. final Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public void testPriority ( ) throws Exception { final LogFactory instance = LogFactory . getFactory ( ) ; final String id = ( String ) instance . getAttribute ( " configId " ) ; assertEquals ( " Correct config file loaded " , " priority20 " , id ) ; } 
public void testElements ( ) throws Exception { final ArrayList elements = new ArrayList ( ) ; for ( final Enumeration e = weakHashtable . elements ( ) ; e . hasMoreElements ( ) ; ) { elements . add ( e . nextElement ( ) ) ; } assertEquals ( 3 , elements . size ( ) ) ; assertTrue ( elements . contains ( valueOne ) ) ; assertTrue ( elements . contains ( valueTwo ) ) ; assertTrue ( elements . contains ( valueThree ) ) ; } 
public void testEntrySet ( ) throws Exception { final Set entrySet = weakHashtable . entrySet ( ) ; for ( final Iterator it = entrySet . iterator ( ) ; it . hasNext ( ) ; ) { final Map . Entry entry = ( Map . Entry ) it . next ( ) ; 
public void testKeys ( ) throws Exception { final ArrayList keys = new ArrayList ( ) ; for ( final Enumeration e = weakHashtable . keys ( ) ; e . hasMoreElements ( ) ; ) { keys . add ( e . nextElement ( ) ) ; } assertEquals ( 3 , keys . size ( ) ) ; assertTrue ( keys . contains ( keyOne ) ) ; assertTrue ( keys . contains ( keyTwo ) ) ; assertTrue ( keys . contains ( keyThree ) ) ; } 
public void testKeySet ( ) throws Exception { final Set keySet = weakHashtable . keySet ( ) ; assertEquals ( 3 , keySet . size ( ) ) ; assertTrue ( keySet . contains ( keyOne ) ) ; assertTrue ( keySet . contains ( keyTwo ) ) ; assertTrue ( keySet . contains ( keyThree ) ) ; } 
public void testPut ( ) throws Exception { final Long anotherKey = new Long ( 2004 ) ; weakHashtable . put ( anotherKey , new Long ( 1066 ) ) ; assertEquals ( new Long ( 1066 ) , weakHashtable . get ( anotherKey ) ) ; Test compliance with the hashtable API re nulls Exception caught = null; try { weakHashtable.put(null, new Object()); } catch (final Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null key", caught); caught = null; try { weakHashtable.put(new Object(), null); } catch (final Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null value", caught); } 
public void testPutAll ( ) throws Exception { final Map newValues = new HashMap ( ) ; final Long newKey = new Long ( 1066 ) ; final Long newValue = new Long ( 1415 ) ; newValues . put ( newKey , newValue ) ; final Long anotherNewKey = new Long ( 1645 ) ; final Long anotherNewValue = new Long ( 1815 ) ; newValues . put ( anotherNewKey , anotherNewValue ) ; weakHashtable . putAll ( newValues ) ; assertEquals ( 5 , weakHashtable . size ( ) ) ; assertEquals ( newValue , weakHashtable . get ( newKey ) ) ; assertEquals ( anotherNewValue , weakHashtable . get ( anotherNewKey ) ) ; } 
public void testValues ( ) throws Exception { final Collection values = weakHashtable . values ( ) ; assertEquals ( 3 , values . size ( ) ) ; assertTrue ( values . contains ( valueOne ) ) ; assertTrue ( values . contains ( valueTwo ) ) ; assertTrue ( values . contains ( valueThree ) ) ; } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; final ReferenceQueue testQueue = new ReferenceQueue ( ) ; final WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } else { create garbage: final byte[] b = new byte[bytz]; bytz = bytz * 2; } } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public void testLOGGING_119 ( ) throws Exception { final Thread [ ] = new Thread [ THREAD_COUNT ] ; for ( int j = 1 ; j < = OUTER_LOOP ; j + + ) { hashtable = new WeakHashtable ( ) ; 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging-api"); final PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); final Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging"); final PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); final Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
protected static byte [ ] readClass ( final String name , final ClassLoader srcCL ) throws Exception { final String resName = name . replace ( '.' , '/' ) + " .class " ; System . err . println ( " Trying to load resource [ " + resName + " ] " ) ; final InputStream is = srcCL . getResourceAsStream ( resName ) ; final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; System . err . println ( " Reading resource [ " + resName + " ] " ) ; final byte [ ] buf = new byte [ 1000 ] ; for ( ; ; ) { final int read = is . read ( buf ) ; if ( read < = 0 ) { break ; } baos . write ( buf , 0 , read ) ; } is . close ( ) ; return baos . toByteArray ( ) ; } 
protected static void loadTestHandler ( final String className , final ClassLoader targetCL ) { try { targetCL . loadClass ( className ) ; fail("Class already in target classloader"); return; } catch(final ClassNotFoundException ex) { ok, go ahead and load it } try { final ClassLoader srcCL = CustomConfigAPITestCase.class.getClassLoader(); 
public static Test suite ( ) throws Exception { final PathableClassLoader cl = new PathableClassLoader ( null ) ; cl . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessable from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); cl.useExplicitLoader(HANDLER_NAME, scl); cl.addLogicalLib("commons-logging"); cl.addLogicalLib("testclasses"); final Class testClass = cl.loadClass(CustomConfigTestCase.class.getName()); return new PathableTestSuite(testClass, cl); } 
protected void checkLogRecords ( final boolean thrown ) { final Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; final LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertTrue ( " LogRecord class " , record . getSourceClassName ( ) . startsWith ( " org.apache.commons.logging.jdk14.CustomConfig " ) ) ; if ( thrown ) { assertEquals ( " LogRecord method " , " logExceptionMessages " , record . getSourceMethodName ( ) ) ; } else { assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } if ( thrown ) { assertNotNull ( " LogRecord thrown " , record . getThrown ( ) ) ; assertTrue ( " LogRecord thrown type " , record . getThrown ( ) instanceof DummyException ) ; } else { assertNull ( " LogRecord thrown " , record . getThrown ( ) ) ; } } assertTrue ( ! records . hasNext ( ) ) ; handler . flush ( ) ; } 
protected void logExceptionMessages ( ) { final Throwable = new DummyException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
protected void setUpLogger ( final String name ) throws Exception { logger = Logger . getLogger ( name ) ; } 
protected void setUpManager ( final String config ) throws Exception { manager = LogManager . getLogManager ( ) ; final InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( config ) ; manager . readConfiguration ( is ) ; is . close ( ) ; } 
public static Test suite ( ) throws Exception { final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( DefaultConfigTestCase . class . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; 
public void testSerializable ( ) throws Exception { Serialize and deserialize the instance final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); Check the characteristics of the resulting object checkLog(); 
protected void setUpLog ( final String name ) throws Exception { log = LogFactory . getLog ( name ) ; } 
public void close ( ) { } public void flush ( ) { records . clear ( ) ; } public void publish ( final LogRecord record ) { records . add ( record ) ; } } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; ----------------------------------------------------------- Test Methods private void logExceptionMessages(final Log log) { final Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
public void testCreateFactory ( ) { final LogFactory factory = LogFactory . getFactory ( ) ; assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void testPlainMessages ( ) throws Exception { final List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; final Log log = LogFactory . getLog ( " test-category " ) ; logPlainMessages ( log ) ; checkLoggingEvents ( logEvents , false ) ; } 
public void testExceptionMessages ( ) throws Exception { final List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; final Log log = LogFactory . getLog ( " test-category " ) ; logExceptionMessages ( log ) ; checkLoggingEvents ( logEvents , true ) ; } 
public void testSerializable ( ) throws Exception { final List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; final Log log = LogFactory . getLog ( " test-category " ) ; final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( log ) ; oos . close ( ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; final ObjectInputStream ois = new ObjectInputStream ( bais ) ; final Log newLog = ( Log ) ois . readObject ( ) ; ois . close ( ) ; Check the characteristics of the resulting object logExceptionMessages(newLog); checkLoggingEvents(logEvents, true); } 
private void checkLoggingEvents ( final List logEvents , final boolean thrown ) { LogEvent ev ; assertEquals ( " Unexpected number of log events " , 4 , logEvents . size ( ) ) ; ev = ( LogEvent ) logEvents . get ( 0 ) ; assertEquals ( " Info message expected " , " info " , ev . msg ) ; assertEquals ( " Info level expected " , " INFO " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 1 ) ; assertEquals ( " Warn message expected " , " warn " , ev . msg ) ; assertEquals ( " Warn level expected " , " WARN " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 2 ) ; assertEquals ( " Error message expected " , " error " , ev . msg ) ; assertEquals ( " Error level expected " , " ERROR " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; ev = ( LogEvent ) logEvents . get ( 3 ) ; assertEquals ( " Fatal message expected " , " fatal " , ev . msg ) ; assertEquals ( " Fatal level expected " , " FATAL " , ev . level ) ; assertEquals ( " Exception data incorrect " , ev . throwable ! = null , thrown ) ; } 
private void logPlainMessages ( final Log log ) { log . trace ( " trace " ) ; Should not actually get logged log.debug("debug"); Should not actually get logged log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); } 
private void logExceptionMessages ( final Log log ) { final Throwable = new DummyException ( ) ; log . trace ( " trace " , ) ; Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); } 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging-api " ) ; final PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; child . addLogicalLib ( " testclasses " ) ; final Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " log4j12 " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; final PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; child . addLogicalLib ( " log4j12 " ) ; child . addLogicalLib ( " commons-logging " ) ; final Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " log4j12 " ) ; final PathableClassLoader child = new PathableClassLoader ( parent ) ; child . addLogicalLib ( " testclasses " ) ; final Class testClass = child . loadClass ( " org.apache.commons.logging.log4j.log4j12.Log4j12StandardTests " ) ; return new PathableTestSuite ( testClass , child ) ; } 
public static Test suite ( ) throws Exception { final Class thisClass = StandardTestCase . class ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; loader . addLogicalLib ( " logkit " ) ; final Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void testSerializable ( ) throws Exception { checkStandard ( ) ; Serialize and deserialize the instance final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); checkStandard(); } 
public void testSerializable ( ) throws Exception { Log log = LogFactory . getLog ( this . getClass ( ) . getName ( ) ) ; checkLog ( log ) ; Serialize and deserialize the instance final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); checkLog(log); } 
private void checkLog ( final Log log ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.NoOpLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? Note that *everything* is permanently disabled for NoOpLog assertFalse(log.isTraceEnabled()); assertFalse(log.isDebugEnabled()); assertFalse(log.isInfoEnabled()); assertFalse(log.isWarnEnabled()); assertFalse(log.isErrorEnabled()); assertFalse(log.isFatalEnabled()); } 
public static Test suite ( ) throws Exception { final Class thisClass = ChildFirstTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath final PathableClassLoader parent = new PathableClassLoader(null); parent.setParentFirst(false); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); Make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); Create a child classloader to load the test case through final PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); Obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); Create a third classloader to be the context classloader. final PathableClassLoader context = new PathableClassLoader(child); context.setParentFirst(false); reload this class via the child classloader final Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); final ClassLoader childLoader = contextLoader.getParent(); final ClassLoader parentLoader = childLoader.getParent(); final ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behavior - even though it's not the desired behavior. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no guarantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order final String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
private static URL [ ] toURLArray ( final Enumeration e ) { final ArrayList l = new ArrayList ( ) ; while ( e . hasMoreElements ( ) ) { final URL u = ( URL ) e . nextElement ( ) ; l . add ( u ) ; } final URL [ ] tmp = new URL [ l . size ( ) ] ; return ( URL [ ] ) l . toArray ( tmp ) ; } 
public void testResourceAsStream ( ) throws Exception { java . io . InputStream is ; verify the classloader hierarchy final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); final ClassLoader childLoader = contextLoader.getParent(); final ClassLoader parentLoader = childLoader.getParent(); final ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResourceAsStream where no instances exist is = childLoader.getResourceAsStream("nosuchfile"); assertNull("Invalid resource returned non-null stream", is); getResourceAsStream where resource does exist is = childLoader.getResourceAsStream("org/apache/commons/logging/Log.class"); assertNotNull("Null returned for valid resource", is); is.close(); 
public static Test suite ( ) throws Exception { final Class thisClass = GeneralTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , thisClassLoader ) ; loader . addLogicalLib ( " testclasses " ) ; reload this class via the child classloader final Class testClass = loader.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, loader); } 
private static void checkAndSetContext ( ) { final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( " ContextLoader is of unexpected type " , contextLoader . getClass ( ) . getName ( ) , PathableClassLoader . class . getName ( ) ) ; final URL [ ] noUrls = new URL [ 0 ] ; Thread . currentThread ( ) . setContextClassLoader ( new URLClassLoader ( noUrls ) ) ; } 
public static Test suite ( ) throws Exception { final Class thisClass = ParentFirstTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath final PathableClassLoader parent = new PathableClassLoader(null); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through final PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. final PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader final Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The filename part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); final ClassLoader childLoader = contextLoader.getParent(); final ClassLoader parentLoader = childLoader.getParent(); final ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order final String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf("/commons-logging-1.") > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf("/commons-logging-adapters-1.") > 0); 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; final Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityAllowedTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void testAllAllowed ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; final MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; mySecurityManager . addPermission ( new AllPermission ( ) ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; final Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityForbiddenTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void testAllForbidden ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; final MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { Use reflection so that we can control exactly when the static 
public void testContextClassLoader ( ) { System . setProperty ( LogFactory . HASHTABLE_IMPLEMENTATION_PROPERTY , CustomHashtable . class . getName ( ) ) ; final MockSecurityManager mySecurityManager = new MockSecurityManager ( ) ; System . setSecurityManager ( mySecurityManager ) ; try { load a dummy class with another classloader 
private Object loadClass ( final String name , final ClassLoader classLoader ) { try { final Class clazz = classLoader . loadClass ( name ) ; final Object obj = clazz . newInstance ( ) ; return obj ; } catch ( final Exception e ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw ) ; e . printStackTrace ( pw ) ; fail ( " Unexpected exception: " + e . getMessage ( ) + " : " + sw . toString ( ) ) ; } return null ; } 
public static Test suite ( ) throws Exception { LogFactory in parent LogFactory in child (loads test) LogFactory in tccl Having the test loaded via a loader above the tccl emulates the situation where a web.xml file specifies ServletContextCleaner as a listener, and that class is deployed via a shared classloader. final PathableClassLoader parent = new PathableClassLoader(null); parent.useExplicitLoader("junit.", Test.class.getClassLoader()); parent.addLogicalLib("commons-logging"); parent.addLogicalLib("servlet-api"); final PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); child.addLogicalLib("commons-logging"); child.addLogicalLib("testclasses"); final PathableClassLoader tccl = new PathableClassLoader(child); tccl.setParentFirst(false); tccl.addLogicalLib("commons-logging"); final Class testClass = child.loadClass(BasicServletTestCase.class.getName()); return new PathableTestSuite(testClass, tccl); } 
public void testBasics ( ) { final ServletContextCleaner scc = new ServletContextCleaner ( ) ; scc . contextDestroyed ( null ) ; } 
public static Test suite ( ) throws Exception { final Class thisClass = CustomConfigTestCase . class ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
protected void checkExpected ( ) { final List acts = ( ( DecoratedSimpleLog ) log ) . getCache ( ) ; final Iterator exps = expected . iterator ( ) ; int = 0 ; while ( exps . hasNext ( ) ) { final LogRecord exp = ( LogRecord ) exps . next ( ) ; 
protected void logExceptionMessages ( ) { Generate log records final Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", t)); 
public static Test suite ( ) throws Exception { final Class thisClass = DateTimeCustomConfigTestCase . class ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
protected void checkDecoratedDateTime ( ) { assertEquals ( " Expected date format to be set " , " dd.mm.yyyy " , ( ( DecoratedSimpleLog ) log ) . getDateTimeFormat ( ) ) ; try the formatter final Date now = new Date(); final DateFormat formatter = ((DecoratedSimpleLog) log).getDateTimeFormatter(); final SimpleDateFormat sampleFormatter = new SimpleDateFormat("dd.mm.yyyy"); assertEquals("Date should be formatters to pattern dd.mm.yyyy", sampleFormatter.format(now), formatter.format(now)); 
protected void log ( final int type , final Object message , final Throwable ) { super . log ( type , message , ) ; cache . add ( new LogRecord ( type , message , ) ) ; 
public static Test suite ( ) throws Exception { final Class thisClass = DefaultConfigTestCase . class ; final PathableClassLoader loader = new PathableClassLoader ( null ) ; loader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; loader . addLogicalLib ( " testclasses " ) ; loader . addLogicalLib ( " commons-logging " ) ; final Class testClass = loader . loadClass ( thisClass . getName ( ) ) ; return new PathableTestSuite ( testClass , loader ) ; } 
public void testSerializable ( ) throws Exception { Serialize and deserialize the instance final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(log); oos.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream ois = new ObjectInputStream(bais); log = (Log) ois.readObject(); ois.close(); Check the characteristics of the resulting object checkStandard(); 
public static Test suite ( ) throws Exception { final PathableClassLoader contextClassLoader = new PathableClassLoader ( null ) ; contextClassLoader . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; final PathableTestSuite suite = new PathableTestSuite ( BadTCCLTestCase . class , contextClassLoader ) ; return suite ; } 
public void testGetLog ( ) { final Log log = LogFactory . getLog ( BadTCCLTestCase . class ) ; log . debug ( " Hello, Mum " ) ; } 
public static Test suite ( ) throws Exception { final PathableTestSuite suite = new PathableTestSuite ( NullTCCLTestCase . class , null ) ; return suite ; } 
public void testGetLog ( ) { final Log log = LogFactory . getLog ( NullTCCLTestCase . class ) ; log . debug ( " Hello, Mum " ) ; } 
public void trace ( final Object message ) { } public void trace ( final Object message , final Throwable ) { } public void debug ( final Object message ) { } public void debug ( final Object message , final Throwable ) { } public void info ( final Object message ) { } public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void trace ( final Object message , final Throwable ) { } public void debug ( final Object message ) { } public void debug ( final Object message , final Throwable ) { } public void info ( final Object message ) { } public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void debug ( final Object message ) { } public void debug ( final Object message , final Throwable ) { } public void info ( final Object message ) { } public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void debug ( final Object message , final Throwable ) { } public void info ( final Object message ) { } public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void info ( final Object message ) { } public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void info ( final Object message , final Throwable ) { } public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void warn ( final Object message ) { } public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void warn ( final Object message , final Throwable ) { } public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void error ( final Object message ) { } public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void error ( final Object message , final Throwable ) { } public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message ) { } public void fatal ( final Object message , final Throwable ) { } } 
public static Test suite ( ) throws Exception { final Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLog parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); assertNotNull(clazz); silence warnings about unused var } catch(final ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testTcclLoading ( ) throws Exception { final LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; try { final Log log = instance . getInstance ( " test " ) ; 
public static Test suite ( ) throws Exception { final Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testTcclLoading ( ) throws Exception { final LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , " org.apache.commons.logging.impl.LogFactoryImpl " , instance . getClass ( ) . getName ( ) ) ; final Log log = instance . getInstance ( " test " ) ; assertEquals ( " Correct Log loaded " , 
public static Test suite ( ) throws Exception { final Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass(MY_LOG_FACTORY_IMPL); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(final ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass(MY_LOG_FACTORY_IMPL); 
public void testTcclLoading ( ) throws Exception { try { final LogFactory instance = LogFactory . getFactory ( ) ; 
public static Test suite ( ) throws Exception { final Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the testcase classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass( "org.apache.commons.logging.tccl.custom.MyLogFactoryImpl"); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch(final ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass( 
public void testTcclLoading ( ) throws Exception { final LogFactory instance = LogFactory . getFactory ( ) ; assertEquals ( " Correct LogFactory loaded " , 
public Set entrySet ( ) { purge ( ) ; final Set referencedEntries = super . entrySet ( ) ; final Set unreferencedEntries = new HashSet ( ) ; for ( final Object referencedEntry : referencedEntries ) { final Map . Entry entry = ( Map . Entry ) referencedEntry ; final Referenced referencedKey = ( Referenced ) entry . getKey ( ) ; final Object key = referencedKey . getValue ( ) ; final Object value = entry . getValue ( ) ; if ( key ! = null ) { final Entry dereferencedEntry = new Entry ( key , value ) ; unreferencedEntries . add ( dereferencedEntry ) ; } } return unreferencedEntries ; } 
public Set keySet ( ) { purge ( ) ; final Set referencedKeys = super . keySet ( ) ; final Set unreferencedKeys = new HashSet ( ) ; for ( final Object referencedKey : referencedKeys ) { final Referenced referenceKey = ( Referenced ) referencedKey ; final Object keyValue = referenceKey . getValue ( ) ; if ( keyValue ! = null ) { unreferencedKeys . add ( keyValue ) ; } } return unreferencedKeys ; } 
public Class loadClass ( final String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exeptions to simlify handling in test for (final String element : LOG_PCKG) { if( name.startsWith( element ) && name.indexOf("Exception") == -1 ){ return def(name); } } return super.loadClass(name); } 
public void addLogicalLib ( final String [ ] logicalLibs ) { for ( final String logicalLib : logicalLibs ) { addLogicalLib ( logicalLib ) ; 
private URL libFromClasspath ( final String logicalLib ) { final ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } final URLClassLoader ucl = ( URLClassLoader ) cl ; final URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( final URL u : path ) { extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } final int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } if (filename.startsWith(logicalLib)) { ok, this is a candidate if (filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } } return shortestMatch; } 
protected Class loadClass ( final String name , final boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for (final Object element : lookasides.entrySet()) { final Map.Entry entry = (Map.Entry) element; final String prefix = (String) entry.getKey(); if (name.startsWith(prefix) == true) { final ClassLoader loader = (ClassLoader) entry.getValue(); final Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); 
public void testEntrySet ( ) throws Exception { final Set entrySet = weakHashtable . entrySet ( ) ; for ( final Object element : entrySet ) { final Map . Entry entry = ( Map . Entry ) element ; 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. final Object result = AccessController.doPrivileged( new PrivilegedAction() { @Override public Object run() { return createFactory(factoryClass, classLoader); } }); if (result instanceof LogConfigurationException) { final LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic("An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic("Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
public void trace ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public Enumeration keys ( ) { purge ( ) ; final Enumeration enumer = super . keys ( ) ; return new Enumeration ( ) { @Override 
public void close ( ) { } @Override public void flush ( ) { records . clear ( ) ; } @Override public void publish ( final LogRecord record ) { records . add ( record ) ; } } 
public void close ( ) { } @Override public boolean requiresLayout ( ) { return false ; } } 
public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void debug ( final Object message ) { } @Override public void debug ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void trace ( final Object message , final Throwable ) { } @Override public void debug ( final Object message ) { } @Override public void debug ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void debug ( final Object message ) { } @Override public void debug ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void debug ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void warn ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } } 
protected static boolean isDiagnosticsEnabled ( ) { return DIAGNOSTICS_STREAM ! = null ; } 
private static final void logDiagnostic ( final String msg ) { if ( DIAGNOSTICS_STREAM ! = null ) { DIAGNOSTICS_STREAM . print ( diagnosticPrefix ) ; 
protected static final void logRawDiagnostic ( final String msg ) { if ( DIAGNOSTICS_STREAM ! = null ) { DIAGNOSTICS_STREAM . println ( msg ) ; 
private static void logHierarchy ( final String prefix , ClassLoader classLoader ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } ClassLoader systemClassLoader ; if ( classLoader ! = null ) { final String classLoaderString = classLoader . toString ( ) ; logDiagnostic ( prefix + objectId ( classLoader ) + " == ' " + classLoaderString + " ' " ) ; } try { systemClassLoader = ClassLoader . getSystemClassLoader ( ) ; } catch ( final SecurityException ex ) { logDiagnostic ( prefix + " Security forbids determining the system classloader. " ) ; return ; } if ( classLoader ! = null ) { final StringBuilder buf = new StringBuilder ( prefix + " ClassLoader tree: " ) ; 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialized/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { final Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch(final ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch(final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch(final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch(final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void testType ( ) { Here, the reference to the LogFactory class should cause the class to be loaded and initialized. It will see the property set and use the AltHashtable class. If other tests in this class have already been run within the same classloader then LogFactory will already have been initialized, but that doesn't change the effectiveness of this test. assertTrue(LogFactory.factories instanceof AltHashtable); } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && (Boolean.valueOf(useTCCLStr).booleanValue() == false)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private URL libFromClasspath ( final String logicalLib ) { final ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( cl instanceof URLClassLoader = = false ) { return null ; } final URLClassLoader ucl = ( URLClassLoader ) cl ; final URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( final URL u : path ) { extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } final int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } ok, this is a candidate if (filename.startsWith(logicalLib) && filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } return shortestMatch; } 
private void setAllowFlawedContext ( final Class c , final String state ) throws Exception { final Class [ ] params = { String . class } ; final java . lang . reflect . Method m = c . getDeclaredMethod ( " setAllowFlawedContext " , params ) ; m . invoke ( null , state ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && (Boolean.parseBoolean(useTCCLStr) == false)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public Object run ( ) { if ( loader ! = null ) { return loader . getResourceAsStream ( name ) ; } return ClassLoader . getSystemResourceAsStream ( name ) ; } 
private static PrintStream initDiagnostics ( ) { String dest ; try { dest = getSystemProperty ( DIAGNOSTICS_DEST_PROPERTY , null ) ; if ( dest = = null ) { return null ; } } catch ( final SecurityException ex ) { We must be running in some very secure environment. We just have to assume output is not wanted.. return null; } if (dest.equals("STDOUT")) { return System.out; } if (dest.equals("STDERR")) { return System.err; } try { open the file in append mode 
public static String objectId ( final Object o ) { if ( o = = null ) { return " null " ; } return o . getClass ( ) . getName ( ) + " @ " + System . identityHashCode ( o ) ; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { final ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( ! useTCCL ) { return thisClassLoader ; } final ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; final ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two classloaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (!allowFlawedContext) { throw new LogConfigurationException("Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } if (isDiagnosticsEnabled()) { logDiagnostic("[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom classloaders but fail to set the context classloader so we handle those flawed systems anyway. if (!allowFlawedContext) { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } return baseClassLoader; } 
public Object run ( ) { final ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { return threadCL . getResourceAsStream ( name ) ; } return ClassLoader . getSystemResourceAsStream ( name ) ; } 
protected Class loadClass ( final String name , final boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for (final Object element : lookasides.entrySet()) { final Map.Entry entry = (Map.Entry) element; final String prefix = (String) entry.getKey(); if (name.startsWith(prefix) == true) { final ClassLoader loader = (ClassLoader) entry.getValue(); final Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); } try { Class clazz = findLoadedClass(name); 
public Enumeration getResourcesInOrder ( final String name ) throws IOException { if ( parentFirst ) { return super . getResources ( name ) ; } final Enumeration localUrls = super . findResources ( name ) ; final ClassLoader parent = getParent ( ) ; if ( parent = = null ) { Alas, there is no method to get matching resources from a null (BOOT) parent classloader. Calling ClassLoader.getSystemClassLoader isn't right. Maybe calling Class.class.getResources(name) would do? However for the purposes of unit tests, we can simply assume that no relevant resources are loadable from the parent; unit tests will never be putting any of their resources in a "boot" classloader path! return localUrls; } final Enumeration parentUrls = parent.getResources(name); final ArrayList localItems = toList(localUrls); final ArrayList parentItems = toList(parentUrls); localItems.addAll(parentItems); return Collections.enumeration(localItems); } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; final ReferenceQueue testQueue = new ReferenceQueue ( ) ; final WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if(iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if(weakHashtable.get(new Long(1)) == null) { break; } create garbage: final byte[] b = new byte[bytz]; bytz = bytz * 2; } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoader; } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private URL libFromClasspath ( final String logicalLib ) { final ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( ! ( cl instanceof URLClassLoader ) ) { return null ; } final URLClassLoader ucl = ( URLClassLoader ) cl ; final URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( final URL u : path ) { extract the filename bit on the end of the url String filename = u.toString(); if (!filename.endsWith(".jar")) { not a jarfile, ignore it continue; } final int lastSlash = filename.lastIndexOf('/'); if (lastSlash >= 0) { filename = filename.substring(lastSlash+1); } ok, this is a candidate if (filename.startsWith(logicalLib) && filename.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = filename.length(); } } return shortestMatch; } 
protected Class loadClass ( final String name , final boolean resolve ) throws ClassNotFoundException { just for performance, check java and javax if (name.startsWith("java.") || name.startsWith("javax.")) { return super.loadClass(name, resolve); } if (lookasides != null) { for (final Object element : lookasides.entrySet()) { final Map.Entry entry = (Map.Entry) element; final String prefix = (String) entry.getKey(); if (name.startsWith(prefix)) { final ClassLoader loader = (ClassLoader) entry.getValue(); final Class clazz = Class.forName(name, resolve, loader); return clazz; } } } if (parentFirst) { return super.loadClass(name, resolve); } try { Class clazz = findLoadedClass(name); 
void debug ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void debug ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void error ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void error ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void fatal ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void fatal ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
void info ( Object message ) ; void warn ( Object message , Throwable ) ; } 
void info ( Object message , Throwable ) ; void warn ( Object message , Throwable ) ; } 
boolean isDebugEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isErrorEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isFatalEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isInfoEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
boolean isTraceEnabled ( ) ; void warn ( Object message , Throwable ) ; } 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + msg.trim()); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + msg.trim()); break; } } constructor = c.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the {@code setLogFactory} method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! "".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public void write ( int b ) { } @Override public void write ( byte [ ] b ) { } @Override public void write ( byte [ ] b , int off , int len ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; class GcTask implements Runnable { @Override public void run ( ) { try { while ( running . get ( ) ) { Allocate data to help suggest a GC try { 1mb of heap byte[] buf = new byte[1024 * 1024]; SINK.write(buf); } catch (final IOException ignored) { } May no-op depending on the JVM configuration System.gc(); } } finally { latch.countDown(); } } } @Override public void run() { if (running.compareAndSet(false, true)) { gcThread.start(); } } @Override public void close() { running.set(false); try { junit.framework.TestCase.assertTrue("GarbageCollectionHelper did not shut down cleanly", latch.await(10, TimeUnit.SECONDS)); } catch (final InterruptedException e) { throw new RuntimeException(e); } }} 
public void write ( byte [ ] b ) { } @Override public void write ( byte [ ] b , int off , int len ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; class GcTask implements Runnable { @Override public void run ( ) { try { while ( running . get ( ) ) { Allocate data to help suggest a GC try { 1mb of heap byte[] buf = new byte[1024 * 1024]; SINK.write(buf); } catch (final IOException ignored) { } May no-op depending on the JVM configuration System.gc(); } } finally { latch.countDown(); } } } @Override public void run() { if (running.compareAndSet(false, true)) { gcThread.start(); } } @Override public void close() { running.set(false); try { junit.framework.TestCase.assertTrue("GarbageCollectionHelper did not shut down cleanly", latch.await(10, TimeUnit.SECONDS)); } catch (final InterruptedException e) { throw new RuntimeException(e); } }} 
public void write ( byte [ ] b , int off , int len ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; class GcTask implements Runnable { @Override public void run ( ) { try { while ( running . get ( ) ) { Allocate data to help suggest a GC try { 1mb of heap byte[] buf = new byte[1024 * 1024]; SINK.write(buf); } catch (final IOException ignored) { } May no-op depending on the JVM configuration System.gc(); } } finally { latch.countDown(); } } } @Override public void run() { if (running.compareAndSet(false, true)) { gcThread.start(); } } @Override public void close() { running.set(false); try { junit.framework.TestCase.assertTrue("GarbageCollectionHelper did not shut down cleanly", latch.await(10, TimeUnit.SECONDS)); } catch (final InterruptedException e) { throw new RuntimeException(e); } }} 
public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; 
public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , 
public void testNotLeakingThisClassLoader ( ) throws Exception { create an isolated loader PathableClassLoader loader = new PathableClassLoader(null); loader.addLogicalLib("commons-logging"); load the LogFactory class through this loader Class<?> logFactoryClass = loader.loadClass(LogFactory.class.getName()); reflection hacks to obtain the weak reference Field field = logFactoryClass.getDeclaredField("thisClassLoaderRef"); field.setAccessible(true); WeakReference thisClassLoaderRef = (WeakReference) field.get(null); the ref should at this point contain the loader assertSame(loader, thisClassLoaderRef.get()); null out the hard refs field = null; logFactoryClass = null; loader.close(); loader = null; GarbageCollectionHelper gcHelper = new GarbageCollectionHelper(); gcHelper.run(); try { long start = System.currentTimeMillis(); 
private Class reload ( ) throws Exception { Class testObjCls = null ; final AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( final ClassNotFoundException cnfe ) { throw cnfe ; } catch ( final Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertSame ( " app isolated " , testObjCls . getClassLoader ( ) , appLoader ) ; return testObjCls ; 
public void testPristineLogger ( ) { assertNotNull ( " Logger exists " , logger ) ; assertEquals ( " Logger name " , this . getClass ( ) . getName ( ) , logger . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(logger.isLoggable(Level.SEVERE)); assertTrue(logger.isLoggable(Level.WARNING)); assertTrue(logger.isLoggable(Level.INFO)); assertTrue(logger.isLoggable(Level.CONFIG)); assertTrue(logger.isLoggable(Level.FINE)); assertFalse(logger.isLoggable(Level.FINER)); assertFalse(logger.isLoggable(Level.FINEST)); 
protected void checkLog ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.Jdk14Logger " , log . getClass ( ) . getName ( ) ) ; Assert which logging levels have been enabled assertTrue(log.isFatalEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isWarnEnabled()); assertTrue(log.isInfoEnabled()); assertTrue(log.isDebugEnabled()); assertFalse(log.isTraceEnabled()); 
protected void checkLogRecords ( final boolean thrown ) { final Iterator records = handler . records ( ) ; for ( int i = 0 ; i < testMessages . length ; i + + ) { assertTrue ( records . hasNext ( ) ) ; final LogRecord record = ( LogRecord ) records . next ( ) ; assertEquals ( " LogRecord level " , testLevels [ i ] , record . getLevel ( ) ) ; assertEquals ( " LogRecord message " , testMessages [ i ] , record . getMessage ( ) ) ; assertTrue ( " LogRecord class " , record . getSourceClassName ( ) . startsWith ( " org.apache.commons.logging.jdk14.CustomConfig " ) ) ; if ( thrown ) { assertEquals ( " LogRecord method " , " logExceptionMessages " , record . getSourceMethodName ( ) ) ; } else { assertEquals ( " LogRecord method " , " logPlainMessages " , record . getSourceMethodName ( ) ) ; } if ( thrown ) { assertNotNull ( " LogRecord thrown " , record . getThrown ( ) ) ; assertTrue ( " LogRecord thrown type " , record . getThrown ( ) instanceof DummyException ) ; } else { assertNull ( " LogRecord thrown " , record . getThrown ( ) ) ; } } assertFalse ( records . hasNext ( ) ) ; handler . flush ( ) ; } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertNotEquals("System classloader has unexpected type", PathableClassLoader.class.getName(), systemLoader.getClass().getName()); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch(final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertTrue(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertFalse(log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_DEBUG, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? checkDecoratedDateTime(); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); checkShowDateTime(); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkShowDateTime ( ) { assertFalse ( ( ( DecoratedSimpleLog ) log ) . getShowDateTime ( ) ) ; } 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertFalse(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertFalse(log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("yyyy/MM/dd HH:mm:ss:SSS zzz", ((DecoratedSimpleLog) log).getDateTimeFormat()); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertFalse(((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); 
protected void checkStandard ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.SimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertFalse(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertFalse(log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); 
public synchronized Object put ( final Object key , final Object value ) { check for nulls, ensuring semantics match superclass Objects.requireNonNull(key, "key"); Objects.requireNonNull(value, "value"); for performance reasons, only purge every MAX_CHANGES_BEFORE_PURGE times if (changeCount++ > MAX_CHANGES_BEFORE_PURGE) { purge(); changeCount = 0; } do a partial purge more often else if (changeCount % PARTIAL_PURGE_COUNT == 0) { purgeOne(); } final Referenced keyRef = new Referenced(key, queue); return super.put(keyRef, value); } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; private void logExceptionMessages(final Log log) { final Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
public abstract Log getLogObject ( ) ; public void testLoggingWithNullParameters ( ) { final Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } } 
public void testLoggingWithNullParameters ( ) { final Log log = this . getLogObject ( ) ; assertNotNull ( log ) ; log . debug ( null ) ; log . debug ( null , null ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement " ) ; log . debug ( log . getClass ( ) . getName ( ) + " : debug statement w/ null exception " , new RuntimeException ( ) ) ; log . error ( null ) ; log . error ( null , null ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement " ) ; log . error ( log . getClass ( ) . getName ( ) + " : error statement w/ null exception " , new RuntimeException ( ) ) ; log . fatal ( null ) ; log . fatal ( null , null ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement " ) ; log . fatal ( log . getClass ( ) . getName ( ) + " : fatal statement w/ null exception " , new RuntimeException ( ) ) ; log . info ( null ) ; log . info ( null , null ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement " ) ; log . info ( log . getClass ( ) . getName ( ) + " : info statement w/ null exception " , new RuntimeException ( ) ) ; log . trace ( null ) ; log . trace ( null , null ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement " ) ; log . trace ( log . getClass ( ) . getName ( ) + " : trace statement w/ null exception " , new RuntimeException ( ) ) ; log . warn ( null ) ; log . warn ( null , null ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement " ) ; log . warn ( log . getClass ( ) . getName ( ) + " : warn statement w/ null exception " , new RuntimeException ( ) ) ; } 
private Class def ( final String name ) throws ClassNotFoundException { Class result = ( Class ) classes . get ( name ) ; if ( result ! = null ) { return result ; } try { 
public Class loadClass ( final String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exeptions to simlify handling in test for (final String element : LOG_PCKG) { if (name.startsWith(element) && name.indexOf("Exception") == -1) { return def(name); } } return super.loadClass(name); } 
private Class reload ( ) throws Exception { Class testObjCls = null ; final AppClassLoader appLoader = new AppClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; try { testObjCls = appLoader . loadClass ( UserClass . class . getName ( ) ) ; } catch ( final ClassNotFoundException cnfe ) { throw cnfe ; } catch ( final Throwable ) { . printStackTrace ( ) ; fail ( " AppClassLoader failed " ) ; } assertSame ( " app isolated " , testObjCls . getClassLoader ( ) , appLoader ) ; return testObjCls ; 
private void execute ( final Class cls ) throws Exception { cls . newInstance ( ) ; } 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String names [ ] = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void close ( ) { } @Override public void flush ( ) { records . clear ( ) ; } @Override public void publish ( final LogRecord record ) { records . add ( record ) ; } } 
public void testExceptionMessages ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logExceptionMessages ( ) ; checkExpected ( ) ; } 
public void testPlainMessages ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logPlainMessages ( ) ; checkExpected ( ) ; } 
public void testSerializable ( ) throws Exception { ( ( DecoratedSimpleLog ) log ) . clearCache ( ) ; logPlainMessages ( ) ; super . testSerializable ( ) ; logExceptionMessages ( ) ; checkExpected ( ) ; } 
protected void checkExpected ( ) { final List acts = ( ( DecoratedSimpleLog ) log ) . getCache ( ) ; final Iterator exps = expected . iterator ( ) ; int = 0 ; while ( exps . hasNext ( ) ) { final LogRecord exp = ( LogRecord ) exps . next ( ) ; 
protected void logExceptionMessages ( ) { Generate log records final Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", t)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", t)); } 
protected void logPlainMessages ( ) { Generate log records log.trace("trace"); Should not actually get logged log.debug("debug"); log.info("info"); log.warn("warn"); log.error("error"); log.fatal("fatal"); Record the log records we expect expected.add(new LogRecord(SimpleLog.LOG_LEVEL_DEBUG, "debug", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_INFO, "info", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_WARN, "warn", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_ERROR, "error", null)); expected.add(new LogRecord(SimpleLog.LOG_LEVEL_FATAL, "fatal", null)); } 
public void testPristineDecorated ( ) { setUpDecorated ( " DecoratedLogger " ) ; checkDecorated ( ) ; } 
protected void checkDecorated ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.simple.DecoratedSimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertFalse(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertFalse(log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); Can we validate the extra exposed properties? assertEquals("yyyy/MM/dd HH:mm:ss:SSS zzz", ((DecoratedSimpleLog) log).getDateTimeFormat()); assertEquals("DecoratedLogger", ((DecoratedSimpleLog) log).getLogName()); assertFalse(((DecoratedSimpleLog) log).getShowDateTime()); assertTrue(((DecoratedSimpleLog) log).getShowShortName()); } 
protected void checkStandard ( ) { assertNotNull ( " Log exists " , log ) ; assertEquals ( " Log class " , " org.apache.commons.logging.impl.SimpleLog " , log . getClass ( ) . getName ( ) ) ; Can we call level checkers with no exceptions? assertFalse(log.isDebugEnabled()); assertTrue(log.isErrorEnabled()); assertTrue(log.isFatalEnabled()); assertTrue(log.isInfoEnabled()); assertFalse(log.isTraceEnabled()); assertTrue(log.isWarnEnabled()); Can we retrieve the current log level? assertEquals(SimpleLog.LOG_LEVEL_INFO, ((SimpleLog) log).getLevel()); } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! factoryClassName.isEmpty()) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public Class loadClass ( final String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exceptions to simlify handling in test for (final String element : LOG_PCKG) { if (name.startsWith(element) && name.indexOf("Exception") == -1) { return def(name); } } return super.loadClass(name); } 
public Class loadClass ( final String name ) throws ClassNotFoundException { isolates all logging classes, application in the same classloader too. filters exceptions to simplify handling in test for (final String element : LOG_PCKG) { if (name.startsWith(element) && name.indexOf("Exception") == -1) { return def(name); } } return super.loadClass(name); } 
public static Test suite ( ) throws Exception { final Class thisClass = FirstPriorityConfigTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. We'll put JCL in the container path, the test in a webapp path, and both config files into the webapp path too. final PathableClassLoader containerLoader = new PathableClassLoader(null); containerLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); containerLoader.addLogicalLib("commons-logging"); final PathableClassLoader webappLoader = new PathableClassLoader(containerLoader); webappLoader.addLogicalLib("testclasses"); final URL pri20URL = new URL(baseUrl, "priority20/"); webappLoader.addURL(pri20URL); final URL pri10URL = new URL(baseUrl, "priority10/"); webappLoader.addURL(pri10URL); load the test class via webapp loader, and use the webapp loader as the tccl loader too. final Class testClass = webappLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, webappLoader); } 
public static Test suite ( ) throws Exception { final Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the test classloader can't see the custom MyLog parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { final Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom Log class. We then create a tccl classloader that can see the custom Log class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the test classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader(MY_LOG_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { final Class thisClass = TcclDisabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the test classloader can't see the custom MyLogFactoryImpl parentLoader.useExplicitLoader( MY_LOG_FACTORY_PKG + ".", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_disable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
public static Test suite ( ) throws Exception { final Class thisClass = TcclEnabledTestCase . class ; Determine the URL to this .class file, so that we can then append the priority dirs to it. For tidiness, load this class through a dummy loader though this is not absolutely necessary... final PathableClassLoader dummy = new PathableClassLoader(null); dummy.useExplicitLoader("junit.", Test.class.getClassLoader()); dummy.addLogicalLib("testclasses"); dummy.addLogicalLib("commons-logging"); final String thisClassPath = thisClass.getName().replace('.', '/') + ".class"; final URL baseUrl = dummy.findResource(thisClassPath); Now set up the desired classloader hierarchy. Everything goes into the parent classpath, but we exclude the custom LogFactoryImpl class. We then create a tccl classloader that can see the custom LogFactory class. Therefore if that class can be found, then the TCCL must have been used to load it. final PathableClassLoader emptyLoader = new PathableClassLoader(null); final PathableClassLoader parentLoader = new PathableClassLoader(null); parentLoader.useExplicitLoader("junit.", Test.class.getClassLoader()); parentLoader.addLogicalLib("commons-logging"); parentLoader.addLogicalLib("testclasses"); hack to ensure that the test classloader can't see the cust MyLogFactoryImpl parentLoader.useExplicitLoader( "org.apache.commons.logging.tccl.custom.", emptyLoader); final URL propsEnableUrl = new URL(baseUrl, "props_enable_tccl/"); parentLoader.addURL(propsEnableUrl); final PathableClassLoader tcclLoader = new PathableClassLoader(parentLoader); tcclLoader.addLogicalLib("testclasses"); final Class testClass = parentLoader.loadClass(thisClass.getName()); return new PathableTestSuite(testClass, tcclLoader); } 
private Log discoverLogImplementation ( final String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use final String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { final StringBuilder messageBuffer = new StringBuilder("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source classloaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behavior). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private void informUponSimilarName ( final StringBuilder messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { Don't suggest a name that is exactly the same as the one the user tried... return; } If the user provides a name that is in the right package, and gets the first 5 characters of the adapter class right (ignoring case), then suggest the candidate adapter class name. if (name.regionMatches(true, 0, candidate, 0, PKG_LEN + 5)) { messageBuffer.append(" Did you mean '"); 
protected void log ( final int type , final Object message , final Throwable ) { Use a string buffer for better performance final StringBuilder buf = new StringBuilder(); Append date-time if so configured if(showDateTime) { final Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if(showShortName) { if(shortLogName == null) { Cut all but the last component of the name for both styles final String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if(showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if(t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); final StringWriter sw = new StringWriter(1024); final PrintWriter pw = new PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
private void write ( final Object buffer ) { System . err . println ( buffer . toString ( ) ) ; } 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialized/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { final Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch (final ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch (final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch (final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessable!"); loader = null; } catch (final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch (final LogConfigurationException ex) { expected; the boot classloader doesn't *have* JCL available } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
public void addLogicalLib ( final String logicalLib ) { first, check the system properties final String filename = System.getProperty(logicalLib); if (filename != null) { try { final URL libUrl = new File(filename).toURL(); addURL(libUrl); return; } catch (final java.net.MalformedURLException e) { throw new UnknownError( "Invalid file [" + filename + "] for logical lib [" + logicalLib + "]"); } } now check the classpath for a similar-named lib final URL libUrl = libFromClasspath(logicalLib); if (libUrl != null) { addURL(libUrl); return; } lib not found throw new UnknownError( "Logical lib [" + logicalLib + "] is not defined" 
protected static void loadTestHandler ( final String className , final ClassLoader targetCL ) { try { targetCL . loadClass ( className ) ; fail("Class already in target classloader"); return; } catch (final ClassNotFoundException ex) { ok, go ahead and load it } try { final ClassLoader srcCL = CustomConfigAPITestCase.class.getClassLoader(); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertNotEquals("System classloader has unexpected type", PathableClassLoader.class.getName(), systemLoader.getClass().getName()); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessable due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLog should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass(MY_LOG_IMPL); fail("Unexpectedly able to load MyLog via test class classloader"); assertNotNull(clazz); silence warnings about unused var } catch (final ClassNotFoundException ex) { ok, expected } MyLog should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass(MY_LOG_IMPL); 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass(MY_LOG_FACTORY_IMPL); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch (final ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass(MY_LOG_FACTORY_IMPL); 
public void testLoader ( ) throws Exception { final ClassLoader thisClassLoader = this . getClass ( ) . getClassLoader ( ) ; final ClassLoader tcclLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; the tccl loader should NOT be the same as the loader that loaded this test class. assertNotSame("tccl not same as test classloader", thisClassLoader, tcclLoader); MyLogFactoryImpl should not be loadable via parent loader try { final Class clazz = thisClassLoader.loadClass( "org.apache.commons.logging.tccl.custom.MyLogFactoryImpl"); fail("Unexpectedly able to load MyLogFactoryImpl via test class classloader"); assertNotNull(clazz); silence warning about unused var } catch (final ClassNotFoundException ex) { ok, expected } MyLogFactoryImpl should be loadable via tccl loader try { final Class clazz = tcclLoader.loadClass( 
public boolean equals ( final Object o ) { boolean result = false ; if ( o instanceof Referenced ) { final Referenced otherKey = ( Referenced ) o ; final Object thisKeyValue = getValue ( ) ; final Object otherKeyValue = otherKey . getValue ( ) ; if ( thisKeyValue = = null ) { result = otherKeyValue = = null ; Since our hash code was calculated from the original non-null referant, the above check breaks the hash code/equals contract, as two cleared Referenced objects could test equal but have different hash codes. We can reduce (not eliminate) the chance of this happening by comparing hash codes. result = result && this.hashCode() == otherKey.hashCode(); In any case, as our c'tor does not allow null referants and Hashtable does not do equality checks between existing keys, normal hashtable operations should never result in an equals comparison between null referants } else { result = thisKeyValue.equals(otherKeyValue); } } return result; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID + "] to define the LogFactory subclass to use..."); } try { final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if ( is != null ) { This code is needed by EBCDIC and other strange systems. It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, "UTF-8")); } catch (final java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName; try { factoryClassName = rd.readLine(); } finally { rd.close(); } if (factoryClassName != null && ! factoryClassName.isEmpty()) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class " + factoryClassName + " as specified by file '" + SERVICE_ID + "' which was present in the path of the context classloader."); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader ); } } else { is == null if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found."); } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected void log ( final int type , final Object message , final Throwable ) { Use a string buffer for better performance final StringBuilder buf = new StringBuilder(); Append date-time if so configured if (showDateTime) { final Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if (showShortName) { if (shortLogName == null) { Cut all but the last component of the name for both styles final String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if (showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if (t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); final StringWriter sw = new StringWriter(1024); final PrintWriter pw = new PrintWriter(sw); t.printStackTrace(pw); pw.close(); buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( new Long ( 1 ) ) ) ; final ReferenceQueue testQueue = new ReferenceQueue ( ) ; final WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if (iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if (weakHashtable.get(new Long(1)) == null) { break; } create garbage: final byte[] b = new byte[bytz]; bytz = bytz * 2; } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
public void run ( ) { for ( int i = 0 ; i < RUN_LOOPS ; i + + ) { hashtable . put ( " key " + " : " + i % 10 , Boolean . TRUE ) ; 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String [ ] names = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; private void logExceptionMessages(final Log log) { final Throwable t = new DummyException(); log.trace("trace", t); Should not actually get logged log.debug("debug", t); Should not actually get logged log.info("info", t); log.warn("warn", t); log.error("error", t); log.fatal("fatal", t); }} 
public void testCreateFactory ( ) { final LogFactory factory = LogFactory . getFactory ( ) ; assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String [ ] names = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
public void testPristineFactory ( ) { assertNotNull ( " LogFactory exists " , factory ) ; assertEquals ( " LogFactory class " , " org.apache.commons.logging.impl.LogFactoryImpl " , factory . getClass ( ) . getName ( ) ) ; final String [ ] names = factory . getAttributeNames ( ) ; assertNotNull ( " Names exists " , names ) ; assertEquals ( " Names empty " , 0 , names . length ) ; } 
private static final Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.getConstructor().newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
private void execute ( final Class cls ) throws Exception { cls . getConstructor ( ) . newInstance ( ) ; } 
private Object loadClass ( final String name , final ClassLoader classLoader ) { try { final Class clazz = classLoader . loadClass ( name ) ; final Object obj = clazz . getConstructor ( ) . newInstance ( ) ; return obj ; } catch ( final Exception e ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw ) ; e . printStackTrace ( pw ) ; fail ( " Unexpected exception: " + e . getMessage ( ) + " : " + sw . toString ( ) ) ; } return null ; } 
static public void setLogImplementation ( final String className ) throws LinkageError , NoSuchMethodException , SecurityException , ClassNotFoundException { try { final Class logclass = Class . forName ( className ) ; 
protected void log ( final Level level , final String msg , final Throwable ex ) { final Logger logger = getLogger ( ) ; if ( logger . isLoggable ( level ) ) { Hack (?) to get the stack trace. 
protected boolean isJdk14Available ( ) { return isLogLibraryAvailable ( " Jdk14 " , " org.apache.commons.logging.impl.Jdk14Logger " ) ; } 
protected boolean isLog4JAvailable ( ) { return isLogLibraryAvailable ( " Log4J " , LOGGING_IMPL_LOG4J_LOGGER ) ; } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( ( PrivilegedAction ) LogFactory : : directGetContextClassLoader ) ; 
private static String getSystemProperty ( final String key , final String def ) throws SecurityException { return ( String ) AccessController . doPrivileged ( ( PrivilegedAction ) ( ) - > System . getProperty ( key , def ) ) ; 
public void trace ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void trace ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void debug ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void info ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void warn ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void error ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public void fatal ( final Object message , final Throwable ) { } @Override public final boolean isWarnEnabled ( ) { return false ; } } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if ((useTCCLStr != null) && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Using ServiceLoader to define the LogFactory subclass to use..."); } try { final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class); final Iterator<LogFactory> iterator = serviceLoader.iterator(); int i = MAX_BROKEN_SERVICES; while (factory == null && i-- > 0) { try { if (iterator.hasNext()) { factory = iterator.next(); } } catch (final ServiceConfigurationError | LinkageError ex) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to find an" + " instance of LogFactory" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public void testServiceLoader ( ) { final LogFactory factory = LogFactory . getFactory ( ) ; assertTrue ( " Wrong factory retrieved through ServiceLoader: " + factory . getClass ( ) . getName ( ) , factory instanceof DummyLogFactory ) ; 
public Log getInstance ( Class clazz ) throws LogConfigurationException { return null ; } 
public Log getInstance ( String name ) throws LogConfigurationException { return null ; } 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute(String name, Object value);} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute(String name, Object value);} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; public abstract void setAttribute(String name, Object value);} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; public abstract void setAttribute(String name, Object value);} 
public abstract void release ( ) ; public abstract void setAttribute(String name, Object value);} 
public abstract void removeAttribute ( String name ) ; ---------------------------------------------------------------------- Static initializer block to perform initialization at class load time. We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. ---------------------------------------------------------------------- public abstract void setAttribute(String name, Object value);} 
public void debug ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void debug ( final Object message , final Throwable ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void error ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void error ( final Object message , final Throwable ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message , final Throwable ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void info ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void info ( final Object message , final Throwable ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void trace ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void write ( byte [ ] b ) { } @Override public void write ( byte [ ] b , int off , int len ) { } @Override public void write ( int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void write ( byte [ ] b , int off , int len ) { } @Override public void write ( int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void write ( int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void close ( ) { } @Override public void flush ( ) { records . clear ( ) ; } @Override public void publish ( final LogRecord record ) { records . add ( record ) ; } public Iterator records ( ) { return records . iterator ( ) ; } } 
public abstract void setUpTestAppender ( List logEvents ) throws Exception ; public void testSerializable ( ) throws Exception { final List logEvents = new ArrayList ( ) ; setUpTestAppender ( logEvents ) ; final Log log = LogFactory . getLog ( " test-category " ) ; final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( log ) ; oos . close ( ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; final ObjectInputStream ois = new ObjectInputStream ( bais ) ; final Log newLog = ( Log ) ois . readObject ( ) ; ois . close ( ) ; Check the characteristics of the resulting object logExceptionMessages(newLog); checkLoggingEvents(logEvents, true); }} 
public void debug ( final Object message ) { } @Override public void debug ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void debug ( final Object message , final Throwable ) { } @Override public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void error ( final Object message ) { } @Override public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void error ( final Object message , final Throwable ) { } @Override public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message ) { } @Override public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void fatal ( final Object message , final Throwable ) { } @Override public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void info ( final Object message ) { } @Override public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void info ( final Object message , final Throwable ) { } @Override public boolean isDebugEnabled ( ) { return false ; } @Override public boolean isErrorEnabled ( ) { return false ; } @Override public boolean isFatalEnabled ( ) { return false ; } @Override public boolean isInfoEnabled ( ) { return false ; } @Override public boolean isTraceEnabled ( ) { return false ; } @Override public boolean isWarnEnabled ( ) { return false ; } @Override public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void trace ( final Object message ) { } @Override public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void trace ( final Object message , final Throwable ) { } @Override public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
public void warn ( final Object message ) { } @Override public void warn ( final Object message , final Throwable ) { } } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( ( PrivilegedAction ) LogFactory : : directGetContextClassLoader ) ; 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Using ServiceLoader to define the LogFactory subclass to use..."); } try { final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class); final Iterator<LogFactory> iterator = serviceLoader.iterator(); int i = MAX_BROKEN_SERVICES; while (factory == null && i-- > 0) { try { if (iterator.hasNext()) { factory = iterator.next(); } } catch (final ServiceConfigurationError | LinkageError ex) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to find an" + " instance of LogFactory" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. final Object result = AccessController.doPrivileged( (PrivilegedAction) () -> createFactory(factoryClass, classLoader)); if (result instanceof LogConfigurationException) { final LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic("An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic("Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory)result; } 
public void write ( final byte [ ] b ) { } @Override public void write ( final byte [ ] b , final int off , final int len ) { } @Override public void write ( final int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void write ( final byte [ ] b , final int off , final int len ) { } @Override public void write ( final int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void write ( final int b ) { } } ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final CountDownLatch latch = new CountDownLatch ( 1 ) ; private final Thread gcThread = new Thread ( new GcTask ( ) ) ; @Override public void close ( ) { running . set ( false ) ; try { junit . framework . TestCase . assertTrue ( " GarbageCollectionHelper did not shut down cleanly " , latch . await ( 10 , TimeUnit . SECONDS ) ) ; } catch ( final InterruptedException e ) { throw new RuntimeException ( e ) ; } } @Override public void run ( ) { if ( running . compareAndSet ( false , true ) ) { gcThread . start ( ) ; } } } 
public void testNotLeakingThisClassLoader ( ) throws Exception { create an isolated loader PathableClassLoader loader = new PathableClassLoader(null); loader.addLogicalLib("commons-logging"); load the LogFactory class through this loader Class<?> logFactoryClass = loader.loadClass(LogFactory.class.getName()); reflection hacks to obtain the weak reference Field field = logFactoryClass.getDeclaredField("thisClassLoaderRef"); field.setAccessible(true); final WeakReference thisClassLoaderRef = (WeakReference) field.get(null); the ref should at this point contain the loader assertSame(loader, thisClassLoaderRef.get()); null out the hard refs field = null; logFactoryClass = null; loader.close(); loader = null; final GarbageCollectionHelper gcHelper = new GarbageCollectionHelper(); gcHelper.run(); try { final long start = System.currentTimeMillis(); 
protected void setUp ( ) throws Exception { super . setUp ( ) ; weakHashtable = new WeakHashtable ( ) ; keyOne = Long . valueOf ( 1 ) ; keyTwo = Long . valueOf ( 2 ) ; keyThree = Long . valueOf ( 3 ) ; valueOne = Long . valueOf ( 100 ) ; valueTwo = Long . valueOf ( 200 ) ; valueThree = Long . valueOf ( 300 ) ; weakHashtable . put ( keyOne , valueOne ) ; weakHashtable . put ( keyTwo , valueTwo ) ; weakHashtable . put ( keyThree , valueThree ) ; } 
public void testContains ( ) throws Exception { assertFalse ( weakHashtable . contains ( Long . valueOf ( 1 ) ) ) ; assertFalse ( weakHashtable . contains ( Long . valueOf ( 2 ) ) ) ; assertFalse ( weakHashtable . contains ( Long . valueOf ( 3 ) ) ) ; assertTrue ( weakHashtable . contains ( Long . valueOf ( 100 ) ) ) ; assertTrue ( weakHashtable . contains ( Long . valueOf ( 200 ) ) ) ; assertTrue ( weakHashtable . contains ( Long . valueOf ( 300 ) ) ) ; assertFalse ( weakHashtable . contains ( Long . valueOf ( 400 ) ) ) ; } 
public void testContainsKey ( ) throws Exception { assertTrue ( weakHashtable . containsKey ( Long . valueOf ( 1 ) ) ) ; assertTrue ( weakHashtable . containsKey ( Long . valueOf ( 2 ) ) ) ; assertTrue ( weakHashtable . containsKey ( Long . valueOf ( 3 ) ) ) ; assertFalse ( weakHashtable . containsKey ( Long . valueOf ( 100 ) ) ) ; assertFalse ( weakHashtable . containsKey ( Long . valueOf ( 200 ) ) ) ; assertFalse ( weakHashtable . containsKey ( Long . valueOf ( 300 ) ) ) ; assertFalse ( weakHashtable . containsKey ( Long . valueOf ( 400 ) ) ) ; } 
public void testContainsValue ( ) throws Exception { assertFalse ( weakHashtable . containsValue ( Long . valueOf ( 1 ) ) ) ; assertFalse ( weakHashtable . containsValue ( Long . valueOf ( 2 ) ) ) ; assertFalse ( weakHashtable . containsValue ( Long . valueOf ( 3 ) ) ) ; assertTrue ( weakHashtable . containsValue ( Long . valueOf ( 100 ) ) ) ; assertTrue ( weakHashtable . containsValue ( Long . valueOf ( 200 ) ) ) ; assertTrue ( weakHashtable . containsValue ( Long . valueOf ( 300 ) ) ) ; assertFalse ( weakHashtable . containsValue ( Long . valueOf ( 400 ) ) ) ; } 
public void testGet ( ) throws Exception { assertEquals ( valueOne , weakHashtable . get ( keyOne ) ) ; assertEquals ( valueTwo , weakHashtable . get ( keyTwo ) ) ; assertEquals ( valueThree , weakHashtable . get ( keyThree ) ) ; assertNull ( weakHashtable . get ( Long . valueOf ( 50 ) ) ) ; } 
public void testPut ( ) throws Exception { final Long anotherKey = Long . valueOf ( 2004 ) ; weakHashtable . put ( anotherKey , Long . valueOf ( 1066 ) ) ; assertEquals ( Long . valueOf ( 1066 ) , weakHashtable . get ( anotherKey ) ) ; Test compliance with the hashtable API re nulls Exception caught = null; try { weakHashtable.put(null, new Object()); } catch (final Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null key", caught); caught = null; try { weakHashtable.put(new Object(), null); } catch (final Exception e) { caught = e; } assertNotNull("did not throw an exception adding a null value", caught); } 
public void testPutAll ( ) throws Exception { final Map newValues = new HashMap ( ) ; final Long newKey = Long . valueOf ( 1066 ) ; final Long newValue = Long . valueOf ( 1415 ) ; newValues . put ( newKey , newValue ) ; final Long anotherNewKey = Long . valueOf ( 1645 ) ; final Long anotherNewValue = Long . valueOf ( 1815 ) ; newValues . put ( anotherNewKey , anotherNewValue ) ; weakHashtable . putAll ( newValues ) ; assertEquals ( 5 , weakHashtable . size ( ) ) ; assertEquals ( newValue , weakHashtable . get ( newKey ) ) ; assertEquals ( anotherNewValue , weakHashtable . get ( anotherNewKey ) ) ; } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( Long . valueOf ( 1 ) ) ) ; final ReferenceQueue testQueue = new ReferenceQueue ( ) ; final WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if (iterations++ > MAX_GC_ITERATIONS){ fail("Max iterations reached before resource released."); } if (weakHashtable.get(Long.valueOf(1)) == null) { break; } create garbage: final byte[] b = new byte[bytz]; bytz = bytz * 2; } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
private static void checkAndSetContext ( ) { final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; assertEquals ( " ContextLoader is of unexpected type " , contextLoader . getClass ( ) . getName ( ) , PathableClassLoader . class . getName ( ) ) ; final URL [ ] noUrls = { } ; Thread . currentThread ( ) . setContextClassLoader ( new URLClassLoader ( noUrls ) ) ; } 
public Log getInstance ( final Class clazz ) throws LogConfigurationException { return null ; } 
public Log getInstance ( final String name ) throws LogConfigurationException { return null ; } 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + trim(msg)); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + trim(msg)); break; } } constructor = c.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, currentCL, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the {@code setLogFactory} method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private String findUserSpecifiedLogClassName ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Trying to get log class from attribute ' " + LOG_PROPERTY + " ' " ) ; } String specifiedClass = ( String ) getAttribute ( LOG_PROPERTY ) ; if ( specifiedClass = = null ) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from attribute '" + LOG_PROPERTY_OLD + "'"); } specifiedClass = (String) getAttribute(LOG_PROPERTY_OLD); } if (specifiedClass == null) { if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY, null); } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY + "' - " + e.getMessage()); } } } if (specifiedClass == null) { @deprecated if (isDiagnosticsEnabled()) { logDiagnostic("Trying to get log class from system property '" + LOG_PROPERTY_OLD + "'"); } try { specifiedClass = getSystemProperty(LOG_PROPERTY_OLD, null); } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("No access allowed to system property '" + LOG_PROPERTY_OLD + "' - " + e.getMessage()); } } } Remove any whitespace; it's never valid in a class name so its presence just means a user mistake. As we know what they meant, we may as well strip the spaces. if (specifiedClass != null) { specifiedClass = specifiedClass.trim(); } return specifiedClass; } 
private boolean isLogLibraryAvailable ( final String name , final String className ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Checking for ' " + name + " '. " ) ; } try { final Log log = createLogFromClass ( 
public void addLogicalLib ( final String logicalLib ) { first, check the system properties final String fileName = System.getProperty(logicalLib); if (fileName != null) { try { final URL libUrl = new File(fileName).toURL(); addURL(libUrl); return; } catch (final java.net.MalformedURLException e) { throw new UnknownError( "Invalid file [" + fileName + "] for logical lib [" + logicalLib + "]"); } } now check the classpath for a similar-named lib final URL libUrl = libFromClasspath(logicalLib); if (libUrl != null) { addURL(libUrl); return; } lib not found throw new UnknownError( "Logical lib [" + logicalLib + "] is not defined" 
private URL libFromClasspath ( final String logicalLib ) { final ClassLoader cl = this . getClass ( ) . getClassLoader ( ) ; if ( ! ( cl instanceof URLClassLoader ) ) { return null ; } final URLClassLoader ucl = ( URLClassLoader ) cl ; final URL [ ] path = ucl . getURLs ( ) ; URL shortestMatch = null ; int shortestMatchLen = Integer . MAX_VALUE ; for ( final URL u : path ) { extract the file name bit on the end of the URL String fileName = u.toString(); if (!fileName.endsWith(".jar")) { not a jarfile, ignore it continue; } final int lastSlash = fileName.lastIndexOf('/'); if (lastSlash >= 0) { fileName = fileName.substring(lastSlash+1); } ok, this is a candidate if (fileName.startsWith(logicalLib) && fileName.length() < shortestMatchLen) { shortestMatch = u; shortestMatchLen = fileName.length(); } } return shortestMatch; } 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessable only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessable only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessable to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
private void handleFlawedDiscovery ( final String logAdapterClassName , final ClassLoader classLoader , USED? final Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. final InvocationTargetException ite = (InvocationTargetException)discoveryFlaw; final Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { final ExceptionInInitializerError eiie = (ExceptionInInitializerError)cause; final Throwable cause2 = eiie.getCause(); if (cause2 != null) { final StringWriter sw = new StringWriter(); cause2.printStackTrace(new PrintWriter(sw, true)); logDiagnostic("... ExceptionInInitializerError: " + sw.toString()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
private void handleFlawedDiscovery ( final String logAdapterClassName , final ClassLoader classLoader , USED? final Throwable discoveryFlaw) { if (isDiagnosticsEnabled()) { logDiagnostic("Could not instantiate Log '" + logAdapterClassName + "' -- " + discoveryFlaw.getClass().getName() + ": " + discoveryFlaw.getLocalizedMessage()); if (discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. final InvocationTargetException ite = (InvocationTargetException) discoveryFlaw; final Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { final ExceptionInInitializerError eiie = (ExceptionInInitializerError) cause; final Throwable cause2 = eiie.getCause(); if (cause2 != null) { final StringWriter sw = new StringWriter(); cause2.printStackTrace(new PrintWriter(sw, true)); logDiagnostic("... ExceptionInInitializerError: " + sw.toString()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + trim(msg)); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + trim(msg)); break; } } constructor = c.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + msg.trim()); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the {@code setLogFactory} method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
private void handleFlawedDiscovery ( final String logAdapterClassName , final Throwable discoveryFlaw ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Could not instantiate Log ' " + logAdapterClassName + " ' -- " + discoveryFlaw . getClass ( ) . getName ( ) + " : " + discoveryFlaw . getLocalizedMessage ( ) ) ; if ( discoveryFlaw instanceof InvocationTargetException ) { Ok, the lib is there but while trying to create a real underlying logger something failed in the underlying lib; display info about that if possible. final InvocationTargetException ite = (InvocationTargetException) discoveryFlaw; final Throwable cause = ite.getTargetException(); if (cause != null) { logDiagnostic("... InvocationTargetException: " + cause.getClass().getName() + ": " + cause.getLocalizedMessage()); if (cause instanceof ExceptionInInitializerError) { final ExceptionInInitializerError eiie = (ExceptionInInitializerError) cause; final Throwable cause2 = eiie.getCause(); if (cause2 != null) { final StringWriter sw = new StringWriter(); cause2.printStackTrace(new PrintWriter(sw, true)); logDiagnostic("... ExceptionInInitializerError: " + sw.toString()); } } } } } if (!allowFlawedDiscovery) { throw new LogConfigurationException(discoveryFlaw); 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialized/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { final Class logFactoryClass = loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch (final ClassNotFoundException ex) { Neither the current classloader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch (final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch (final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessible!"); loader = null; } catch (final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void testSameLogObject ( ) throws Exception { unfortunately, there just isn't any way to emulate JCL being accessible via the null classloader in "standard" systems, so we can't include this test in our standard unit tests. }} 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessible from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging-api"); final PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging"); final Class testClass = child.loadClass(CustomConfigAPITestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessible from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); parent.useExplicitLoader(HANDLER_NAME, scl); parent.addLogicalLib("commons-logging"); final PathableClassLoader child = new PathableClassLoader(parent); child.addLogicalLib("testclasses"); final Class testClass = child.loadClass(CustomConfigFullTestCase.class.getName()); return new PathableTestSuite(testClass, child); } 
public static Test suite ( ) throws Exception { final PathableClassLoader cl = new PathableClassLoader ( null ) ; cl . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; the TestHandler class must be accessible from the System classloader in order for java.util.logging.LogManager.readConfiguration to be able to instantiate it. And this test case must see the same class in order to be able to access its data. Yes this is ugly but the whole jdk14 API is a ******* mess anyway. final ClassLoader scl = ClassLoader.getSystemClassLoader(); loadTestHandler(HANDLER_NAME, scl); cl.useExplicitLoader(HANDLER_NAME, scl); cl.addLogicalLib("commons-logging"); cl.addLogicalLib("testclasses"); final Class testClass = cl.loadClass(CustomConfigTestCase.class.getName()); return new PathableTestSuite(testClass, cl); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessible due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are child-first we should see the child one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-adapters-1.") > 0); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertNotEquals("System classloader has unexpected type", PathableClassLoader.class.getName(), systemLoader.getClass().getName()); junit classes should be visible; their classloader is not in the hierarchy of parent classloaders for this class, though it is accessible due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the classloaders are parent-first we should see the parent one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf("/commons-logging-1.") > 0); 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute(String name, Object value);} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute(String name, Object value);} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; public abstract void setAttribute(String name, Object value);} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; public abstract void setAttribute(String name, Object value);} 
public abstract void release ( ) ; public abstract void setAttribute(String name, Object value);} 
public abstract void removeAttribute ( String name ) ; ---------------------------------------------------------------------- Static initializer block to perform initialization at class load time. We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. ---------------------------------------------------------------------- public abstract void setAttribute(String name, Object value);} 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system classloader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context classloader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Using ServiceLoader to define the LogFactory subclass to use..."); } try { final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class); final Iterator<LogFactory> iterator = serviceLoader.iterator(); int i = MAX_BROKEN_SERVICES; while (factory == null && i-- > 0) { try { if (iterator.hasNext()) { factory = iterator.next(); } } catch (final ServiceConfigurationError | LinkageError ex) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to find an" + " instance of LogFactory" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } Fourth, try one of the 3 provided factories try { We prefer Log4j API, since it does not stringify objects. if (factory == null && isClassAvailable(LOG4J_API_LOGGER, baseClassLoader)) { If the Log4j API is redirected to SLF4J, we use SLF4J directly. if (isClassAvailable(LOG4J_TO_SLF4J_BRIDGE, baseClassLoader)) { logDiagnostic( "[LOOKUP] Log4j API to SLF4J redirection detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } else { logDiagnostic("[LOOKUP] Log4j API detected. Loading the Log4j API LogFactory implementation '" + FACTORY_LOG4J_API + "'."); factory = newFactory(FACTORY_LOG4J_API, baseClassLoader, contextClassLoader); } } if (factory == null && isClassAvailable(SLF4J_API_LOGGER, baseClassLoader)) { logDiagnostic("[LOOKUP] SLF4J detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } } catch (final Exception e) { logDiagnostic("[LOOKUP] An exception occurred while creating LogFactory: " + e.getMessage()); } if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
private static boolean isClassAvailable ( final String className , final ClassLoader classLoader ) { final ClassLoader loader = LogFactory . class . getClassLoader ( ) ; logDiagnostic ( " Checking if class ' " + className + " ' is available in class loader " + objectId ( loader ) ) ; try { Class . forName ( className , true , classLoader ) ; return true ; } catch ( final ClassNotFoundException | LinkageError e ) { logDiagnostic ( " Failed to load class ' " + className + " ' from class loader " + objectId ( loader ) + " : " + e . getMessage ( ) ) ; } return false ; } 
protected Log newLogger ( final String name , final LoggerContext context ) { return new Log4j2Log ( context . getLogger ( name ) ) ; } 
public boolean isDebugEnabled ( ) { return isEnabled ( Level . DEBUG ) ; } 
public boolean isErrorEnabled ( ) { return isEnabled ( Level . ERROR ) ; } 
public boolean isFatalEnabled ( ) { return isEnabled ( Level . FATAL ) ; } 
public boolean isInfoEnabled ( ) { return isEnabled ( Level . INFO ) ; } 
public boolean isTraceEnabled ( ) { return isEnabled ( Level . TRACE ) ; } 
public boolean isWarnEnabled ( ) { return isEnabled ( Level . WARN ) ; } 
public void trace ( final Object message ) { logIfEnabled ( Level . TRACE , message , null ) ; } 
public void trace ( final Object message , final Throwable ) { logIfEnabled ( Level . TRACE , message , ) ; } 
public void debug ( final Object message ) { logIfEnabled ( Level . DEBUG , message , null ) ; } 
public void debug ( final Object message , final Throwable ) { logIfEnabled ( Level . DEBUG , message , ) ; } 
public void info ( final Object message ) { logIfEnabled ( Level . INFO , message , null ) ; } 
public void info ( final Object message , final Throwable ) { logIfEnabled ( Level . INFO , message , ) ; } 
public void warn ( final Object message ) { logIfEnabled ( Level . WARN , message , null ) ; } 
public void warn ( final Object message , final Throwable ) { logIfEnabled ( Level . WARN , message , ) ; } 
public void error ( final Object message ) { logIfEnabled ( Level . ERROR , message , null ) ; } 
public void error ( final Object message , final Throwable ) { logIfEnabled ( Level . ERROR , message , ) ; } 
public void fatal ( final Object message ) { logIfEnabled ( Level . FATAL , message , null ) ; } 
public void fatal ( final Object message , final Throwable ) { logIfEnabled ( Level . FATAL , message , ) ; } 
private boolean isEnabled ( final Level level ) { return logger . isEnabled ( level , MARKER , null ) ; } 
private void logIfEnabled ( final Level level , final Object message , final Throwable ) { if ( message instanceof CharSequence ) { logger . logIfEnabled ( FQCN , level , MARKER , ( CharSequence ) message , ) ; 
public void release ( ) { final ILoggerFactory factory = LoggerFactory . getILoggerFactory ( ) ; try { factory . getClass ( ) . getMethod ( " stop " ) . invoke ( factory ) ; 
public void debug ( Object message ) { logger . debug ( MARKER , String . valueOf ( message ) ) ; } 
public void debug ( Object message , Throwable ) { logger . debug ( MARKER , String . valueOf ( message ) , ) ; } 
public void error ( Object message ) { logger . error ( MARKER , String . valueOf ( message ) ) ; } 
public void error ( Object message , Throwable ) { logger . debug ( MARKER , String . valueOf ( message ) , ) ; } 
public void fatal ( Object message , Throwable ) { error ( message , ) ; } 
public void info ( Object message ) { logger . info ( MARKER , String . valueOf ( message ) ) ; } 
public void info ( Object message , Throwable ) { logger . info ( MARKER , String . valueOf ( message ) , ) ; } 
public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( MARKER ) ; } 
public boolean isErrorEnabled ( ) { return logger . isErrorEnabled ( MARKER ) ; } 
public boolean isFatalEnabled ( ) { return isErrorEnabled ( ) ; } 
public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( MARKER ) ; } 
public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( MARKER ) ; } 
public boolean isWarnEnabled ( ) { return logger . isWarnEnabled ( MARKER ) ; } 
public void trace ( Object message ) { logger . trace ( MARKER , String . valueOf ( message ) ) ; } 
public void trace ( Object message , Throwable ) { logger . trace ( MARKER , String . valueOf ( message ) , ) ; } 
public void warn ( Object message ) { logger . warn ( MARKER , String . valueOf ( message ) ) ; } 
public void warn ( Object message , Throwable ) { logger . warn ( MARKER , String . valueOf ( message ) , ) ; } 
public void debug ( Object message ) { log ( DEBUG_INT , message , null ) ; } 
public void debug ( Object message , Throwable ) { log ( DEBUG_INT , message , ) ; } 
public void error ( Object message ) { log ( ERROR_INT , message , null ) ; } 
public void error ( Object message , Throwable ) { log ( ERROR_INT , message , ) ; } 
public void info ( Object message ) { log ( INFO_INT , message , null ) ; } 
public void info ( Object message , Throwable ) { log ( INFO_INT , message , ) ; } 
public void trace ( Object message ) { log ( TRACE_INT , message , null ) ; } 
public void trace ( Object message , Throwable ) { log ( TRACE_INT , message , ) ; } 
public void warn ( Object message ) { log ( WARN_INT , message , null ) ; } 
public void warn ( Object message , Throwable ) { log ( WARN_INT , message , ) ; } 
private void log ( final int level , final Object message , final Throwable ) { logger . log ( MARKER , FQCN , level , String . valueOf ( message ) , EMPTY_OBJECT_ARRAY , ) ; } 
public void testFactoryClassName ( ) { assertEquals ( Log4jApiLogFactory . class , factory . getClass ( ) ) ; } 
public void testLocationInfo ( ) { appender . clear ( ) ; The following value must match the line number final int currentLineNumber = 65; log.fatal(OBJ); log.fatal(OBJ, T); log.error(OBJ); log.error(OBJ, T); log.warn(OBJ); log.warn(OBJ, T); log.info(OBJ); log.info(OBJ, T); log.debug(OBJ); log.debug(OBJ, T); log.trace(OBJ); log.trace(OBJ, T); final ObjectMessage expectedMessage = new ObjectMessage(OBJ); final List<LogEvent> events = appender.getEvents(); assertEquals("All events received.", levels.length * 2, events.size()); for (int lev = 0; lev < levels.length; lev++) { for (int hasThrowable = 0; hasThrowable <= 1; hasThrowable++) { 
public void testMessageType ( ) { appender . clear ( ) ; log . info ( OBJ ) ; log . info ( STRING ) ; final List < LogEvent > events = appender . getEvents ( ) ; assertEquals ( " Correct number of messages. " , 2 , events . size ( ) ) ; assertEquals ( " Correct message type. " , new ObjectMessage ( OBJ ) , events . get ( 0 ) . getMessage ( ) ) ; assertEquals ( " Correct message type. " , new SimpleMessage ( STRING ) , events . get ( 1 ) . getMessage ( ) ) ; } 
public FilterReply decide ( ILoggingEvent event ) { Force the registration of caller data event.getCallerData(); return FilterReply.NEUTRAL; } 
public void testFactoryClassName ( ) { assertEquals ( Slf4jLogFactory . class , factory . getClass ( ) ) ; } 
public void testLocationInfo ( ) { appender . list . clear ( ) ; The following value must match the line number final int currentLineNumber = 77; log.fatal(STRING); log.fatal(STRING, T); log.error(STRING); log.error(STRING, T); log.warn(STRING); log.warn(STRING, T); log.info(STRING); log.info(STRING, T); log.debug(STRING); log.debug(STRING, T); log.trace(STRING); log.trace(STRING, T); final List<ILoggingEvent> events = new ArrayList<>(appender.list); assertEquals("All events received.", levels.length * 2, events.size()); for (int lev = 0; lev < levels.length; lev++) { for (int hasThrowable = 0; hasThrowable <= 1; hasThrowable++) { 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute(String name, Object value);} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute(String name, Object value);} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; public abstract void setAttribute(String name, Object value);} 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class c; try { c = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + trim(msg)); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. c = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + trim(msg)); break; } } constructor = c.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = c; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, c); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + trim(msg)); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + trim(msg)); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the {@code setLogFactory} method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch (final InvocationTargetException ex) { final Throwable targetException = ex.getTargetException(); LogConfigurationException is expected; the boot classloader doesn't *have* JCL available if (!(targetException instanceof LogConfigurationException)) { throw ex; } } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
public void addLogicalLib ( final String logicalLib ) { first, check the system properties final String fileName = System.getProperty(logicalLib); if (fileName != null) { try { final File file = new File(fileName); if (!file.exists()) { Assert.fail("Unable to add logical library " + fileName); } final URL libUrl = file.toURL(); addURL(libUrl); return; } catch (final java.net.MalformedURLException e) { throw new UnknownError( "Invalid file [" + fileName + "] for logical lib [" + logicalLib + "]"); } } now check the classpath for a similar-named lib final URL libUrl = libFromClasspath(logicalLib); if (libUrl != null) { addURL(libUrl); return; } lib not found throw new UnknownError( "Logical lib [" + logicalLib + "] is not defined" 
public static Test suite ( ) throws Exception { final Class thisClass = ChildFirstTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath final PathableClassLoader parent = new PathableClassLoader(null); parent.setParentFirst(false); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); parent.useExplicitLoader("org.junit.", thisClassLoader); Make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); Create a child classloader to load the test case through final PathableClassLoader child = new PathableClassLoader(parent); child.setParentFirst(false); Obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); Create a third classloader to be the context classloader. final PathableClassLoader context = new PathableClassLoader(child); context.setParentFirst(false); reload this class via the child classloader final Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both classloaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf(Artifacts.getAdaptersJarName()) > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); final ClassLoader childLoader = contextLoader.getParent(); final ClassLoader parentLoader = childLoader.getParent(); final ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (child-resource, parent-resource). IMPORTANT: due to the fact that in java 1.4 and earlier method ClassLoader.getResources is final it isn't possible for PathableClassLoader to override this. So even when child-first is enabled the resource order is still (parent-resources, child-resources). This test verifies the expected behavior - even though it's not the desired behavior. resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no guarantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order final String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf(Artifacts.getAdaptersJarName()) > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf(Artifacts.getMainJarName()) > 0); 
public static Test suite ( ) throws Exception { final Class thisClass = ParentFirstTestCase . class ; final ClassLoader thisClassLoader = thisClass . getClassLoader ( ) ; Make the parent a direct child of the bootloader to hide all other classes in the system classpath final PathableClassLoader parent = new PathableClassLoader(null); Make the junit classes visible as a special case, as junit won't be able to call this class at all without this. The junit classes must be visible from the classloader that loaded this class, so use that as the source for future access to classes from the junit package. parent.useExplicitLoader("junit.", thisClassLoader); parent.useExplicitLoader("org.junit.", thisClassLoader); make the commons-logging.jar classes visible via the parent parent.addLogicalLib("commons-logging"); create a child classloader to load the test case through final PathableClassLoader child = new PathableClassLoader(parent); obviously, the child classloader needs to have the test classes in its path! child.addLogicalLib("testclasses"); child.addLogicalLib("commons-logging-adapters"); create a third classloader to be the context classloader. final PathableClassLoader context = new PathableClassLoader(child); reload this class via the child classloader final Class testClass = child.loadClass(thisClass.getName()); and return our custom TestSuite class return new PathableTestSuite(testClass, context); } 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both classloaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf(Artifacts.getMainJarName()) > 0); 
public void testResources ( ) throws Exception { Enumeration resources ; URL [ ] urls ; verify the classloader hierarchy final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); final ClassLoader childLoader = contextLoader.getParent(); final ClassLoader parentLoader = childLoader.getParent(); final ClassLoader bootLoader = parentLoader.getParent(); assertNull("Unexpected classloader hierarchy", bootLoader); getResources where no instances exist resources = childLoader.getResources("nosuchfile"); urls = toURLArray(resources); assertEquals("Non-null URL returned for invalid resource name", 0, urls.length); getResources where the resource only exists in the parent resources = childLoader.getResources("org/apache/commons/logging/Log.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log.class resources found", 1, urls.length); getResources where the resource only exists in the child resources = childLoader.getResources("org/apache/commons/logging/PathableTestSuite.class"); urls = toURLArray(resources); assertEquals("Unexpected number of PathableTestSuite.class resources found", 1, urls.length); getResources where the resource exists in both. resources should be returned in order (parent-resource, child-resource) resources = childLoader.getResources("org/apache/commons/logging/impl/Log4JLogger.class"); urls = toURLArray(resources); assertEquals("Unexpected number of Log4JLogger.class resources found", 2, urls.length); There is no gaurantee about the ordering of results returned from getResources To make this test portable across JVMs, sort the string to give them a known order final String[] urlsToStrings = new String[2]; urlsToStrings[0] = urls[0].toString(); urlsToStrings[1] = urls[1].toString(); Arrays.sort(urlsToStrings); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[0].indexOf(Artifacts.getAdaptersJarName()) > 0); assertTrue("Incorrect source for Log4JLogger class", urlsToStrings[1].indexOf(Artifacts.getMainJarName()) > 0); 
public static Test suite ( ) throws Exception { final PathableClassLoader parent = new PathableClassLoader ( null ) ; parent . useExplicitLoader ( " junit. " , Test . class . getClassLoader ( ) ) ; parent . useExplicitLoader ( " org.junit. " , Test . class . getClassLoader ( ) ) ; parent . addLogicalLib ( " commons-logging " ) ; parent . addLogicalLib ( " testclasses " ) ; final Class testClass = parent . loadClass ( " org.apache.commons.logging.security.SecurityForbiddenTestCase " ) ; return new PathableTestSuite ( testClass , parent ) ; } 
public void testLocationInfo ( ) { appender . clear ( ) ; The following value must match the line number final int currentLineNumber = 66; log.fatal(OBJ); log.fatal(OBJ, T); log.error(OBJ); log.error(OBJ, T); log.warn(OBJ); log.warn(OBJ, T); log.info(OBJ); log.info(OBJ, T); log.debug(OBJ); log.debug(OBJ, T); log.trace(OBJ); log.trace(OBJ, T); final ObjectMessage expectedMessage = new ObjectMessage(OBJ); final List<LogEvent> events = appender.getEvents(); assertEquals("All events received.", levels.length * 2, events.size()); for (int lev = 0; lev < levels.length; lev++) { for (int hasThrowable = 0; hasThrowable <= 1; hasThrowable++) { 
public void testLocationInfo ( ) { appender . list . clear ( ) ; The following value must match the line number final int currentLineNumber = 78; log.fatal(STRING); log.fatal(STRING, T); log.error(STRING); log.error(STRING, T); log.warn(STRING); log.warn(STRING, T); log.info(STRING); log.info(STRING, T); log.debug(STRING); log.debug(STRING, T); log.trace(STRING); log.trace(STRING, T); final List<ILoggingEvent> events = new ArrayList<>(appender.list); assertEquals("All events received.", levels.length * 2, events.size()); for (int lev = 0; lev < levels.length; lev++) { for (int hasThrowable = 0; hasThrowable <= 1; hasThrowable++) { 
private static Hashtable createFactoryStore ( ) { Hashtable result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.getConstructor().newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable(); } return result; } 
private static void logDiagnostic ( final String msg ) { if ( DIAGNOSTICS_STREAM ! = null ) { DIAGNOSTICS_STREAM . print ( diagnosticPrefix ) ; 
protected static ClassLoader directGetContextClassLoader ( ) throws LogConfigurationException { ClassLoader classLoader = null ; try { classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( final SecurityException ignore ) { getContextClassLoader() throws SecurityException when the context class loader isn't an ancestor of the calling class's class loader, or if security permissions are restricted. We ignore this exception to be consistent with the previous behavior (e.g. 1.1.3 and earlier). ignore } Return the selected class loader return classLoader; } 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract Log getInstance ( Class clazz ) throws LogConfigurationException ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void release ( ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void removeAttribute ( String name ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
protected void log ( final int type , final Object message , final Throwable ) { Use a string buffer for better performance final StringBuilder buf = new StringBuilder(); Append date-time if so configured if (showDateTime) { final Date now = new Date(); String dateText; synchronized(dateFormatter) { dateText = dateFormatter.format(now); } buf.append(dateText); buf.append(" "); } Append a readable representation of the log level switch(type) { case SimpleLog.LOG_LEVEL_TRACE: buf.append("[TRACE] "); break; case SimpleLog.LOG_LEVEL_DEBUG: buf.append("[DEBUG] "); break; case SimpleLog.LOG_LEVEL_INFO: buf.append("[INFO] "); break; case SimpleLog.LOG_LEVEL_WARN: buf.append("[WARN] "); break; case SimpleLog.LOG_LEVEL_ERROR: buf.append("[ERROR] "); break; case SimpleLog.LOG_LEVEL_FATAL: buf.append("[FATAL] "); break; } Append the name of the log instance if so configured if (showShortName) { if (shortLogName == null) { Cut all but the last component of the name for both styles final String slName = logName.substring(logName.lastIndexOf(".") + 1); shortLogName = slName.substring(slName.lastIndexOf("/") + 1); } buf.append(String.valueOf(shortLogName)).append(" - "); } else if (showLogName) { buf.append(String.valueOf(logName)).append(" - "); } Append the message buf.append(String.valueOf(message)); Append stack trace if not null if (t != null) { buf.append(" <"); buf.append(t.toString()); buf.append(">"); final StringWriter sw = new StringWriter(1024); try (PrintWriter pw = new PrintWriter(sw)) { t.printStackTrace(pw); } buf.append(sw.toString()); } Print to the appropriate destination write(buf); } 
private static String getSystemProperty ( final String key , final String def ) throws SecurityException { return AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) - > System . getProperty ( key , def ) ) ; } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) LogFactory : : directGetContextClassLoader ) ; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system class loader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context class loader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Using ServiceLoader to define the LogFactory subclass to use..."); } try { final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class); final Iterator<LogFactory> iterator = serviceLoader.iterator(); int i = MAX_BROKEN_SERVICES; while (factory == null && i-- > 0) { try { if (iterator.hasNext()) { factory = iterator.next(); } } catch (final ServiceConfigurationError | LinkageError ex) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to find an" + " instance of LogFactory" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } Fourth, try one of the 3 provided factories try { We prefer Log4j API, since it does not stringify objects. if (factory == null && isClassAvailable(LOG4J_API_LOGGER, baseClassLoader)) { If the Log4j API is redirected to SLF4J, we use SLF4J directly. if (isClassAvailable(LOG4J_TO_SLF4J_BRIDGE, baseClassLoader)) { logDiagnostic( "[LOOKUP] Log4j API to SLF4J redirection detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } else { logDiagnostic("[LOOKUP] Log4j API detected. Loading the Log4j API LogFactory implementation '" + FACTORY_LOG4J_API + "'."); factory = newFactory(FACTORY_LOG4J_API, baseClassLoader, contextClassLoader); } } if (factory == null && isClassAvailable(SLF4J_API_LOGGER, baseClassLoader)) { logDiagnostic("[LOOKUP] SLF4J detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } } catch (final Exception e) { logDiagnostic("[LOOKUP] An exception occurred while creating LogFactory: " + e.getMessage()); } if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { final String name = (String) names.nextElement(); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
public static LogFactory getFactory ( ) throws LogConfigurationException { Identify the class loader we will be using final ClassLoader contextClassLoader = getContextClassLoaderInternal(); This is an odd enough situation to report about. This output will be a nuisance on JDK1.1, as the system class loader is null in that environment. if (contextClassLoader == null && isDiagnosticsEnabled()) { logDiagnostic("Context classloader is null."); } Return any previously registered factory for this class loader LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] LogFactory implementation requested for the first time for context classloader " + objectId(contextClassLoader)); logHierarchy("[LOOKUP] ", contextClassLoader); } Load properties file. If the properties file exists, then its contents are used as "attributes" on the LogFactory implementation class. One particular property may also control which LogFactory concrete subclass is used, but only if other discovery mechanisms fail.. As the properties file (if it exists) will be used one way or another in the end we may as well look for it first. final Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); Determine whether we will be using the thread context class loader to load logging classes or not by checking the loaded properties file (if any). ClassLoader baseClassLoader = contextClassLoader; if (props != null) { final String useTCCLStr = props.getProperty(TCCL_KEY); The Boolean.valueOf(useTCCLStr).booleanValue() formulation is required for Java 1.2 compatibility. if (useTCCLStr != null && !Boolean.parseBoolean(useTCCLStr)) { Don't use current context class loader when locating any LogFactory or Log classes, just use the class that loaded this abstract class. When this class is deployed in a shared classpath of a container, it means webapps cannot deploy their own logging implementations. It also means that it is up to the implementation whether to load library-specific config files from the TCCL or not. baseClassLoader = thisClassLoaderRef.get(); } } Determine which concrete LogFactory subclass to use. First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY + "] to define the LogFactory subclass to use..."); } try { final String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass + "' as specified by system property " + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined."); } } catch (final SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "]. Trying alternative implementations..."); } ignore } catch (final RuntimeException e) { This is not consistent with the behavior when a bad LogFactory class is specified in a services file. One possible exception that can occur here is a ClassCastException when the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(e.getMessage()) + "] as specified by a system property."); } throw e; } Second, try to find a service by using the JDK1.3 class discovery mechanism, which involves putting a file with the name of an interface class in the META-INF/services directory, where the contents of the file is a single line specifying a concrete class that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Using ServiceLoader to define the LogFactory subclass to use..."); } try { final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class); final Iterator<LogFactory> iterator = serviceLoader.iterator(); int i = MAX_BROKEN_SERVICES; while (factory == null && i-- > 0) { try { if (iterator.hasNext()) { factory = iterator.next(); } } catch (final ServiceConfigurationError | LinkageError ex) { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] An exception occurred while trying to find an" + " instance of LogFactory" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } } } } catch (final Exception ex) { note: if the specified LogFactory class wasn't compatible with LogFactory for some reason, a ClassCastException will be caught here, and attempts will continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] A security exception occurred while trying to create an" + " instance of the custom factory class" + ": [" + trim(ex.getMessage()) + "]. Trying alternative implementations..."); } ignore } } Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY + "' to define the LogFactory subclass to use..."); } final String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass."); } } } else if (isDiagnosticsEnabled()) { logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from.."); } } Fourth, try one of the 3 provided factories try { We prefer Log4j API, since it does not stringify objects. if (factory == null && isClassAvailable(LOG4J_API_LOGGER, baseClassLoader)) { If the Log4j API is redirected to SLF4J, we use SLF4J directly. if (isClassAvailable(LOG4J_TO_SLF4J_BRIDGE, baseClassLoader)) { logDiagnostic( "[LOOKUP] Log4j API to SLF4J redirection detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } else { logDiagnostic("[LOOKUP] Log4j API detected. Loading the Log4j API LogFactory implementation '" + FACTORY_LOG4J_API + "'."); factory = newFactory(FACTORY_LOG4J_API, baseClassLoader, contextClassLoader); } } if (factory == null && isClassAvailable(SLF4J_API_LOGGER, baseClassLoader)) { logDiagnostic("[LOOKUP] SLF4J detected. Loading the SLF4J LogFactory implementation '" + FACTORY_SLF4J + "'."); factory = newFactory(FACTORY_SLF4J, baseClassLoader, contextClassLoader); } } catch (final Exception e) { logDiagnostic("[LOOKUP] An exception occurred while creating LogFactory: " + e.getMessage()); } if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT + "' via the same classloader that loaded this LogFactory" + " class (ie not looking in the context classloader)."); } Note: unlike the above code which can try to load custom LogFactory implementations via the TCCL, we don't try to load the default LogFactory implementation via the context classloader because: / cacheFactory(contextClassLoader, factory); if (props != null) { final Enumeration<?> names = props.propertyNames(); while (names.hasMoreElements()) { final String name = Objects.toString(names.nextElement(), null); final String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } 
protected static Object createFactory ( final String factoryClassName , final ClassLoader classLoader ) { This will be used to diagnose bad configurations and allow a useful message to be sent to the user Class logFactoryClass = null; try { if (classLoader != null) { 
static public void setLogImplementation ( final String className ) throws LinkageError , SecurityException { try { final Class logclass = Class . forName ( className ) ; 
static public void setLogImplementation ( final String className ) throws LinkageError , SecurityException { try { final Class logClass = Class . forName ( className ) ; 
static public void setLogImplementation ( final Class logClass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { final Class [ ] argTypes = new Class [ 1 ] ; argTypes [ 0 ] = " " . getClass ( ) ; logImplctor = logClass . getConstructor ( argTypes ) ; } 
static public void setLogImplementation ( final Class < ? > logClass ) throws LinkageError , ExceptionInInitializerError , NoSuchMethodException , SecurityException { final Class < ? > [ ] argTypes = new Class [ 1 ] ; argTypes [ 0 ] = " " . getClass ( ) ; logImplctor = logClass . getConstructor ( argTypes ) ; } 
static public void setLogImplementation ( final String className ) throws LinkageError , SecurityException { try { final Class < ? > logClass = Class . forName ( className ) ; 
private static Hashtable < ClassLoader , LogFactory > createFactoryStore ( ) { Hashtable < ClassLoader , LogFactory > result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class implementationClass = Class.forName(storeImplementationClass); result = (Hashtable) implementationClass.getConstructor().newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable<>(); } return result; } 
public static void release ( final ClassLoader classLoader ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for classloader " + objectId ( classLoader ) ) ; } factories is not final and could be replaced in this block. final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories; synchronized (factories) { if (classLoader == null) { 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all classloaders. " ) ; } factories is not final and could be replaced in this block. final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories; synchronized (factories) { final Enumeration<LogFactory> elements = factories.elements(); 
private static Hashtable < ClassLoader , LogFactory > createFactoryStore ( ) { Hashtable < ClassLoader , LogFactory > result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class<Hashtable<ClassLoader, LogFactory>> implementationClass = (Class<Hashtable<ClassLoader, LogFactory>>) Class .forName(storeImplementationClass); result = implementationClass.getConstructor().newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom hashtable failed"); } } } if (result == null) { result = new Hashtable<>(); } return result; } 
public static Log getLog ( final Class < ? > clazz ) throws LogConfigurationException { return getFactory ( ) . getInstance ( clazz ) ; } 
private static void logClassLoaderEnvironment ( final Class < ? > clazz ) { if ( ! isDiagnosticsEnabled ( ) ) { return ; } try { Deliberately use System.getProperty here instead of getSystemProperty; if the overall security policy for the calling application forbids access to these variables then we do not want to output them to the diagnostic stream. logDiagnostic("[ENV] Extension directories (java.ext.dir): " + System.getProperty("java.ext.dir")); logDiagnostic("[ENV] Application classpath (java.class.path): " + System.getProperty("java.class.path")); } catch (final SecurityException ex) { logDiagnostic("[ENV] Security setting prevent interrogation of system classpaths."); } final String className = clazz.getName(); ClassLoader classLoader; try { classLoader = getClassLoader(clazz); } catch (final SecurityException ex) { not much useful diagnostics we can print here! logDiagnostic("[ENV] Security forbids determining the classloader for " + className); return; } logDiagnostic("[ENV] Class " + className + " was loaded via classloader " + objectId(classLoader)); logHierarchy("[ENV] Ancestry of classloader which loaded " + className + " is ", classLoader); } 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract Log getInstance ( Class < ? > clazz ) throws LogConfigurationException ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different classloaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
protected static LogFactory newFactory ( final String factoryClass , final ClassLoader classLoader , final ClassLoader contextClassLoader ) throws LogConfigurationException { Note that any unchecked exceptions thrown by the createFactory method will propagate out of this method; in particular a ClassCastException can be thrown. final Object result = AccessController.doPrivileged( (PrivilegedAction) () -> createFactory(factoryClass, classLoader)); if (result instanceof LogConfigurationException) { final LogConfigurationException ex = (LogConfigurationException) result; if (isDiagnosticsEnabled()) { logDiagnostic("An error occurred while loading the factory class:" + ex.getMessage()); } throw ex; } if (isDiagnosticsEnabled()) { logDiagnostic("Created object " + objectId(result) + " to manage classloader " + objectId(contextClassLoader)); } return (LogFactory) result; } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return ( ClassLoader ) AccessController . doPrivileged ( ( PrivilegedAction ) LogFactory : : directGetContextClassLoader ) ; 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch (final InvocationTargetException ex) { final Throwable targetException = ex.getTargetException(); LogConfigurationException is expected; the boot classloader doesn't *have* JCL available if (!(targetException instanceof LogConfigurationException)) { throw ex; } } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
public void executeIsEnabledTest ( final Log log ) { try { log . isTraceEnabled ( ) ; 
public void executeMessageWithExceptionTest ( final Log log ) { try { log . trace ( " Hello, Mum " , new ArithmeticException ( ) ) ; 
public void executeMessageWithoutExceptionTest ( final Log log ) { try { log . trace ( " Hello, Mum " ) ; 
public void testIsEnabledClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeIsEnabledTest ( log ) ; } 
public void testIsEnabledNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeIsEnabledTest ( log ) ; } 
public void testMessageWithExceptionClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithExceptionTest ( log ) ; } 
public void testMessageWithExceptionNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithExceptionTest ( log ) ; } 
public void testMessageWithoutExceptionClassLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testMessageWithoutExceptionNamedLog ( ) { final Log log = LogFactory . getLog ( BasicOperationsTestCase . class . getName ( ) ) ; executeMessageWithoutExceptionTest ( log ) ; } 
public void testInContainer ( ) throws Exception { problem can be in this step (broken app container or missconfiguration) 1. Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); 2. Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader()); we expect this : 1. Thread.currentThread().setContextClassLoader(appLoader); 2. Thread.currentThread().setContextClassLoader(null); Context classloader is same as class calling into log Class cls = reload(); Thread.currentThread().setContextClassLoader(cls.getClassLoader()); execute(cls); Context classloader is the "bootclassloader". This is technically bad, but LogFactoryImpl.ALLOW_FLAWED_CONTEXT defaults to true so this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(null); execute(cls); Context classloader is the "bootclassloader". This is same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(null); try { setAllowFlawedContext(cls, "false"); execute(cls); fail("Logging config succeeded when context classloader was null!"); } catch (final InvocationTargetException ex) { final Throwable targetException = ex.getTargetException(); LogConfigurationException is expected; the boot classloader doesn't *have* JCL available if (!(targetException instanceof LogConfigurationException)) { throw ex; } } Context classloader is the system classloader. This is expected to cause problems, as LogFactoryImpl will attempt to use the system classloader to load the Log4JLogger class, which will then be unable to cast that object to the Log interface loaded via the child classloader. However as ALLOW_FLAWED_CONTEXT defaults to true this test should pass. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); execute(cls); Context classloader is the system classloader. This is the same as above except that ALLOW_FLAWED_CONTEXT is set to false; an error should now be reported. cls = reload(); Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader()); try { setAllowFlawedContext(cls, "false"); 
private ArrayList toList ( final Enumeration en ) { final ArrayList results = new ArrayList ( ) ; if ( en ! = null ) { while ( en . hasMoreElements ( ) ) { final Object element = en . nextElement ( ) ; results . add ( element ) ; } } return results ; } 
public void xxxIgnoretestRelease ( ) throws Exception { assertNotNull ( weakHashtable . get ( Long . valueOf ( 1 ) ) ) ; final ReferenceQueue testQueue = new ReferenceQueue ( ) ; final WeakReference weakKeyOne = new WeakReference ( keyOne , testQueue ) ; lose our references keyOne = null; keyTwo = null; keyThree = null; valueOne = null; valueTwo = null; valueThree = null; int iterations = 0; int bytz = 2; while(true) { System.gc(); if (iterations++ > MAX_GC_ITERATIONS) { fail("Max iterations reached before resource released."); } if (weakHashtable.get(Long.valueOf(1)) == null) { break; } create garbage: final byte[] b = new byte[bytz]; bytz = bytz * 2; } some JVMs seem to take a little time to put references on the reference queue once the reference has been collected need to think about whether this is enough to justify stepping through the collection each time... while(testQueue.poll() == null) {} Test that the released objects are not taking space in the table assertEquals("underlying table not emptied", 0, weakHashtable.size()); } 
private static ClassLoader getContextClassLoaderInternal ( ) throws LogConfigurationException { return AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) LogFactory : : directGetContextClassLoader ) ; } 
public Log getInstance ( final String name ) throws LogConfigurationException { return instances . computeIfAbsent ( name , this : : newInstance ) ; } 
public Log getInstance ( final Class < ? > clazz ) throws LogConfigurationException { return getInstance ( clazz . getName ( ) ) ; } 
private static Hashtable < ClassLoader , LogFactory > createFactoryStore ( ) { Hashtable < ClassLoader , LogFactory > result = null ; String storeImplementationClass ; try { storeImplementationClass = getSystemProperty ( HASHTABLE_IMPLEMENTATION_PROPERTY , null ) ; } catch ( final SecurityException ex ) { Permissions don't allow this to be accessed. Default to the "modern" weak hashtable implementation if it is available. storeImplementationClass = null; } if (storeImplementationClass == null) { storeImplementationClass = WEAK_HASHTABLE_CLASSNAME; } try { final Class<Hashtable<ClassLoader, LogFactory>> implementationClass = (Class<Hashtable<ClassLoader, LogFactory>>) Class .forName(storeImplementationClass); result = implementationClass.getConstructor().newInstance(); } catch (final Throwable t) { handleThrowable(t); may re-throw t ignore if (!WEAK_HASHTABLE_CLASSNAME.equals(storeImplementationClass)) { if the user's trying to set up a custom implementation, give a clue if (isDiagnosticsEnabled()) { use internal logging to issue the warning logDiagnostic("[ERROR] LogFactory: Load of custom Hashtable failed"); } else { we *really* want this output, even if diagnostics weren't explicitly enabled by the user. System.err.println("[ERROR] LogFactory: Load of custom Hashtable failed"); } } } if (result == null) { result = new Hashtable<>(); } return result; } 
private static boolean implementsLogFactory ( final Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { final ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; final Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClass . getName ( ) + " does not implement LogFactory. " ) ; } } } catch ( final SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the classloaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by the class loader which loaded " + "the custom LogFactory implementation. Is the custom factory in the right class loader?"); } } return implementsLogFactory; } 
private static boolean implementsLogFactory ( final Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { final ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; final Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; final String logFactoryClassName = logFactoryClass . getName ( ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClassName + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClassName + " does not implement LogFactory. " ) ; } } } catch ( final SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the classloaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by the class loader which loaded " + "the custom LogFactory implementation. Is the custom factory in the right class loader?"); } } return implementsLogFactory; } 
public void debug ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void debug ( final Object message , final Throwable ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void error ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void error ( final Object message , final Throwable ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void fatal ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void fatal ( final Object message , final Throwable ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void info ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void info ( final Object message , final Throwable ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void trace ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void trace ( final Object message , final Throwable ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void warn ( final Object message ) { no-op } @Override public void warn(final Object message, final Throwable t) { no-op }} 
public void warn ( final Object message , final Throwable ) { no-op }} 
private Log createLogFromClass ( final String logAdapterClassName , final String logCategory , final boolean affectState ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Attempting to instantiate ' " + logAdapterClassName + " ' " ) ; } final Object [ ] params = { logCategory } ; Log logAdapter = null ; Constructor constructor = null ; Class logAdapterClass = null ; ClassLoader currentCL = getBaseClassLoader ( ) ; for ( ; ; ) { Loop through the classloader hierarchy trying to find a viable classloader. logDiagnostic("Trying to load '" + logAdapterClassName + "' from classloader " + objectId(currentCL)); try { if (isDiagnosticsEnabled()) { Show the location of the first occurrence of the .class file in the classpath. This is the location that ClassLoader.loadClass will load the class from -- unless the classloader is doing something weird. URL url; final String resourceName = logAdapterClassName.replace('.', '/') + ".class"; if (currentCL != null) { url = currentCL.getResource(resourceName ); } else { url = ClassLoader.getSystemResource(resourceName + ".class"); } if (url == null) { logDiagnostic("Class '" + logAdapterClassName + "' [" + resourceName + "] cannot be found."); } else { logDiagnostic("Class '" + logAdapterClassName + "' was found at '" + url + "'"); } } Class clazz; try { clazz = Class.forName(logAdapterClassName, true, currentCL); } catch (final ClassNotFoundException originalClassNotFoundException) { The current classloader was unable to find the log adapter in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. String msg = originalClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via classloader " + objectId(currentCL) + ": " + trim(msg)); try { Try the class classloader. This may work in cases where the TCCL does not contain the code executed or JCL. This behavior indicates that the application classloading strategy is not consistent with the Java 1.2 classloading guidelines but JCL can and so should handle this case. clazz = Class.forName(logAdapterClassName); } catch (final ClassNotFoundException secondaryClassNotFoundException) { no point continuing: this adapter isn't available msg = secondaryClassNotFoundException.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is not available via the LogFactoryImpl class classloader: " + trim(msg)); break; } } constructor = clazz.getConstructor(logConstructorSignature); final Object o = constructor.newInstance(params); Note that we do this test after trying to create an instance [rather than testing Log.class.isAssignableFrom(c)] so that we don't complain about Log hierarchy problems when the adapter couldn't be instantiated anyway. if (o instanceof Log) { logAdapterClass = clazz; logAdapter = (Log) o; break; } Oops, we have a potential problem here. An adapter class has been found and its underlying lib is present too, but there are multiple Log interface classes available making it impossible to cast to the type the caller wanted. We certainly can't use this logger, but we need to know whether to keep on discovering or terminate now. The handleFlawedHierarchy method will throw LogConfigurationException if it regards this problem as fatal, and just return if not. handleFlawedHierarchy(currentCL, clazz); } catch (final NoClassDefFoundError e) { We were able to load the adapter but it had references to other classes that could not be found. This simply means that the underlying logger library is not present in this or any ancestor classloader. There's no point in trying higher up in the hierarchy in this case.. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is missing dependencies when loaded via classloader " + objectId(currentCL) + ": " + trim(msg)); break; } catch (final ExceptionInInitializerError e) { A static initializer block or the initializer code associated with a static variable on the log adapter class has thrown an exception. We treat this as meaning the adapter's underlying logging library could not be found. final String msg = e.getMessage(); logDiagnostic("The log adapter '" + logAdapterClassName + "' is unable to initialize itself when loaded via classloader " + objectId(currentCL) + ": " + trim(msg)); break; } catch (final LogConfigurationException e) { call to handleFlawedHierarchy above must have thrown a LogConfigurationException, so just throw it on throw e; } catch (final Throwable t) { handleThrowable(t); may re-throw t handleFlawedDiscovery will determine whether this is a fatal problem or not. If it is fatal, then a LogConfigurationException will be thrown. handleFlawedDiscovery(logAdapterClassName, t); } if (currentCL == null) { break; } try the parent classloader currentCL = currentCL.getParent(); currentCL = getParentClassLoader(currentCL); } if (logAdapterClass != null && affectState) { We've succeeded, so set instance fields this.logClassName = logAdapterClassName; this.logConstructor = constructor; Identify the {@code setLogFactory} method (if there is one) try { this.logMethod = logAdapterClass.getMethod("setLogFactory", logMethodSignature); logDiagnostic("Found method setLogFactory(LogFactory) in '" + logAdapterClassName + "'"); } catch (final Throwable t) { handleThrowable(t); may re-throw t this.logMethod = null; logDiagnostic("[INFO] '" + logAdapterClassName + "' from classloader " + objectId(currentCL) + " does not declare optional method " + "setLogFactory(LogFactory)"); } logDiagnostic("Log adapter '" + logAdapterClassName + "' from classloader " + objectId(logAdapterClass.getClassLoader()) + " has been selected for use."); } return logAdapter; } 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of classloaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialized/configured once. These references from ancestor LogFactory classes down to TCCL classloaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { @SuppressWarnings("unchecked") final Class<LogFactory> logFactoryClass = (Class<LogFactory>) loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch (final ClassNotFoundException ex) { Neither the current class loader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch (final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch (final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessible!"); loader = null; } catch (final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
private static boolean implementsLogFactory ( final Class logFactoryClass ) { boolean implementsLogFactory = false ; if ( logFactoryClass ! = null ) { try { final ClassLoader logFactoryClassLoader = logFactoryClass . getClassLoader ( ) ; if ( logFactoryClassLoader = = null ) { logDiagnostic ( " [CUSTOM LOG FACTORY] was loaded by the boot classloader " ) ; } else { logHierarchy ( " [CUSTOM LOG FACTORY] " , logFactoryClassLoader ) ; final Class factoryFromCustomLoader = Class . forName ( " org.apache.commons.logging.LogFactory " , false , logFactoryClassLoader ) ; implementsLogFactory = factoryFromCustomLoader . isAssignableFrom ( logFactoryClass ) ; final String logFactoryClassName = logFactoryClass . getName ( ) ; if ( implementsLogFactory ) { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClassName + " implements LogFactory but was loaded by an incompatible classloader. " ) ; } else { logDiagnostic ( " [CUSTOM LOG FACTORY] " + logFactoryClassName + " does not implement LogFactory. " ) ; } } } catch ( final SecurityException e ) { The application is running within a hostile security environment. This will make it very hard to diagnose issues with JCL. Consider running less securely whilst debugging this issue. logDiagnostic("[CUSTOM LOG FACTORY] SecurityException caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final LinkageError e) { This should be an unusual circumstance. LinkageError's usually indicate that a dependent class has incompatibly changed. Another possibility may be an exception thrown by an initializer. Time for a clean rebuild? logDiagnostic("[CUSTOM LOG FACTORY] LinkageError caught trying to determine whether " + "the compatibility was caused by a class loader conflict: " + e.getMessage()); } catch (final ClassNotFoundException e) { LogFactory cannot be loaded by the classloader which loaded the custom factory implementation. The custom implementation is not viable until this is corrected. Ensure that the JCL jar and the custom class are available from the same classloader. Running with diagnostics on should give information about the class loaders used to load the custom factory. logDiagnostic("[CUSTOM LOG FACTORY] LogFactory class cannot be loaded by the class loader which loaded " + "the custom LogFactory implementation. Is the custom factory in the right class loader?"); } } return implementsLogFactory; } 
public static void releaseAll ( ) { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Releasing factory for all class loaders. " ) ; } factories is not final and could be replaced in this block. final Hashtable<ClassLoader, LogFactory> factories = LogFactory.factories; synchronized (factories) { final Enumeration<LogFactory> elements = factories.elements(); 
public abstract Object getAttribute ( String name ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract String [ ] getAttributeNames ( ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract Log getInstance ( Class < ? > clazz ) throws LogConfigurationException ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract Log getInstance ( String name ) throws LogConfigurationException ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void release ( ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void removeAttribute ( String name ) ; public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
public abstract void setAttribute ( String name , Object value ) ; We can't do this in the class constructor, as there are many static methods on this class that can be called before any LogFactory instances are created, and they depend upon this stuff having been set up. Note that this block must come after any variable declarations used by any methods called from this block, as we want any static initializer associated with the variable to run first. If static initializers for variables run after this code, then (a) their value might be needed by methods called from here, and (b) they might *override* any value computed here! So the wisest thing to do is just to place this code at the very end of the class file. static { note: it's safe to call methods before initDiagnostics (though diagnostic output gets discarded). final ClassLoader thisClassLoader = getClassLoader(LogFactory.class); thisClassLoaderRef = new WeakReference<>(thisClassLoader); In order to avoid confusion where multiple instances of JCL are being used via different class loaders within the same app, we ensure each logged message has a prefix of form [LogFactory from classloader OID] Note that this prefix should be kept consistent with that in LogFactoryImpl. However here we don't need to output info about the actual *instance* of LogFactory, as all methods that output diagnostics from this class are static. String classLoaderName; try { if (thisClassLoader == null) { classLoaderName = "BOOTLOADER"; } else { classLoaderName = objectId(thisClassLoader); } } catch (final SecurityException e) { classLoaderName = "UNKNOWN"; } diagnosticPrefix = "[LogFactory from " + classLoaderName + "] "; DIAGNOSTICS_STREAM = initDiagnostics(); logClassLoaderEnvironment(LogFactory.class); factories = createFactoryStore(); if (isDiagnosticsEnabled()) { logDiagnostic("BOOTSTRAP COMPLETED"); } }} 
private Log discoverLogImplementation ( final String logCategory ) throws LogConfigurationException { if ( isDiagnosticsEnabled ( ) ) { logDiagnostic ( " Discovering a Log implementation... " ) ; } initConfiguration ( ) ; Log result = null ; See if the user specified the Log implementation to use final String specifiedLogClassName = findUserSpecifiedLogClassName(); if (specifiedLogClassName != null) { if (isDiagnosticsEnabled()) { logDiagnostic("Attempting to load user-specified log class '" + specifiedLogClassName + "'..."); } result = createLogFromClass(specifiedLogClassName, logCategory, true); if (result == null) { final StringBuilder messageBuffer = new StringBuilder("User-specified log class '"); messageBuffer.append(specifiedLogClassName); messageBuffer.append("' cannot be found or is not useable."); Mistyping or misspelling names is a common fault. Construct a good error message, if we can informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LOG4J_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_JDK14_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_LUMBERJACK_LOGGER); informUponSimilarName(messageBuffer, specifiedLogClassName, LOGGING_IMPL_SIMPLE_LOGGER); throw new LogConfigurationException(messageBuffer.toString()); } return result; } No user specified log; try to discover what's on the classpath Note that we deliberately loop here over classesToDiscover and expect method createLogFromClass to loop over the possible source class loaders. The effect is: for each discoverable log adapter for each possible classloader see if it works It appears reasonable at first glance to do the opposite: for each possible classloader for each discoverable log adapter see if it works The latter certainly has advantages for user-installable logging libraries such as log4j; in a webapp for example this code should first check whether the user has provided any of the possible logging libraries before looking in the parent classloader. Unfortunately, however, Jdk14Logger will always work in jvm>=1.4, and SimpleLog will always work in any JVM. So the loop would never ever look for logging libraries in the parent classpath. Yet many users would expect that putting log4j there would cause it to be detected (and this is the historical JCL behavior). So we go with the first approach. A user that has bundled a specific logging lib in a webapp should use a commons-logging.properties file or a service file in META-INF to force use of that logging lib anyway, rather than relying on discovery. if (isDiagnosticsEnabled()) { logDiagnostic( "No user-specified Log implementation; performing discovery" + " using the standard supported logging implementations..."); } for(int i=0; i<classesToDiscover.length && result == null; ++i) { result = createLogFromClass(classesToDiscover[i], logCategory, true); } if (result == null) { throw new LogConfigurationException ("No suitable Log implementation"); } return result; } 
private ClassLoader getBaseClassLoader ( ) throws LogConfigurationException { final ClassLoader thisClassLoader = getClassLoader ( LogFactoryImpl . class ) ; if ( ! useTCCL ) { return thisClassLoader ; } final ClassLoader contextClassLoader = getContextClassLoaderInternal ( ) ; final ClassLoader baseClassLoader = getLowestClassLoader ( contextClassLoader , thisClassLoader ) ; if ( baseClassLoader = = null ) { The two class loaders are not part of a parent child relationship. In some classloading setups (e.g. JBoss with its UnifiedLoaderRepository) this can still work, so if user hasn't forbidden it, just return the contextClassLoader. if (!allowFlawedContext) { throw new LogConfigurationException("Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } if (isDiagnosticsEnabled()) { logDiagnostic("[WARNING] the context classloader is not part of a" + " parent-child relationship with the classloader that" + " loaded LogFactoryImpl."); } If contextClassLoader were null, getLowestClassLoader() would have returned thisClassLoader. The fact we are here means contextClassLoader is not null, so we can just return it. return contextClassLoader; } if (baseClassLoader != contextClassLoader) { We really should just use the contextClassLoader as the starting point for scanning for log adapter classes. However it is expected that there are a number of broken systems out there which create custom class loaders but fail to set the context classloader so we handle those flawed systems anyway. if (!allowFlawedContext) { throw new LogConfigurationException( "Bad classloader hierarchy; LogFactoryImpl was loaded via" + " a classloader that is not related to the current context" + " classloader."); } if (isDiagnosticsEnabled()) { logDiagnostic( "Warning: the context classloader is an ancestor of the" + " classloader that loaded LogFactoryImpl; it should be" + " the same or a descendant. The application using" + " commons-logging should ensure the context classloader" + " is used correctly."); } } return baseClassLoader; } 
public void contextDestroyed ( final ServletContextEvent sce ) { final ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; final Object [ ] params = new Object [ 1 ] ; params [ 0 ] = tccl ; Walk up the tree of class loaders, finding all the available LogFactory classes and releasing any objects associated with the tccl (ie the webapp). When there is only one LogFactory in the classpath, and it is within the webapp being undeployed then there is no problem; garbage collection works fine. When there are multiple LogFactory classes in the classpath but parent-first classloading is used everywhere, this loop is really short. The first instance of LogFactory found will be the highest in the classpath, and then no more will be found. This is ok, as with this setup this will be the only LogFactory holding any data associated with the tccl being released. When there are multiple LogFactory classes in the classpath and child-first classloading is used in any classloader, then multiple LogFactory instances may hold info about this TCCL; whenever the webapp makes a call into a class loaded via an ancestor classloader and that class calls LogFactory the tccl gets registered in the LogFactory instance that is visible from the ancestor classloader. However the concrete logging library it points to is expected to have been loaded via the TCCL, so the underlying logging lib is only initialized/configured once. These references from ancestor LogFactory classes down to TCCL class loaders are held via weak references and so should be released but there are circumstances where they may not. Walking up the classloader ancestry ladder releasing the current tccl at each level tree, though, will definitely clear any problem references. ClassLoader loader = tccl; while (loader != null) { Load via the current loader. Note that if the class is not accessible via this loader, but is accessible via some ancestor then that class will be returned. try { @SuppressWarnings("unchecked") final Class<LogFactory> logFactoryClass = (Class<LogFactory>) loader.loadClass("org.apache.commons.logging.LogFactory"); final Method releaseMethod = logFactoryClass.getMethod("release", RELEASE_SIGNATURE); releaseMethod.invoke(null, params); loader = logFactoryClass.getClassLoader().getParent(); } catch (final ClassNotFoundException ex) { Neither the current class loader nor any of its ancestors could find the LogFactory class, so we can stop now. loader = null; } catch (final NoSuchMethodException ex) { This is not expected; every version of JCL has this method System.err.println("LogFactory instance found which does not support release method!"); loader = null; } catch (final IllegalAccessException ex) { This is not expected; every ancestor class should be accessible System.err.println("LogFactory instance found which is not accessible!"); loader = null; } catch (final InvocationTargetException ex) { This is not expected System.err.println("LogFactory instance release method failed!"); loader = null; } } Just to be sure, invoke release on the LogFactory that is visible from this ServletContextCleaner class too. This should already have been caught by the above loop but just in case... LogFactory.release(tccl); } 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertFalse("System classloader has unexpected type", PathableClassLoader.class.getName().equals( systemLoader.getClass().getName())); junit classes should be visible; their classloader is not in the hierarchy of parent class loaders for this class, though it is accessible due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the class loaders are child-first we should see the child one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via child", log4jClass.getClassLoader(), thisLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both class loaders. The one visible to the child should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-adapters-nnnn.jar, not commons-logging-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf(Artifacts.getAdaptersJarName()) > 0); 
public void testPaths ( ) throws Exception { the context classloader is not expected to be null final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); assertNotNull("Context classloader is null", contextLoader); assertEquals("Context classloader has unexpected type", PathableClassLoader.class.getName(), contextLoader.getClass().getName()); the classloader that loaded this class is obviously not null final ClassLoader thisLoader = this.getClass().getClassLoader(); assertNotNull("thisLoader is null", thisLoader); assertEquals("thisLoader has unexpected type", PathableClassLoader.class.getName(), thisLoader.getClass().getName()); the suite method specified that the context classloader's parent is the loader that loaded this test case. assertSame("Context classloader is not child of thisLoader", thisLoader, contextLoader.getParent()); thisLoader's parent should be available final ClassLoader parentLoader = thisLoader.getParent(); assertNotNull("Parent classloader is null", parentLoader); assertEquals("Parent classloader has unexpected type", PathableClassLoader.class.getName(), parentLoader.getClass().getName()); parent should have a parent of null assertNull("Parent classloader has non-null parent", parentLoader.getParent()); getSystemClassloader is not a PathableClassLoader; it's of a built-in type. This also verifies that system classloader is none of (context, child, parent). final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); assertNotNull("System classloader is null", systemLoader); assertNotEquals("System classloader has unexpected type", PathableClassLoader.class.getName(), systemLoader.getClass().getName()); junit classes should be visible; their classloader is not in the hierarchy of parent class loaders for this class, though it is accessible due to trickery in the PathableClassLoader. final Class junitTest = contextLoader.loadClass("junit.framework.Test"); final Set ancestorCLs = getAncestorCLs(); assertFalse("Junit not loaded by ancestor classloader", ancestorCLs.contains(junitTest.getClassLoader())); jcl api classes should be visible only via the parent final Class logClass = contextLoader.loadClass("org.apache.commons.logging.Log"); assertSame("Log class not loaded via parent", logClass.getClassLoader(), parentLoader); jcl adapter classes should be visible via both parent and child. However as the class loaders are parent-first we should see the parent one. final Class log4jClass = contextLoader.loadClass("org.apache.commons.logging.impl.Log4JLogger"); assertSame("Log4JLogger not loaded via parent", log4jClass.getClassLoader(), parentLoader); test classes should be visible via the child only final Class testClass = contextLoader.loadClass("org.apache.commons.logging.PathableTestSuite"); assertSame("PathableTestSuite not loaded via child", testClass.getClassLoader(), thisLoader); test loading of class that is not available try { final Class noSuchClass = contextLoader.loadClass("no.such.class"); fail("Class no.such.class is unexpectedly available"); assertNotNull(noSuchClass); silence warning about unused var } catch (final ClassNotFoundException ex) { ok } String class classloader is null final Class stringClass = contextLoader.loadClass("java.lang.String"); assertNull("String class classloader is not null!", stringClass.getClassLoader()); 
public void testResource ( ) { URL resource ; final ClassLoader contextLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final ClassLoader childLoader = contextLoader . getParent ( ) ; getResource where it doesn't exist resource = childLoader.getResource("nosuchfile"); assertNull("Non-null URL returned for invalid resource name", resource); getResource where it is accessible only to parent classloader resource = childLoader.getResource("org/apache/commons/logging/Log.class"); assertNotNull("Unable to locate Log.class resource", resource); getResource where it is accessible only to child classloader resource = childLoader.getResource("org/apache/commons/logging/PathableTestSuite.class"); assertNotNull("Unable to locate PathableTestSuite.class resource", resource); getResource where it is accessible to both class loaders. The one visible to the parent should be returned. The URL returned will be of form jar:file:/x/y.jar!path/to/resource. The file name part should include the jarname of form commons-logging-nnnn.jar, not commons-logging-adapters-nnnn.jar resource = childLoader.getResource("org/apache/commons/logging/impl/Log4JLogger.class"); assertNotNull("Unable to locate Log4JLogger.class resource", resource); assertTrue("Incorrect source for Log4JLogger class", resource.toString().indexOf(Artifacts.getMainJarName()) > 0); 
