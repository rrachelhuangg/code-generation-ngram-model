public void setupBenchmark ( ) { thashes = new GeoHash [ NUMBER_OF_HASHES ] ; tlatitudes = new double [ NUMBER_OF_HASHES ] ; tlongitudes = new double [ NUMBER_OF_HASHES ] ; tRandom rand = new Random ( ) ; tfor ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { tlatitudes [ i ] = rand . nextDouble ( ) * 180 - 90 ; 
public void benchmarkGeoHashEncoding ( ) { tfor ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { thashes [ i ] = GeoHash . withBitPrecision ( latitudes [ i ] , longitudes [ i ] , 60 ) ; 
public static GeoHash withCharacterPrecision ( double latitude , tdouble longitude , int numberOfCharacters ) { tint desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; treturn new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , tint numberOfBits ) { treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { treturn null ; } 
public int significantBits ( ) { treturn ( int ) significantBits ; } 
public String toBase32 ( ) { tStringBuffer buf = new StringBuffer ( ) ; tlong firstFiveBitsMask = 0xf800000000000000l ; tlong bitsCopy = bits ; tint partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; tfor ( int i = 0 ; i < partialChunks ; i + + ) { tint pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; tbuf . append ( base32 [ pointer ] ) ; tbitsCopy < < = 5 ; } treturn buf . toString ( ) ; } 
public boolean within ( GeoHash boundingBox ) { treturn ( bits & boundingBox . mask ( ) ) = = boundingBox . bits ; } 
public String toString ( ) { treturn String . format ( " %s -> (%d,%d) " , longToBitString ( bits ) , 0 , 0 ) ; } 
public final long mask ( ) { if ( significantBits = = 0 ) { treturn 0 ; 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { if ( ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { thash . addOnBitToEnd ( ) ; } else { thash . addOffBitToEnd ( ) ; } tlatBits [ 0 ] < < = 1 ; } else { if ( ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { thash . addOnBitToEnd ( ) ; } else { thash . addOffBitToEnd ( ) ; } tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( 64 - hash . significantBits ) ; treturn hash ; } 
private long maskLastNBits ( long value , long ) { tlong mask = 0xffffffffffffffffl ; tmask > > > = ( 64 - ) ; treturn value & mask ; } 
protected final void addOnBitToEnd ( ) { significantBits + + ; tbits < < = 1 ; tbits = bits | 0x1 ; } 
protected final void addOffBitToEnd ( ) { significantBits + + ; tbits < < = 1 ; } 
protected static String longToBitString ( long value ) { tStringBuffer buf = new StringBuffer ( ) ; tfor ( int i = 64 ; i > 0 ; i - - ) { tlong bit = value & FIRST_BIT_FLAGGED ; if ( bit = = FIRST_BIT_FLAGGED ) { tbuf . append ( '1' ) ; } else { tbuf . append ( '0' ) ; } tvalue < < = 1 ; } treturn buf . toString ( ) ; } 
private void highCapDesiredPrecision ( int desiredPrecision ) { if ( desiredPrecision > 64 ) tdesiredPrecision = 64 ; 
public String toString ( ) { treturn String . format ( " (%f,%f) " , latitude , longitude ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof WGS84Point ) { tWGS84Point other = ( WGS84Point ) obj ; treturn latitude = = other . latitude & & longitude = = other . longitude ; } treturn false ; } 
public void testAddingOnes ( ) { thash . addOnBitToEnd ( ) ; tAssert . assertEquals ( 0x1l , hash . bits ) ; tAssert . assertEquals ( 1 , hash . significantBits ( ) ) ; thash . addOnBitToEnd ( ) ; thash . addOnBitToEnd ( ) ; thash . addOnBitToEnd ( ) ; tAssert . assertEquals ( 0xfl , hash . bits ) ; tAssert . assertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void testAddingZeroes ( ) { thash . addOnBitToEnd ( ) ; tAssert . assertEquals ( 0x1l , hash . bits ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; tAssert . assertEquals ( 0x10l , hash . bits ) ; tAssert . assertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void testLongToBitString ( ) { thash . bits = 0x5555555555555555l ; tAssert . assertEquals ( 
public void testToBase32 ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tString base32 = hash . toBase32 ( ) ; tAssert . assertEquals ( " ezs42 " , base32 ) ; } 
public void testWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tSystem . out . println ( hash ) ; tSystem . out . println ( hash . toBase32 ( ) ) ; tAssert . assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6ff0000000000000l ; tbbox . significantBits = 12 ; tAssert . assertTrue ( hash . toBase32 ( ) + " should be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; 
public void testNotWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tAssert . assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6fc0000000000000l ; tbbox . significantBits = 12 ; tAssert . assertFalse ( hash . toBase32 ( ) + " should NOT be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; 
public void testConstructorWithBitPrecision ( ) { tGeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; tAssert . assertEquals ( hash1 . significantBits , 20 ) ; tSystem . out . println ( hash1 ) ; tSystem . out . println ( hash1 . toBase32 ( ) ) ; tGeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; tAssert . assertEquals ( hash2 . significantBits , 55 ) ; tSystem . out . println ( hash2 ) ; tSystem . out . println ( hash2 . toBase32 ( ) ) ; tAssert . assertTrue ( hash2 . within ( hash1 ) ) ; } 
public void testLatLonBoundingBoxes ( ) { thash = GeoHash . withBitPrecision ( 40 , 120 , 10 ) ; tSystem . out . println ( hash . toBase32 ( ) ) ; tprintBoundingBox ( hash ) ; } 
public void testByCharacterPrecision ( ) { thash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; tAssert . assertEquals ( " sew1c2vs2q5r " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; tAssert . assertEquals ( " ksqn1rje83g2 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , t12 ) ; tAssert . assertEquals ( " ksq9zbs0b7vw " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 12 ) ; tAssert . assertEquals ( " hf7u8p8gn747 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 8 ) ; tAssert . assertEquals ( " hf7u8p8g " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 4 ) ; tAssert . assertEquals ( " hf7u " , hash . toBase32 ( ) ) ; } 
public void testGetLatitudeBits ( ) { thash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; tlong [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; tAssert . assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; tAssert . assertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void testGetLongitudeBits ( ) { thash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; tlong [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; tAssert . assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; tAssert . assertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
private void printBoundingBox ( GeoHash hash ) { tSystem . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; tSystem . out . print ( " corners= " ) ; tSystem . out . println ( String . format ( " %s,%s " , hash . getBoundingBoxPoints ( ) [ 0 ] , 
public void testVincenty ( ) { tWGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; tint distanceInMeters = 10000 ; tWGS84Point result = WGS84Point . moveInDirection ( startPoint , 120 , tdistanceInMeters ) ; tAssert . assertEquals ( 40.10134882 , result . longitude , DELTA ) ; tAssert . assertEquals ( 39.9549245 , result . latitude , DELTA ) ; tAssert . assertEquals ( distanceInMeters , WGS84Point . distanceInMeters ( tstartPoint , result ) , DELTA ) ; tWGS84Point p1 = new WGS84Point ( 1 , 1 ) ; tint tenThousandKilometers = 10000000 ; tWGS84Point p2 = WGS84Point . moveInDirection ( p1 , 270 , tenThousandKilometers ) ; tSystem . out . println ( p2 ) ; tAssert . assertEquals ( tenThousandKilometers , WGS84Point . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public String toString ( ) { treturn String . format ( " %s -> [%s,%s] " , longToBitString ( bits ) , boundingBox [ 0 ] , boundingBox [ 1 ] ) ; } 
public void testAddingOnes ( ) { thash . addOnBitToEnd ( ) ; tassertEquals ( 0x1l , hash . bits ) ; tassertEquals ( 1 , hash . significantBits ( ) ) ; thash . addOnBitToEnd ( ) ; thash . addOnBitToEnd ( ) ; thash . addOnBitToEnd ( ) ; tassertEquals ( 0xfl , hash . bits ) ; tassertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void testAddingZeroes ( ) { thash . addOnBitToEnd ( ) ; tassertEquals ( 0x1l , hash . bits ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; thash . addOffBitToEnd ( ) ; tassertEquals ( 0x10l , hash . bits ) ; tassertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void testLongToBitString ( ) { thash . bits = 0x5555555555555555l ; tassertEquals ( " 0101010101010101010101010101010101010101010101010101010101010101 " , 
public void testToBase32 ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tString base32 = hash . toBase32 ( ) ; tassertEquals ( " ezs42 " , base32 ) ; } 
public void testWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tSystem . out . println ( hash . toBase32 ( ) ) ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6ff0000000000000l ; tbbox . significantBits = 12 ; tassertTrue ( hash . toBase32 ( ) + " should be within " + bbox . toBase32 ( ) , thash . within ( bbox ) ) ; 
public void testNotWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6fc0000000000000l ; tbbox . significantBits = 12 ; tassertFalse ( hash . toBase32 ( ) + " should NOT be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; 
public void testConstructorWithBitPrecision ( ) { tGeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; tassertEquals ( hash1 . significantBits , 20 ) ; tSystem . out . println ( hash1 ) ; tSystem . out . println ( hash1 . toBase32 ( ) ) ; tGeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; tassertEquals ( hash2 . significantBits , 55 ) ; tSystem . out . println ( hash2 ) ; tSystem . out . println ( hash2 . toBase32 ( ) ) ; tassertTrue ( hash2 . within ( hash1 ) ) ; } 
public void testByCharacterPrecision ( ) { thash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; tassertEquals ( " sew1c2vs2q5r " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; tassertEquals ( " ksqn1rje83g2 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , t12 ) ; tassertEquals ( " ksq9zbs0b7vw " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 12 ) ; tassertEquals ( " hf7u8p8gn747 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 8 ) ; tassertEquals ( " hf7u8p8g " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , t39 .0247389581054 , 4 ) ; tassertEquals ( " hf7u " , hash . toBase32 ( ) ) ; } 
public void testGetLatitudeBits ( ) { thash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; tlong [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; tassertEquals ( 0xaal , latitudeBits [ 0 ] ) ; tassertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void testGetLongitudeBits ( ) { thash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; tlong [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; tassertEquals ( 0x95l , longitudeBits [ 0 ] ) ; tassertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
public void testNeighbourLocationCode ( ) { } 
public void testIssue1 ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tString base32 = hash . toBase32 ( ) ; tSystem . out . println ( base32 ) ; tassertEquals ( " dr4jb0bn2180 " , base32 ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] points = decode ( geohash ) ; treturn GeoHash . withCharacterPrecision ( points [ 0 ] , points [ 1 ] , geohash . length ( ) ) ; } 
public static double [ ] decode ( String geohash ) { tdouble [ ] lat_interval = { - 90.0 , 90.0 } ; tdouble [ ] lon_interval = { - 180.0 , 180.0 } ; tdouble lat_err = 90.0 ; tdouble lon_err = 180.0 ; tboolean is_even = true ; tint sz = geohash . length ( ) ; tint [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; tint bsz = bits . length ; tdouble latitude , longitude ; tfor ( int i = 0 ; i < sz ; i + + ) { tint cd = _decodemap . get ( geohash . charAt ( i ) ) ; tfor ( int z = 0 ; z < bsz ; z + + ) { tint mask = bits [ z ] ; if ( is_even ) { tlon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { tlon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { tlat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { tlat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } tis_even = is_even ? false : true ; } } tlatitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; tlongitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; treturn new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public static double [ ] decode ( String geohash ) { tdouble [ ] lat_interval = { - 90.0 , 90.0 } ; tdouble [ ] lon_interval = { - 180.0 , 180.0 } ; tdouble lat_err = 90.0 ; tdouble lon_err = 180.0 ; tboolean is_even = true ; tint sz = geohash . length ( ) ; tint [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; tint bsz = bits . length ; tdouble latitude , longitude ; tfor ( int i = 0 ; i < sz ; i + + ) { tint cd = _decodemap . get ( geohash . charAt ( i ) ) ; tfor ( int z = 0 ; z < bsz ; z + + ) { tint mask = bits [ z ] ; if ( is_even ) { tlon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { tlon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { tlat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { tlat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } tis_even = ! is_even ; } } tlatitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; tlongitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; treturn new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public void testDecode ( ) { 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += 1) { 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { tint desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; treturn new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] lat_interval = { - 90.0 , 90.0 } ; tdouble [ ] lon_interval = { - 180.0 , 180.0 } ; tdouble lat_err = 90.0 ; tdouble lon_err = 180.0 ; tboolean is_even = true ; tint sz = geohash . length ( ) ; tint [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; tint bsz = bits . length ; tdouble latitude , longitude ; tfor ( int i = 0 ; i < sz ; i + + ) { tint cd = _decodemap . get ( geohash . charAt ( i ) ) ; tfor ( int z = 0 ; z < bsz ; z + + ) { tint mask = bits [ z ] ; if ( is_even ) { tlon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { tlon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { tlat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { tlat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } tis_even = ! is_even ; } } tlatitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; tlongitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; tdouble [ ] points = new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public void setup ( ) { } @Benchmark public void benchmarkRandomEncoding ( ) { } } 
public void setup ( ) { trandomHashes = new String [ NUMBER_OF_HASHES ] ; tRandom rand = new Random ( ) ; tfor ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { at least two chars 
public void benchmarkRandomDecoding ( ) { tfor ( String hash : randomHashes ) { tGeoHash geoHash = GeoHash . fromGeohashString ( hash ) ; 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] lat_interval = { - 90.0 , 90.0 } ; tdouble [ ] lon_interval = { - 180.0 , 180.0 } ; tdouble lat_err = 90.0 ; tdouble lon_err = 180.0 ; tboolean is_even = true ; tint sz = geohash . length ( ) ; tint [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; tint bsz = bits . length ; tdouble latitude , longitude ; tfor ( int i = 0 ; i < sz ; i + + ) { tint cd = _decodemap . get ( geohash . charAt ( i ) ) ; tfor ( int z = 0 ; z < bsz ; z + + ) { tint mask = bits [ z ] ; if ( is_even ) { tlon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { tlon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { tlat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { tlat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { tlat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } tis_even = ! is_even ; } } tlatitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; tlongitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; tdouble [ ] points = new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public String toString ( ) { treturn String . format ( " %s -> %s " , longToBitString ( bits ) , boundingBox ! = null ? boundingBox : " null " ) ; } 
public boolean equals ( Object obj ) { if ( obj = = this ) { treturn true ; } if ( obj instanceof GeoHash ) { tGeoHash other = ( GeoHash ) obj ; if ( other . significantBits = = significantBits & & other . bits = = bits ) { treturn true ; } } treturn false ; } 
public void testLongToBitString ( ) { thash . bits = 0x5555555555555555l ; tassertEquals ( " 0101010101010101010101010101010101010101010101010101010101010101 " , GeoHash . longToBitString ( hash . bits ) ) ; 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += 1) { 
public void testWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tSystem . out . println ( hash . toBase32 ( ) ) ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6ff0000000000000l ; tbbox . significantBits = 12 ; tassertTrue ( hash . toBase32 ( ) + " should be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; } 
public void testNotWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6fc0000000000000l ; tbbox . significantBits = 12 ; tassertFalse ( hash . toBase32 ( ) + " should NOT be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; } 
public void testByCharacterPrecision ( ) { thash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; tassertEquals ( " sew1c2vs2q5r " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; tassertEquals ( " ksqn1rje83g2 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; tassertEquals ( " ksq9zbs0b7vw " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; tassertEquals ( " hf7u8p8gn747 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; tassertEquals ( " hf7u8p8g " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; tassertEquals ( " hf7u " , hash . toBase32 ( ) ) ; } 
public void testEquals ( ) { tGeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; tassertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; tassertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; } 
public void testMoveAroundWorldOnLongitudeStrip ( ) { tfor ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the longitude range by 2^bits 
public void testIssue1 ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tString base32 = hash . toBase32 ( ) ; tSystem . out . println ( base32 ) ; tassertEquals ( " dr4jb0bn2180 " , base32 ) ; } 
private void printBoundingBox ( GeoHash hash ) { tSystem . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; tSystem . out . print ( " corners= " ) ; tSystem . out . println ( String . format ( " %s,%s " , hash . getBoundingBoxPoints ( ) [ 0 ] , hash . getBoundingBoxPoints ( ) [ 1 ] ) ) ; } 
public void testMovingAroundWorldOnHashStrips ( ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { tString [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; tfor ( String direction : directions ) { tcheckMoveAroundStrip ( direction ) ; 
public void checkMoveAroundStrip ( String direction ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { tfor ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.5) { 
public void testMovingAroundWorldOnHashStrips ( ) throws SecurityException , NoSuchMethodException , tIllegalArgumentException , IllegalAccessException , InvocationTargetException { tString [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; tfor ( String direction : directions ) { tcheckMoveAroundStrip ( direction ) ; 
public void checkMoveAroundStrip ( String direction ) throws SecurityException , NoSuchMethodException , tIllegalArgumentException , IllegalAccessException , InvocationTargetException { tfor ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public void testIssue1 ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tGeoHash fromRef = GeoHash . fromGeohashString ( " dr4jb0bn2180 " ) ; tSystem . out . println ( hash ) ; tSystem . out . println ( fromRef ) ; tassertEquals ( hash , fromRef ) ; } 
public int hashCode ( ) { tint f = 17 ; tf = 31 * f + ( int ) ( bits ^ ( bits > > > 32 ) ) ; tf = 31 * f + significantBits ; treturn f ; } 
public void testEqualsAndHashCode ( ) { tGeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; tassertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; tassertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; tassertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; tassertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) tthrow new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
protected String longToBitString ( long value ) { tStringBuilder buf = new StringBuilder ( ) ; tfor ( int i = significantBits ; i > 0 ; i - - ) { tlong bit = value & FIRST_BIT_FLAGGED ; if ( bit = = FIRST_BIT_FLAGGED ) { tbuf . append ( '1' ) ; } else { tbuf . append ( '0' ) ; } tvalue < < = 1 ; } treturn buf . toString ( ) ; } 
public void testEqualsAndHashCode ( ) { tGeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; tGeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; tassertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; tassertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; tassertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; tassertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public void testAdjacentHashes ( ) { tGeoHash [ ] adjacent = GeoHash . fromGeohashString ( " dqcw4 " ) . getAdjacent ( ) ; tassertEquals ( 8 , adjacent . length ) ; } 
public void testMovingInCircle ( ) { } 
private void checkMovingInCircle ( double latitude , double longitude ) { tGeoHash start ; tGeoHash end ; tstart = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; tend = start . getEasternNeighbour ( ) ; tend = end . getSouthernNeighbour ( ) ; tend = end . getWesternNeighbour ( ) ; tend = end . getNorthernNeighbour ( ) ; tassertEquals ( start , end ) ; } 
private void checkMoveAroundStrip ( String direction ) throws SecurityException , NoSuchMethodException , tIllegalArgumentException , IllegalAccessException , InvocationTargetException { tfor ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public boolean enclosesCircleAroundPoint ( WGS84Point point , double radius ) { treturn false ; } 
public String toString ( ) { treturn String . format ( " %s -> %s,%s " , longToBitString ( bits ) , upperLeft , lowerRight ) ; } 
public void testByCharacterPrecision ( ) { thash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; tassertEquals ( " sew1c2vs2q5r " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; tassertEquals ( " ksqn1rje83g2 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; tassertEquals ( " ksq9zbs0b7vw " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; tassertEquals ( " hf7u8p8gn747 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; tassertEquals ( " hf7u8p8g " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; tassertEquals ( " hf7u " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( 39.0247389581054 , - 76.5110040642321 , 12 ) ; tassertEquals ( " dqcw4bnrs6s7 " , hash . toBase32 ( ) ) ; } 
public String toBase32 ( ) { tStringBuilder buf = new StringBuilder ( ) ; tlong firstFiveBitsMask = 0xf800000000000000l ; tlong bitsCopy = bits ; tint partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; tfor ( int i = 0 ; i < partialChunks ; i + + ) { tint pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; tbuf . append ( base32 [ pointer ] ) ; tbitsCopy < < = 5 ; } treturn buf . toString ( ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tint sz = geohash . length ( ) ; tint [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; tint bsz = bits . length ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < sz ; i + + ) { tint cd = decodeMap . get ( geohash . charAt ( i ) ) ; tfor ( int z = 0 ; z < bsz ; z + + ) { tint mask = bits [ z ] ; if ( isEvenBit ) { tdivideRange ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRange ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; thash . upperLeft = new WGS84Point ( latitudeRange [ 0 ] , longitudeRange [ 0 ] ) ; thash . lowerRight = new WGS84Point ( latitudeRange [ 1 ] , longitudeRange [ 1 ] ) ; treturn hash ; } 
private void divideRangeEncode ( double value , double [ ] range ) { tdouble mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( value > = mid ) { taddOnBitToEnd ( ) ; 
private static void divideRange ( GeoHash hash , double [ ] range , boolean b ) { tdouble mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { thash . addOnBitToEnd ( ) ; 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < geohash . length ( ) ; i + + ) { tint cd = decodeMap . get ( geohash . charAt ( i ) ) ; tfor ( int j = 0 ; j < BASE32_BITS ; j + + ) { tint mask = BITS [ j ] ; if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; thash . upperLeft = new WGS84Point ( latitudeRange [ 0 ] , longitudeRange [ 0 ] ) ; thash . lowerRight = new WGS84Point ( latitudeRange [ 1 ] , longitudeRange [ 1 ] ) ; thash . bits < < = ( 64 - hash . significantBits ) ; treturn hash ; } 
private static void divideRangeDecode ( GeoHash hash , double [ ] range , boolean b ) { tdouble mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { thash . addOnBitToEnd ( ) ; 
public String toString ( ) { treturn String . format ( " ( " + latitude + " , " + longitude + " ) " ) ; } 
public void testIssue1 ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tString base32 = " dr4jb0bn2180 " ; tGeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; tassertEquals ( hash , fromRef ) ; tassertEquals ( base32 , hash . toBase32 ( ) ) ; tassertEquals ( base32 , fromRef . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; tassertEquals ( " dr4jb0bn21 " , hash . toBase32 ( ) ) ; } 
private final long mask ( ) { if ( significantBits = = 0 ) { treturn 0 ; 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < geohash . length ( ) ; i + + ) { tint cd = decodeMap . get ( geohash . charAt ( i ) ) ; tfor ( int j = 0 ; j < BASE32_BITS ; j + + ) { tint mask = BITS [ j ] ; if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( 64 - hash . significantBits ) ; treturn hash ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlatBits [ 0 ] < < = 1 ; } else { tdivideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( 64 - hash . significantBits ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; treturn hash ; } 
private void checkMovingInCircle ( double latitude , double longitude ) { tGeoHash start ; tGeoHash end ; tstart = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; tend = start . getEasternNeighbour ( ) ; tend = end . getSouthernNeighbour ( ) ; tend = end . getWesternNeighbour ( ) ; tend = end . getNorthernNeighbour ( ) ; tassertEquals ( start , end ) ; tassertArrayEquals ( start . getBoundingBoxPoints ( ) , end . getBoundingBoxPoints ( ) ) ; } 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.5) { 
public void testByCharacterPrecision ( ) { thash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; tassertEquals ( " sew1c2vs2q5r " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; tassertEquals ( " ksqn1rje83g2 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; tassertEquals ( " ksq9zbs0b7vw " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; tassertEquals ( " hf7u8p8gn747 " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; tassertEquals ( " hf7u8p8g " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; tassertEquals ( " hf7u " , hash . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( 39.0247389581054 , - 76.5110040642321 , 12 ) ; tassertEquals ( " dqcw4bnrs6s7 " , hash . toBase32 ( ) ) ; } 
public void testMovingInCircle ( ) { } 
public void testMovingAroundWorldOnHashStrips ( ) throws Exception { tString [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; tfor ( String direction : directions ) { tcheckMoveAroundStrip ( direction ) ; 
private void checkMoveAroundStrip ( String direction ) throws Exception { tfor ( int bits = 2 ; bits < 16 ; bits + + ) { tdouble randomLatitude = ( rand . nextDouble ( ) - 0.5 ) * 180 ; 
public void testIssue1 ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tString base32 = " dr4jb0bn2180 " ; tGeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; tassertEquals ( hash , fromRef ) ; tassertEquals ( base32 , hash . toBase32 ( ) ) ; tassertEquals ( base32 , fromRef . toBase32 ( ) ) ; thash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; tassertEquals ( " dr4jb0bn21 " , hash . toBase32 ( ) ) ; } 
public void testByCharacterPrecision ( ) { tassertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; tWGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; tString fullStringValue = " hf7u8p8gn747 " ; tfor ( int characters = 12 ; characters > 1 ; characters - - ) { tassertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } tassertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; } 
private void assertEncodingWithCharacterPrecision ( WGS84Point point , int numberOfCharacters , String stringValue ) { tGeoHash hash = GeoHash . withCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , numberOfCharacters ) ; tassertEquals ( stringValue , hash . toBase32 ( ) ) ; } 
public String toString ( ) { treturn String . format ( " %s -> %s,%s " , Long . toBinaryString ( bits ) , upperLeft , lowerRight ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) treturn true ; if ( obj instanceof BoundingBox ) { tBoundingBox o = ( BoundingBox ) obj ; 
public int hashCode ( ) { treturn 31 * ( 713 + upperLeft . hashCode ( ) ) + lowerRight . hashCode ( ) ; } 
public double area ( ) { treturn ( lowerRight . latitude - upperLeft . latitude ) * ( lowerRight . longitude - lowerRight . longitude ) ; } 
public boolean contains ( WGS84Point point ) { treturn point . latitude > = upperLeft . latitude & & point . latitude < = upperLeft . latitude & & point . longitude > = lowerRight . longitude & & point . longitude < = lowerRight . longitude ; 
public String toString ( ) { treturn upperLeft + " -> " + lowerRight ; } 
public int hashCode ( ) { tint result = 42 ; tlong latBits = Double . doubleToLongBits ( latitude ) ; tlong lonBits = Double . doubleToLongBits ( longitude ) ; tresult = 31 * result + ( int ) ( latBits ^ ( latBits > > > 32 ) ) ; tresult = 31 * result + ( int ) ( lonBits ^ ( lonBits > > > 32 ) ) ; treturn result ; } 
public void testHashCode ( ) { tassertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; tassertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; } 
public void testEqualsObject ( ) { tassertEquals ( a , b ) ; tassertEquals ( b , a ) ; tassertFalse ( a . equals ( c ) ) ; } 
private void assertContains ( BoundingBox box , WGS84Point p ) { tassertTrue ( p + " should be in " + box , box . contains ( p ) ) ; } 
public void testWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tSystem . out . println ( hash . toBase32 ( ) ) ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6ff0000000000000l ; tbbox . significantBits = 12 ; tassertWithin ( hash , bbox ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { tassertTrue ( hash . toBase32 ( ) + " should be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; } 
public void testSimpleWithin ( ) { tGeoHash hash = GeoHash . withBitPrecision ( 70 , - 120 , 8 ) ; tGeoHash inside = GeoHash . withBitPrecision ( 74 , - 130 , 64 ) ; tassertWithin ( inside , hash ) ; } 
public void testEquals ( ) { tassertEquals ( a , a ) ; tassertEquals ( a , b ) ; tassertEquals ( b , a ) ; tassertNotSame ( a , b ) ; tassertFalse ( a . equals ( c ) ) ; tassertFalse ( c . equals ( a ) ) ; tassertFalse ( d . equals ( c ) ) ; tassertFalse ( d . equals ( a ) ) ; tassertFalse ( d . equals ( new Integer ( 10 ) ) ) ; } 
public void testHashCode ( ) { tassertEquals ( a . hashCode ( ) , a . hashCode ( ) ) ; tassertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; tassertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; tassertFalse ( d . hashCode ( ) = = c . hashCode ( ) ) ; tassertFalse ( d . hashCode ( ) = = new Integer ( 10 ) . hashCode ( ) ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlatBits [ 0 ] < < = 1 ; } else { tdivideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( 64 - hash . significantBits ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; treturn hash ; } 
public String toString ( ) { treturn String . format ( " %s -> %s " , Long . toBinaryString ( bits ) , boundingBox ) ; } 
private void checkMovingInCircle ( double latitude , double longitude ) { tGeoHash start ; tGeoHash end ; tstart = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; tend = start . getEasternNeighbour ( ) ; tend = end . getSouthernNeighbour ( ) ; tend = end . getWesternNeighbour ( ) ; tend = end . getNorthernNeighbour ( ) ; tassertEquals ( start , end ) ; tassertEquals ( start . getBoundingBox ( ) , end . getBoundingBox ( ) ) ; } 
private void printBoundingBox ( GeoHash hash ) { tSystem . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; tSystem . out . print ( " corners= " ) ; tSystem . out . println ( hash . getBoundingBox ( ) ) ; } 
public boolean contains ( WGS84Point point ) { treturn ( point . latitude > = upperLeft . latitude ) & & ( point . longitude > = upperLeft . longitude ) 
public boolean contains ( WGS84Point point ) { treturn ( point . latitude > = upperLeft . latitude ) & & ( point . longitude > = upperLeft . longitude ) & & ( point . latitude < = lowerRight . latitude ) & & ( point . longitude < = lowerRight . longitude ) ; 
public void testContains ( ) { tBoundingBox bbox = new BoundingBox ( new WGS84Point ( 45 , 120 ) , new WGS84Point ( 46 , 121 ) ) ; tassertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; tassertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
private void assertNotContains ( BoundingBox box , WGS84Point p ) { tassertFalse ( p + " should NOT be in " + box , box . contains ( p ) ) ; } 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.85) { 
public void testRangeCheck ( ) { tWGS84Point p = new WGS84Point ( 180 , 240 ) ; } 
public void testBoundingBoxSearch ( ) { tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( new WGS84Point ( 40.09872762 , t30 .0113312322 ) , new WGS84Point ( 41.23452234 , 31.23432 ) ) ) ; 
private long extractEverySecondBit ( long copyOfBits , int numberOfBits ) { tlong value = 0 ; tfor ( int i = 0 ; i < numberOfBits ; i + + ) { if ( ( copyOfBits & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { tvalue | = 0x1 ; } tvalue < < = 1 ; tcopyOfBits < < = 2 ; } tvalue > > > = 1 ; treturn value ; } 
public static final int commonPrefixLength ( long a , long b ) { tint result = 0 ; twhile ( result < 64 & & ( a & FIRST_BIT ) = = ( b & FIRST_BIT ) ) { tresult + + ; ta < < = 1 ; tb < < = 1 ; } treturn result ; } 
public void testSameNumbersHave64BitsPrefix ( ) { tfor ( long a = 0 ; a < 120000000 ; a + = 101 ) { tlong b = a ; 
public void testKnownPrefixLenghts ( ) { tlong a = 0x8f00000000000000l ; tlong b = 0x8000000000000000l ; tlong c = 0x8800000000000000l ; tassertPrefixLength ( 4 , a , b ) ; tassertPrefixLength ( 4 , b , c ) ; tassertPrefixLength ( 5 , a , c ) ; tassertPrefixLength ( 0 , 0x0 , a ) ; tassertPrefixLength ( 16 , 0x8888300000000000l , 0x8888c00000000000l ) ; } 
private void assertPrefixLength ( int length , long a , long b ) { tassertEquals ( length , LongUtil . commonPrefixLength ( a , b ) ) ; } 
public void testDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 1.54) { 
public void testNeighbourLocationCode ( ) { assertEquals(0x5400000000000000l, east.bits); 
public void testKnownNeighbouringHashes ( ) { tGeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; tassertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; } 
public String toString ( ) { if ( significantBits % 5 = = 0 ) { treturn String . format ( " %s -> %s -> %s " , Long . toBinaryString ( bits ) , boundingBox , toBase32 ( ) ) ; 
public void testKnownNeighbouringHashes ( ) { tGeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; tassertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; } 
public void testKnownAdjacentNeighbours ( ) { tGeoHash center = GeoHash . fromGeohashString ( " dqcjqc " ) ; tGeoHash [ ] adjacent = center . getAdjacent ( ) ; tfor ( String check : new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ) { 
private void assertArrayContainsGeoHash ( String check , GeoHash [ ] hashes ) { tboolean found = false ; tfor ( GeoHash hash : hashes ) { if ( hash . toBase32 ( ) . equals ( check ) ) { tfound = true ; tbreak ; } } tassertTrue ( " Array should contain " + check , found ) ; } 
public void testKnownNeighbouringHashes ( ) { tGeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; tassertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . toBase32 ( ) ) ; } 
public void testKnownAdjacentNeighbours ( ) { tString center = " dqcjqc " ; tString [ ] adjacent = new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ; tassertAdjacentHashesAre ( center , adjacent ) ; tcenter = " u1x0dfg " ; tadjacent = new String [ ] { " u1x0dg4 " , " u1x0dg5 " , " u1x0dgh " , " u1x0dfu " , " u1x0dfs " , " u1x0dfe " , " u1x0dfd " , " u1x0dff " } ; tassertAdjacentHashesAre ( center , adjacent ) ; tcenter = " sp2j " ; tadjacent = new String [ ] { " ezry " , " sp2n " , " sp2q " , " sp2m " , " sp2k " , " sp2h " , " ezru " , " ezrv " } ; tassertAdjacentHashesAre ( center , adjacent ) ; } 
private void assertAdjacentHashesAre ( String centerString , String [ ] adjacentStrings ) { tGeoHash center = GeoHash . fromGeohashString ( centerString ) ; tGeoHash [ ] adjacent = center . getAdjacent ( ) ; tfor ( String check : adjacentStrings ) { tassertArrayContainsGeoHash ( check , adjacent ) ; 
public void testNeibouringHashesNearMeridian ( ) { tGeoHash hash = GeoHash . fromGeohashString ( " sp2j " ) ; tGeoHash west = hash . getWesternNeighbour ( ) ; tassertEquals ( " ezrv " , west . toBase32 ( ) ) ; twest = west . getWesternNeighbour ( ) ; tassertEquals ( " ezrt " , west . toBase32 ( ) ) ; } 
protected static final double dLat ( int bits ) { treturn 180 d / Math . pow ( 2 , bits / 2 ) ; } 
protected static final double dLon ( int bits ) { treturn 360 d / Math . pow ( 2 , ( bits + 1 ) / 2 ) ; } 
public void testDLat ( ) { tassertDLatIs ( 180 d , 0 ) ; tassertDLatIs ( 180 d , 1 ) ; tassertDLatIs ( 90 d , 2 ) ; tassertDLatIs ( 0.3515625 , 18 ) ; tassertDLatIs ( 0.3515625 , 19 ) ; } 
private void assertDLatIs ( double d , int i ) { tassertEquals ( d , GeoHashSizeTable . dLat ( i ) , 0 ) ; } 
public void testDLon ( ) { tassertDLonIs ( 360 , 0 ) ; tassertDLonIs ( 180 , 1 ) ; tassertDLonIs ( 0.0439453125 , 25 ) ; tassertDLonIs ( 0.0439453125 , 26 ) ; } 
private void assertDLonIs ( double d , int i ) { tassertEquals ( d , GeoHashSizeTable . dLon ( i ) , 1 - 128 ) ; } 
public int numberOfBitsForOverlappingGeoHash ( BoundingBox boundingBox ) { treturn 0 ; } 
private void assertDLonIs ( double d , int i ) { tassertEquals ( d , GeoHashSizeTable . dLon ( i ) , 1 - 128 ) ; } 
public void testKnownBoundingBoxSizes ( ) { tfor ( int bits = 3 ; bits < 64 ; bits + + ) { make the bounding box a little smaller than dLat/dLon 
public boolean contains ( WGS84Point point ) { treturn boundingBox . contains ( point ) ; } 
public String toString ( ) { if ( significantBits % 5 = = 0 ) { treturn String . format ( " %s -> %s -> %s " , Long . toBinaryString ( bits ) , boundingBox , toBase32 ( ) ) ; 
public boolean intersects ( BoundingBox other ) { treturn ( upperLeft . latitude < other . lowerRight . latitude ) & & ( lowerRight . latitude > other . upperLeft . latitude ) & & ( upperLeft . longitude < other . lowerRight . longitude ) & & ( lowerRight . longitude > other . upperLeft . longitude ) ; 
private void addSearchHash ( GeoHash hash ) { tsearchHashes . add ( hash ) ; texpandSearchBoundingBox ( hash ) ; } 
private void expandSearchBoundingBox ( GeoHash hash ) { }} 
private boolean hashFits ( GeoHash hash , BoundingBox bbox ) { treturn hash . contains ( bbox . getUpperLeft ( ) ) & & hash . contains ( bbox . getLowerRight ( ) ) ; } 
public void testBoundingBoxSearch ( ) { tGeoHashBoundingBoxSearch search = createSearch ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; 
public void testSeveralBoundingBoxes ( ) { tGeoHashBoundingBoxSearch search = createSearch ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcreateSearch ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcreateSearch ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; } 
private GeoHashBoundingBoxSearch createSearch ( double minx , double miny , double maxx , double maxy ) { treturn new GeoHashBoundingBoxSearch ( new BoundingBox ( new WGS84Point ( minx , miny ) , new WGS84Point ( maxx , maxy ) ) ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double minLon , double maxLat , double maxLon ) { tWGS84Point upperLeft = new WGS84Point ( minLat , minLon ) ; tWGS84Point lowerRight = new WGS84Point ( maxLat , maxLon ) ; tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( upperLeft , lowerRight ) ) ; tassertRightNumberOfSearchHashes ( search ) ; } 
private void assertRightNumberOfSearchHashes ( GeoHashBoundingBoxSearch search ) { tassertTrue ( search . getSearchHashes ( ) . size ( ) = = 2 | | search . getSearchHashes ( ) . size ( ) = = 4 ) ; } 
public void testKnownSmallerBoundingBoxSizes ( ) { tfor ( int bits = 3 ; bits < 64 ; bits + + ) { make the bounding box a little smaller than dLat/dLon 
public void testKnownLargerBoundingBoxSizes ( ) { tfor ( int bits = 4 ; bits < 63 ; bits + + ) { tdouble dLat = GeoHashSizeTable . dLat ( bits ) ; 
public BoundingBox generate ( int bits ) { } 
public BoundingBox generate ( int bits ) { tdouble dLat = GeoHashSizeTable . dLat ( bits ) ; tdouble dLon = GeoHashSizeTable . dLon ( bits ) ; treturn new BoundingBox ( 0 , 0 , dLat + DELTA , dLon + DELTA ) ; } 
public BoundingBox generate ( int bits ) { treturn null ; } 
public void testKnownSmallerBoundingBoxSizes ( ) { tcheckWithGenerator ( new ALittleTooSmallVerifier ( ) ) ; } 
public void testKnownLargerBoundingBoxSizes ( ) { tcheckWithGenerator ( new BothALittleTooLargeVerifier ( ) ) ; } 
public void testKnownOneBitLargerBoxSizes ( ) { }} 
private void checkWithGenerator ( BoundingBoxSizeTableVerifier generator ) { tfor ( int bits = 4 ; bits < 64 ; bits + + ) { tBoundingBox bbox = generator . generate ( bits ) ; 
public BoundingBox generate ( int bits ) { tdouble dLat = GeoHashSizeTable . dLat ( bits ) ; tdouble dLon = GeoHashSizeTable . dLon ( bits ) ; if ( latitudeAffected = rand . nextBoolean ( ) ) { tdLat + = DELTA ; } else { tdLon + = DELTA ; } treturn new BoundingBox ( 0 , 0 , dLat , dLon ) ; } 
public void testKnownOneBitLargerBoxSizes ( ) { tcheckWithGenerator ( new OnlyOneALittleTooLargeVerifier ( ) ) ; } 
public String toString ( ) { tStringBuilder bui = new StringBuilder ( ) ; tfor ( GeoHash hash : searchHashes ) { tbui . append ( hash ) . append ( " " ) ; } treturn bui . toString ( ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; tcheckSearchYieldsCorrectHashes ( 47.447907 , 8.471276 , 47.300200 , 8.760941 , " u0qj " ) ; tcheckSearchYieldsCorrectHashes ( 47.157502 , 8.562244 , 47.329727 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double minLon , double maxLat , double maxLon ) { tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , minLon , maxLat , maxLon ) ) ; tassertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double minLon , double maxLat , double maxLon , tString . . . hashes ) { tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , minLon , maxLat , maxLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
private void assertRightNumberOfSearchHashes ( GeoHashBoundingBoxSearch search ) { tint size = search . getSearchHashes ( ) . size ( ) ; tassertTrue ( size = = 1 | | size = = 2 | | size = = 4 ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) treturn true ; if ( obj instanceof BoundingBox ) { tBoundingBox that = ( BoundingBox ) obj ; 
public int hashCode ( ) { tint result = 17 ; tresult = 37 * result + hashCode ( minLat ) ; tresult = 37 * result + hashCode ( maxLat ) ; tresult = 37 * result + hashCode ( minLon ) ; tresult = 37 * result + hashCode ( maxLon ) ; treturn result ; } 
private static int hashCode ( double x ) { tlong f = Double . doubleToLongBits ( x ) ; treturn ( int ) ( f ^ ( f > > > 32 ) ) ; } 
public boolean contains ( WGS84Point point ) { treturn ( point . latitude > = minLat ) & & ( point . longitude > = minLon ) & & ( point . latitude < = maxLat ) & & ( point . longitude < = maxLon ) ; 
public boolean intersects ( BoundingBox other ) { treturn ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLon > maxLon | | other . maxLon < minLon ) ; } 
public String toString ( ) { treturn getUpperLeft ( ) + " -> " + getLowerRight ( ) ; } 
public void testContains ( ) { tBoundingBox bbox = new BoundingBox ( 45 , 46 , 121 , 120 ) ; tassertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; tassertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
public void testIntersects ( ) { tBoundingBox bbox = new BoundingBox ( 10 , - 10 , 41 , 40 ) ; tassertIntersects ( bbox , new BoundingBox ( 5 , - 15 , 40.5 , 43 ) ) ; tassertDoesNotIntersect ( bbox , new BoundingBox ( 5 , - 15 , 42 , 43 ) ) ; } 
private void assertDoesNotIntersect ( BoundingBox bbox , BoundingBox boundingBox ) { tassertFalse ( bbox + " should NOT intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; tassertFalse ( boundingBox + " should NOT intersect " + bbox , boundingBox . intersects ( bbox ) ) ; } 
private void assertIntersects ( BoundingBox bbox , BoundingBox boundingBox ) { tassertTrue ( bbox + " should intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; tassertTrue ( boundingBox + " should intersect " + bbox , boundingBox . intersects ( bbox ) ) ; } 
private void assertContains ( BoundingBox box , WGS84Point p ) { tassertTrue ( p + " should be in " + box , box . contains ( p ) ) ; } 
private void assertNotContains ( BoundingBox box , WGS84Point p ) { tassertFalse ( p + " should NOT be in " + box , box . contains ( p ) ) ; } 
public static final int numberOfBitsForOverlappingGeoHash ( BoundingBox boundingBox ) { tint bits = 63 ; tdouble height = boundingBox . getLatitudeSize ( ) ; tdouble width = boundingBox . getLongitudeSize ( ) ; twhile ( ( dLat [ bits ] < height | | dLon [ bits ] < width ) & & bits > 0 ) { tbits - - ; } treturn bits ; } 
public void testSize ( ) { tBoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; tassertHeightIs ( bbox , 45 ) ; tassertWidthIs ( bbox , 30 ) ; tbbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; tassertHeightIs ( bbox , 90 ) ; tassertWidthIs ( bbox , 52.5 ) ; tbbox = new BoundingBox ( - 44 , - 46.1 , - 127.2 , - 128 ) ; tassertHeightIs ( bbox , 2.1 ) ; tassertWidthIs ( bbox , 0.8 ) ; } 
private void assertWidthIs ( BoundingBox bbox , double width ) { tassertEquals ( width , bbox . getLongitudeSize ( ) , DELTA ) ; } 
private void assertHeightIs ( BoundingBox bbox , double height ) { tassertEquals ( height , bbox . getLatitudeSize ( ) , DELTA ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( - 22.5 , - 22.4 , 40.2 , 40.3 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2 , 40.3 , - 22.5 , - 22.4 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; tcheckSearchYieldsCorrectHashes ( 8.760941 , 8.471276 , 47.447907 , 47.300200 , " u0qj " ) ; tcheckSearchYieldsCorrectHashes ( 8.562244 , 8.859215 , 47.157502 , 47.329727 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double maxLat , double minLon , double maxLon ) { tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; tassertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , tString . . . hashes ) { tGeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
public BoundingBox generate ( int bits ) { } 
public BoundingBox generate ( int bits ) { tdouble dLat = GeoHashSizeTable . dLat ( bits ) ; tdouble dLon = GeoHashSizeTable . dLon ( bits ) ; treturn new BoundingBox ( 0 , dLat + DELTA , 0 , dLon + DELTA ) ; } 
public BoundingBox generate ( int bits ) { tdouble dLat = GeoHashSizeTable . dLat ( bits ) ; tdouble dLon = GeoHashSizeTable . dLon ( bits ) ; if ( latitudeAffected = rand . nextBoolean ( ) ) { tdLat + = DELTA ; } else { tdLon + = DELTA ; } treturn new BoundingBox ( 0 , dLat , 0 , dLon ) ; } 
public boolean intersects ( BoundingBox other ) { treturn ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLat > maxLat | | other . maxLat < minLat ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; tcheckSearchYieldsCorrectHashes ( 47.447907 , 47.300200 , 8.760941 , 8.471276 , " u0qj " ) ; tcheckSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
public boolean contains ( WGS84Point point ) { treturn ( point . getLatitude ( ) > = minLat ) & & ( point . getLongitude ( ) > = minLon ) & & ( point . getLatitude ( ) < = maxLat ) & & ( point . getLongitude ( ) < = maxLon ) ; 
public void testVincenty ( ) { tWGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; tint distanceInMeters = 10000 ; tWGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , tdistanceInMeters ) ; tAssert . assertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; tAssert . assertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; tAssert . assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( tstartPoint , result ) , DELTA ) ; tWGS84Point p1 = new WGS84Point ( 1 , 1 ) ; tint tenThousandKilometers = 10000000 ; tWGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , tenThousandKilometers ) ; tSystem . out . println ( p2 ) ; tAssert . assertEquals ( tenThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public boolean contains ( GeoHash hash ) { tfor ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) treturn true ; } treturn false ; } 
public boolean contains ( GeoHash hash ) { treturn query . contains ( hash ) ; } 
public abstract boolean contains ( GeoHash hash ) ; public abstract List < GeoHash > getSearchHashes ( ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double maxLat , double minLon , double maxLon ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; tassertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , tString . . . hashes ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
private void assertRightNumberOfSearchHashes ( GeoHashQuery search ) { tint size = search . getSearchHashes ( ) . size ( ) ; tassertTrue ( size = = 1 | | size = = 2 | | size = = 4 ) ; } 
public void testRangeCheck ( ) { tnew WGS84Point ( 180 , 240 ) ; } 
public String toBase32 ( ) { if ( significantBits % 5 ! = 0 ) { treturn " " ; } tStringBuilder buf = new StringBuilder ( ) ; tlong firstFiveBitsMask = 0xf800000000000000l ; tlong bitsCopy = bits ; tint partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; tfor ( int i = 0 ; i < partialChunks ; i + + ) { tint pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; tbuf . append ( base32 [ pointer ] ) ; tbitsCopy < < = 5 ; } treturn buf . toString ( ) ; } 
public String toString ( ) { treturn " Cicle Query [center= " + center + " , radius= " + getRadiusString ( ) + " ] " ; } 
public void expandToInclude ( BoundingBox other ) { if ( other . minLon < minLon ) { tminLon = other . minLon ; } if ( other . maxLon > maxLon ) { tmaxLon = other . maxLon ; } if ( other . minLat < minLat ) { tminLat = other . minLat ; } if ( other . maxLat > maxLat ) { tmaxLat = other . maxLat ; 
private void addSearchHash ( GeoHash hash ) { if ( boundingBox = = null ) { tboundingBox = new BoundingBox ( hash . getBoundingBox ( ) ) ; } else { tboundingBox . expandToInclude ( hash . getBoundingBox ( ) ) ; } tsearchHashes . add ( hash ) ; } 
public abstract boolean contains ( GeoHash hash ) ; public abstract List < GeoHash > getSearchHashes ( ) ; public abstract String getWktBox ( ) ; } 
public abstract List < GeoHash > getSearchHashes ( ) ; public abstract String getWktBox ( ) ; } 
public void checkJerryDonSample1 ( ) { tcheckRadiusSearchHashes ( 1000 , " t9y2bk " ) ; } 
public void testJerryDonSample2 ( ) { tcheckRadiusSearchHashes ( 1500 , " t9y2bh " , " t9y2bs " , " t9yb2b0 " , " t9yb2b8 " ) ; } 
public void testJerryDonSample3 ( ) { tcheckRadiusSearchHashes ( 2500 , " t9y2b " ) ; } 
private void checkRadiusSearchHashes ( int radius , String . . . string ) { tGeoHashQuery query = new GeoHashCircleQuery ( center , radius ) ; tList < String > expectedHashes = Arrays . asList ( string ) ; tList < GeoHash > searchHashes = query . getSearchHashes ( ) ; tassertEquals ( expectedHashes . size ( ) , searchHashes . size ( ) ) ; tfor ( GeoHash hash : searchHashes ) { if ( ! expectedHashes . contains ( hash . toBase32 ( ) ) ) { 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuffer b = new StringBuffer ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { b . append ( " 0 " ) ; } binaryString = b . toString ( ) ; } geohash . bits = Long . valueOf ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; 
public String oStringWithSignificantPrecision ( ) { return Long . toBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
public boolean contains ( WGS84Point point ) { treturn contains ( GeoHash . withBitPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 64 ) ) ; } 
public boolean contains ( WGS84Point point ) { treturn query . contains ( point ) ; } 
public boolean contains ( GeoHash hash ) ; public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public boolean contains ( WGS84Point point ) ; public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public void testIssue3WithCircleQuery ( ) throws Exception { tWGS84Point center = new WGS84Point ( 39.86391280373075 , 116.37356590048701 ) ; tGeoHashCircleQuery query = new GeoHashCircleQuery ( center , 589 ) ; } 
public static BoundingBoxGeoHashIterator withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; GeoHash topRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; return new BoundingBoxGeoHashIterator ( bottomLeft , topRight ) ; } 
public static BoundingBoxGeoHashIterator withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; GeoHash topRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; return new BoundingBoxGeoHashIterator ( bottomLeft , topRight ) ; } 
public boolean hasNext ( ) { return current . compareTo ( topRight ) < = 0 ; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public void testIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 10 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void testIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 35 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; int idx = 0 ; System.out.println("idx,lat,lon"); for (GeoHash gh : hashes) { if (prev != null) Assert.assertTrue(prev.compareTo(gh) < 0); 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = true ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . toBinaryString ( hashVal ) ; while ( binaryString . length ( ) < 64 ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( 64 - hash . significantBits ) ; treturn hash ; } 
public GeoHash next ( ) { return fromLongValue ( bits + ( 1l < < ( 64 - significantBits ) ) , significantBits ) ; } 
public int compareTo ( GeoHash o ) { return new Long ( bits ) . compareTo ( o . bits ) ; } 
public void testToLongAndBack ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; long lv = hash . longValue ( ) ; assertEquals ( lv + ( 1 < < ( 64 - hash . significantBits ( ) ) ) , hash . next ( ) . longValue ( ) ) ; GeoHash hashFromLong = GeoHash . fromLongValue ( lv , hash . significantBits ( ) ) ; assertEquals ( " dr4jb0bn21 " , hashFromLong . toBase32 ( ) ) ; assertEquals ( hash , hashFromLong ) ; } 
public void testNext ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; GeoHash next = hash . next ( ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public void testIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 35 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public static GeoHash fromBinaryString ( String binaryString ) { tGeoHash geohash = new GeoHash ( ) ; tgeohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { tStringBuffer b = new StringBuffer ( ) ; tb . append ( binaryString ) ; tfor ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { tb . append ( " 0 " ) ; } tbinaryString = b . toString ( ) ; } tgeohash . bits = Long . valueOf ( binaryString , 2 ) ; tlong [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; tlong [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; treturn geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj instanceof BoundingBox ) { BoundingBox that = ( BoundingBox ) obj ; 
public int hashCode ( ) { int result = 17 ; result = 37 * result + hashCode ( minLat ) ; result = 37 * result + hashCode ( maxLat ) ; result = 37 * result + hashCode ( minLon ) ; result = 37 * result + hashCode ( maxLon ) ; return result ; } 
private static int hashCode ( double x ) { long f = Double . doubleToLongBits ( x ) ; return ( int ) ( f ^ ( f > > > 32 ) ) ; } 
public boolean contains ( WGS84Point point ) { return ( point . getLatitude ( ) > = minLat ) & & ( point . getLongitude ( ) > = minLon ) & & ( point . getLatitude ( ) < = maxLat ) & & ( point . getLongitude ( ) < = maxLon ) ; 
public boolean intersects ( BoundingBox other ) { return ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLat > maxLat | | other . maxLat < minLat ) ; } 
public String toString ( ) { return getUpperLeft ( ) + " -> " + getLowerRight ( ) ; } 
public void expandToInclude ( BoundingBox other ) { if ( other . minLon < minLon ) { minLon = other . minLon ; } if ( other . maxLon > maxLon ) { maxLon = other . maxLon ; } if ( other . minLat < minLat ) { minLat = other . minLat ; } if ( other . maxLat > maxLat ) { maxLat = other . maxLat ; 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { int desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; return new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) throw new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuffer b = new StringBuffer ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { b . append ( " 0 " ) ; } binaryString = b . toString ( ) ; } geohash . bits = Long . valueOf ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = true ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = true ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . toBinaryString ( hashVal ) ; while ( binaryString . length ( ) < 64 ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
private void divideRangeEncode ( double value , double [ ] range ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( value > = mid ) { addOnBitToEnd ( ) ; 
private static void divideRangeDecode ( GeoHash hash , double [ ] range , boolean b ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { hash . addOnBitToEnd ( ) ; 
public int significantBits ( ) { return ( int ) significantBits ; } 
public String toBase32 ( ) { if ( significantBits % 5 ! = 0 ) { return " " ; } StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . toString ( ) ; } 
public boolean within ( GeoHash boundingBox ) { return ( bits & boundingBox . mask ( ) ) = = boundingBox . bits ; } 
public boolean contains ( WGS84Point point ) { return boundingBox . contains ( point ) ; } 
public boolean enclosesCircleAroundPoint ( WGS84Point point , double radius ) { return false ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; return hash ; } 
private long extractEverySecondBit ( long copyOfBits , int numberOfBits ) { long value = 0 ; for ( int i = 0 ; i < numberOfBits ; i + + ) { if ( ( copyOfBits & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { value | = 0x1 ; } value < < = 1 ; copyOfBits < < = 2 ; } value > > > = 1 ; return value ; } 
protected final void addOnBitToEnd ( ) { significantBits + + ; bits < < = 1 ; bits = bits | 0x1 ; } 
protected final void addOffBitToEnd ( ) { significantBits + + ; bits < < = 1 ; } 
public String toString ( ) { if ( significantBits % 5 = = 0 ) { return String . format ( " %s -> %s -> %s " , Long . toBinaryString ( bits ) , boundingBox , toBase32 ( ) ) ; 
public String oStringWithSignificantPrecision ( ) { return Long . toBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof GeoHash ) { GeoHash other = ( GeoHash ) obj ; if ( other . significantBits = = significantBits & & other . bits = = bits ) { return true ; } } return false ; } 
public int hashCode ( ) { int f = 17 ; f = 31 * f + ( int ) ( bits ^ ( bits > > > 32 ) ) ; f = 31 * f + significantBits ; return f ; } 
private long mask ( ) { if ( significantBits = = 0 ) { return 0 ; 
private long maskLastNBits ( long value , long ) { long mask = 0xffffffffffffffffl ; mask > > > = ( 64 - ) ; return value & mask ; } 
public String toString ( ) { return String . format ( " ( " + latitude + " , " + longitude + " ) " ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof WGS84Point ) { WGS84Point other = ( WGS84Point ) obj ; return latitude = = other . latitude & & longitude = = other . longitude ; } return false ; } 
public int hashCode ( ) { int result = 42 ; long latBits = Double . doubleToLongBits ( latitude ) ; long lonBits = Double . doubleToLongBits ( longitude ) ; result = 31 * result + ( int ) ( latBits ^ ( latBits > > > 32 ) ) ; result = 31 * result + ( int ) ( lonBits ^ ( lonBits > > > 32 ) ) ; return result ; } 
private void addSearchHash ( GeoHash hash ) { if ( boundingBox = = null ) { boundingBox = new BoundingBox ( hash . getBoundingBox ( ) ) ; } else { boundingBox . expandToInclude ( hash . getBoundingBox ( ) ) ; } searchHashes . add ( hash ) ; } 
private boolean hashFits ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getUpperLeft ( ) ) & & hash . contains ( bbox . getLowerRight ( ) ) ; } 
public boolean contains ( GeoHash hash ) { for ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) return true ; } return false ; } 
public boolean contains ( WGS84Point point ) { return contains ( GeoHash . withBitPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 64 ) ) ; } 
public String toString ( ) { StringBuilder bui = new StringBuilder ( ) ; for ( GeoHash hash : searchHashes ) { bui . append ( hash ) . append ( " " ) ; } return bui . toString ( ) ; } 
public boolean contains ( GeoHash hash ) { return query . contains ( hash ) ; } 
public String toString ( ) { return " Cicle Query [center= " + center + " , radius= " + getRadiusString ( ) + " ] " ; } 
public boolean contains ( WGS84Point point ) { return query . contains ( point ) ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tString binaryString = Long . toBinaryString ( hashVal ) ; twhile ( binaryString . length ( ) < 64 ) { tbinaryString = " 0 " + binaryString ; } tfor ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { tdivideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } tisEvenBit = ! isEvenBit ; } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( 64 - hash . significantBits ) ; treturn hash ; } 
public GeoHash next ( ) { treturn fromLongValue ( bits + ( 1l < < ( 64 - significantBits ) ) , significantBits ) ; } 
public String toBase32 ( ) { if ( significantBits % 5 ! = 0 ) { treturn " " ; } tStringBuilder buf = new StringBuilder ( ) ; tlong firstFiveBitsMask = 0xf800000000000000l ; tlong bitsCopy = bits ; tint partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; tfor ( int i = 0 ; i < partialChunks ; i + + ) { tint pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; tbuf . append ( base32 [ pointer ] ) ; tbitsCopy < < = 5 ; } treturn buf . toString ( ) ; } 
public String oStringWithSignificantPrecision ( ) { treturn Long . toBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
private long mask ( ) { if ( significantBits = = 0 ) { treturn 0 ; 
public int compareTo ( GeoHash o ) { treturn new Long ( bits ) . compareTo ( o . bits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { tGeoHash geohash = new GeoHash ( ) ; tgeohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { tStringBuilder b = new StringBuilder ( ) ; tb . append ( binaryString ) ; tfor ( int i = binaryString . length ( ) ; i < 64 ; i + + ) { tb . append ( '0' ) ; } tbinaryString = b . toString ( ) ; } tgeohash . bits = Long . parseLong ( binaryString , 2 ) ; tlong [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; tlong [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; treturn geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public String toBinaryString ( ) { tStringBuilder bui = new StringBuilder ( ) ; tlong bitsCopy = bits ; tfor ( int i = 0 ; i < significantBits ; i + + ) { if ( ( bitsCopy & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { tbui . append ( '1' ) ; } else { tbui . append ( '0' ) ; } tbitsCopy < < = 1 ; } treturn bui . toString ( ) ; } 
public void testDecode ( ) { BoundingBox bbox = gh.getBoundingBox(); 
public void testToAndFromBinaryString ( ) { tfor ( GeoHash gh : RandomGeohashes . fullRange ( ) ) { tString binaryString = gh . toBinaryString ( ) ; 
public void testOffendingBinaryString ( ) { tString offendingString = " 1000000000000000000010101000000000000000000000000000000000000000 " ; tassertEquals ( 64 , offendingString . length ( ) ) ; tLong . parseLong ( offendingString , 2 ) ; } 
public void testKnownNeighbouringHashes ( ) { tGeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; tassertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; tassertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . toBase32 ( ) ) ; } 
public void testToLongAndBack ( ) { tdouble lat = 40.390943 ; tdouble lon = - 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; tlong lv = hash . longValue ( ) ; tassertEquals ( lv + ( 1 < < ( 64 - hash . significantBits ( ) ) ) , hash . next ( ) . longValue ( ) ) ; tGeoHash hashFromLong = GeoHash . fromLongValue ( lv , hash . significantBits ( ) ) ; tassertEquals ( " dr4jb0bn21 " , hashFromLong . toBase32 ( ) ) ; tassertEquals ( hash , hashFromLong ) ; } 
public void testNext ( ) { tdouble lat = 37.7 ; tdouble lon = - 122.52 ; tGeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; tGeoHash next = hash . next ( ) ; tassertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public static Iterable < GeoHash > fullRange ( ) { treturn new Iterable < GeoHash > ( ) { @Override 
public Iterator < GeoHash > iterator ( ) { tRandom rand = new Random ( ) ; tList < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; tfor ( double lat = - 90 ; lat < = 90 ; lat + = rand . nextDouble ( ) + 1.45 ) { tfor ( double lon = - 180 ; lon < = 180 ; lon + = rand . nextDouble ( ) + 1.54 ) { tfor ( int precisionChars = 6 ; precisionChars < = 12 ; precisionChars + + ) { tGeoHash gh = GeoHash . withCharacterPrecision ( lat , lon , precisionChars ) ; thashes . add ( gh ) ; } } } treturn hashes . iterator ( ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { tGeoHash geohash = new GeoHash ( ) ; tfor ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { tgeohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { tgeohash . addOffBitToEnd ( ) ; } else { tthrow new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } tgeohash . bits < < = ( 64 - geohash . significantBits ) ; tlong [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; tlong [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; treturn geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public GeoHash next ( int step ) { int insignificantBits = 64 - significantBits ; long unshiftedVal = bits > > insignificantBits ; unshiftedVal + = step ; return fromLongValue ( unshiftedVal < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash two ) { if ( one . significantBits ( ) ! = two . significantBits ( ) ) throw new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; int insignificantBits = 64 - one . significantBits ( ) ; long unshiftedVal1 = one . bits > > insignificantBits ; long unshiftedVal2 = two . bits > > insignificantBits ; return unshiftedVal2 - unshiftedVal1 ; } 
public void testAddingOnes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; assertEquals ( 1 , hash . significantBits ( ) ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; assertEquals ( 0xfl , hash . bits ) ; assertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void testAddingZeroes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; assertEquals ( 0x10l , hash . bits ) ; assertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void testToBase32 ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; String base32 = hash . toBase32 ( ) ; assertEquals ( " ezs42 " , base32 ) ; } 
public void testDecode ( ) { for all lat/lon pairs check decoded point is in the same bbox as the geohash formed by encoder TODO could possibly be less brute-force here and be more scientific about possible failure points for (double lat = -90; lat <= 90; lat += rand.nextDouble() + 1.45) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 1.54) { 
public void testWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . toBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertWithin ( hash , bbox ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { assertTrue ( hash . toBase32 ( ) + " should be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; } 
public void testNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash . toBase32 ( ) + " should NOT be within " + bbox . toBase32 ( ) , hash . within ( bbox ) ) ; } 
public void testConstructorWithBitPrecision ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; assertEquals ( hash1 . significantBits , 20 ) ; System . out . println ( hash1 ) ; System . out . println ( hash1 . toBase32 ( ) ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; assertEquals ( hash2 . significantBits , 55 ) ; System . out . println ( hash2 ) ; System . out . println ( hash2 . toBase32 ( ) ) ; assertTrue ( hash2 . within ( hash1 ) ) ; this should match Dave Troys Codebase. This is also his maximum accuracy (12 5-nibbles). GeoHash hash3 = GeoHash.withBitPrecision(20, 31, 60); assertEquals("sew1c2vs2q5r", hash3.toBase32()); } 
public void testLatLonBoundingBoxes ( ) { hash = GeoHash . withBitPrecision ( 40 , 120 , 10 ) ; System . out . println ( hash . toBase32 ( ) ) ; printBoundingBox ( hash ) ; } 
public void testByCharacterPrecision ( ) { assertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; WGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; String fullStringValue = " hf7u8p8gn747 " ; for ( int characters = 12 ; characters > 1 ; characters - - ) { assertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } assertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; } 
private void assertEncodingWithCharacterPrecision ( WGS84Point point , int numberOfCharacters , String stringValue ) { GeoHash hash = GeoHash . withCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , numberOfCharacters ) ; assertEquals ( stringValue , hash . toBase32 ( ) ) ; } 
public void testGetLatitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; assertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void testGetLongitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; assertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
public void testNeighbourLocationCode ( ) { set up corner case hash.bits = 0xc400000000000000l; hash.significantBits = 7; long[] lonBits = hash.getRightAlignedLongitudeBits(); assertEquals(0x8, lonBits[0]); assertEquals(4, lonBits[1]); long[] latBits = hash.getRightAlignedLatitudeBits(); assertEquals(0x5, latBits[0]); assertEquals(3, latBits[1]); GeoHash north = hash.getNorthernNeighbour(); assertEquals(0xd000000000000000l, north.bits); assertEquals(7, north.significantBits); GeoHash south = hash.getSouthernNeighbour(); assertEquals(0xc000000000000000l, south.bits); assertEquals(7, south.significantBits()); GeoHash east = hash.getEasternNeighbour(); assertEquals(0xc600000000000000l, east.bits); NOTE: this is actually a corner case! GeoHash west = hash.getWesternNeighbour(); assertEquals(0x6e00000000000000l, west.bits); NOTE: and now, for the most extreme corner case in 7-bit geohash-land hash.bits = 0xfe00000000000000l; east = hash.getEasternNeighbour(); assertEquals(0x5400000000000000l, east.bits); 
public void testEqualsAndHashCode ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; assertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; assertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public void testAdjacentHashes ( ) { GeoHash [ ] adjacent = GeoHash . fromGeohashString ( " dqcw4 " ) . getAdjacent ( ) ; assertEquals ( 8 , adjacent . length ) ; } 
public void testMovingInCircle ( ) { moving around hashes in a circle should be possible checkMovingInCircle(34.2, -45.123); this should also work at the "back" of the earth checkMovingInCircle(45, 180); checkMovingInCircle(90, 180); checkMovingInCircle(0, -180); } 
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; assertEquals ( start . getBoundingBox ( ) , end . getBoundingBox ( ) ) ; } 
public void testMovingAroundWorldOnHashStrips ( ) throws Exception { String [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; for ( String direction : directions ) { checkMoveAroundStrip ( direction ) ; 
private void checkMoveAroundStrip ( String direction ) throws Exception { for ( int bits = 2 ; bits < 16 ; bits + + ) { double randomLatitude = ( rand . nextDouble ( ) - 0.5 ) * 180 ; 
public void testKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . toBase32 ( ) ) ; assertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . toBase32 ( ) ) ; } 
public void testKnownAdjacentNeighbours ( ) { String center = " dqcjqc " ; String [ ] adjacent = new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " u1x0dfg " ; adjacent = new String [ ] { " u1x0dg4 " , " u1x0dg5 " , " u1x0dgh " , " u1x0dfu " , " u1x0dfs " , " u1x0dfe " , " u1x0dfd " , " u1x0dff " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " sp2j " ; adjacent = new String [ ] { " ezry " , " sp2n " , " sp2q " , " sp2m " , " sp2k " , " sp2h " , " ezru " , " ezrv " } ; assertAdjacentHashesAre ( center , adjacent ) ; } 
private void assertAdjacentHashesAre ( String centerString , String [ ] adjacentStrings ) { GeoHash center = GeoHash . fromGeohashString ( centerString ) ; GeoHash [ ] adjacent = center . getAdjacent ( ) ; for ( String check : adjacentStrings ) { assertArrayContainsGeoHash ( check , adjacent ) ; 
private void assertArrayContainsGeoHash ( String check , GeoHash [ ] hashes ) { boolean found = false ; for ( GeoHash hash : hashes ) { if ( hash . toBase32 ( ) . equals ( check ) ) { found = true ; break ; } } assertTrue ( " Array should contain " + check , found ) ; } 
public void testNeibouringHashesNearMeridian ( ) { GeoHash hash = GeoHash . fromGeohashString ( " sp2j " ) ; GeoHash west = hash . getWesternNeighbour ( ) ; assertEquals ( " ezrv " , west . toBase32 ( ) ) ; west = west . getWesternNeighbour ( ) ; assertEquals ( " ezrt " , west . toBase32 ( ) ) ; } 
public void testIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = " dr4jb0bn2180 " ; GeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; assertEquals ( hash , fromRef ) ; assertEquals ( base32 , hash . toBase32 ( ) ) ; assertEquals ( base32 , fromRef . toBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; assertEquals ( " dr4jb0bn21 " , hash . toBase32 ( ) ) ; } 
public void testSimpleWithin ( ) { GeoHash hash = GeoHash . withBitPrecision ( 70 , - 120 , 8 ) ; GeoHash inside = GeoHash . withBitPrecision ( 74 , - 130 , 64 ) ; assertWithin ( inside , hash ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( hash . getBoundingBox ( ) ) ; } 
public void testNext ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; GeoHash next = hash . next ( ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public void testNextPrev ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 35 ) ; GeoHash next = hash . next ( 2 ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; GeoHash prev1 = next . prev ( ) ; GeoHash prev2 = prev1 . next ( - 1 ) ; assertTrue ( prev1 . compareTo ( next ) < 0 ) ; System . out . println ( " hash: " + hash . toBase32 ( ) ) ; System . out . println ( " next: " + next . toBase32 ( ) ) ; System . out . println ( " prev1: " + prev1 . toBase32 ( ) ) ; System . out . println ( " prev2: " + prev2 . toBase32 ( ) ) ; assertTrue ( prev2 . compareTo ( prev1 ) < 0 ) ; assertTrue ( prev2 . compareTo ( hash ) = = 0 ) ; } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getTopRight ( ) ) < = 0 ; } 
public GeoHash next ( ) { if ( alreadyUsed . size ( ) = = maxSamples ) return null ; int idx = rand . nextInt ( maxSamples + 1 ) ; while ( alreadyUsed . contains ( idx ) ) { idx = rand . nextInt ( maxSamples + 1 ) ; } alreadyUsed . add ( idx ) ; GeoHash gh = boundingBox . getBottomLeft ( ) . next ( idx ) ; if ( ! boundingBox . getBoundingBox ( ) . contains ( gh . getPoint ( ) ) ) return next ( ) ; return gh ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; GeoHash topRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; GeoHash topRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public void testIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void testIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void testSampler ( ) { BoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < String > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . toBase32 ( ) ) ) ; hashes . add ( gh . toBase32 ( ) ) ; if ( prev ! = null ) sumOfComp + = prev . compareTo ( gh ) ; prev = gh ; if ( sumOfComp = = 0 ) crossingZero + + ; gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; The expected value of the sum should be zero. This checks that it is at least close. Worst case is 12875 or -12875 so -40 is sufficiently close assertEquals(-40, sumOfComp); Check that the sum is zero a number of times, to make sure values are increasing and decreasing. assertEquals(123, crossingZero); } 
public GeoHash next ( int step ) { return fromOrd ( ord ( ) + step , significantBits ) ; } 
public long ord ( ) { int insignificantBits = 64 - significantBits ; return bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { int insignificantBits = 64 - significantBits ; return fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash two ) { if ( one . significantBits ( ) ! = two . significantBits ( ) ) tthrow new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; treturn two . ord ( ) - one . ord ( ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String bottomLeft = base32 . substring ( 0 , 7 ) ; String topRight = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( bottomLeft ) , GeoHash . fromGeohashString ( topRight ) ) ; } 
public String toBase32 ( ) { return bottomLeft . toBase32 ( ) + topRight . toBase32 ( ) ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) { treturn true ; } if ( obj instanceof BoundingBox ) { tBoundingBox that = ( BoundingBox ) obj ; 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { tthrow new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { tGeoHash geohash = new GeoHash ( ) ; tfor ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { tgeohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { tgeohash . addOffBitToEnd ( ) ; } else { tthrow new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } tgeohash . bits < < = ( 64 - geohash . significantBits ) ; tlong [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; tlong [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; treturn geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public GeoHash next ( int step ) { treturn fromOrd ( ord ( ) + step , significantBits ) ; } 
public long ord ( ) { tint insignificantBits = 64 - significantBits ; treturn bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { tint insignificantBits = 64 - significantBits ; treturn fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash two ) { if ( one . significantBits ( ) ! = two . significantBits ( ) ) { tthrow new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; } treturn two . ord ( ) - one . ord ( ) ; } 
public boolean contains ( GeoHash hash ) { tfor ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) { treturn true ; } } treturn false ; } 
public boolean hasNext ( ) { treturn current . compareTo ( boundingBox . getTopRight ( ) ) < = 0 ; } 
public void remove ( ) { tthrow new UnsupportedOperationException ( ) ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { tGeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; tGeoHash topRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; treturn new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { tGeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; tGeoHash topRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; treturn new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { tString bottomLeft = base32 . substring ( 0 , 7 ) ; tString topRight = base32 . substring ( 7 ) ; treturn new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( bottomLeft ) , GeoHash . fromGeohashString ( topRight ) ) ; } 
public String toBase32 ( ) { treturn bottomLeft . toBase32 ( ) + topRight . toBase32 ( ) ; } 
public void testSize ( ) { tBoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; tassertHeightIs ( bbox , 45 ) ; tassertWidthIs ( bbox , 30 ) ; tbbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; tassertHeightIs ( bbox , 90 ) ; tassertWidthIs ( bbox , 52.5 ) ; tbbox = new BoundingBox ( - 44 , - 46.1 , - 127.2 , - 128 ) ; tassertHeightIs ( bbox , 2.1 ) ; tassertWidthIs ( bbox , 0.8 ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; tcheckSearchYieldsCorrectHashes ( 47.447907 , 47.300200 , 8.760941 , 8.471276 , " u0qj " ) ; tcheckSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , tString . . . hashes ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) 
public void testNextPrev ( ) { tdouble lat = 37.7 ; tdouble lon = - 122.52 ; tGeoHash hash = GeoHash . withBitPrecision ( lat , lon , 35 ) ; tGeoHash next = hash . next ( 2 ) ; tassertTrue ( hash . compareTo ( next ) < 0 ) ; tGeoHash prev1 = next . prev ( ) ; tGeoHash prev2 = prev1 . next ( - 1 ) ; tassertTrue ( prev1 . compareTo ( next ) < 0 ) ; tSystem . out . println ( " hash: " + hash . toBase32 ( ) ) ; tSystem . out . println ( " next: " + next . toBase32 ( ) ) ; tSystem . out . println ( " prev1: " + prev1 . toBase32 ( ) ) ; tSystem . out . println ( " prev2: " + prev2 . toBase32 ( ) ) ; tassertTrue ( prev2 . compareTo ( prev1 ) < 0 ) ; tassertTrue ( prev2 . compareTo ( hash ) = = 0 ) ; } 
public void testVincenty ( ) { tWGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; tint distanceInMeters = 10000 ; tWGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , tdistanceInMeters ) ; tAssert . assertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; tAssert . assertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; tAssert . assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( tstartPoint , result ) , DELTA ) ; tWGS84Point p1 = new WGS84Point ( 1 , 1 ) ; tint tenThousandKilometers = 10000000 ; tWGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , tenThousandKilometers ) ; tSystem . out . println ( p2 ) ; tAssert . assertEquals ( tenThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public void testEquals ( ) { tassertEquals ( a , a ) ; tassertEquals ( a , b ) ; tassertEquals ( b , a ) ; tassertNotSame ( a , b ) ; tassertFalse ( a . equals ( c ) ) ; tassertFalse ( c . equals ( a ) ) ; tassertFalse ( d . equals ( c ) ) ; tassertFalse ( d . equals ( a ) ) ; tassertFalse ( d . equals ( new Integer ( 10 ) ) ) ; } 
public void testIter ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; tBoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; tList < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; twhile ( iter . hasNext ( ) ) { thashes . add ( iter . next ( ) ) ; } tGeoHash prev = null ; tfor ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void testIter2 ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; tBoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; tList < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; twhile ( iter . hasNext ( ) ) { thashes . add ( iter . next ( ) ) ; } tGeoHash prev = null ; tfor ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void testSampler ( ) { tBoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; tbbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; tGeoHash gh = sampler . next ( ) ; tSet < String > hashes = new HashSet < String > ( ) ; tint sumOfComp = 0 ; tint crossingZero = 0 ; tGeoHash prev = null ; twhile ( gh ! = null ) { tassertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; tassertFalse ( hashes . contains ( gh . toBase32 ( ) ) ) ; thashes . add ( gh . toBase32 ( ) ) ; if ( prev ! = null ) { tsumOfComp + = prev . compareTo ( gh ) ; } tprev = gh ; if ( sumOfComp = = 0 ) { tcrossingZero + + ; } tgh = sampler . next ( ) ; } tassertEquals ( 12875 , hashes . size ( ) ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlatBits [ 0 ] < < = 1 ; } else { tdivideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( 64 - hash . significantBits ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . point = hash . boundingBox . getCenterPoint ( ) ; treturn hash ; } 
public void testThatAdjacentHashesHavePointInitialized ( ) { tString center = " dqcjqc " ; tGeoHash geohash = GeoHash . fromGeohashString ( center ) ; tGeoHash [ ] adjacentHashes = geohash . getAdjacent ( ) ; tfor ( GeoHash adjacentHash : adjacentHashes ) { tassertNotNull ( adjacentHash . getBoundingBox ( ) ) ; 
public void testGetCharacterPrecisionThrows ( ) throws Exception { tGeoHash hash = GeoHash . withBitPrecision ( 37.7 , - 122.52 , 32 ) ; thash . getCharacterPrecision ( ) ; } 
public void testGetCharacterPrecisionWorksWhenPrecisionIsMultipleOfFive ( ) throws Exception { tGeoHash hash = GeoHash . withBitPrecision ( 37.7 , - 122.52 , 60 ) ; tint precision = hash . getCharacterPrecision ( ) ; tassertEquals ( precision , 12 ) ; } 
public static String geoHashStringWithCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { GeoHash hash = withCharacterPrecision ( latitude , longitude , numberOfCharacters ) ; return hash . toBase32 ( ) ; } 
public void testByCharacterPrecision ( ) { tassertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; tWGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; tString fullStringValue = " hf7u8p8gn747 " ; tfor ( int characters = 12 ; characters > 1 ; characters - - ) { tassertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } tassertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; String geoHashString = GeoHash . geoHashStringWithCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 12 ) ; assertEquals ( fullStringValue , geoHashString ) ; } 
public static String geoHashStringWithCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { tGeoHash hash = withCharacterPrecision ( latitude , longitude , numberOfCharacters ) ; treturn hash . toBase32 ( ) ; } 
public String toBase32 ( ) { if ( significantBits % 5 ! = 0 ) { tthrow new IllegalStateException ( " Cannot convert a geohash to base32 if the precision is not a multiple of 5. " ) ; } tStringBuilder buf = new StringBuilder ( ) ; tlong firstFiveBitsMask = 0xf800000000000000l ; tlong bitsCopy = bits ; tint partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; tfor ( int i = 0 ; i < partialChunks ; i + + ) { tint pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; tbuf . append ( base32 [ pointer ] ) ; tbitsCopy < < = 5 ; } treturn buf . toString ( ) ; } 
public void toBase32ShouldThrowWhenPrecisionIsNotAMultipleOf5 ( ) { thash . bits = 0x6ff0413000000000l ; thash . significantBits = 24 ; thash . toBase32 ( ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { tassertTrue ( hash + " should be within " + bbox , hash . within ( bbox ) ) ; } 
public void testNotWithin ( ) { thash . bits = 0x6ff0414000000000l ; thash . significantBits = 25 ; tassertEquals ( " ezs42 " , hash . toBase32 ( ) ) ; tGeoHash bbox = new GeoHash ( ) ; tbbox . bits = 0x6fc0000000000000l ; tbbox . significantBits = 12 ; tassertFalse ( hash + " should NOT be within " + bbox , hash . within ( bbox ) ) ; } 
public void testByCharacterPrecision ( ) { tassertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; tassertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; tWGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; tString fullStringValue = " hf7u8p8gn747 " ; tfor ( int characters = 12 ; characters > 1 ; characters - - ) { tassertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } tassertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; tString geoHashString = GeoHash . geoHashStringWithCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 12 ) ; tassertEquals ( fullStringValue , geoHashString ) ; } 
public void testThatAdjacentHashesHavePointInitialized ( ) { tString center = " dqcjqc " ; tGeoHash geohash = GeoHash . fromGeohashString ( center ) ; tGeoHash [ ] adjacentHashes = geohash . getAdjacent ( ) ; tfor ( GeoHash adjacentHash : adjacentHashes ) { tassertNotNull ( adjacentHash . getBoundingBox ( ) ) ; 
public int compareTo ( GeoHash o ) { tint bitsCmp = Long . compare ( bits ^ FIRST_BIT_FLAGGED , o . bits ^ FIRST_BIT_FLAGGED ) ; if ( bitsCmp ! = 0 ) { treturn bitsCmp ; 
public void testCompareTo ( ) { tGeoHash prevHash = null ; tfor ( int i = 0 ; i < 1000000 ; i + + ) { tdouble latitude = rand . nextDouble ( ) * 180 - 90 ; 
public void setupBenchmark ( ) { thashes = new GeoHash [ NUMBER_OF_HASHES ] ; } 
public void benchmarkGeoHashEncoding ( ) { tfor ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { thashes [ i ] = RandomGeohashes . createWithPrecision ( 60 ) ; 
private void checkMoveAroundStrip ( String direction ) throws Exception { tfor ( int bits = 2 ; bits < 16 ; bits + + ) { 
public void testCompareTo ( ) { tGeoHash prevHash = null ; tfor ( int i = 0 ; i < 10000 ; i + + ) { tGeoHash hash = RandomGeohashes . createWith5BitsPrecision ( ) ; 
public static GeoHash create ( ) { treturn GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomPrecision ( ) ) ; } 
public static GeoHash createWith5BitsPrecision ( ) { treturn GeoHash . withCharacterPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomCharacterPrecision ( ) ) ; } 
public static GeoHash createWithPrecision ( int precision ) { treturn GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , precision ) ; } 
private static double randomLatitude ( ) { treturn ( rand . nextDouble ( ) - 0.5 ) * 180 ; } 
private static double randomLongitude ( ) { treturn ( rand . nextDouble ( ) - 0.5 ) * 360 ; } 
private static int randomPrecision ( ) { treturn rand . nextInt ( 60 ) + 5 ; } 
private static int randomCharacterPrecision ( ) { treturn rand . nextInt ( 12 ) + 1 ; } 
public int compareTo ( GeoHash o ) { tint bitsCmp = Long . compare ( bits ^ FIRST_BIT_FLAGGED , o . bits ^ FIRST_BIT_FLAGGED ) ; if ( bitsCmp ! = 0 ) { treturn bitsCmp ; 
public void testVincenty ( ) { tWGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; tint distanceInMeters = 10000 ; tWGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , tdistanceInMeters ) ; tassertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; tassertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; tassertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( tstartPoint , result ) , DELTA ) ; tWGS84Point p1 = new WGS84Point ( 1 , 1 ) ; tint tenThousandKilometers = 10000000 ; tWGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , tenThousandKilometers ) ; tSystem . out . println ( p2 ) ; tassertEquals ( tenThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public void testIter ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; tBoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; tList < GeoHash > hashes = new ArrayList < > ( ) ; twhile ( iter . hasNext ( ) ) { thashes . add ( iter . next ( ) ) ; } tGeoHash prev = null ; tfor ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void testIter2 ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; tBoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; tList < GeoHash > hashes = new ArrayList < > ( ) ; twhile ( iter . hasNext ( ) ) { thashes . add ( iter . next ( ) ) ; } tGeoHash prev = null ; tfor ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void testSampler ( ) { tBoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; tbbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; tGeoHash gh = sampler . next ( ) ; tSet < String > hashes = new HashSet < > ( ) ; tint sumOfComp = 0 ; tint crossingZero = 0 ; tGeoHash prev = null ; twhile ( gh ! = null ) { tassertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; tassertFalse ( hashes . contains ( gh . toBase32 ( ) ) ) ; thashes . add ( gh . toBase32 ( ) ) ; if ( prev ! = null ) { tsumOfComp + = prev . compareTo ( gh ) ; } tprev = gh ; if ( sumOfComp = = 0 ) { tcrossingZero + + ; } tgh = sampler . next ( ) ; } tassertEquals ( 12875 , hashes . size ( ) ) ; } 
public Iterator < GeoHash > iterator ( ) { tRandom rand = new Random ( ) ; tList < GeoHash > hashes = new ArrayList < > ( ) ; tfor ( double lat = - 90 ; lat < = 90 ; lat + = rand . nextDouble ( ) + 1.45 ) { tfor ( double lon = - 180 ; lon < = 180 ; lon + = rand . nextDouble ( ) + 1.54 ) { tfor ( int precisionChars = 6 ; precisionChars < = 12 ; precisionChars + + ) { tGeoHash gh = GeoHash . withCharacterPrecision ( lat , lon , precisionChars ) ; thashes . add ( gh ) ; } } } treturn hashes . iterator ( ) ; } 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { if ( numberOfCharacters > MAX_CHARACTER_PRECISION ) { tthrow new IllegalArgumentException ( " A geohash can only be " + MAX_CHARACTER_PRECISION + " character long. " ) ; } tint desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; treturn new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( numberOfBits > MAX_BIT_PRECISION ) { tthrow new IllegalArgumentException ( " A Geohash can only be " + MAX_BIT_PRECISION + " bits long! " ) ; } if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { tthrow new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { tGeoHash geohash = new GeoHash ( ) ; tfor ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { tgeohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { tgeohash . addOffBitToEnd ( ) ; } else { tthrow new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } tgeohash . bits < < = ( MAX_BIT_PRECISION - geohash . significantBits ) ; tlong [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; tlong [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; treturn geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < geohash . length ( ) ; i + + ) { tint cd = decodeMap . get ( geohash . charAt ( i ) ) ; tfor ( int j = 0 ; j < BASE32_BITS ; j + + ) { tint mask = BITS [ j ] ; if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; treturn hash ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tString binaryString = Long . toBinaryString ( hashVal ) ; twhile ( binaryString . length ( ) < MAX_BIT_PRECISION ) { tbinaryString = " 0 " + binaryString ; } tfor ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { tdivideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } tisEvenBit = ! isEvenBit ; } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; treturn hash ; } 
public long ord ( ) { tint insignificantBits = MAX_BIT_PRECISION - significantBits ; treturn bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { tint insignificantBits = MAX_BIT_PRECISION - significantBits ; treturn fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( MAX_BIT_PRECISION - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( MAX_BIT_PRECISION - lonBits [ 1 ] ) ; tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlatBits [ 0 ] < < = 1 ; } else { tdivideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . point = hash . boundingBox . getCenterPoint ( ) ; treturn hash ; } 
private long maskLastNBits ( long value , long ) { tlong mask = 0xffffffffffffffffl ; tmask > > > = ( MAX_BIT_PRECISION - ) ; treturn value & mask ; } 
public void itShouldCreateAHashWithMaximumPrecisionOf64Bits ( ) { tGeoHash . withBitPrecision ( 10.0 , 10.0 , 64 ) ; } 
public void itShouldThrowWhenTheBitPrecisionIsMoreThan64Bits ( ) { tGeoHash . withBitPrecision ( 46.0 , 8.0 , 70 ) ; } 
public void itShouldThrowWhenTheCharacterPrecisionIsTooBig ( ) { tGeoHash . withCharacterPrecision ( 10.0 , 120.0 , 14 ) ; } 
public long ord ( ) { tint insignificantBits = 64 - significantBits ; tlong bitMask = ( 1L < < significantBits ) - 1 ; treturn ( bits > > insignificantBits ) & bitMask ; } 
public void testOrdIsPositive ( ) { tdouble lat = 40.390943 ; tdouble lon = 75.9375 ; tGeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; tassertEquals ( 0xcf6915015410500l , hash . ord ( ) ) ; tassertTrue ( hash . ord ( ) > = 0 ) ; } 
public long ord ( ) { tint insignificantBits = 64 - significantBits ; treturn bits > > > insignificantBits ; } 
public void testSecondCaseWhereOrdMustBePositive ( ) { tGeoHash hash = GeoHash . withCharacterPrecision ( - 36.919550434870125 , 174.71024582237604 , 7 ) ; tassertTrue ( hash . ord ( ) > 0 ) ; } 
public long ord ( ) { tint insignificantBits = MAX_BIT_PRECISION - significantBits ; treturn bits > > > insignificantBits ; } 
public void testIter ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; tcheckIterator ( iter ) ; } 
public void testIter2 ( ) { tBoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; tcheckIterator ( iter ) ; } 
public void testIter3 ( ) { tBoundingBox box = new BoundingBox ( 28.5 , 67.15 , - 33.2 , 44.5 ) ; tBoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( tTwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ) ; tList < GeoHash > hashes = checkIterator ( iter ) ; tassertThat ( hashes . size ( ) , is ( 49 ) ) ; } 
public void testEndlessIterator ( ) { tBoundingBox box = new BoundingBox ( 72.28907f , 88.62655f , - 50.976562f , 170.50781f ) ; tTwoGeoHashBoundingBox twoGeoHashBoundingBox = TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ; tBoundingBoxGeoHashIterator iterator = new BoundingBoxGeoHashIterator ( twoGeoHashBoundingBox ) ; tSet < GeoHash > hashes = new HashSet < > ( ) ; twhile ( iterator . hasNext ( ) ) { tGeoHash hash = iterator . next ( ) ; 
public void testAllCells ( ) { tBoundingBox box = new BoundingBox ( - 90 , 90 , - 180 , 180 ) ; tTwoGeoHashBoundingBox twoGeoHashBoundingBox = TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ; tBoundingBoxGeoHashIterator iterator = new BoundingBoxGeoHashIterator ( twoGeoHashBoundingBox ) ; tSet < GeoHash > hashes = new HashSet < > ( ) ; twhile ( iterator . hasNext ( ) ) { tGeoHash hash = iterator . next ( ) ; thashes . add ( hash ) ; } tassertThat ( hashes . size ( ) , is ( 1024 ) ) ; } 
public void testTopRightCorner ( ) { tBoundingBox box = new BoundingBox ( 84.4 , 84.9 , 169.3 , 179.6 ) ; GeoHash hash = iterator.next(); 
private List < GeoHash > checkIterator ( BoundingBoxGeoHashIterator iter ) { tBoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; tList < GeoHash > hashes = new ArrayList < > ( ) ; twhile ( iter . hasNext ( ) ) { thashes . add ( iter . next ( ) ) ; } tGeoHash prev = null ; tfor ( GeoHash gh : hashes ) { if ( prev ! = null ) { tAssert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; } tAssert . assertTrue ( newBox . contains ( gh . getPoint ( ) ) ) ; tprev = gh ; } treturn hashes ; } 
public int hashCode ( ) { tint result = 17 ; tresult = 37 * result + hashCode ( southLatitude ) ; tresult = 37 * result + hashCode ( northLatitude ) ; tresult = 37 * result + hashCode ( westLongitude ) ; tresult = 37 * result + hashCode ( eastLongitude ) ; treturn result ; } 
public boolean contains ( WGS84Point point ) { treturn containsLatitude ( point . getLatitude ( ) ) & & containsLongitude ( point . getLongitude ( ) ) ; } 
public boolean intersects ( BoundingBox other ) { return false; 
public String toString ( ) { treturn getNorthWestPoint ( ) + " -> " + getSouthEastPoint ( ) ; } 
private boolean containsLatitude ( double latitude ) { treturn latitude > = southLatitude & & latitude < = northLatitude ; } 
private boolean containsLongitude ( double longitude ) { if ( intersects180Meridian ) { treturn longitude < = eastLongitude | | longitude > = westLongitude ; 
public boolean intersects180Meridian ( ) { treturn intersects180Meridian ; } 
private void generateSearchHashes ( BoundingBox bbox ) { tint fittingBits = GeoHashSizeTable . numberOfBitsForOverlappingGeoHash ( bbox ) ; tWGS84Point center = bbox . getCenterPoint ( ) ; tGeoHash centerHash = GeoHash . withBitPrecision ( center . getLatitude ( ) , center . getLongitude ( ) , fittingBits ) ; if ( hashContainsBoundingBox ( centerHash , bbox ) ) { If the centerHash completly fits into the provided bounding box, just add the hash and continue 
private boolean hashContainsBoundingBox ( GeoHash hash , BoundingBox bbox ) { treturn hash . contains ( bbox . getNorthWestPoint ( ) ) & & hash . contains ( bbox . getSouthEastPoint ( ) ) ; } 
public boolean hasNext ( ) { treturn current . compareTo ( boundingBox . getNorthWest ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { tGeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; tGeoHash topRight = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; treturn new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { tGeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; tGeoHash topRight = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; treturn new TwoGeoHashBoundingBox ( bottomLeft , topRight ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { tString southWestBase32 = base32 . substring ( 0 , 7 ) ; tString northEastBase32 = base32 . substring ( 7 ) ; treturn new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( southWestBase32 ) , GeoHash . fromGeohashString ( northEastBase32 ) ) ; } 
public String toBase32 ( ) { treturn southEast . toBase32 ( ) + northWest . toBase32 ( ) ; } 
public void testEqualsObject ( ) { tassertEquals ( a , b ) ; tassertEquals ( b , a ) ; tassertFalse ( a . equals ( c ) ) ; tassertEquals ( d , e ) ; tassertEquals ( e , d ) ; tassertFalse ( c . equals ( d ) ) ; tassertFalse ( c . equals ( a ) ) ; } 
public void testContains ( ) { tBoundingBox bbox = new BoundingBox ( 45 , 46 , 120 , 121 ) ; tassertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; tassertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
public void testSize ( ) { tBoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; tassertHeightIs ( bbox , 45 ) ; tassertWidthIs ( bbox , 30 ) ; tbbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; tassertHeightIs ( bbox , 90 ) ; tassertWidthIs ( bbox , 52.5 ) ; tbbox = new BoundingBox ( - 46.1 , - 44 , - 128 , - 127.2 ) ; tassertHeightIs ( bbox , 2.1 ) ; tassertWidthIs ( bbox , 0.8 ) ; } 
public void testIntersects ( ) { tBoundingBox bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; tassertIntersects ( bbox , new BoundingBox ( - 15 , 5 , 40.5 , 43 ) ) ; tassertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 42 , 43 ) ) ; } 
public void testSeveralBoundingBoxes ( ) { tcheckSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; tcheckSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 41.23452234 , 30.0113312322 , 31.23432 ) ; tcheckSearchYieldsCorrectHashes ( 47.300200 , 47.447907 , 8.471276 , 8.760941 , " u0qj " ) ; tcheckSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double southLat , double northLat , double westLon , double eastLon ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; tassertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double southLat , double northLat , double westLon , double eastLon , String . . . hashes ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain ' " + expectedHash + " ':' " + GeoHash . fromGeohashString ( expectedHash ) + " '. Saved hashes: n " + search , search . getSearchHashes ( ) . contains ( GeoHash . fromGeohashString ( expectedHash ) ) ) ; 
private void checkSearchYieldsCorrectBinaryHashes ( double southLat , double northLat , double westLon , double eastLon , String . . . hashes ) { tGeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; tassertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; tfor ( String expectedHash : hashes ) { tassertTrue ( " search hashes should contain ' " + expectedHash + " ':' " + GeoHash . fromBinaryString ( expectedHash ) + " '. Saved hashes: n " + search , search . getSearchHashes ( ) . contains ( GeoHash . fromBinaryString ( expectedHash ) ) ) ; 
private void assertRightNumberOfSearchHashes ( GeoHashQuery search ) { tint size = search . getSearchHashes ( ) . size ( ) ; tassertTrue ( size < = 8 & & size > 0 ) ; } 
public void testIssue3WithCircleQuery ( ) throws Exception { tWGS84Point center = new WGS84Point ( 39.86391280373075 , 116.37356590048701 ) ; tGeoHashCircleQuery query = new GeoHashCircleQuery ( center , 589 ) ; } 
public void test180MeridianCircleQuery ( ) throws Exception { } 
public String toString ( ) { if ( significantBits % 5 = = 0 ) { treturn String . format ( " %s -> %s -> %s " , padLeft ( Long . toBinaryString ( bits ) , 64 , " 0 " ) , boundingBox , toBase32 ( ) ) ; 
private static String padLeft ( String s , int , String pad ) { treturn String . format ( " % " + + " s " , s ) . replace ( " " , pad ) ; } 
public BoundingBox generate ( int bits ) { } 
public boolean hasNext ( ) { treturn current . compareTo ( boundingBox . getNorthEast ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash southWest = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; GeoHash northEast = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( southWest , northEast ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash southWest = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; GeoHash northEast = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( southWest , northEast ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String southWestBase32 = base32 . substring ( 0 , 7 ) ; String northEastBase32 = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( southWestBase32 ) , GeoHash . fromGeohashString ( northEastBase32 ) ) ; } 
public String toBase32 ( ) { return southWest . toBase32 ( ) + northEast . toBase32 ( ) ; } 
public String toString ( ) { treturn getNorthWestCorner ( ) + " -> " + getSouthEastCorner ( ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { tGeoHash hash = new GeoHash ( ) ; tboolean isEvenBit = false ; tlatBits [ 0 ] < < = ( MAX_BIT_PRECISION - latBits [ 1 ] ) ; tlonBits [ 0 ] < < = ( MAX_BIT_PRECISION - lonBits [ 1 ] ) ; tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tfor ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { tdivideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlatBits [ 0 ] < < = 1 ; } else { tdivideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; tlonBits [ 0 ] < < = 1 ; } tisEvenBit = ! isEvenBit ; } thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . point = hash . boundingBox . getCenter ( ) ; treturn hash ; } 
private void generateSearchHashes ( BoundingBox bbox ) { tint fittingBits = GeoHashSizeTable . numberOfBitsForOverlappingGeoHash ( bbox ) ; tWGS84Point center = bbox . getCenter ( ) ; tGeoHash centerHash = GeoHash . withBitPrecision ( center . getLatitude ( ) , center . getLongitude ( ) , fittingBits ) ; if ( hashContainsBoundingBox ( centerHash , bbox ) ) { If the centerHash completly fits into the provided bounding box, just add the hash and continue 
private boolean hashContainsBoundingBox ( GeoHash hash , BoundingBox bbox ) { treturn hash . contains ( bbox . getNorthWestCorner ( ) ) & & hash . contains ( bbox . getSouthEastCorner ( ) ) ; } 
public boolean hasNext ( ) { treturn current . compareTo ( boundingBox . getNorthEastCorner ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { tGeoHash southWestCorner = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; tGeoHash northEastCorner = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; treturn new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { tGeoHash southWestCorner = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; tGeoHash northEastCorner = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; treturn new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; } 
public String toBase32 ( ) { treturn southWestCorner . toBase32 ( ) + northEastCorner . toBase32 ( ) ; } 
private void printBoundingBox ( GeoHash hash ) { tSystem . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenter ( ) ) ; tSystem . out . print ( " corners= " ) ; tSystem . out . println ( hash . getBoundingBox ( ) ) ; } 
public void testSampler ( ) { tBoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; tBoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; tbbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; tGeoHash gh = sampler . next ( ) ; tSet < String > hashes = new HashSet < > ( ) ; tint sumOfComp = 0 ; tint crossingZero = 0 ; tGeoHash prev = null ; twhile ( gh ! = null ) { tassertTrue ( bbox . contains ( gh . getOriginatingPoint ( ) ) ) ; tassertFalse ( hashes . contains ( gh . toBase32 ( ) ) ) ; thashes . add ( gh . toBase32 ( ) ) ; if ( prev ! = null ) { tsumOfComp + = prev . compareTo ( gh ) ; } tprev = gh ; if ( sumOfComp = = 0 ) { tcrossingZero + + ; } tgh = sampler . next ( ) ; } tassertEquals ( 12875 , hashes . size ( ) ) ; } 
public void expandToInclude ( WGS84Point point ) { } 
public static double remainderWithFix ( double value , int remainder ) { tdouble res = value % remainder ; } 
private void assertExpandToInclude ( BoundingBox bbox , double southLatitude , double northLatitude , double westLongitude , double eastLongitude ) { tassertEquals ( southLatitude , bbox . getSouthLatitude ( ) , DELTA ) ; tassertEquals ( northLatitude , bbox . getNorthLatitude ( ) , DELTA ) ; tassertEquals ( westLongitude , bbox . getWestLongitude ( ) , DELTA ) ; tassertEquals ( eastLongitude , bbox . getEastLongitude ( ) , DELTA ) ; } 
public void testPositiveValue ( ) { tassertEquals ( 58.1541 , DoubleUtil . remainderWithFix ( 58.1541 , 360 ) , 0.00001 ) ; tassertEquals ( 93.1541 , DoubleUtil . remainderWithFix ( 453.1541 , 360 ) , 0.00001 ) ; } 
public void testNegativeValue ( ) { tassertEquals ( 301.8459 , DoubleUtil . remainderWithFix ( - 58.1541 , 360 ) , 0.00001 ) ; tassertEquals ( 266.8459 , DoubleUtil . remainderWithFix ( - 453.1541 , 360 ) , 0.00001 ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < geohash . length ( ) ; i + + ) { if ( decodeMap . containsKey ( geohash . charAt ( i ) ) ) { tint cd = decodeMap . get ( geohash . charAt ( i ) ) ; tfor ( int j = 0 ; j < BASE32_BITS ; j + + ) { tint mask = BITS [ j ] ; if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } else { tthrow new IllegalArgumentException ( " Invalid character character ' " + geohash . charAt ( i ) + " ' in geohash ' " + geohash + " '! " ) ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; treturn hash ; } 
public void itShouldThrowANiceExceptionOnIllegalCharacters ( ) { tGeoHash . fromGeohashString ( " abba " ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { tdouble [ ] latitudeRange = { - 90.0 , 90.0 } ; tdouble [ ] longitudeRange = { - 180.0 , 180.0 } ; tboolean isEvenBit = true ; tGeoHash hash = new GeoHash ( ) ; tfor ( int i = 0 ; i < geohash . length ( ) ; i + + ) { tchar c = geohash . charAt ( i ) ; tint cd ; if ( c > = decodeArray . length | | ( cd = decodeArray [ c ] ) < 0 ) { tthrow new IllegalArgumentException ( " Invalid character character ' " + c + " ' in geohash ' " + geohash + " '! " ) ; } tfor ( int j = 0 ; j < BASE32_BITS ; j + + ) { tint mask = BITS [ j ] ; if ( isEvenBit ) { tdivideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { tdivideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } tisEvenBit = ! isEvenBit ; } } tdouble latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; tdouble longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; thash . point = new WGS84Point ( latitude , longitude ) ; tsetBoundingBox ( hash , latitudeRange , longitudeRange ) ; thash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; treturn hash ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( numberOfBits < 0 ) { tthrow new IllegalArgumentException ( " A Geohash can't be of negative bits long! " ) ; } if ( numberOfBits > MAX_BIT_PRECISION ) { tthrow new IllegalArgumentException ( " A Geohash can only be " + MAX_BIT_PRECISION + " bits long! " ) ; } if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { tthrow new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } treturn new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public void itShouldCreateAHashWithMinimumPrecisionOf0Bits ( ) { tGeoHash . withBitPrecision ( 10.0 , 10.0 , 0 ) ; } 
public void itShouldThrowWhenTheBitPrecisionIsLessThan0Bits ( ) { tGeoHash . withBitPrecision ( 46.0 , 8.0 , - 1 ) ; } 
public void itShouldCreateAHashWithMinimumPrecisionOf0Bits ( ) { tGeoHash geoHash = GeoHash . withBitPrecision ( 10.0 , 10.0 , 0 ) ; tassertEquals ( 0 , geoHash . significantBits ( ) ) ; tassertEquals ( 0 , geoHash . longValue ( ) ) ; tassertEquals ( new WGS84Point ( 10.0 , 10.0 ) , geoHash . getOriginatingPoint ( ) ) ; } 
public void itShouldCreateAHashWithMaximumPrecisionOf64Bits ( ) { tGeoHash geoHash = GeoHash . withBitPrecision ( 10.0 , 10.0 , 64 ) ; tassertEquals ( 64 , geoHash . significantBits ( ) ) ; tassertEquals ( 0xc07e07e07e07e07eL , geoHash . longValue ( ) ) ; tassertEquals ( new WGS84Point ( 10.0 , 10.0 ) , geoHash . getOriginatingPoint ( ) ) ; } 
