public void setupBenchmark ( ) { hashes = new GeoHash [ NUMBER_OF_HASHES ] ; latitudes = new double [ NUMBER_OF_HASHES ] ; longitudes = new double [ NUMBER_OF_HASHES ] ; Random rand = new Random ( ) ; for ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { latitudes [ i ] = rand . nextDouble ( ) * 180 - 90 ; 
public void benchmarkGeoHashEncoding ( ) { for ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { hashes [ i ] = GeoHash . withBitPrecision ( latitudes [ i ] , longitudes [ i ] , 60 ) ; 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { int desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; return new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { return null ; } 
public int significantBits ( ) { return ( int ) significantBits ; } 
public String oBase32 ( ) { StringBuffer buf = new StringBuffer ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public boolean within ( GeoHash boundingBox ) { return ( bits & boundingBox . mask ( ) ) = = boundingBox . bits ; } 
public String oString ( ) { return String . format ( " %s -> (%d,%d) " , longToBitString ( bits ) , 0 , 0 ) ; } 
public final long mask ( ) { if ( significantBits = = 0 ) { return 0 ; 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { if ( ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { hash . addOnBitToEnd ( ) ; } else { hash . addOffBitToEnd ( ) ; } latBits [ 0 ] < < = 1 ; } else { if ( ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { hash . addOnBitToEnd ( ) ; } else { hash . addOffBitToEnd ( ) ; } lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
private long maskLastNBits ( long value , long ) { long mask = 0xffffffffffffffffl ; mask > > > = ( 64 - ) ; return value & mask ; } 
protected final void addOnBitToEnd ( ) { significantBits + + ; bits < < = 1 ; bits = bits | 0x1 ; } 
protected final void addOffBitToEnd ( ) { significantBits + + ; bits < < = 1 ; } 
protected static String longToBitString ( long value ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 64 ; i > 0 ; i - - ) { long bit = value & FIRST_BIT_FLAGGED ; if ( bit = = FIRST_BIT_FLAGGED ) { buf . append ( '1' ) ; } else { buf . append ( '0' ) ; } value < < = 1 ; } return buf . oString ( ) ; } 
private void highCapDesiredPrecision ( int desiredPrecision ) { if ( desiredPrecision > 64 ) desiredPrecision = 64 ; 
public String oString ( ) { return String . format ( " (%f,%f) " , latitude , longitude ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof WGS84Point ) { WGS84Point other = ( WGS84Point ) obj ; return latitude = = other . latitude & & longitude = = other . longitude ; } return false ; } 
public void estAddingOnes ( ) { hash . addOnBitToEnd ( ) ; Assert . assertEquals ( 0x1l , hash . bits ) ; Assert . assertEquals ( 1 , hash . significantBits ( ) ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; Assert . assertEquals ( 0xfl , hash . bits ) ; Assert . assertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void estAddingZeroes ( ) { hash . addOnBitToEnd ( ) ; Assert . assertEquals ( 0x1l , hash . bits ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; Assert . assertEquals ( 0x10l , hash . bits ) ; Assert . assertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void estLongToBitString ( ) { hash . bits = 0x5555555555555555l ; Assert . assertEquals ( 
public void estToBase32 ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; String base32 = hash . oBase32 ( ) ; Assert . assertEquals ( " ezs42 " , base32 ) ; } 
public void estWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash ) ; System . out . println ( hash . oBase32 ( ) ) ; Assert . assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; Assert . assertTrue ( hash . oBase32 ( ) + " should be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; 
public void estNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; Assert . assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; Assert . assertFalse ( hash . oBase32 ( ) + " should NOT be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; 
public void estConstructorWithBitPrecision ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; Assert . assertEquals ( hash1 . significantBits , 20 ) ; System . out . println ( hash1 ) ; System . out . println ( hash1 . oBase32 ( ) ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; Assert . assertEquals ( hash2 . significantBits , 55 ) ; System . out . println ( hash2 ) ; System . out . println ( hash2 . oBase32 ( ) ) ; Assert . assertTrue ( hash2 . within ( hash1 ) ) ; } 
public void estLatLonBoundingBoxes ( ) { hash = GeoHash . withBitPrecision ( 40 , 120 , 10 ) ; System . out . println ( hash . oBase32 ( ) ) ; printBoundingBox ( hash ) ; } 
public void estByCharacterPrecision ( ) { hash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; Assert . assertEquals ( " sew1c2vs2q5r " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; Assert . assertEquals ( " ksqn1rje83g2 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; Assert . assertEquals ( " ksq9zbs0b7vw " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 12 ) ; Assert . assertEquals ( " hf7u8p8gn747 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 8 ) ; Assert . assertEquals ( " hf7u8p8g " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 4 ) ; Assert . assertEquals ( " hf7u " , hash . oBase32 ( ) ) ; } 
public void estGetLatitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; Assert . assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; Assert . assertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void estGetLongitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; Assert . assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; Assert . assertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( String . format ( " %s,%s " , hash . getBoundingBoxPoints ( ) [ 0 ] , 
public void estVincenty ( ) { WGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; int distanceInMeters = 10000 ; WGS84Point result = WGS84Point . moveInDirection ( startPoint , 120 , distanceInMeters ) ; Assert . assertEquals ( 40.10134882 , result . longitude , DELTA ) ; Assert . assertEquals ( 39.9549245 , result . latitude , DELTA ) ; Assert . assertEquals ( distanceInMeters , WGS84Point . distanceInMeters ( startPoint , result ) , DELTA ) ; WGS84Point p1 = new WGS84Point ( 1 , 1 ) ; int enThousandKilometers = 10000000 ; WGS84Point p2 = WGS84Point . moveInDirection ( p1 , 270 , enThousandKilometers ) ; System . out . println ( p2 ) ; Assert . assertEquals ( enThousandKilometers , WGS84Point . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public String oString ( ) { return String . format ( " %s -> [%s,%s] " , longToBitString ( bits ) , boundingBox [ 0 ] , boundingBox [ 1 ] ) ; } 
public void estAddingOnes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; assertEquals ( 1 , hash . significantBits ( ) ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; assertEquals ( 0xfl , hash . bits ) ; assertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void estAddingZeroes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; assertEquals ( 0x10l , hash . bits ) ; assertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void estLongToBitString ( ) { hash . bits = 0x5555555555555555l ; assertEquals ( " 0101010101010101010101010101010101010101010101010101010101010101 " , 
public void estToBase32 ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; String base32 = hash . oBase32 ( ) ; assertEquals ( " ezs42 " , base32 ) ; } 
public void estWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . oBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertTrue ( hash . oBase32 ( ) + " should be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; 
public void estNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash . oBase32 ( ) + " should NOT be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; 
public void estConstructorWithBitPrecision ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; assertEquals ( hash1 . significantBits , 20 ) ; System . out . println ( hash1 ) ; System . out . println ( hash1 . oBase32 ( ) ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; assertEquals ( hash2 . significantBits , 55 ) ; System . out . println ( hash2 ) ; System . out . println ( hash2 . oBase32 ( ) ) ; assertTrue ( hash2 . within ( hash1 ) ) ; } 
public void estByCharacterPrecision ( ) { hash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; assertEquals ( " sew1c2vs2q5r " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; assertEquals ( " ksqn1rje83g2 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; assertEquals ( " ksq9zbs0b7vw " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 12 ) ; assertEquals ( " hf7u8p8gn747 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 8 ) ; assertEquals ( " hf7u8p8g " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39 .0247389581054 , 4 ) ; assertEquals ( " hf7u " , hash . oBase32 ( ) ) ; } 
public void estGetLatitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; assertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void estGetLongitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; assertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
public void estNeighbourLocationCode ( ) { } 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = hash . oBase32 ( ) ; System . out . println ( base32 ) ; assertEquals ( " dr4jb0bn2180 " , base32 ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] points = decode ( geohash ) ; return GeoHash . withCharacterPrecision ( points [ 0 ] , points [ 1 ] , geohash . length ( ) ) ; } 
public static double [ ] decode ( String geohash ) { double [ ] lat_interval = { - 90.0 , 90.0 } ; double [ ] lon_interval = { - 180.0 , 180.0 } ; double lat_err = 90.0 ; double lon_err = 180.0 ; boolean is_even = rue ; int sz = geohash . length ( ) ; int [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; int bsz = bits . length ; double latitude , longitude ; for ( int i = 0 ; i < sz ; i + + ) { int cd = _decodemap . get ( geohash . charAt ( i ) ) ; for ( int z = 0 ; z < bsz ; z + + ) { int mask = bits [ z ] ; if ( is_even ) { lon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { lon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { lat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { lat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } is_even = is_even ? false : rue ; } } latitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; longitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; return new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public static double [ ] decode ( String geohash ) { double [ ] lat_interval = { - 90.0 , 90.0 } ; double [ ] lon_interval = { - 180.0 , 180.0 } ; double lat_err = 90.0 ; double lon_err = 180.0 ; boolean is_even = rue ; int sz = geohash . length ( ) ; int [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; int bsz = bits . length ; double latitude , longitude ; for ( int i = 0 ; i < sz ; i + + ) { int cd = _decodemap . get ( geohash . charAt ( i ) ) ; for ( int z = 0 ; z < bsz ; z + + ) { int mask = bits [ z ] ; if ( is_even ) { lon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { lon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { lat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { lat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } is_even = ! is_even ; } } latitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; longitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; return new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public void estDecode ( ) { 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += 1) { 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { int desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; return new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] lat_interval = { - 90.0 , 90.0 } ; double [ ] lon_interval = { - 180.0 , 180.0 } ; double lat_err = 90.0 ; double lon_err = 180.0 ; boolean is_even = rue ; int sz = geohash . length ( ) ; int [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; int bsz = bits . length ; double latitude , longitude ; for ( int i = 0 ; i < sz ; i + + ) { int cd = _decodemap . get ( geohash . charAt ( i ) ) ; for ( int z = 0 ; z < bsz ; z + + ) { int mask = bits [ z ] ; if ( is_even ) { lon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { lon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { lat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { lat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } is_even = ! is_even ; } } latitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; longitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; double [ ] points = new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public void setup ( ) { } @Benchmark public void benchmarkRandomEncoding ( ) { } } 
public void setup ( ) { randomHashes = new String [ NUMBER_OF_HASHES ] ; Random rand = new Random ( ) ; for ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { at least two chars 
public void benchmarkRandomDecoding ( ) { for ( String hash : randomHashes ) { GeoHash geoHash = GeoHash . fromGeohashString ( hash ) ; 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] lat_interval = { - 90.0 , 90.0 } ; double [ ] lon_interval = { - 180.0 , 180.0 } ; double lat_err = 90.0 ; double lon_err = 180.0 ; boolean is_even = rue ; int sz = geohash . length ( ) ; int [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; int bsz = bits . length ; double latitude , longitude ; for ( int i = 0 ; i < sz ; i + + ) { int cd = _decodemap . get ( geohash . charAt ( i ) ) ; for ( int z = 0 ; z < bsz ; z + + ) { int mask = bits [ z ] ; if ( is_even ) { lon_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lon_interval [ 0 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } else { lon_interval [ 1 ] = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; } } else { lat_err / = 2 ; if ( ( cd & mask ) ! = 0 ) { lat_interval [ 0 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } else { lat_interval [ 1 ] = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; } } is_even = ! is_even ; } } latitude = ( lat_interval [ 0 ] + lat_interval [ 1 ] ) / 2 ; longitude = ( lon_interval [ 0 ] + lon_interval [ 1 ] ) / 2 ; double [ ] points = new double [ ] { latitude , longitude , lat_err , lon_err } ; } 
public String oString ( ) { return String . format ( " %s -> %s " , longToBitString ( bits ) , boundingBox ! = null ? boundingBox : " null " ) ; } 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof GeoHash ) { GeoHash other = ( GeoHash ) obj ; if ( other . significantBits = = significantBits & & other . bits = = bits ) { return rue ; } } return false ; } 
public void estLongToBitString ( ) { hash . bits = 0x5555555555555555l ; assertEquals ( " 0101010101010101010101010101010101010101010101010101010101010101 " , GeoHash . longToBitString ( hash . bits ) ) ; 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += 1) { 
public void estWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . oBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertTrue ( hash . oBase32 ( ) + " should be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; } 
public void estNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash . oBase32 ( ) + " should NOT be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; } 
public void estByCharacterPrecision ( ) { hash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; assertEquals ( " sew1c2vs2q5r " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; assertEquals ( " ksqn1rje83g2 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; assertEquals ( " ksq9zbs0b7vw " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; assertEquals ( " hf7u8p8gn747 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; assertEquals ( " hf7u8p8g " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; assertEquals ( " hf7u " , hash . oBase32 ( ) ) ; } 
public void estEquals ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; } 
public void estMoveAroundWorldOnLongitudeStrip ( ) { for ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the longitude range by 2^bits 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = hash . oBase32 ( ) ; System . out . println ( base32 ) ; assertEquals ( " dr4jb0bn2180 " , base32 ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( String . format ( " %s,%s " , hash . getBoundingBoxPoints ( ) [ 0 ] , hash . getBoundingBoxPoints ( ) [ 1 ] ) ) ; } 
public void estMovingAroundWorldOnHashStrips ( ) hrows SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { String [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; for ( String direction : directions ) { checkMoveAroundStrip ( direction ) ; 
public void checkMoveAroundStrip ( String direction ) hrows SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { for ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.5) { 
public void estMovingAroundWorldOnHashStrips ( ) hrows SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { String [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; for ( String direction : directions ) { checkMoveAroundStrip ( direction ) ; 
public void checkMoveAroundStrip ( String direction ) hrows SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { for ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; GeoHash fromRef = GeoHash . fromGeohashString ( " dr4jb0bn2180 " ) ; System . out . println ( hash ) ; System . out . println ( fromRef ) ; assertEquals ( hash , fromRef ) ; } 
public int hashCode ( ) { int f = 17 ; f = 31 * f + ( int ) ( bits ^ ( bits > > > 32 ) ) ; f = 31 * f + significantBits ; return f ; } 
public void estEqualsAndHashCode ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; assertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; assertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) throw new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
protected String longToBitString ( long value ) { StringBuilder buf = new StringBuilder ( ) ; for ( int i = significantBits ; i > 0 ; i - - ) { long bit = value & FIRST_BIT_FLAGGED ; if ( bit = = FIRST_BIT_FLAGGED ) { buf . append ( '1' ) ; } else { buf . append ( '0' ) ; } value < < = 1 ; } return buf . oString ( ) ; } 
public void estEqualsAndHashCode ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; assertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; assertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public void estAdjacentHashes ( ) { GeoHash [ ] adjacent = GeoHash . fromGeohashString ( " dqcw4 " ) . getAdjacent ( ) ; assertEquals ( 8 , adjacent . length ) ; } 
public void estMovingInCircle ( ) { } 
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; } 
private void checkMoveAroundStrip ( String direction ) hrows SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { for ( int bits = 2 ; bits < 12 ; bits + + ) { this divides the range by 2^bits 
public boolean enclosesCircleAroundPoint ( WGS84Point point , double radius ) { return false ; } 
public String oString ( ) { return String . format ( " %s -> %s,%s " , longToBitString ( bits ) , upperLeft , lowerRight ) ; } 
public void estByCharacterPrecision ( ) { hash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; assertEquals ( " sew1c2vs2q5r " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; assertEquals ( " ksqn1rje83g2 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; assertEquals ( " ksq9zbs0b7vw " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; assertEquals ( " hf7u8p8gn747 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; assertEquals ( " hf7u8p8g " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; assertEquals ( " hf7u " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( 39.0247389581054 , - 76.5110040642321 , 12 ) ; assertEquals ( " dqcw4bnrs6s7 " , hash . oBase32 ( ) ) ; } 
public String oBase32 ( ) { StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; int sz = geohash . length ( ) ; int [ ] bits = { 16 , 8 , 4 , 2 , 1 } ; int bsz = bits . length ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < sz ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int z = 0 ; z < bsz ; z + + ) { int mask = bits [ z ] ; if ( isEvenBit ) { divideRange ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRange ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; hash . upperLeft = new WGS84Point ( latitudeRange [ 0 ] , longitudeRange [ 0 ] ) ; hash . lowerRight = new WGS84Point ( latitudeRange [ 1 ] , longitudeRange [ 1 ] ) ; return hash ; } 
private void divideRangeEncode ( double value , double [ ] range ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( value > = mid ) { addOnBitToEnd ( ) ; 
private static void divideRange ( GeoHash hash , double [ ] range , boolean b ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { hash . addOnBitToEnd ( ) ; 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; hash . upperLeft = new WGS84Point ( latitudeRange [ 0 ] , longitudeRange [ 0 ] ) ; hash . lowerRight = new WGS84Point ( latitudeRange [ 1 ] , longitudeRange [ 1 ] ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
private static void divideRangeDecode ( GeoHash hash , double [ ] range , boolean b ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { hash . addOnBitToEnd ( ) ; 
public String oString ( ) { return String . format ( " ( " + latitude + " , " + longitude + " ) " ) ; } 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = " dr4jb0bn2180 " ; GeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; assertEquals ( hash , fromRef ) ; assertEquals ( base32 , hash . oBase32 ( ) ) ; assertEquals ( base32 , fromRef . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; assertEquals ( " dr4jb0bn21 " , hash . oBase32 ( ) ) ; } 
private final long mask ( ) { if ( significantBits = = 0 ) { return 0 ; 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; return hash ; } 
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; assertArrayEquals ( start . getBoundingBoxPoints ( ) , end . getBoundingBoxPoints ( ) ) ; } 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.5) { 
public void estByCharacterPrecision ( ) { hash = GeoHash . withCharacterPrecision ( 20 , 31 , 12 ) ; assertEquals ( " sew1c2vs2q5r " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20 , 31 , 12 ) ; assertEquals ( " ksqn1rje83g2 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 20.783236276 , 31.9867127312312 , 12 ) ; assertEquals ( " ksq9zbs0b7vw " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 12 ) ; assertEquals ( " hf7u8p8gn747 " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 8 ) ; assertEquals ( " hf7u8p8g " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( - 76.5110040642321 , 39.0247389581054 , 4 ) ; assertEquals ( " hf7u " , hash . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( 39.0247389581054 , - 76.5110040642321 , 12 ) ; assertEquals ( " dqcw4bnrs6s7 " , hash . oBase32 ( ) ) ; } 
public void estMovingInCircle ( ) { } 
public void estMovingAroundWorldOnHashStrips ( ) hrows Exception { String [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; for ( String direction : directions ) { checkMoveAroundStrip ( direction ) ; 
private void checkMoveAroundStrip ( String direction ) hrows Exception { for ( int bits = 2 ; bits < 16 ; bits + + ) { double randomLatitude = ( rand . nextDouble ( ) - 0.5 ) * 180 ; 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = " dr4jb0bn2180 " ; GeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; assertEquals ( hash , fromRef ) ; assertEquals ( base32 , hash . oBase32 ( ) ) ; assertEquals ( base32 , fromRef . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; assertEquals ( " dr4jb0bn21 " , hash . oBase32 ( ) ) ; } 
public void estByCharacterPrecision ( ) { assertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; WGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; String fullStringValue = " hf7u8p8gn747 " ; for ( int characters = 12 ; characters > 1 ; characters - - ) { assertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } assertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; } 
private void assertEncodingWithCharacterPrecision ( WGS84Point point , int numberOfCharacters , String stringValue ) { GeoHash hash = GeoHash . withCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , numberOfCharacters ) ; assertEquals ( stringValue , hash . oBase32 ( ) ) ; } 
public String oString ( ) { return String . format ( " %s -> %s,%s " , Long . oBinaryString ( bits ) , upperLeft , lowerRight ) ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj instanceof BoundingBox ) { BoundingBox o = ( BoundingBox ) obj ; 
public int hashCode ( ) { return 31 * ( 713 + upperLeft . hashCode ( ) ) + lowerRight . hashCode ( ) ; } 
public double area ( ) { return ( lowerRight . latitude - upperLeft . latitude ) * ( lowerRight . longitude - lowerRight . longitude ) ; } 
public boolean contains ( WGS84Point point ) { return point . latitude > = upperLeft . latitude & & point . latitude < = upperLeft . latitude & & point . longitude > = lowerRight . longitude & & point . longitude < = lowerRight . longitude ; 
public String oString ( ) { return upperLeft + " -> " + lowerRight ; } 
public int hashCode ( ) { int result = 42 ; long latBits = Double . doubleToLongBits ( latitude ) ; long lonBits = Double . doubleToLongBits ( longitude ) ; result = 31 * result + ( int ) ( latBits ^ ( latBits > > > 32 ) ) ; result = 31 * result + ( int ) ( lonBits ^ ( lonBits > > > 32 ) ) ; return result ; } 
public void estHashCode ( ) { assertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; assertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; } 
public void estEqualsObject ( ) { assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertFalse ( a . equals ( c ) ) ; } 
private void assertContains ( BoundingBox box , WGS84Point p ) { assertTrue ( p + " should be in " + box , box . contains ( p ) ) ; } 
public void estWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . oBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertWithin ( hash , bbox ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { assertTrue ( hash . oBase32 ( ) + " should be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; } 
public void estSimpleWithin ( ) { GeoHash hash = GeoHash . withBitPrecision ( 70 , - 120 , 8 ) ; GeoHash inside = GeoHash . withBitPrecision ( 74 , - 130 , 64 ) ; assertWithin ( inside , hash ) ; } 
public void estEquals ( ) { assertEquals ( a , a ) ; assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertNotSame ( a , b ) ; assertFalse ( a . equals ( c ) ) ; assertFalse ( c . equals ( a ) ) ; assertFalse ( d . equals ( c ) ) ; assertFalse ( d . equals ( a ) ) ; assertFalse ( d . equals ( new Integer ( 10 ) ) ) ; } 
public void estHashCode ( ) { assertEquals ( a . hashCode ( ) , a . hashCode ( ) ) ; assertEquals ( a . hashCode ( ) , b . hashCode ( ) ) ; assertFalse ( a . hashCode ( ) = = c . hashCode ( ) ) ; assertFalse ( d . hashCode ( ) = = c . hashCode ( ) ) ; assertFalse ( d . hashCode ( ) = = new Integer ( 10 ) . hashCode ( ) ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; return hash ; } 
public String oString ( ) { return String . format ( " %s -> %s " , Long . oBinaryString ( bits ) , boundingBox ) ; } 
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; assertEquals ( start . getBoundingBox ( ) , end . getBoundingBox ( ) ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( hash . getBoundingBox ( ) ) ; } 
public boolean contains ( WGS84Point point ) { return ( point . latitude > = upperLeft . latitude ) & & ( point . longitude > = upperLeft . longitude ) 
public boolean contains ( WGS84Point point ) { return ( point . latitude > = upperLeft . latitude ) & & ( point . longitude > = upperLeft . longitude ) & & ( point . latitude < = lowerRight . latitude ) & & ( point . longitude < = lowerRight . longitude ) ; 
public void estContains ( ) { BoundingBox bbox = new BoundingBox ( new WGS84Point ( 45 , 120 ) , new WGS84Point ( 46 , 121 ) ) ; assertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; assertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
private void assertNotContains ( BoundingBox box , WGS84Point p ) { assertFalse ( p + " should NOT be in " + box , box . contains ( p ) ) ; } 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 0.85) { 
public void estRangeCheck ( ) { WGS84Point p = new WGS84Point ( 180 , 240 ) ; } 
public void estBoundingBoxSearch ( ) { GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( new WGS84Point ( 40.09872762 , 30 .0113312322 ) , new WGS84Point ( 41.23452234 , 31.23432 ) ) ) ; 
private long extractEverySecondBit ( long copyOfBits , int numberOfBits ) { long value = 0 ; for ( int i = 0 ; i < numberOfBits ; i + + ) { if ( ( copyOfBits & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { value | = 0x1 ; } value < < = 1 ; copyOfBits < < = 2 ; } value > > > = 1 ; return value ; } 
public static final int commonPrefixLength ( long a , long b ) { int result = 0 ; while ( result < 64 & & ( a & FIRST_BIT ) = = ( b & FIRST_BIT ) ) { result + + ; a < < = 1 ; b < < = 1 ; } return result ; } 
public void estSameNumbersHave64BitsPrefix ( ) { for ( long a = 0 ; a < 120000000 ; a + = 101 ) { long b = a ; 
public void estKnownPrefixLenghts ( ) { long a = 0x8f00000000000000l ; long b = 0x8000000000000000l ; long c = 0x8800000000000000l ; assertPrefixLength ( 4 , a , b ) ; assertPrefixLength ( 4 , b , c ) ; assertPrefixLength ( 5 , a , c ) ; assertPrefixLength ( 0 , 0x0 , a ) ; assertPrefixLength ( 16 , 0x8888300000000000l , 0x8888c00000000000l ) ; } 
private void assertPrefixLength ( int length , long a , long b ) { assertEquals ( length , LongUtil . commonPrefixLength ( a , b ) ) ; } 
public void estDecode ( ) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 1.54) { 
public void estNeighbourLocationCode ( ) { assertEquals(0x5400000000000000l, east.bits); 
public void estKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . oBase32 ( ) ) ; } 
public String oString ( ) { if ( significantBits % 5 = = 0 ) { return String . format ( " %s -> %s -> %s " , Long . oBinaryString ( bits ) , boundingBox , oBase32 ( ) ) ; 
public void estKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . oBase32 ( ) ) ; } 
public void estKnownAdjacentNeighbours ( ) { GeoHash center = GeoHash . fromGeohashString ( " dqcjqc " ) ; GeoHash [ ] adjacent = center . getAdjacent ( ) ; for ( String check : new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ) { 
private void assertArrayContainsGeoHash ( String check , GeoHash [ ] hashes ) { boolean found = false ; for ( GeoHash hash : hashes ) { if ( hash . oBase32 ( ) . equals ( check ) ) { found = rue ; break ; } } assertTrue ( " Array should contain " + check , found ) ; } 
public void estKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . oBase32 ( ) ) ; } 
public void estKnownAdjacentNeighbours ( ) { String center = " dqcjqc " ; String [ ] adjacent = new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " u1x0dfg " ; adjacent = new String [ ] { " u1x0dg4 " , " u1x0dg5 " , " u1x0dgh " , " u1x0dfu " , " u1x0dfs " , " u1x0dfe " , " u1x0dfd " , " u1x0dff " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " sp2j " ; adjacent = new String [ ] { " ezry " , " sp2n " , " sp2q " , " sp2m " , " sp2k " , " sp2h " , " ezru " , " ezrv " } ; assertAdjacentHashesAre ( center , adjacent ) ; } 
private void assertAdjacentHashesAre ( String centerString , String [ ] adjacentStrings ) { GeoHash center = GeoHash . fromGeohashString ( centerString ) ; GeoHash [ ] adjacent = center . getAdjacent ( ) ; for ( String check : adjacentStrings ) { assertArrayContainsGeoHash ( check , adjacent ) ; 
public void estNeibouringHashesNearMeridian ( ) { GeoHash hash = GeoHash . fromGeohashString ( " sp2j " ) ; GeoHash west = hash . getWesternNeighbour ( ) ; assertEquals ( " ezrv " , west . oBase32 ( ) ) ; west = west . getWesternNeighbour ( ) ; assertEquals ( " ezrt " , west . oBase32 ( ) ) ; } 
protected static final double dLat ( int bits ) { return 180 d / Math . pow ( 2 , bits / 2 ) ; } 
protected static final double dLon ( int bits ) { return 360 d / Math . pow ( 2 , ( bits + 1 ) / 2 ) ; } 
public void estDLat ( ) { assertDLatIs ( 180 d , 0 ) ; assertDLatIs ( 180 d , 1 ) ; assertDLatIs ( 90 d , 2 ) ; assertDLatIs ( 0.3515625 , 18 ) ; assertDLatIs ( 0.3515625 , 19 ) ; } 
private void assertDLatIs ( double d , int i ) { assertEquals ( d , GeoHashSizeTable . dLat ( i ) , 0 ) ; } 
public void estDLon ( ) { assertDLonIs ( 360 , 0 ) ; assertDLonIs ( 180 , 1 ) ; assertDLonIs ( 0.0439453125 , 25 ) ; assertDLonIs ( 0.0439453125 , 26 ) ; } 
private void assertDLonIs ( double d , int i ) { assertEquals ( d , GeoHashSizeTable . dLon ( i ) , 1 - 128 ) ; } 
public int numberOfBitsForOverlappingGeoHash ( BoundingBox boundingBox ) { return 0 ; } 
private void assertDLonIs ( double d , int i ) { assertEquals ( d , GeoHashSizeTable . dLon ( i ) , 1 - 128 ) ; } 
public void estKnownBoundingBoxSizes ( ) { for ( int bits = 3 ; bits < 64 ; bits + + ) { make the bounding box a little smaller than dLat/dLon 
public boolean contains ( WGS84Point point ) { return boundingBox . contains ( point ) ; } 
public String oString ( ) { if ( significantBits % 5 = = 0 ) { return String . format ( " %s -> %s -> %s " , Long . oBinaryString ( bits ) , boundingBox , oBase32 ( ) ) ; 
public boolean intersects ( BoundingBox other ) { return ( upperLeft . latitude < other . lowerRight . latitude ) & & ( lowerRight . latitude > other . upperLeft . latitude ) & & ( upperLeft . longitude < other . lowerRight . longitude ) & & ( lowerRight . longitude > other . upperLeft . longitude ) ; 
private void addSearchHash ( GeoHash hash ) { searchHashes . add ( hash ) ; expandSearchBoundingBox ( hash ) ; } 
private void expandSearchBoundingBox ( GeoHash hash ) { }} 
private boolean hashFits ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getUpperLeft ( ) ) & & hash . contains ( bbox . getLowerRight ( ) ) ; } 
public void estBoundingBoxSearch ( ) { GeoHashBoundingBoxSearch search = createSearch ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; 
public void estSeveralBoundingBoxes ( ) { GeoHashBoundingBoxSearch search = createSearch ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; createSearch ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; createSearch ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; } 
private GeoHashBoundingBoxSearch createSearch ( double minx , double miny , double maxx , double maxy ) { return new GeoHashBoundingBoxSearch ( new BoundingBox ( new WGS84Point ( minx , miny ) , new WGS84Point ( maxx , maxy ) ) ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double minLon , double maxLat , double maxLon ) { WGS84Point upperLeft = new WGS84Point ( minLat , minLon ) ; WGS84Point lowerRight = new WGS84Point ( maxLat , maxLon ) ; GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( upperLeft , lowerRight ) ) ; assertRightNumberOfSearchHashes ( search ) ; } 
private void assertRightNumberOfSearchHashes ( GeoHashBoundingBoxSearch search ) { assertTrue ( search . getSearchHashes ( ) . size ( ) = = 2 | | search . getSearchHashes ( ) . size ( ) = = 4 ) ; } 
public void estKnownSmallerBoundingBoxSizes ( ) { for ( int bits = 3 ; bits < 64 ; bits + + ) { make the bounding box a little smaller than dLat/dLon 
public void estKnownLargerBoundingBoxSizes ( ) { for ( int bits = 4 ; bits < 63 ; bits + + ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; 
public BoundingBox generate ( int bits ) { } 
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; return new BoundingBox ( 0 , 0 , dLat + DELTA , dLon + DELTA ) ; } 
public BoundingBox generate ( int bits ) { return null ; } 
public void estKnownSmallerBoundingBoxSizes ( ) { checkWithGenerator ( new ALittleTooSmallVerifier ( ) ) ; } 
public void estKnownLargerBoundingBoxSizes ( ) { checkWithGenerator ( new BothALittleTooLargeVerifier ( ) ) ; } 
public void estKnownOneBitLargerBoxSizes ( ) { }} 
private void checkWithGenerator ( BoundingBoxSizeTableVerifier generator ) { for ( int bits = 4 ; bits < 64 ; bits + + ) { BoundingBox bbox = generator . generate ( bits ) ; 
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; if ( latitudeAffected = rand . nextBoolean ( ) ) { dLat + = DELTA ; } else { dLon + = DELTA ; } return new BoundingBox ( 0 , 0 , dLat , dLon ) ; } 
public void estKnownOneBitLargerBoxSizes ( ) { checkWithGenerator ( new OnlyOneALittleTooLargeVerifier ( ) ) ; } 
public String oString ( ) { StringBuilder bui = new StringBuilder ( ) ; for ( GeoHash hash : searchHashes ) { bui . append ( hash ) . append ( " " ) ; } return bui . oString ( ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2 , - 22.5 , 40.3 , - 22.4 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , - 22.523432424324 , 40.21982983232432 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 30.0113312322 , 41.23452234 , 31.23432 ) ; checkSearchYieldsCorrectHashes ( 47.447907 , 8.471276 , 47.300200 , 8.760941 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 47.157502 , 8.562244 , 47.329727 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double minLon , double maxLat , double maxLon ) { GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , minLon , maxLat , maxLon ) ) ; assertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double minLon , double maxLat , double maxLon , String . . . hashes ) { GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , minLon , maxLat , maxLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
private void assertRightNumberOfSearchHashes ( GeoHashBoundingBoxSearch search ) { int size = search . getSearchHashes ( ) . size ( ) ; assertTrue ( size = = 1 | | size = = 2 | | size = = 4 ) ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj instanceof BoundingBox ) { BoundingBox hat = ( BoundingBox ) obj ; 
public int hashCode ( ) { int result = 17 ; result = 37 * result + hashCode ( minLat ) ; result = 37 * result + hashCode ( maxLat ) ; result = 37 * result + hashCode ( minLon ) ; result = 37 * result + hashCode ( maxLon ) ; return result ; } 
private static int hashCode ( double x ) { long f = Double . doubleToLongBits ( x ) ; return ( int ) ( f ^ ( f > > > 32 ) ) ; } 
public boolean contains ( WGS84Point point ) { return ( point . latitude > = minLat ) & & ( point . longitude > = minLon ) & & ( point . latitude < = maxLat ) & & ( point . longitude < = maxLon ) ; 
public boolean intersects ( BoundingBox other ) { return ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLon > maxLon | | other . maxLon < minLon ) ; } 
public String oString ( ) { return getUpperLeft ( ) + " -> " + getLowerRight ( ) ; } 
public void estContains ( ) { BoundingBox bbox = new BoundingBox ( 45 , 46 , 121 , 120 ) ; assertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; assertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
public void estIntersects ( ) { BoundingBox bbox = new BoundingBox ( 10 , - 10 , 41 , 40 ) ; assertIntersects ( bbox , new BoundingBox ( 5 , - 15 , 40.5 , 43 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( 5 , - 15 , 42 , 43 ) ) ; } 
private void assertDoesNotIntersect ( BoundingBox bbox , BoundingBox boundingBox ) { assertFalse ( bbox + " should NOT intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; assertFalse ( boundingBox + " should NOT intersect " + bbox , boundingBox . intersects ( bbox ) ) ; } 
private void assertIntersects ( BoundingBox bbox , BoundingBox boundingBox ) { assertTrue ( bbox + " should intersect " + boundingBox , bbox . intersects ( boundingBox ) ) ; assertTrue ( boundingBox + " should intersect " + bbox , boundingBox . intersects ( bbox ) ) ; } 
private void assertContains ( BoundingBox box , WGS84Point p ) { assertTrue ( p + " should be in " + box , box . contains ( p ) ) ; } 
private void assertNotContains ( BoundingBox box , WGS84Point p ) { assertFalse ( p + " should NOT be in " + box , box . contains ( p ) ) ; } 
public static final int numberOfBitsForOverlappingGeoHash ( BoundingBox boundingBox ) { int bits = 63 ; double height = boundingBox . getLatitudeSize ( ) ; double width = boundingBox . getLongitudeSize ( ) ; while ( ( dLat [ bits ] < height | | dLon [ bits ] < width ) & & bits > 0 ) { bits - - ; } return bits ; } 
public void estSize ( ) { BoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; assertHeightIs ( bbox , 45 ) ; assertWidthIs ( bbox , 30 ) ; bbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; assertHeightIs ( bbox , 90 ) ; assertWidthIs ( bbox , 52.5 ) ; bbox = new BoundingBox ( - 44 , - 46.1 , - 127.2 , - 128 ) ; assertHeightIs ( bbox , 2.1 ) ; assertWidthIs ( bbox , 0.8 ) ; } 
private void assertWidthIs ( BoundingBox bbox , double width ) { assertEquals ( width , bbox . getLongitudeSize ( ) , DELTA ) ; } 
private void assertHeightIs ( BoundingBox bbox , double height ) { assertEquals ( height , bbox . getLatitudeSize ( ) , DELTA ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( - 22.5 , - 22.4 , 40.2 , 40.3 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2 , 40.3 , - 22.5 , - 22.4 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; checkSearchYieldsCorrectHashes ( 8.760941 , 8.471276 , 47.447907 , 47.300200 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 8.562244 , 8.859215 , 47.157502 , 47.329727 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double maxLat , double minLon , double maxLon ) { GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; assertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , String . . . hashes ) { GeoHashBoundingBoxSearch search = new GeoHashBoundingBoxSearch ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
public BoundingBox generate ( int bits ) { } 
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; return new BoundingBox ( 0 , dLat + DELTA , 0 , dLon + DELTA ) ; } 
public BoundingBox generate ( int bits ) { double dLat = GeoHashSizeTable . dLat ( bits ) ; double dLon = GeoHashSizeTable . dLon ( bits ) ; if ( latitudeAffected = rand . nextBoolean ( ) ) { dLat + = DELTA ; } else { dLon + = DELTA ; } return new BoundingBox ( 0 , dLat , 0 , dLon ) ; } 
public boolean intersects ( BoundingBox other ) { return ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLat > maxLat | | other . maxLat < minLat ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; checkSearchYieldsCorrectHashes ( 47.447907 , 47.300200 , 8.760941 , 8.471276 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
public boolean contains ( WGS84Point point ) { return ( point . getLatitude ( ) > = minLat ) & & ( point . getLongitude ( ) > = minLon ) & & ( point . getLatitude ( ) < = maxLat ) & & ( point . getLongitude ( ) < = maxLon ) ; 
public void estVincenty ( ) { WGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; int distanceInMeters = 10000 ; WGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , distanceInMeters ) ; Assert . assertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; Assert . assertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; Assert . assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( startPoint , result ) , DELTA ) ; WGS84Point p1 = new WGS84Point ( 1 , 1 ) ; int enThousandKilometers = 10000000 ; WGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , enThousandKilometers ) ; System . out . println ( p2 ) ; Assert . assertEquals ( enThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public boolean contains ( GeoHash hash ) { for ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) return rue ; } return false ; } 
public boolean contains ( GeoHash hash ) { return query . contains ( hash ) ; } 
public abstract boolean contains ( GeoHash hash ) ; public abstract List < GeoHash > getSearchHashes ( ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double minLat , double maxLat , double minLon , double maxLon ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; assertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , String . . . hashes ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) . contains ( 
private void assertRightNumberOfSearchHashes ( GeoHashQuery search ) { int size = search . getSearchHashes ( ) . size ( ) ; assertTrue ( size = = 1 | | size = = 2 | | size = = 4 ) ; } 
public void estRangeCheck ( ) { new WGS84Point ( 180 , 240 ) ; } 
public String oBase32 ( ) { if ( significantBits % 5 ! = 0 ) { return " " ; } StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public String oString ( ) { return " Cicle Query [center= " + center + " , radius= " + getRadiusString ( ) + " ] " ; } 
public void expandToInclude ( BoundingBox other ) { if ( other . minLon < minLon ) { minLon = other . minLon ; } if ( other . maxLon > maxLon ) { maxLon = other . maxLon ; } if ( other . minLat < minLat ) { minLat = other . minLat ; } if ( other . maxLat > maxLat ) { maxLat = other . maxLat ; 
private void addSearchHash ( GeoHash hash ) { if ( boundingBox = = null ) { boundingBox = new BoundingBox ( hash . getBoundingBox ( ) ) ; } else { boundingBox . expandToInclude ( hash . getBoundingBox ( ) ) ; } searchHashes . add ( hash ) ; } 
public abstract boolean contains ( GeoHash hash ) ; public abstract List < GeoHash > getSearchHashes ( ) ; public abstract String getWktBox ( ) ; } 
public abstract List < GeoHash > getSearchHashes ( ) ; public abstract String getWktBox ( ) ; } 
public void checkJerryDonSample1 ( ) { checkRadiusSearchHashes ( 1000 , " 9y2bk " ) ; } 
public void estJerryDonSample2 ( ) { checkRadiusSearchHashes ( 1500 , " 9y2bh " , " 9y2bs " , " 9yb2b0 " , " 9yb2b8 " ) ; } 
public void estJerryDonSample3 ( ) { checkRadiusSearchHashes ( 2500 , " 9y2b " ) ; } 
private void checkRadiusSearchHashes ( int radius , String . . . string ) { GeoHashQuery query = new GeoHashCircleQuery ( center , radius ) ; List < String > expectedHashes = Arrays . asList ( string ) ; List < GeoHash > searchHashes = query . getSearchHashes ( ) ; assertEquals ( expectedHashes . size ( ) , searchHashes . size ( ) ) ; for ( GeoHash hash : searchHashes ) { if ( ! expectedHashes . contains ( hash . oBase32 ( ) ) ) { 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuffer b = new StringBuffer ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { b . append ( " 0 " ) ; } binaryString = b . oString ( ) ; } geohash . bits = Long . valueOf ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; 
public String oStringWithSignificantPrecision ( ) { return Long . oBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
public boolean contains ( WGS84Point point ) { return contains ( GeoHash . withBitPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 64 ) ) ; } 
public boolean contains ( WGS84Point point ) { return query . contains ( point ) ; } 
public boolean contains ( GeoHash hash ) ; public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public boolean contains ( WGS84Point point ) ; public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public List < GeoHash > getSearchHashes ( ) ; public String getWktBox ( ) ; } 
public void estIssue3WithCircleQuery ( ) hrows Exception { WGS84Point center = new WGS84Point ( 39.86391280373075 , 116.37356590048701 ) ; GeoHashCircleQuery query = new GeoHashCircleQuery ( center , 589 ) ; } 
public static BoundingBoxGeoHashIterator withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; GeoHash opRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; return new BoundingBoxGeoHashIterator ( bottomLeft , opRight ) ; } 
public static BoundingBoxGeoHashIterator withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; GeoHash opRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; return new BoundingBoxGeoHashIterator ( bottomLeft , opRight ) ; } 
public boolean hasNext ( ) { return current . compareTo ( opRight ) < = 0 ; } 
public void remove ( ) { hrow new UnsupportedOperationException ( ) ; } 
public void estIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 10 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 35 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; int idx = 0 ; System.out.println("idx,lat,lon"); for (GeoHash gh : hashes) { if (prev != null) Assert.assertTrue(prev.compareTo(gh) < 0); 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . oBinaryString ( hashVal ) ; while ( binaryString . length ( ) < 64 ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
public GeoHash next ( ) { return fromLongValue ( bits + ( 1l < < ( 64 - significantBits ) ) , significantBits ) ; } 
public int compareTo ( GeoHash o ) { return new Long ( bits ) . compareTo ( o . bits ) ; } 
public void estToLongAndBack ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; long lv = hash . longValue ( ) ; assertEquals ( lv + ( 1 < < ( 64 - hash . significantBits ( ) ) ) , hash . next ( ) . longValue ( ) ) ; GeoHash hashFromLong = GeoHash . fromLongValue ( lv , hash . significantBits ( ) ) ; assertEquals ( " dr4jb0bn21 " , hashFromLong . oBase32 ( ) ) ; assertEquals ( hash , hashFromLong ) ; } 
public void estNext ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; GeoHash next = hash . next ( ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = BoundingBoxGeoHashIterator . withBitPrecision ( box , 35 ) ; BoundingBox newBox = iter . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuffer b = new StringBuffer ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { b . append ( " 0 " ) ; } binaryString = b . oString ( ) ; } geohash . bits = Long . valueOf ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj instanceof BoundingBox ) { BoundingBox hat = ( BoundingBox ) obj ; 
public int hashCode ( ) { int result = 17 ; result = 37 * result + hashCode ( minLat ) ; result = 37 * result + hashCode ( maxLat ) ; result = 37 * result + hashCode ( minLon ) ; result = 37 * result + hashCode ( maxLon ) ; return result ; } 
private static int hashCode ( double x ) { long f = Double . doubleToLongBits ( x ) ; return ( int ) ( f ^ ( f > > > 32 ) ) ; } 
public boolean contains ( WGS84Point point ) { return ( point . getLatitude ( ) > = minLat ) & & ( point . getLongitude ( ) > = minLon ) & & ( point . getLatitude ( ) < = maxLat ) & & ( point . getLongitude ( ) < = maxLon ) ; 
public boolean intersects ( BoundingBox other ) { return ! ( other . minLon > maxLon | | other . maxLon < minLon | | other . minLat > maxLat | | other . maxLat < minLat ) ; } 
public String oString ( ) { return getUpperLeft ( ) + " -> " + getLowerRight ( ) ; } 
public void expandToInclude ( BoundingBox other ) { if ( other . minLon < minLon ) { minLon = other . minLon ; } if ( other . maxLon > maxLon ) { maxLon = other . maxLon ; } if ( other . minLat < minLat ) { minLat = other . minLat ; } if ( other . maxLat > maxLat ) { maxLat = other . maxLat ; 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { int desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; return new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) hrow new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuffer b = new StringBuffer ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 63 ; i + + ) { b . append ( " 0 " ) ; } binaryString = b . oString ( ) ; } geohash . bits = Long . valueOf ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . oBinaryString ( hashVal ) ; while ( binaryString . length ( ) < 64 ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
private void divideRangeEncode ( double value , double [ ] range ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( value > = mid ) { addOnBitToEnd ( ) ; 
private static void divideRangeDecode ( GeoHash hash , double [ ] range , boolean b ) { double mid = ( range [ 0 ] + range [ 1 ] ) / 2 ; if ( b ) { hash . addOnBitToEnd ( ) ; 
public int significantBits ( ) { return ( int ) significantBits ; } 
public String oBase32 ( ) { if ( significantBits % 5 ! = 0 ) { return " " ; } StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public boolean within ( GeoHash boundingBox ) { return ( bits & boundingBox . mask ( ) ) = = boundingBox . bits ; } 
public boolean contains ( WGS84Point point ) { return boundingBox . contains ( point ) ; } 
public boolean enclosesCircleAroundPoint ( WGS84Point point , double radius ) { return false ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; return hash ; } 
private long extractEverySecondBit ( long copyOfBits , int numberOfBits ) { long value = 0 ; for ( int i = 0 ; i < numberOfBits ; i + + ) { if ( ( copyOfBits & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { value | = 0x1 ; } value < < = 1 ; copyOfBits < < = 2 ; } value > > > = 1 ; return value ; } 
protected final void addOnBitToEnd ( ) { significantBits + + ; bits < < = 1 ; bits = bits | 0x1 ; } 
protected final void addOffBitToEnd ( ) { significantBits + + ; bits < < = 1 ; } 
public String oString ( ) { if ( significantBits % 5 = = 0 ) { return String . format ( " %s -> %s -> %s " , Long . oBinaryString ( bits ) , boundingBox , oBase32 ( ) ) ; 
public String oStringWithSignificantPrecision ( ) { return Long . oBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
public boolean equals ( Object obj ) { if ( obj = = his ) { return rue ; } if ( obj instanceof GeoHash ) { GeoHash other = ( GeoHash ) obj ; if ( other . significantBits = = significantBits & & other . bits = = bits ) { return rue ; } } return false ; } 
public int hashCode ( ) { int f = 17 ; f = 31 * f + ( int ) ( bits ^ ( bits > > > 32 ) ) ; f = 31 * f + significantBits ; return f ; } 
private long mask ( ) { if ( significantBits = = 0 ) { return 0 ; 
private long maskLastNBits ( long value , long ) { long mask = 0xffffffffffffffffl ; mask > > > = ( 64 - ) ; return value & mask ; } 
public String oString ( ) { return String . format ( " ( " + latitude + " , " + longitude + " ) " ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof WGS84Point ) { WGS84Point other = ( WGS84Point ) obj ; return latitude = = other . latitude & & longitude = = other . longitude ; } return false ; } 
public int hashCode ( ) { int result = 42 ; long latBits = Double . doubleToLongBits ( latitude ) ; long lonBits = Double . doubleToLongBits ( longitude ) ; result = 31 * result + ( int ) ( latBits ^ ( latBits > > > 32 ) ) ; result = 31 * result + ( int ) ( lonBits ^ ( lonBits > > > 32 ) ) ; return result ; } 
private void addSearchHash ( GeoHash hash ) { if ( boundingBox = = null ) { boundingBox = new BoundingBox ( hash . getBoundingBox ( ) ) ; } else { boundingBox . expandToInclude ( hash . getBoundingBox ( ) ) ; } searchHashes . add ( hash ) ; } 
private boolean hashFits ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getUpperLeft ( ) ) & & hash . contains ( bbox . getLowerRight ( ) ) ; } 
public boolean contains ( GeoHash hash ) { for ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) return rue ; } return false ; } 
public boolean contains ( WGS84Point point ) { return contains ( GeoHash . withBitPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 64 ) ) ; } 
public String oString ( ) { StringBuilder bui = new StringBuilder ( ) ; for ( GeoHash hash : searchHashes ) { bui . append ( hash ) . append ( " " ) ; } return bui . oString ( ) ; } 
public boolean contains ( GeoHash hash ) { return query . contains ( hash ) ; } 
public String oString ( ) { return " Cicle Query [center= " + center + " , radius= " + getRadiusString ( ) + " ] " ; } 
public boolean contains ( WGS84Point point ) { return query . contains ( point ) ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . oBinaryString ( hashVal ) ; while ( binaryString . length ( ) < 64 ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( 64 - hash . significantBits ) ; return hash ; } 
public GeoHash next ( ) { return fromLongValue ( bits + ( 1l < < ( 64 - significantBits ) ) , significantBits ) ; } 
public String oBase32 ( ) { if ( significantBits % 5 ! = 0 ) { return " " ; } StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public String oStringWithSignificantPrecision ( ) { return Long . oBinaryString ( bits ) . substring ( 0 , significantBits ) ; } 
private long mask ( ) { if ( significantBits = = 0 ) { return 0 ; 
public int compareTo ( GeoHash o ) { return new Long ( bits ) . compareTo ( o . bits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; geohash . significantBits = ( byte ) binaryString . length ( ) ; if ( binaryString . length ( ) < 64 ) { StringBuilder b = new StringBuilder ( ) ; b . append ( binaryString ) ; for ( int i = binaryString . length ( ) ; i < 64 ; i + + ) { b . append ( '0' ) ; } binaryString = b . oString ( ) ; } geohash . bits = Long . parseLong ( binaryString , 2 ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public String oBinaryString ( ) { StringBuilder bui = new StringBuilder ( ) ; long bitsCopy = bits ; for ( int i = 0 ; i < significantBits ; i + + ) { if ( ( bitsCopy & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) { bui . append ( '1' ) ; } else { bui . append ( '0' ) ; } bitsCopy < < = 1 ; } return bui . oString ( ) ; } 
public void estDecode ( ) { BoundingBox bbox = gh.getBoundingBox(); 
public void estToAndFromBinaryString ( ) { for ( GeoHash gh : RandomGeohashes . fullRange ( ) ) { String binaryString = gh . oBinaryString ( ) ; 
public void estOffendingBinaryString ( ) { String offendingString = " 1000000000000000000010101000000000000000000000000000000000000000 " ; assertEquals ( 64 , offendingString . length ( ) ) ; Long . parseLong ( offendingString , 2 ) ; } 
public void estKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . oBase32 ( ) ) ; } 
public void estToLongAndBack ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; long lv = hash . longValue ( ) ; assertEquals ( lv + ( 1 < < ( 64 - hash . significantBits ( ) ) ) , hash . next ( ) . longValue ( ) ) ; GeoHash hashFromLong = GeoHash . fromLongValue ( lv , hash . significantBits ( ) ) ; assertEquals ( " dr4jb0bn21 " , hashFromLong . oBase32 ( ) ) ; assertEquals ( hash , hashFromLong ) ; } 
public void estNext ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; GeoHash next = hash . next ( ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public static Iterable < GeoHash > fullRange ( ) { return new Iterable < GeoHash > ( ) { @Override 
public Iterator < GeoHash > iterator ( ) { Random rand = new Random ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; for ( double lat = - 90 ; lat < = 90 ; lat + = rand . nextDouble ( ) + 1.45 ) { for ( double lon = - 180 ; lon < = 180 ; lon + = rand . nextDouble ( ) + 1.54 ) { for ( int precisionChars = 6 ; precisionChars < = 12 ; precisionChars + + ) { GeoHash gh = GeoHash . withCharacterPrecision ( lat , lon , precisionChars ) ; hashes . add ( gh ) ; } } } return hashes . iterator ( ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; for ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { geohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { geohash . addOffBitToEnd ( ) ; } else { throw new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } geohash . bits < < = ( 64 - geohash . significantBits ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public GeoHash next ( int step ) { int insignificantBits = 64 - significantBits ; long unshiftedVal = bits > > insignificantBits ; unshiftedVal + = step ; return fromLongValue ( unshiftedVal < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash wo ) { if ( one . significantBits ( ) ! = wo . significantBits ( ) ) hrow new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; int insignificantBits = 64 - one . significantBits ( ) ; long unshiftedVal1 = one . bits > > insignificantBits ; long unshiftedVal2 = wo . bits > > insignificantBits ; return unshiftedVal2 - unshiftedVal1 ; } 
public void estAddingOnes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; assertEquals ( 1 , hash . significantBits ( ) ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; hash . addOnBitToEnd ( ) ; assertEquals ( 0xfl , hash . bits ) ; assertEquals ( 4 , hash . significantBits ( ) ) ; } 
public void estAddingZeroes ( ) { hash . addOnBitToEnd ( ) ; assertEquals ( 0x1l , hash . bits ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; hash . addOffBitToEnd ( ) ; assertEquals ( 0x10l , hash . bits ) ; assertEquals ( 5 , hash . significantBits ( ) ) ; } 
public void estToBase32 ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; String base32 = hash . oBase32 ( ) ; assertEquals ( " ezs42 " , base32 ) ; } 
public void estDecode ( ) { for all lat/lon pairs check decoded point is in the same bbox as the geohash formed by encoder TODO could possibly be less brute-force here and be more scientific about possible failure points for (double lat = -90; lat <= 90; lat += rand.nextDouble() + 1.45) { for (double lon = -180; lon <= 180; lon += rand.nextDouble() + 1.54) { 
public void estWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; System . out . println ( hash . oBase32 ( ) ) ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6ff0000000000000l ; bbox . significantBits = 12 ; assertWithin ( hash , bbox ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { assertTrue ( hash . oBase32 ( ) + " should be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; } 
public void estNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash . oBase32 ( ) + " should NOT be within " + bbox . oBase32 ( ) , hash . within ( bbox ) ) ; } 
public void estConstructorWithBitPrecision ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 45 , 120 , 20 ) ; assertEquals ( hash1 . significantBits , 20 ) ; System . out . println ( hash1 ) ; System . out . println ( hash1 . oBase32 ( ) ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 45 , 120 , 55 ) ; assertEquals ( hash2 . significantBits , 55 ) ; System . out . println ( hash2 ) ; System . out . println ( hash2 . oBase32 ( ) ) ; assertTrue ( hash2 . within ( hash1 ) ) ; this should match Dave Troys Codebase. This is also his maximum accuracy (12 5-nibbles). GeoHash hash3 = GeoHash.withBitPrecision(20, 31, 60); assertEquals("sew1c2vs2q5r", hash3.toBase32()); } 
public void estLatLonBoundingBoxes ( ) { hash = GeoHash . withBitPrecision ( 40 , 120 , 10 ) ; System . out . println ( hash . oBase32 ( ) ) ; printBoundingBox ( hash ) ; } 
public void estByCharacterPrecision ( ) { assertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; WGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; String fullStringValue = " hf7u8p8gn747 " ; for ( int characters = 12 ; characters > 1 ; characters - - ) { assertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } assertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; } 
private void assertEncodingWithCharacterPrecision ( WGS84Point point , int numberOfCharacters , String stringValue ) { GeoHash hash = GeoHash . withCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , numberOfCharacters ) ; assertEquals ( stringValue , hash . oBase32 ( ) ) ; } 
public void estGetLatitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] latitudeBits = hash . getRightAlignedLatitudeBits ( ) ; assertEquals ( 0xaal , latitudeBits [ 0 ] ) ; assertEquals ( 8 , latitudeBits [ 1 ] ) ; } 
public void estGetLongitudeBits ( ) { hash = GeoHash . withBitPrecision ( 30 , 30 , 16 ) ; long [ ] longitudeBits = hash . getRightAlignedLongitudeBits ( ) ; assertEquals ( 0x95l , longitudeBits [ 0 ] ) ; assertEquals ( 8 , longitudeBits [ 1 ] ) ; } 
public void estNeighbourLocationCode ( ) { set up corner case hash.bits = 0xc400000000000000l; hash.significantBits = 7; long[] lonBits = hash.getRightAlignedLongitudeBits(); assertEquals(0x8, lonBits[0]); assertEquals(4, lonBits[1]); long[] latBits = hash.getRightAlignedLatitudeBits(); assertEquals(0x5, latBits[0]); assertEquals(3, latBits[1]); GeoHash north = hash.getNorthernNeighbour(); assertEquals(0xd000000000000000l, north.bits); assertEquals(7, north.significantBits); GeoHash south = hash.getSouthernNeighbour(); assertEquals(0xc000000000000000l, south.bits); assertEquals(7, south.significantBits()); GeoHash east = hash.getEasternNeighbour(); assertEquals(0xc600000000000000l, east.bits); NOTE: this is actually a corner case! GeoHash west = hash.getWesternNeighbour(); assertEquals(0x6e00000000000000l, west.bits); NOTE: and now, for the most extreme corner case in 7-bit geohash-land hash.bits = 0xfe00000000000000l; east = hash.getEasternNeighbour(); assertEquals(0x5400000000000000l, east.bits); 
public void estEqualsAndHashCode ( ) { GeoHash hash1 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash2 = GeoHash . withBitPrecision ( 30 , 30 , 24 ) ; GeoHash hash3 = GeoHash . withBitPrecision ( 30 , 30 , 10 ) ; assertTrue ( hash1 . equals ( hash2 ) & & hash2 . equals ( hash1 ) ) ; assertFalse ( hash1 . equals ( hash3 ) & & hash3 . equals ( hash1 ) ) ; assertEquals ( hash1 . hashCode ( ) , hash2 . hashCode ( ) ) ; assertFalse ( hash1 . hashCode ( ) = = hash3 . hashCode ( ) ) ; } 
public void estAdjacentHashes ( ) { GeoHash [ ] adjacent = GeoHash . fromGeohashString ( " dqcw4 " ) . getAdjacent ( ) ; assertEquals ( 8 , adjacent . length ) ; } 
public void estMovingInCircle ( ) { moving around hashes in a circle should be possible checkMovingInCircle(34.2, -45.123); this should also work at the "back" of the earth checkMovingInCircle(45, 180); checkMovingInCircle(90, 180); checkMovingInCircle(0, -180); } 
private void checkMovingInCircle ( double latitude , double longitude ) { GeoHash start ; GeoHash end ; start = GeoHash . withCharacterPrecision ( latitude , longitude , 12 ) ; end = start . getEasternNeighbour ( ) ; end = end . getSouthernNeighbour ( ) ; end = end . getWesternNeighbour ( ) ; end = end . getNorthernNeighbour ( ) ; assertEquals ( start , end ) ; assertEquals ( start . getBoundingBox ( ) , end . getBoundingBox ( ) ) ; } 
public void estMovingAroundWorldOnHashStrips ( ) hrows Exception { String [ ] directions = { " Northern " , " Eastern " , " Southern " , " Western " } ; for ( String direction : directions ) { checkMoveAroundStrip ( direction ) ; 
private void checkMoveAroundStrip ( String direction ) hrows Exception { for ( int bits = 2 ; bits < 16 ; bits + + ) { double randomLatitude = ( rand . nextDouble ( ) - 0.5 ) * 180 ; 
public void estKnownNeighbouringHashes ( ) { GeoHash h1 = GeoHash . fromGeohashString ( " u1pb " ) ; assertEquals ( " u0zz " , h1 . getSouthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1pc " , h1 . getNorthernNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u300 " , h1 . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u302 " , h1 . getEasternNeighbour ( ) . getEasternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " u1p8 " , h1 . getWesternNeighbour ( ) . oBase32 ( ) ) ; assertEquals ( " sp2j " , GeoHash . withCharacterPrecision ( 41.7 , 0.08 , 4 ) . oBase32 ( ) ) ; } 
public void estKnownAdjacentNeighbours ( ) { String center = " dqcjqc " ; String [ ] adjacent = new String [ ] { " dqcjqf " , " dqcjqb " , " dqcjr1 " , " dqcjq9 " , " dqcjqd " , " dqcjr4 " , " dqcjr0 " , " dqcjq8 " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " u1x0dfg " ; adjacent = new String [ ] { " u1x0dg4 " , " u1x0dg5 " , " u1x0dgh " , " u1x0dfu " , " u1x0dfs " , " u1x0dfe " , " u1x0dfd " , " u1x0dff " } ; assertAdjacentHashesAre ( center , adjacent ) ; center = " sp2j " ; adjacent = new String [ ] { " ezry " , " sp2n " , " sp2q " , " sp2m " , " sp2k " , " sp2h " , " ezru " , " ezrv " } ; assertAdjacentHashesAre ( center , adjacent ) ; } 
private void assertAdjacentHashesAre ( String centerString , String [ ] adjacentStrings ) { GeoHash center = GeoHash . fromGeohashString ( centerString ) ; GeoHash [ ] adjacent = center . getAdjacent ( ) ; for ( String check : adjacentStrings ) { assertArrayContainsGeoHash ( check , adjacent ) ; 
private void assertArrayContainsGeoHash ( String check , GeoHash [ ] hashes ) { boolean found = false ; for ( GeoHash hash : hashes ) { if ( hash . oBase32 ( ) . equals ( check ) ) { found = rue ; break ; } } assertTrue ( " Array should contain " + check , found ) ; } 
public void estNeibouringHashesNearMeridian ( ) { GeoHash hash = GeoHash . fromGeohashString ( " sp2j " ) ; GeoHash west = hash . getWesternNeighbour ( ) ; assertEquals ( " ezrv " , west . oBase32 ( ) ) ; west = west . getWesternNeighbour ( ) ; assertEquals ( " ezrt " , west . oBase32 ( ) ) ; } 
public void estIssue1 ( ) { double lat = 40.390943 ; double lon = - 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; String base32 = " dr4jb0bn2180 " ; GeoHash fromRef = GeoHash . fromGeohashString ( base32 ) ; assertEquals ( hash , fromRef ) ; assertEquals ( base32 , hash . oBase32 ( ) ) ; assertEquals ( base32 , fromRef . oBase32 ( ) ) ; hash = GeoHash . withCharacterPrecision ( lat , lon , 10 ) ; assertEquals ( " dr4jb0bn21 " , hash . oBase32 ( ) ) ; } 
public void estSimpleWithin ( ) { GeoHash hash = GeoHash . withBitPrecision ( 70 , - 120 , 8 ) ; GeoHash inside = GeoHash . withBitPrecision ( 74 , - 130 , 64 ) ; assertWithin ( inside , hash ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenterPoint ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( hash . getBoundingBox ( ) ) ; } 
public void estNext ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 10 ) ; GeoHash next = hash . next ( ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; } 
public void estNextPrev ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 35 ) ; GeoHash next = hash . next ( 2 ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; GeoHash prev1 = next . prev ( ) ; GeoHash prev2 = prev1 . next ( - 1 ) ; assertTrue ( prev1 . compareTo ( next ) < 0 ) ; System . out . println ( " hash: " + hash . oBase32 ( ) ) ; System . out . println ( " next: " + next . oBase32 ( ) ) ; System . out . println ( " prev1: " + prev1 . oBase32 ( ) ) ; System . out . println ( " prev2: " + prev2 . oBase32 ( ) ) ; assertTrue ( prev2 . compareTo ( prev1 ) < 0 ) ; assertTrue ( prev2 . compareTo ( hash ) = = 0 ) ; } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getTopRight ( ) ) < = 0 ; } 
public GeoHash next ( ) { if ( alreadyUsed . size ( ) = = maxSamples ) return null ; int idx = rand . nextInt ( maxSamples + 1 ) ; while ( alreadyUsed . contains ( idx ) ) { idx = rand . nextInt ( maxSamples + 1 ) ; } alreadyUsed . add ( idx ) ; GeoHash gh = boundingBox . getBottomLeft ( ) . next ( idx ) ; if ( ! boundingBox . getBoundingBox ( ) . contains ( gh . getPoint ( ) ) ) return next ( ) ; return gh ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; GeoHash opRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; GeoHash opRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public void estIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; 
public void estSampler ( ) { BoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < String > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . oBase32 ( ) ) ) ; hashes . add ( gh . oBase32 ( ) ) ; if ( prev ! = null ) sumOfComp + = prev . compareTo ( gh ) ; prev = gh ; if ( sumOfComp = = 0 ) crossingZero + + ; gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; The expected value of the sum should be zero. This checks that it is at least close. Worst case is 12875 or -12875 so -40 is sufficiently close assertEquals(-40, sumOfComp); Check that the sum is zero a number of times, to make sure values are increasing and decreasing. assertEquals(123, crossingZero); } 
public GeoHash next ( int step ) { return fromOrd ( ord ( ) + step , significantBits ) ; } 
public long ord ( ) { int insignificantBits = 64 - significantBits ; return bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { int insignificantBits = 64 - significantBits ; return fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash wo ) { if ( one . significantBits ( ) ! = wo . significantBits ( ) ) throw new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; return wo . ord ( ) - one . ord ( ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String bottomLeft = base32 . substring ( 0 , 7 ) ; String opRight = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( bottomLeft ) , GeoHash . fromGeohashString ( opRight ) ) ; } 
public String oBase32 ( ) { return bottomLeft . oBase32 ( ) + opRight . oBase32 ( ) ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) { return rue ; } if ( obj instanceof BoundingBox ) { BoundingBox hat = ( BoundingBox ) obj ; 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { throw new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; for ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { geohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { geohash . addOffBitToEnd ( ) ; } else { throw new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } geohash . bits < < = ( 64 - geohash . significantBits ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public GeoHash next ( int step ) { return fromOrd ( ord ( ) + step , significantBits ) ; } 
public long ord ( ) { int insignificantBits = 64 - significantBits ; return bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { int insignificantBits = 64 - significantBits ; return fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
public static long stepsBetween ( GeoHash one , GeoHash wo ) { if ( one . significantBits ( ) ! = wo . significantBits ( ) ) { throw new IllegalArgumentException ( " It is only valid to compare the number of steps between two hashes if they have the same number of significant bits " ) ; } return wo . ord ( ) - one . ord ( ) ; } 
public boolean contains ( GeoHash hash ) { for ( GeoHash searchHash : searchHashes ) { if ( hash . within ( searchHash ) ) { return rue ; } } return false ; } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getTopRight ( ) ) < = 0 ; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfCharacters ) ; GeoHash opRight = GeoHash . withCharacterPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getMinLat ( ) , bbox . getMinLon ( ) , numberOfBits ) ; GeoHash opRight = GeoHash . withBitPrecision ( bbox . getMaxLat ( ) , bbox . getMaxLon ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String bottomLeft = base32 . substring ( 0 , 7 ) ; String opRight = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( bottomLeft ) , GeoHash . fromGeohashString ( opRight ) ) ; } 
public String oBase32 ( ) { return bottomLeft . oBase32 ( ) + opRight . oBase32 ( ) ; } 
public void estSize ( ) { BoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; assertHeightIs ( bbox , 45 ) ; assertWidthIs ( bbox , 30 ) ; bbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; assertHeightIs ( bbox , 90 ) ; assertWidthIs ( bbox , 52.5 ) ; bbox = new BoundingBox ( - 44 , - 46.1 , - 127.2 , - 128 ) ; assertHeightIs ( bbox , 2.1 ) ; assertWidthIs ( bbox , 0.8 ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 41.23452234 , 40.09872762 , 31.23432 , 30.0113312322 ) ; checkSearchYieldsCorrectHashes ( 47.447907 , 47.300200 , 8.760941 , 8.471276 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectHashes ( double minLat , double maxLat , double minLon , double maxLon , String . . . hashes ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( minLat , maxLat , minLon , maxLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain " + expectedHash + " is: " + search , search . getSearchHashes ( ) 
public void estNextPrev ( ) { double lat = 37.7 ; double lon = - 122.52 ; GeoHash hash = GeoHash . withBitPrecision ( lat , lon , 35 ) ; GeoHash next = hash . next ( 2 ) ; assertTrue ( hash . compareTo ( next ) < 0 ) ; GeoHash prev1 = next . prev ( ) ; GeoHash prev2 = prev1 . next ( - 1 ) ; assertTrue ( prev1 . compareTo ( next ) < 0 ) ; System . out . println ( " hash: " + hash . oBase32 ( ) ) ; System . out . println ( " next: " + next . oBase32 ( ) ) ; System . out . println ( " prev1: " + prev1 . oBase32 ( ) ) ; System . out . println ( " prev2: " + prev2 . oBase32 ( ) ) ; assertTrue ( prev2 . compareTo ( prev1 ) < 0 ) ; assertTrue ( prev2 . compareTo ( hash ) = = 0 ) ; } 
public void estVincenty ( ) { WGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; int distanceInMeters = 10000 ; WGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , distanceInMeters ) ; Assert . assertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; Assert . assertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; Assert . assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( startPoint , result ) , DELTA ) ; WGS84Point p1 = new WGS84Point ( 1 , 1 ) ; int enThousandKilometers = 10000000 ; WGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , enThousandKilometers ) ; System . out . println ( p2 ) ; Assert . assertEquals ( enThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public void estEquals ( ) { assertEquals ( a , a ) ; assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertNotSame ( a , b ) ; assertFalse ( a . equals ( c ) ) ; assertFalse ( c . equals ( a ) ) ; assertFalse ( d . equals ( c ) ) ; assertFalse ( d . equals ( a ) ) ; assertFalse ( d . equals ( new Integer ( 10 ) ) ) ; } 
public void estIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < GeoHash > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void estSampler ( ) { BoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < String > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . oBase32 ( ) ) ) ; hashes . add ( gh . oBase32 ( ) ) ; if ( prev ! = null ) { sumOfComp + = prev . compareTo ( gh ) ; } prev = gh ; if ( sumOfComp = = 0 ) { crossingZero + + ; } gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( 64 - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( 64 - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( 64 - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . point = hash . boundingBox . getCenterPoint ( ) ; return hash ; } 
public void estThatAdjacentHashesHavePointInitialized ( ) { String center = " dqcjqc " ; GeoHash geohash = GeoHash . fromGeohashString ( center ) ; GeoHash [ ] adjacentHashes = geohash . getAdjacent ( ) ; for ( GeoHash adjacentHash : adjacentHashes ) { assertNotNull ( adjacentHash . getBoundingBox ( ) ) ; 
public void estGetCharacterPrecisionThrows ( ) hrows Exception { GeoHash hash = GeoHash . withBitPrecision ( 37.7 , - 122.52 , 32 ) ; hash . getCharacterPrecision ( ) ; } 
public void estGetCharacterPrecisionWorksWhenPrecisionIsMultipleOfFive ( ) hrows Exception { GeoHash hash = GeoHash . withBitPrecision ( 37.7 , - 122.52 , 60 ) ; int precision = hash . getCharacterPrecision ( ) ; assertEquals ( precision , 12 ) ; } 
public static String geoHashStringWithCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { GeoHash hash = withCharacterPrecision ( latitude , longitude , numberOfCharacters ) ; return hash . oBase32 ( ) ; } 
public void estByCharacterPrecision ( ) { assertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; WGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; String fullStringValue = " hf7u8p8gn747 " ; for ( int characters = 12 ; characters > 1 ; characters - - ) { assertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } assertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; String geoHashString = GeoHash . geoHashStringWithCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 12 ) ; assertEquals ( fullStringValue , geoHashString ) ; } 
public static String geoHashStringWithCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { GeoHash hash = withCharacterPrecision ( latitude , longitude , numberOfCharacters ) ; return hash . oBase32 ( ) ; } 
public String oBase32 ( ) { if ( significantBits % 5 ! = 0 ) { throw new IllegalStateException ( " Cannot convert a geohash to base32 if the precision is not a multiple of 5. " ) ; } StringBuilder buf = new StringBuilder ( ) ; long firstFiveBitsMask = 0xf800000000000000l ; long bitsCopy = bits ; int partialChunks = ( int ) Math . ceil ( ( ( double ) significantBits / 5 ) ) ; for ( int i = 0 ; i < partialChunks ; i + + ) { int pointer = ( int ) ( ( bitsCopy & firstFiveBitsMask ) > > > 59 ) ; buf . append ( base32 [ pointer ] ) ; bitsCopy < < = 5 ; } return buf . oString ( ) ; } 
public void oBase32ShouldThrowWhenPrecisionIsNotAMultipleOf5 ( ) { hash . bits = 0x6ff0413000000000l ; hash . significantBits = 24 ; hash . oBase32 ( ) ; } 
private void assertWithin ( GeoHash hash , GeoHash bbox ) { assertTrue ( hash + " should be within " + bbox , hash . within ( bbox ) ) ; } 
public void estNotWithin ( ) { hash . bits = 0x6ff0414000000000l ; hash . significantBits = 25 ; assertEquals ( " ezs42 " , hash . oBase32 ( ) ) ; GeoHash bbox = new GeoHash ( ) ; bbox . bits = 0x6fc0000000000000l ; bbox . significantBits = 12 ; assertFalse ( hash + " should NOT be within " + bbox , hash . within ( bbox ) ) ; } 
public void estByCharacterPrecision ( ) { assertEncodingWithCharacterPrecision ( new WGS84Point ( 20 , 31 ) , 12 , " sew1c2vs2q5r " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20 , 31 ) , 12 , " ksqn1rje83g2 " ) ; assertEncodingWithCharacterPrecision ( new WGS84Point ( - 20.783236276 , 31.9867127312312 ) , 12 , " ksq9zbs0b7vw " ) ; WGS84Point point = new WGS84Point ( - 76.5110040642321 , 39.0247389581054 ) ; String fullStringValue = " hf7u8p8gn747 " ; for ( int characters = 12 ; characters > 1 ; characters - - ) { assertEncodingWithCharacterPrecision ( point , characters , fullStringValue . substring ( 0 , characters ) ) ; } assertEncodingWithCharacterPrecision ( new WGS84Point ( 39.0247389581054 , - 76.5110040642321 ) , 12 , " dqcw4bnrs6s7 " ) ; String geoHashString = GeoHash . geoHashStringWithCharacterPrecision ( point . getLatitude ( ) , point . getLongitude ( ) , 12 ) ; assertEquals ( fullStringValue , geoHashString ) ; } 
public void estThatAdjacentHashesHavePointInitialized ( ) { String center = " dqcjqc " ; GeoHash geohash = GeoHash . fromGeohashString ( center ) ; GeoHash [ ] adjacentHashes = geohash . getAdjacent ( ) ; for ( GeoHash adjacentHash : adjacentHashes ) { assertNotNull ( adjacentHash . getBoundingBox ( ) ) ; 
public int compareTo ( GeoHash o ) { int bitsCmp = Long . compare ( bits ^ FIRST_BIT_FLAGGED , o . bits ^ FIRST_BIT_FLAGGED ) ; if ( bitsCmp ! = 0 ) { return bitsCmp ; 
public void estCompareTo ( ) { GeoHash prevHash = null ; for ( int i = 0 ; i < 1000000 ; i + + ) { double latitude = rand . nextDouble ( ) * 180 - 90 ; 
public void setupBenchmark ( ) { hashes = new GeoHash [ NUMBER_OF_HASHES ] ; } 
public void benchmarkGeoHashEncoding ( ) { for ( int i = 0 ; i < NUMBER_OF_HASHES ; i + + ) { hashes [ i ] = RandomGeohashes . createWithPrecision ( 60 ) ; 
private void checkMoveAroundStrip ( String direction ) hrows Exception { for ( int bits = 2 ; bits < 16 ; bits + + ) { 
public void estCompareTo ( ) { GeoHash prevHash = null ; for ( int i = 0 ; i < 10000 ; i + + ) { GeoHash hash = RandomGeohashes . createWith5BitsPrecision ( ) ; 
public static GeoHash create ( ) { return GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomPrecision ( ) ) ; } 
public static GeoHash createWith5BitsPrecision ( ) { return GeoHash . withCharacterPrecision ( randomLatitude ( ) , randomLongitude ( ) , randomCharacterPrecision ( ) ) ; } 
public static GeoHash createWithPrecision ( int precision ) { return GeoHash . withBitPrecision ( randomLatitude ( ) , randomLongitude ( ) , precision ) ; } 
private static double randomLatitude ( ) { return ( rand . nextDouble ( ) - 0.5 ) * 180 ; } 
private static double randomLongitude ( ) { return ( rand . nextDouble ( ) - 0.5 ) * 360 ; } 
private static int randomPrecision ( ) { return rand . nextInt ( 60 ) + 5 ; } 
private static int randomCharacterPrecision ( ) { return rand . nextInt ( 12 ) + 1 ; } 
public int compareTo ( GeoHash o ) { int bitsCmp = Long . compare ( bits ^ FIRST_BIT_FLAGGED , o . bits ^ FIRST_BIT_FLAGGED ) ; if ( bitsCmp ! = 0 ) { return bitsCmp ; 
public void estVincenty ( ) { WGS84Point startPoint = new WGS84Point ( 40 , 40 ) ; int distanceInMeters = 10000 ; WGS84Point result = VincentyGeodesy . moveInDirection ( startPoint , 120 , distanceInMeters ) ; assertEquals ( 40.10134882 , result . getLongitude ( ) , DELTA ) ; assertEquals ( 39.9549245 , result . getLatitude ( ) , DELTA ) ; assertEquals ( distanceInMeters , VincentyGeodesy . distanceInMeters ( startPoint , result ) , DELTA ) ; WGS84Point p1 = new WGS84Point ( 1 , 1 ) ; int enThousandKilometers = 10000000 ; WGS84Point p2 = VincentyGeodesy . moveInDirection ( p1 , 270 , enThousandKilometers ) ; System . out . println ( p2 ) ; assertEquals ( enThousandKilometers , VincentyGeodesy . distanceInMeters ( p1 , p2 ) , DELTA ) ; } 
public void estIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) { 
public void estSampler ( ) { BoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . oBase32 ( ) ) ) ; hashes . add ( gh . oBase32 ( ) ) ; if ( prev ! = null ) { sumOfComp + = prev . compareTo ( gh ) ; } prev = gh ; if ( sumOfComp = = 0 ) { crossingZero + + ; } gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; } 
public Iterator < GeoHash > iterator ( ) { Random rand = new Random ( ) ; List < GeoHash > hashes = new ArrayList < > ( ) ; for ( double lat = - 90 ; lat < = 90 ; lat + = rand . nextDouble ( ) + 1.45 ) { for ( double lon = - 180 ; lon < = 180 ; lon + = rand . nextDouble ( ) + 1.54 ) { for ( int precisionChars = 6 ; precisionChars < = 12 ; precisionChars + + ) { GeoHash gh = GeoHash . withCharacterPrecision ( lat , lon , precisionChars ) ; hashes . add ( gh ) ; } } } return hashes . iterator ( ) ; } 
public static GeoHash withCharacterPrecision ( double latitude , double longitude , int numberOfCharacters ) { if ( numberOfCharacters > MAX_CHARACTER_PRECISION ) { throw new IllegalArgumentException ( " A geohash can only be " + MAX_CHARACTER_PRECISION + " character long. " ) ; } int desiredPrecision = ( numberOfCharacters * 5 < = 60 ) ? numberOfCharacters * 5 : 60 ; return new GeoHash ( latitude , longitude , desiredPrecision ) ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( numberOfBits > MAX_BIT_PRECISION ) { throw new IllegalArgumentException ( " A Geohash can only be " + MAX_BIT_PRECISION + " bits long! " ) ; } if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { throw new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public static GeoHash fromBinaryString ( String binaryString ) { GeoHash geohash = new GeoHash ( ) ; for ( int i = 0 ; i < binaryString . length ( ) ; i + + ) { if ( binaryString . charAt ( i ) = = '1' ) { geohash . addOnBitToEnd ( ) ; } else if ( binaryString . charAt ( i ) = = '0' ) { geohash . addOffBitToEnd ( ) ; } else { throw new IllegalArgumentException ( binaryString + " is not a valid geohash as a binary string " ) ; } } geohash . bits < < = ( MAX_BIT_PRECISION - geohash . significantBits ) ; long [ ] latitudeBits = geohash . getRightAlignedLatitudeBits ( ) ; long [ ] longitudeBits = geohash . getRightAlignedLongitudeBits ( ) ; return geohash . recombineLatLonBitsToHash ( latitudeBits , longitudeBits ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; return hash ; } 
public static GeoHash fromLongValue ( long hashVal , int significantBits ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; String binaryString = Long . oBinaryString ( hashVal ) ; while ( binaryString . length ( ) < MAX_BIT_PRECISION ) { binaryString = " 0 " + binaryString ; } for ( int j = 0 ; j < significantBits ; j + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } else { divideRangeDecode ( hash , latitudeRange , binaryString . charAt ( j ) ! = '0' ) ; } isEvenBit = ! isEvenBit ; } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; return hash ; } 
public long ord ( ) { int insignificantBits = MAX_BIT_PRECISION - significantBits ; return bits > > insignificantBits ; } 
public static GeoHash fromOrd ( long ord , int significantBits ) { int insignificantBits = MAX_BIT_PRECISION - significantBits ; return fromLongValue ( ord < < insignificantBits , significantBits ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( MAX_BIT_PRECISION - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( MAX_BIT_PRECISION - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . point = hash . boundingBox . getCenterPoint ( ) ; return hash ; } 
private long maskLastNBits ( long value , long ) { long mask = 0xffffffffffffffffl ; mask > > > = ( MAX_BIT_PRECISION - ) ; return value & mask ; } 
public void itShouldCreateAHashWithMaximumPrecisionOf64Bits ( ) { GeoHash . withBitPrecision ( 10.0 , 10.0 , 64 ) ; } 
public void itShouldThrowWhenTheBitPrecisionIsMoreThan64Bits ( ) { GeoHash . withBitPrecision ( 46.0 , 8.0 , 70 ) ; } 
public void itShouldThrowWhenTheCharacterPrecisionIsTooBig ( ) { GeoHash . withCharacterPrecision ( 10.0 , 120.0 , 14 ) ; } 
public long ord ( ) { int insignificantBits = 64 - significantBits ; long bitMask = ( 1L < < significantBits ) - 1 ; return ( bits > > insignificantBits ) & bitMask ; } 
public void estOrdIsPositive ( ) { double lat = 40.390943 ; double lon = 75.9375 ; GeoHash hash = GeoHash . withCharacterPrecision ( lat , lon , 12 ) ; assertEquals ( 0xcf6915015410500l , hash . ord ( ) ) ; assertTrue ( hash . ord ( ) > = 0 ) ; } 
public long ord ( ) { int insignificantBits = 64 - significantBits ; return bits > > > insignificantBits ; } 
public void estSecondCaseWhereOrdMustBePositive ( ) { GeoHash hash = GeoHash . withCharacterPrecision ( - 36.919550434870125 , 174.71024582237604 , 7 ) ; assertTrue ( hash . ord ( ) > 0 ) ; } 
public long ord ( ) { int insignificantBits = MAX_BIT_PRECISION - significantBits ; return bits > > > insignificantBits ; } 
public void estIter ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 10 ) ) ; checkIterator ( iter ) ; } 
public void estIter2 ( ) { BoundingBox box = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withBitPrecision ( box , 35 ) ) ; checkIterator ( iter ) ; } 
public void estIter3 ( ) { BoundingBox box = new BoundingBox ( 28.5 , 67.15 , - 33.2 , 44.5 ) ; BoundingBoxGeoHashIterator iter = new BoundingBoxGeoHashIterator ( TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ) ; List < GeoHash > hashes = checkIterator ( iter ) ; assertThat ( hashes . size ( ) , is ( 49 ) ) ; } 
public void estEndlessIterator ( ) { BoundingBox box = new BoundingBox ( 72.28907f , 88.62655f , - 50.976562f , 170.50781f ) ; TwoGeoHashBoundingBox woGeoHashBoundingBox = TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ; BoundingBoxGeoHashIterator iterator = new BoundingBoxGeoHashIterator ( woGeoHashBoundingBox ) ; Set < GeoHash > hashes = new HashSet < > ( ) ; while ( iterator . hasNext ( ) ) { GeoHash hash = iterator . next ( ) ; 
public void estAllCells ( ) { BoundingBox box = new BoundingBox ( - 90 , 90 , - 180 , 180 ) ; TwoGeoHashBoundingBox woGeoHashBoundingBox = TwoGeoHashBoundingBox . withCharacterPrecision ( box , 2 ) ; BoundingBoxGeoHashIterator iterator = new BoundingBoxGeoHashIterator ( woGeoHashBoundingBox ) ; Set < GeoHash > hashes = new HashSet < > ( ) ; while ( iterator . hasNext ( ) ) { GeoHash hash = iterator . next ( ) ; hashes . add ( hash ) ; } assertThat ( hashes . size ( ) , is ( 1024 ) ) ; } 
public void estTopRightCorner ( ) { BoundingBox box = new BoundingBox ( 84.4 , 84.9 , 169.3 , 179.6 ) ; GeoHash hash = iterator.next(); 
private List < GeoHash > checkIterator ( BoundingBoxGeoHashIterator iter ) { BoundingBox newBox = iter . getBoundingBox ( ) . getBoundingBox ( ) ; List < GeoHash > hashes = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) { hashes . add ( iter . next ( ) ) ; } GeoHash prev = null ; for ( GeoHash gh : hashes ) { if ( prev ! = null ) { Assert . assertTrue ( prev . compareTo ( gh ) < 0 ) ; } Assert . assertTrue ( newBox . contains ( gh . getPoint ( ) ) ) ; prev = gh ; } return hashes ; } 
public int hashCode ( ) { int result = 17 ; result = 37 * result + hashCode ( southLatitude ) ; result = 37 * result + hashCode ( northLatitude ) ; result = 37 * result + hashCode ( westLongitude ) ; result = 37 * result + hashCode ( eastLongitude ) ; return result ; } 
public boolean contains ( WGS84Point point ) { return containsLatitude ( point . getLatitude ( ) ) & & containsLongitude ( point . getLongitude ( ) ) ; } 
public boolean intersects ( BoundingBox other ) { return false; 
public String oString ( ) { return getNorthWestPoint ( ) + " -> " + getSouthEastPoint ( ) ; } 
private boolean containsLatitude ( double latitude ) { return latitude > = southLatitude & & latitude < = northLatitude ; } 
private boolean containsLongitude ( double longitude ) { if ( intersects180Meridian ) { return longitude < = eastLongitude | | longitude > = westLongitude ; 
public boolean intersects180Meridian ( ) { return intersects180Meridian ; } 
private void generateSearchHashes ( BoundingBox bbox ) { int fittingBits = GeoHashSizeTable . numberOfBitsForOverlappingGeoHash ( bbox ) ; WGS84Point center = bbox . getCenterPoint ( ) ; GeoHash centerHash = GeoHash . withBitPrecision ( center . getLatitude ( ) , center . getLongitude ( ) , fittingBits ) ; if ( hashContainsBoundingBox ( centerHash , bbox ) ) { If the centerHash completly fits into the provided bounding box, just add the hash and continue 
private boolean hashContainsBoundingBox ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getNorthWestPoint ( ) ) & & hash . contains ( bbox . getSouthEastPoint ( ) ) ; } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getNorthWest ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash bottomLeft = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; GeoHash opRight = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash bottomLeft = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; GeoHash opRight = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( bottomLeft , opRight ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String southWestBase32 = base32 . substring ( 0 , 7 ) ; String northEastBase32 = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( southWestBase32 ) , GeoHash . fromGeohashString ( northEastBase32 ) ) ; } 
public String oBase32 ( ) { return southEast . oBase32 ( ) + northWest . oBase32 ( ) ; } 
public void estEqualsObject ( ) { assertEquals ( a , b ) ; assertEquals ( b , a ) ; assertFalse ( a . equals ( c ) ) ; assertEquals ( d , e ) ; assertEquals ( e , d ) ; assertFalse ( c . equals ( d ) ) ; assertFalse ( c . equals ( a ) ) ; } 
public void estContains ( ) { BoundingBox bbox = new BoundingBox ( 45 , 46 , 120 , 121 ) ; assertContains ( bbox , new WGS84Point ( 45.5 , 120.5 ) ) ; assertNotContains ( bbox , new WGS84Point ( 90 , 90 ) ) ; } 
public void estSize ( ) { BoundingBox bbox = new BoundingBox ( 45 , 90 , 0 , 30 ) ; assertHeightIs ( bbox , 45 ) ; assertWidthIs ( bbox , 30 ) ; bbox = new BoundingBox ( - 45 , 45 , - 22.5 , 30 ) ; assertHeightIs ( bbox , 90 ) ; assertWidthIs ( bbox , 52.5 ) ; bbox = new BoundingBox ( - 46.1 , - 44 , - 128 , - 127.2 ) ; assertHeightIs ( bbox , 2.1 ) ; assertWidthIs ( bbox , 0.8 ) ; } 
public void estIntersects ( ) { BoundingBox bbox = new BoundingBox ( - 10 , 10 , 40 , 41 ) ; assertIntersects ( bbox , new BoundingBox ( - 15 , 5 , 40.5 , 43 ) ) ; assertDoesNotIntersect ( bbox , new BoundingBox ( - 15 , 5 , 42 , 43 ) ) ; } 
public void estSeveralBoundingBoxes ( ) { checkSearchYieldsCorrectNumberOfHashes ( 40.2090980098 , 40.21982983232432 , - 22.523432424324 , - 22.494234232442 ) ; checkSearchYieldsCorrectNumberOfHashes ( 40.09872762 , 41.23452234 , 30.0113312322 , 31.23432 ) ; checkSearchYieldsCorrectHashes ( 47.300200 , 47.447907 , 8.471276 , 8.760941 , " u0qj " ) ; checkSearchYieldsCorrectHashes ( 47.157502 , 47.329727 , 8.562244 , 8.859215 , " u0qj " , " u0qm " , " u0qh " , " u0qk " ) ; } 
private void checkSearchYieldsCorrectNumberOfHashes ( double southLat , double northLat , double westLon , double eastLon ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; assertRightNumberOfSearchHashes ( search ) ; } 
private void checkSearchYieldsCorrectHashes ( double southLat , double northLat , double westLon , double eastLon , String . . . hashes ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain ' " + expectedHash + " ':' " + GeoHash . fromGeohashString ( expectedHash ) + " '. Saved hashes: n " + search , search . getSearchHashes ( ) . contains ( GeoHash . fromGeohashString ( expectedHash ) ) ) ; 
private void checkSearchYieldsCorrectBinaryHashes ( double southLat , double northLat , double westLon , double eastLon , String . . . hashes ) { GeoHashQuery search = new GeoHashBoundingBoxQuery ( new BoundingBox ( southLat , northLat , westLon , eastLon ) ) ; assertEquals ( hashes . length , search . getSearchHashes ( ) . size ( ) ) ; for ( String expectedHash : hashes ) { assertTrue ( " search hashes should contain ' " + expectedHash + " ':' " + GeoHash . fromBinaryString ( expectedHash ) + " '. Saved hashes: n " + search , search . getSearchHashes ( ) . contains ( GeoHash . fromBinaryString ( expectedHash ) ) ) ; 
private void assertRightNumberOfSearchHashes ( GeoHashQuery search ) { int size = search . getSearchHashes ( ) . size ( ) ; assertTrue ( size < = 8 & & size > 0 ) ; } 
public void estIssue3WithCircleQuery ( ) hrows Exception { WGS84Point center = new WGS84Point ( 39.86391280373075 , 116.37356590048701 ) ; GeoHashCircleQuery query = new GeoHashCircleQuery ( center , 589 ) ; } 
public void est180MeridianCircleQuery ( ) hrows Exception { } 
public String oString ( ) { if ( significantBits % 5 = = 0 ) { return String . format ( " %s -> %s -> %s " , padLeft ( Long . oBinaryString ( bits ) , 64 , " 0 " ) , boundingBox , oBase32 ( ) ) ; 
private static String padLeft ( String s , int , String pad ) { return String . format ( " % " + + " s " , s ) . replace ( " " , pad ) ; } 
public BoundingBox generate ( int bits ) { } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getNorthEast ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash southWest = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; GeoHash northEast = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( southWest , northEast ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash southWest = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; GeoHash northEast = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( southWest , northEast ) ; } 
public static TwoGeoHashBoundingBox fromBase32 ( String base32 ) { String southWestBase32 = base32 . substring ( 0 , 7 ) ; String northEastBase32 = base32 . substring ( 7 ) ; return new TwoGeoHashBoundingBox ( GeoHash . fromGeohashString ( southWestBase32 ) , GeoHash . fromGeohashString ( northEastBase32 ) ) ; } 
public String oBase32 ( ) { return southWest . oBase32 ( ) + northEast . oBase32 ( ) ; } 
public String oString ( ) { return getNorthWestCorner ( ) + " -> " + getSouthEastCorner ( ) ; } 
protected GeoHash recombineLatLonBitsToHash ( long [ ] latBits , long [ ] lonBits ) { GeoHash hash = new GeoHash ( ) ; boolean isEvenBit = false ; latBits [ 0 ] < < = ( MAX_BIT_PRECISION - latBits [ 1 ] ) ; lonBits [ 0 ] < < = ( MAX_BIT_PRECISION - lonBits [ 1 ] ) ; double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; for ( int i = 0 ; i < latBits [ 1 ] + lonBits [ 1 ] ; i + + ) { if ( isEvenBit ) { divideRangeDecode ( hash , latitudeRange , ( latBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; latBits [ 0 ] < < = 1 ; } else { divideRangeDecode ( hash , longitudeRange , ( lonBits [ 0 ] & FIRST_BIT_FLAGGED ) = = FIRST_BIT_FLAGGED ) ; lonBits [ 0 ] < < = 1 ; } isEvenBit = ! isEvenBit ; } hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . point = hash . boundingBox . getCenter ( ) ; return hash ; } 
private void generateSearchHashes ( BoundingBox bbox ) { int fittingBits = GeoHashSizeTable . numberOfBitsForOverlappingGeoHash ( bbox ) ; WGS84Point center = bbox . getCenter ( ) ; GeoHash centerHash = GeoHash . withBitPrecision ( center . getLatitude ( ) , center . getLongitude ( ) , fittingBits ) ; if ( hashContainsBoundingBox ( centerHash , bbox ) ) { If the centerHash completly fits into the provided bounding box, just add the hash and continue 
private boolean hashContainsBoundingBox ( GeoHash hash , BoundingBox bbox ) { return hash . contains ( bbox . getNorthWestCorner ( ) ) & & hash . contains ( bbox . getSouthEastCorner ( ) ) ; } 
public boolean hasNext ( ) { return current . compareTo ( boundingBox . getNorthEastCorner ( ) ) < = 0 ; } 
public static TwoGeoHashBoundingBox withCharacterPrecision ( BoundingBox bbox , int numberOfCharacters ) { GeoHash southWestCorner = GeoHash . withCharacterPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfCharacters ) ; GeoHash northEastCorner = GeoHash . withCharacterPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfCharacters ) ; return new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; } 
public static TwoGeoHashBoundingBox withBitPrecision ( BoundingBox bbox , int numberOfBits ) { GeoHash southWestCorner = GeoHash . withBitPrecision ( bbox . getSouthLatitude ( ) , bbox . getWestLongitude ( ) , numberOfBits ) ; GeoHash northEastCorner = GeoHash . withBitPrecision ( bbox . getNorthLatitude ( ) , bbox . getEastLongitude ( ) , numberOfBits ) ; return new TwoGeoHashBoundingBox ( southWestCorner , northEastCorner ) ; } 
public String oBase32 ( ) { return southWestCorner . oBase32 ( ) + northEastCorner . oBase32 ( ) ; } 
private void printBoundingBox ( GeoHash hash ) { System . out . println ( " Bounding Box: ncenter = " + hash . getBoundingBoxCenter ( ) ) ; System . out . print ( " corners= " ) ; System . out . println ( hash . getBoundingBox ( ) ) ; } 
public void estSampler ( ) { BoundingBox bbox = new BoundingBox ( 37.7 , 37.84 , - 122.52 , - 122.35 ) ; BoundingBoxSampler sampler = new BoundingBoxSampler ( TwoGeoHashBoundingBox . withBitPrecision ( bbox , 35 ) , 1179 ) ; bbox = sampler . getBoundingBox ( ) . getBoundingBox ( ) ; GeoHash gh = sampler . next ( ) ; Set < String > hashes = new HashSet < > ( ) ; int sumOfComp = 0 ; int crossingZero = 0 ; GeoHash prev = null ; while ( gh ! = null ) { assertTrue ( bbox . contains ( gh . getOriginatingPoint ( ) ) ) ; assertFalse ( hashes . contains ( gh . oBase32 ( ) ) ) ; hashes . add ( gh . oBase32 ( ) ) ; if ( prev ! = null ) { sumOfComp + = prev . compareTo ( gh ) ; } prev = gh ; if ( sumOfComp = = 0 ) { crossingZero + + ; } gh = sampler . next ( ) ; } assertEquals ( 12875 , hashes . size ( ) ) ; } 
public void expandToInclude ( WGS84Point point ) { } 
public static double remainderWithFix ( double value , int remainder ) { double res = value % remainder ; } 
private void assertExpandToInclude ( BoundingBox bbox , double southLatitude , double northLatitude , double westLongitude , double eastLongitude ) { assertEquals ( southLatitude , bbox . getSouthLatitude ( ) , DELTA ) ; assertEquals ( northLatitude , bbox . getNorthLatitude ( ) , DELTA ) ; assertEquals ( westLongitude , bbox . getWestLongitude ( ) , DELTA ) ; assertEquals ( eastLongitude , bbox . getEastLongitude ( ) , DELTA ) ; } 
public void estPositiveValue ( ) { assertEquals ( 58.1541 , DoubleUtil . remainderWithFix ( 58.1541 , 360 ) , 0.00001 ) ; assertEquals ( 93.1541 , DoubleUtil . remainderWithFix ( 453.1541 , 360 ) , 0.00001 ) ; } 
public void estNegativeValue ( ) { assertEquals ( 301.8459 , DoubleUtil . remainderWithFix ( - 58.1541 , 360 ) , 0.00001 ) ; assertEquals ( 266.8459 , DoubleUtil . remainderWithFix ( - 453.1541 , 360 ) , 0.00001 ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { if ( decodeMap . containsKey ( geohash . charAt ( i ) ) ) { int cd = decodeMap . get ( geohash . charAt ( i ) ) ; for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } else { throw new IllegalArgumentException ( " Invalid character character ' " + geohash . charAt ( i ) + " ' in geohash ' " + geohash + " '! " ) ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; return hash ; } 
public void itShouldThrowANiceExceptionOnIllegalCharacters ( ) { GeoHash . fromGeohashString ( " abba " ) ; } 
public static GeoHash fromGeohashString ( String geohash ) { double [ ] latitudeRange = { - 90.0 , 90.0 } ; double [ ] longitudeRange = { - 180.0 , 180.0 } ; boolean isEvenBit = rue ; GeoHash hash = new GeoHash ( ) ; for ( int i = 0 ; i < geohash . length ( ) ; i + + ) { char c = geohash . charAt ( i ) ; int cd ; if ( c > = decodeArray . length | | ( cd = decodeArray [ c ] ) < 0 ) { throw new IllegalArgumentException ( " Invalid character character ' " + c + " ' in geohash ' " + geohash + " '! " ) ; } for ( int j = 0 ; j < BASE32_BITS ; j + + ) { int mask = BITS [ j ] ; if ( isEvenBit ) { divideRangeDecode ( hash , longitudeRange , ( cd & mask ) ! = 0 ) ; } else { divideRangeDecode ( hash , latitudeRange , ( cd & mask ) ! = 0 ) ; } isEvenBit = ! isEvenBit ; } } double latitude = ( latitudeRange [ 0 ] + latitudeRange [ 1 ] ) / 2 ; double longitude = ( longitudeRange [ 0 ] + longitudeRange [ 1 ] ) / 2 ; hash . point = new WGS84Point ( latitude , longitude ) ; setBoundingBox ( hash , latitudeRange , longitudeRange ) ; hash . bits < < = ( MAX_BIT_PRECISION - hash . significantBits ) ; return hash ; } 
public static GeoHash withBitPrecision ( double latitude , double longitude , int numberOfBits ) { if ( numberOfBits < 0 ) { throw new IllegalArgumentException ( " A Geohash can't be of negative bits long! " ) ; } if ( numberOfBits > MAX_BIT_PRECISION ) { throw new IllegalArgumentException ( " A Geohash can only be " + MAX_BIT_PRECISION + " bits long! " ) ; } if ( Math . abs ( latitude ) > 90.0 | | Math . abs ( longitude ) > 180.0 ) { throw new IllegalArgumentException ( " Can't have lat/lon values out of (-90,90)/(-180/180) " ) ; } return new GeoHash ( latitude , longitude , numberOfBits ) ; } 
public void itShouldCreateAHashWithMinimumPrecisionOf0Bits ( ) { GeoHash . withBitPrecision ( 10.0 , 10.0 , 0 ) ; } 
public void itShouldThrowWhenTheBitPrecisionIsLessThan0Bits ( ) { GeoHash . withBitPrecision ( 46.0 , 8.0 , - 1 ) ; } 
public void itShouldCreateAHashWithMinimumPrecisionOf0Bits ( ) { GeoHash geoHash = GeoHash . withBitPrecision ( 10.0 , 10.0 , 0 ) ; assertEquals ( 0 , geoHash . significantBits ( ) ) ; assertEquals ( 0 , geoHash . longValue ( ) ) ; assertEquals ( new WGS84Point ( 10.0 , 10.0 ) , geoHash . getOriginatingPoint ( ) ) ; } 
public void itShouldCreateAHashWithMaximumPrecisionOf64Bits ( ) { GeoHash geoHash = GeoHash . withBitPrecision ( 10.0 , 10.0 , 64 ) ; assertEquals ( 64 , geoHash . significantBits ( ) ) ; assertEquals ( 0xc07e07e07e07e07eL , geoHash . longValue ( ) ) ; assertEquals ( new WGS84Point ( 10.0 , 10.0 ) , geoHash . getOriginatingPoint ( ) ) ; } 
